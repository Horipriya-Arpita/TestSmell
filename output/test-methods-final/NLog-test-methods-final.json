[
  {
    "file": "AutoReloadTests.cs",
    "methods": [
      {
        "name": "TestNoAutoReload",
        "body": "{| string config1 = @\"<nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string config2 = @\"<nlog>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string configFilePath = Path.Combine(tempDir, nameof(TestNoAutoReload) + \".nlog\");| WriteConfigFile(configFilePath, config1);| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();| Assert.False(((XmlLoggingConfiguration)logFactory.Configuration).AutoReload);| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| ChangeAndReloadConfigFile(logFactory, configFilePath, config2, assertDidReload: false);| logger.Debug(\"bbb\");| // Assert that config1 is still loaded.| AssertDebugLastMessage(\"bbb\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      },
      {
        "name": "TestAutoReloadOnFileChange",
        "body": "{| string config1 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string config2 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string badConfig = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='(${message})' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string configFilePath = Path.Combine(tempDir, nameof(TestAutoReloadOnFileChange) + \".nlog\");| WriteConfigFile(configFilePath, config1);| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();| Assert.True(((XmlLoggingConfiguration)logFactory.Configuration).AutoReload);| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| ChangeAndReloadConfigFile(logFactory, configFilePath, badConfig, assertDidReload: false);| logger.Debug(\"bbb\");| // Assert that config1 is still loaded.| AssertDebugLastMessage(\"bbb\", logFactory);| ChangeAndReloadConfigFile(logFactory, configFilePath, config2);| logger.Debug(\"ccc\");| // Assert that config2 is loaded.| AssertDebugLastMessage(\"[ccc]\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      },
      {
        "name": "TestAutoReloadOnFileMove",
        "body": "{|#if !NETFRAMEWORK || MONO| if (IsLinux())| {| Console.WriteLine(\"[SKIP] AutoReloadTests.TestAutoReloadOnFileMove because we are running in Travis\");| return;| }|#endif| string config1 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string config2 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string configFilePath = Path.Combine(tempDir, \"reload.nlog\");| WriteConfigFile(configFilePath, config1);| string otherFilePath = Path.Combine(tempDir, \"other.nlog\");| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))| {| File.Move(configFilePath, otherFilePath);| reloadWaiter.WaitForReload();| }| logger.Debug(\"bbb\");| // Assert that config1 is still loaded.| AssertDebugLastMessage(\"bbb\", logFactory);| WriteConfigFile(otherFilePath, config2);| using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))| {| File.Move(otherFilePath, configFilePath);| reloadWaiter.WaitForReload();| Assert.True(reloadWaiter.DidReload);| }| logger.Debug(\"ccc\");| // Assert that config2 is loaded.| AssertDebugLastMessage(\"[ccc]\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      },
      {
        "name": "TestAutoReloadOnFileCopy",
        "body": "{| string config1 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string config2 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string tempPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempPath);| string configFilePath = Path.Combine(tempPath, \"reload.nlog\");| WriteConfigFile(configFilePath, config1);| string otherFilePath = Path.Combine(tempPath, \"other.nlog\");| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))| {| File.Delete(configFilePath);| reloadWaiter.WaitForReload();| }| logger.Debug(\"bbb\");| // Assert that config1 is still loaded.| AssertDebugLastMessage(\"bbb\", logFactory);| WriteConfigFile(otherFilePath, config2);| using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))| {| File.Copy(otherFilePath, configFilePath);| File.Delete(otherFilePath);| reloadWaiter.WaitForReload();| Assert.True(reloadWaiter.DidReload);| }| logger.Debug(\"ccc\");| // Assert that config2 is loaded.| AssertDebugLastMessage(\"[ccc]\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempPath))| Directory.Delete(tempPath, true);| }| }"
      },
      {
        "name": "TestIncludedConfigNoReload",
        "body": "{| string mainConfig1 = @\"<nlog>| <include file='included.nlog' />| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string mainConfig2 = @\"<nlog>| <include file='included.nlog' />| <rules><logger name='*' minlevel='Info' writeTo='debug' /></rules>| </nlog>\";| string includedConfig1 = @\"<nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| </nlog>\";| string includedConfig2 = @\"<nlog>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| </nlog>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");| WriteConfigFile(mainConfigFilePath, mainConfig1);| string includedConfigFilePath = Path.Combine(tempDir, \"included.nlog\");| WriteConfigFile(includedConfigFilePath, includedConfig1);| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2, assertDidReload: false);| logger.Debug(\"bbb\");| // Assert that mainConfig1 is still loaded.| AssertDebugLastMessage(\"bbb\", logFactory);| WriteConfigFile(mainConfigFilePath, mainConfig1);| ChangeAndReloadConfigFile(logFactory, includedConfigFilePath, includedConfig2, assertDidReload: false);| logger.Debug(\"ccc\");| // Assert that includedConfig1 is still loaded.| AssertDebugLastMessage(\"ccc\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      },
      {
        "name": "TestIncludedConfigReload",
        "body": "{| string mainConfig1 = @\"<nlog>| <include file='included.nlog' />| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string mainConfig2 = @\"<nlog>| <include file='included.nlog' />| <rules><logger name='*' minlevel='Info' writeTo='debug' /></rules>| </nlog>\";| string includedConfig1 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| </nlog>\";| string includedConfig2 = @\"<nlog autoReload='true'>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| </nlog>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");| WriteConfigFile(mainConfigFilePath, mainConfig1);| string includedConfigFilePath = Path.Combine(tempDir, \"included.nlog\");| WriteConfigFile(includedConfigFilePath, includedConfig1);| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2, assertDidReload: false);| logger.Debug(\"bbb\");| // Assert that mainConfig1 is still loaded.| AssertDebugLastMessage(\"bbb\", logFactory);| WriteConfigFile(mainConfigFilePath, mainConfig1);| ChangeAndReloadConfigFile(logFactory, includedConfigFilePath, includedConfig2);| logger.Debug(\"ccc\");| // Assert that includedConfig2 is loaded.| AssertDebugLastMessage(\"[ccc]\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      },
      {
        "name": "TestMainConfigReload",
        "body": "{| string mainConfig1 = @\"<nlog autoReload='true'>| <include file='included.nlog' />| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string mainConfig2 = @\"<nlog autoReload='true'>| <include file='included2.nlog' />| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string included1Config = @\"<nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| </nlog>\";| string included2Config1 = @\"<nlog>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| </nlog>\";| string included2Config2 = @\"<nlog>| <targets><target name='debug' type='Debug' layout='(${message})' /></targets>| </nlog>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");| WriteConfigFile(mainConfigFilePath, mainConfig1);| string included1ConfigFilePath = Path.Combine(tempDir, \"included.nlog\");| WriteConfigFile(included1ConfigFilePath, included1Config);| string included2ConfigFilePath = Path.Combine(tempDir, \"included2.nlog\");| WriteConfigFile(included2ConfigFilePath, included2Config1);| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2);| logger.Debug(\"bbb\");| // Assert that mainConfig2 is loaded (which refers to included2.nlog).| AssertDebugLastMessage(\"[bbb]\", logFactory);| ChangeAndReloadConfigFile(logFactory, included2ConfigFilePath, included2Config2);| logger.Debug(\"ccc\");| // Assert that included2Config2 is loaded.| AssertDebugLastMessage(\"(ccc)\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      },
      {
        "name": "TestMainConfigReloadIncludedConfigNoReload",
        "body": "{| string mainConfig1 = @\"<nlog autoReload='true'>| <include file='included.nlog' />| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string mainConfig2 = @\"<nlog autoReload='true'>| <include file='included2.nlog' />| <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>| </nlog>\";| string included1Config = @\"<nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| </nlog>\";| string included2Config1 = @\"<nlog autoReload='false'>| <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>| </nlog>\";| string included2Config2 = @\"<nlog autoReload='false'>| <targets><target name='debug' type='Debug' layout='(${message})' /></targets>| </nlog>\";| string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| var logFactory = new LogFactory();| try| {| Directory.CreateDirectory(tempDir);| string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");| WriteConfigFile(mainConfigFilePath, mainConfig1);| string included1ConfigFilePath = Path.Combine(tempDir, \"included.nlog\");| WriteConfigFile(included1ConfigFilePath, included1Config);| string included2ConfigFilePath = Path.Combine(tempDir, \"included2.nlog\");| WriteConfigFile(included2ConfigFilePath, included2Config1);| var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();| logger.Debug(\"aaa\");| AssertDebugLastMessage(\"aaa\", logFactory);| ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2);| logger.Debug(\"bbb\");| // Assert that mainConfig2 is loaded (which refers to included2.nlog).| AssertDebugLastMessage(\"[bbb]\", logFactory);| ChangeAndReloadConfigFile(logFactory, included2ConfigFilePath, included2Config2, assertDidReload: false);| logger.Debug(\"ccc\");| // Assert that included2Config1 is still loaded.| AssertDebugLastMessage(\"[ccc]\", logFactory);| }| finally| {| logFactory.Shutdown();| if (Directory.Exists(tempDir))| Directory.Delete(tempDir, true);| }| }"
      }
    ]
  },
  {
    "file": "ConditionEvaluatorTests.cs",
    "methods": [
      {
        "name": "ConditionMethodsTest",
        "body": "{| AssertEvaluationResult(true, \"regex-matches('foo', '^foo$')\");| AssertEvaluationResult(false, \"regex-matches('foo', '^bar$')\");| //Check that calling with empty string is equivalent with not passing the parameter| AssertEvaluationResult(true, \"regex-matches('foo', '^foo$', '')\");| AssertEvaluationResult(false, \"regex-matches('foo', '^bar$', '')\");| //Check that options are parsed correctly| AssertEvaluationResult(true, \"regex-matches('Foo', '^foo$', 'ignorecase')\");| AssertEvaluationResult(false, \"regex-matches('Foo', '^foo$')\");| AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,multiline')\");| AssertEvaluationResult(false, \"regex-matches('foo\\nbar', '^Foo$')\");| Assert.Throws<ConditionEvaluationException>(() => AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,nonexistent')\"));| }"
      }
    ]
  },
  {
    "file": "RegexReplaceTests.cs",
    "methods": [
      {
        "name": "ReplaceTestWithoutRegEx",
        "body": "{| // Arrange| SimpleLayout layout = @\"${regex-replace:inner=${message}:searchFor=foo:replaceWith=BAR}\";| // Act| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));| // Assert| Assert.Equal(\" BAR bar bar BAR bar FOO\", result);| }"
      },
      {
        "name": "ReplaceTestIgnoreCaseWithoutRegEx",
        "body": "{| // Arrange| SimpleLayout layout = @\"${regex-replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true}\";| // Act| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));| // Assert| Assert.Equal(\" BAR bar bar BAR bar BAR\", result);| }"
      },
      {
        "name": "ReplaceTestWholeWordsWithoutRegEx",
        "body": "{| // Arrange| SimpleLayout layout = @\"${regex-replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true:WholeWords=true}\";| // Act| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foobar bar FOO\"));| // Assert| Assert.Equal(\" BAR bar bar foobar bar BAR\", result);| }"
      },
      {
        "name": "ReplaceTestWithSimpleRegExFromConfig",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <targets>| <target name='d1' type='Debug' layout='${regex-replace:inner=${message}:searchFor=\\\\r\\\\n|\\\\s:replaceWith= }' />| </targets>| <rules>| <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />| </rules>|</nlog>\");| var d1 = configuration.FindTargetByName(\"d1\") as DebugTarget;| Assert.NotNull(d1);| var layout = d1.Layout as SimpleLayout;| Assert.NotNull(layout);| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"\\r\\nfoo\\rbar\\nbar\\tbar bar \\n bar\"));| Assert.Equal(\" foo bar bar bar bar bar\", result);| }"
      },
      {
        "name": "ReplaceTestWithSimpleRegExFromConfig2",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name=\"\"whitespace\"\" value=\"\"\\\\r\\\\n|\\\\s\"\" />| <variable name=\"\"oneLineMessage\"\" value=\"\"${regex-replace:inner=${message}:searchFor=${whitespace}:replaceWith= }\"\" />| <targets>| <target name=\"\"d1\"\" type=\"\"Debug\"\" layout=\"\"${oneLineMessage}\"\" />| </targets>| <rules>| <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />| </rules>|</nlog>\");| var d1 = configuration.FindTargetByName(\"d1\") as DebugTarget;| Assert.NotNull(d1);| var layout = d1.Layout as SimpleLayout;| Assert.NotNull(layout);| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"\\r\\nfoo\\rbar\\nbar\\tbar bar \\n bar\"));| Assert.Equal(\" foo bar bar bar bar bar\", result);| }"
      },
      {
        "name": "ReplaceTestWithComplexRegEx",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <variable name=\"\"searchExp\"\"| value=\"\"(?&lt;!\\\\d[ -]*)(?\\:(?&lt;digits&gt;\\\\d)[ -]*)\\{8,16\\}(?=(\\\\d[ -]*)\\{3\\}(\\\\d)(?![ -]\\\\d))\"\"| />| <variable name=\"\"message1\"\" value=\"\"${regex-replace:inner=${message}:searchFor=${searchExp}:replaceWith=X:replaceGroupName=digits:ignorecase=true}\"\" />| <targets>| <target name=\"\"d1\"\" type=\"\"Debug\"\" layout=\"\"${message1}\"\" />| </targets>| <rules>| <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />| </rules>|</nlog>\").LogFactory;| var d1 = logFactory.Configuration.FindTargetByName<DebugTarget>(\"d1\");| Assert.NotNull(d1);| var layout = d1.Layout as SimpleLayout;| Assert.NotNull(layout);| var testCases = new List<Tuple<string, string>>| {| Tuple.Create(\"1234\", \"1234\"),| Tuple.Create(\"1234-5678-1234-5678\", \"XXXX-XXXX-XXXX-5678\"),| Tuple.Create(\"1234 5678 1234 5678\", \"XXXX XXXX XXXX 5678\"),| Tuple.Create(\"1234567812345678\", \"XXXXXXXXXXXX5678\"),| Tuple.Create(\"ABCD-1234-5678-1234-5678\", \"ABCD-XXXX-XXXX-XXXX-5678\"),| Tuple.Create(\"1234-5678-1234-5678-ABCD\", \"XXXX-XXXX-XXXX-5678-ABCD\"),| Tuple.Create(\"ABCD-1234-5678-1234-5678-ABCD\", \"ABCD-XXXX-XXXX-XXXX-5678-ABCD\"),| };| foreach (var testCase in testCases)| {| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", testCase.Item1));| Assert.Equal(testCase.Item2, result);| }| }"
      }
    ]
  },
  {
    "file": "Log4JXmlTests.cs",
    "methods": [
      {
        "name": "Log4JXmlTest",
        "body": "{| var logFactory = new LogFactory().Setup()| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' layout='${log4jxmlevent:includeCallSite=true:includeSourceInfo=true:includeNdlc=true:includeMdc=true:IncludeNdc=true:includeMdlc=true:IncludeAllProperties=true:ndcItemSeparator=\\:\\::includenlogdata=true:loggerName=${logger}:formattedMessage=${message}}' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| ScopeContext.Clear();| ScopeContext.PushProperty(\"foo1\", \"bar1\");| ScopeContext.PushProperty(\"foo2\", \"bar2\");| ScopeContext.PushProperty(\"foo3\", \"bar3\");| ScopeContext.PushNestedState(\"baz1\");| ScopeContext.PushNestedState(\"baz2\");| ScopeContext.PushNestedState(\"baz3\");| var logger = logFactory.GetLogger(\"A\");| var logEventInfo = LogEventInfo.Create(LogLevel.Debug, \"A\", new Exception(\"Hello Exception\", new Exception(\"Goodbye Exception\")), null, \"some message \\u0014\");| logEventInfo.Properties[\"nlogPropertyKey\"] = \"nlogPropertyValue\";| logger.Log(logEventInfo);| string result = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\").LastMessage;| Assert.DoesNotContain(\"dummy\", result);| string wrappedResult = \"<log4j:dummyRoot xmlns:log4j='http://log4j' xmlns:nlog='http://nlog'>\" + result + \"</log4j:dummyRoot>\";| Assert.NotEqual(\"\", result);| // make sure the XML can be read back and verify some fields| StringReader stringReader = new StringReader(wrappedResult);| var foundsChilds = new Dictionary<string, int>();| var requiredChilds = new List<string>| {| \"log4j.event\",| \"log4j.message\",| \"log4j.NDC\",| \"log4j.locationInfo\",| \"log4j.properties\",| \"log4j.throwable\",| \"log4j.data\",| };| using (XmlReader reader = XmlReader.Create(stringReader))| {| while (reader.Read())| {| var key = reader.LocalName;| var fullKey = reader.Prefix + \".\" + key;| if (!foundsChilds.ContainsKey(fullKey))| {| foundsChilds[fullKey] = 0;| }| foundsChilds[fullKey]++;| if (reader.NodeType == XmlNodeType.Element && reader.Prefix == \"log4j\")| {| switch (reader.LocalName)| {| case \"dummyRoot\":| break;| case \"event\":| Assert.Equal(\"DEBUG\", reader.GetAttribute(\"level\"));| Assert.Equal(\"A\", reader.GetAttribute(\"logger\"));| var epochStart = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);| long timestamp = Convert.ToInt64(reader.GetAttribute(\"timestamp\"));| var time = epochStart.AddMilliseconds(timestamp);| var now = DateTime.UtcNow;| Assert.True(now.Ticks - time.Ticks < TimeSpan.FromSeconds(3).Ticks);| Assert.Equal(Environment.CurrentManagedThreadId.ToString(), reader.GetAttribute(\"thread\"));| break;| case \"message\":| reader.Read();| Assert.Equal(\"some message \", reader.Value);| break;| case \"NDC\":| reader.Read();| Assert.Equal(\"baz1::baz2::baz3\", reader.Value);| break;| case \"locationInfo\":| Assert.Equal(MethodBase.GetCurrentMethod().DeclaringType.FullName, reader.GetAttribute(\"class\"));| Assert.Equal(MethodBase.GetCurrentMethod().Name, reader.GetAttribute(\"method\"));| break;| case \"properties\":| break;| case \"throwable\":| reader.Read();| Assert.Contains(\"Hello Exception\", reader.Value);| Assert.Contains(\"Goodbye Exception\", reader.Value);| break;| case \"data\":| string name = reader.GetAttribute(\"name\");| string value = reader.GetAttribute(\"value\");| switch (name)| {| case \"log4japp\":| Assert.Equal(AppDomain.CurrentDomain.FriendlyName + \"(\" + System.Diagnostics.Process.GetCurrentProcess().Id + \")\", value);| break;| case \"log4jmachinename\":| Assert.Equal(Environment.MachineName, value);| break;| case \"foo1\":| Assert.Equal(\"bar1\", value);| break;| case \"foo2\":| Assert.Equal(\"bar2\", value);| break;| case \"foo3\":| Assert.Equal(\"bar3\", value);| break;| case \"nlogPropertyKey\":| Assert.Equal(\"nlogPropertyValue\", value);| break;| default:| Assert.Fail(\"Unknown <log4j:data>: \" + name);| break;| }| break;| default:| throw new NotSupportedException(\"Unknown element: \" + key);| }| }| }| }| foreach (var required in requiredChilds)| {| Assert.True(foundsChilds.ContainsKey(required), $\"{required} not found!\");| }| }"
      },
      {
        "name": "Log4JXmlEventLayoutParameterTest",
        "body": "{| var log4jLayout = new Log4JXmlEventLayout()| {| Parameters =| {| new Log4JXmlEventParameter| {| Name = \"mt\",| Layout = \"${message:raw=true}\",| }| },| };| log4jLayout.Renderer.AppInfo = \"MyApp\";| var logEventInfo = new LogEventInfo| {| LoggerName = \"MyLOgger\",| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56, DateTimeKind.Utc),| Level = LogLevel.Info,| Message = \"hello, <{0}>\",| Parameters = new[] { \"world\" },| };| var threadid = Environment.CurrentManagedThreadId;| var machinename = Environment.MachineName;| Assert.Equal($\"<log4j:event logger=\\\"MyLOgger\\\" level=\\\"INFO\\\" timestamp=\\\"1262349296000\\\" thread=\\\"{threadid}\\\"><log4j:message>hello, &lt;world&gt;</log4j:message><log4j:properties><log4j:data name=\\\"mt\\\" value=\\\"hello, &lt;{{0}}&gt;\\\" /><log4j:data name=\\\"log4japp\\\" value=\\\"MyApp\\\" /><log4j:data name=\\\"log4jmachinename\\\" value=\\\"{machinename}\\\" /></log4j:properties></log4j:event>\", log4jLayout.Render(logEventInfo));| }"
      },
      {
        "name": "BadXmlValueTest",
        "body": "{| var sb = new System.Text.StringBuilder();| var forbidden = new HashSet<int>();| int start = 64976; int end = 65007;| for (int i = start; i <= end; i++)| {| forbidden.Add(i);| }| forbidden.Add(0xFFFE);| forbidden.Add(0xFFFF);| for (int i = char.MinValue; i <= char.MaxValue; i++)| {| char c = Convert.ToChar(i);| if (char.IsSurrogate(c))| {| continue; // skip surrogates| }| if (forbidden.Contains(c))| {| continue;| }| sb.Append(c);| }| var badString = sb.ToString();| var settings = new XmlWriterSettings| {| Indent = true,| ConformanceLevel = ConformanceLevel.Fragment,| IndentChars = \" \",| };| sb.Length = 0;| using (XmlWriter xtw = XmlWriter.Create(sb, settings))| {| xtw.WriteStartElement(\"log4j\", \"event\", \"http:://hello/\");| xtw.WriteElementSafeString(\"log4j\", \"message\", \"http:://hello/\", badString);| xtw.WriteEndElement();| xtw.Flush();| }| string goodString = null;| using (XmlReader reader = XmlReader.Create(new StringReader(sb.ToString())))| {| while (reader.Read())| {| if (reader.NodeType == XmlNodeType.Text)| {| if (reader.Value.Contains(\"abc\"))| goodString = reader.Value;| }| }| }| Assert.NotNull(goodString);| Assert.NotEqual(badString.Length, goodString.Length);| Assert.Contains(\"abc\", badString);| Assert.Contains(\"abc\", goodString);| }"
      }
    ]
  },
  {
    "file": "HttpNetworkSenderTests.cs",
    "methods": [
      {
        "name": "HttpNetworkSenderViaNetworkTargetTest",
        "body": "{| // Arrange| var networkTarget = new NetworkTarget(\"target1\")| {| Address = \"http://test.with.mock\",| Layout = \"${logger}|${message}|${exception}\",| MaxQueueSize = 1234,| OnQueueOverflow = NetworkTargetQueueOverflowAction.Block,| MaxMessageSize = 0,| };| var webRequestMock = new WebRequestMock();| var networkSenderFactoryMock = CreateNetworkSenderFactoryMock(webRequestMock);| networkTarget.SenderFactory = networkSenderFactoryMock;| var logFactory = new LogFactory();| var config = new LoggingConfiguration(logFactory);| config.AddRuleForAllLevels(networkTarget);| logFactory.Configuration = config;| var logger = logFactory.GetLogger(\"HttpHappyPathTestLogger\");| // Act| logger.Info(\"test message1\");| logFactory.Flush();| // Assert| var mock = webRequestMock;| var requestedString = mock.GetRequestContentAsString();| Assert.Equal(\"http://test.with.mock/\", mock.RequestedAddress.ToString());| Assert.Equal(\"HttpHappyPathTestLogger|test message1|\", requestedString);| Assert.Equal(\"POST\", mock.Method);| networkSenderFactoryMock.Received(1).Create(\"http://test.with.mock\", 1234, NetworkTargetQueueOverflowAction.Block, 0, SslProtocols.None, TimeSpan.Zero, TimeSpan.Zero);| // Cleanup| mock.Dispose();| }"
      },
      {
        "name": "HttpNetworkSenderViaNetworkTargetRecoveryTest",
        "body": "{| // Arrange| var networkTarget = new NetworkTarget(\"target1\")| {| Address = \"http://test.with.mock\",| Layout = \"${logger}|${message}|${exception}\",| MaxQueueSize = 1234,| OnQueueOverflow = NetworkTargetQueueOverflowAction.Block,| MaxMessageSize = 0,| };| var webRequestMock = new WebRequestMock();| webRequestMock.FirstRequestMustFail = true;| var networkSenderFactoryMock = CreateNetworkSenderFactoryMock(webRequestMock);| networkTarget.SenderFactory = networkSenderFactoryMock;| var logFactory = new LogFactory();| var config = new LoggingConfiguration(logFactory);| config.AddRuleForAllLevels(networkTarget);| logFactory.Configuration = config;| var logger = logFactory.GetLogger(\"HttpHappyPathTestLogger\");| // Act| logger.Info(\"test message1\"); // Will fail after short delay| logger.Info(\"test message2\"); // Will be queued and sent after short delay| logFactory.Flush();| // Assert| var mock = webRequestMock;| var requestedString = mock.GetRequestContentAsString();| Assert.Equal(\"http://test.with.mock/\", mock.RequestedAddress.ToString());| Assert.Equal(\"HttpHappyPathTestLogger|test message2|\", requestedString);| Assert.Equal(\"POST\", mock.Method);| networkSenderFactoryMock.Received(1).Create(\"http://test.with.mock\", 1234, NetworkTargetQueueOverflowAction.Block, 0, SslProtocols.None, TimeSpan.Zero, TimeSpan.Zero); // Only created one HttpNetworkSender| // Cleanup| mock.Dispose();| }"
      }
    ]
  },
  {
    "file": "TcpNetworkSenderTests.cs",
    "methods": [
      {
        "name": "TcpHappyPathTest",
        "body": "{| foreach (bool async in new[] { false, true })| {| var sender = new MyTcpNetworkSender(\"tcp://hostname:123\", AddressFamily.Unspecified)| {| Async = async,| };| sender.Initialize();| byte[] buffer = Encoding.UTF8.GetBytes(\"quick brown fox jumps over the lazy dog\");| var exceptions = new List<Exception>();| for (int i = 1; i < 8; i *= 2)| {| sender.Send(| buffer, 0, i, ex =>| {| lock (exceptions) exceptions.Add(ex);| });| }| var mre = new ManualResetEvent(false);| sender.FlushAsync(ex =>| {| lock (exceptions)| {| exceptions.Add(ex);| }| mre.Set();| });| Assert.True(mre.WaitOne(10000), \"Network Flush not completed\");| var actual = sender.Log.ToString();| Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);| Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);| Assert.Contains(\"connect async to 0.0.0.0:123\", actual);| Assert.Contains(\"send async 0 1 'q'\", actual);| Assert.Contains(\"send async 0 2 'qu'\", actual);| Assert.Contains(\"send async 0 4 'quic'\", actual);| mre.Reset();| for (int i = 1; i < 8; i *= 2)| {| sender.Send(| buffer, 0, i, ex =>| {| lock (exceptions) exceptions.Add(ex);| });| }| sender.Close(ex =>| {| lock (exceptions)| {| exceptions.Add(ex);| }| mre.Set();| });| Assert.True(mre.WaitOne(10000), \"Network Close not completed\");| actual = sender.Log.ToString();| Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);| Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);| Assert.Contains(\"connect async to 0.0.0.0:123\", actual);| Assert.Contains(\"send async 0 1 'q'\", actual);| Assert.Contains(\"send async 0 2 'qu'\", actual);| Assert.Contains(\"send async 0 4 'quic'\", actual);| Assert.Contains(\"send async 0 1 'q'\", actual);| Assert.Contains(\"send async 0 2 'qu'\", actual);| Assert.Contains(\"send async 0 4 'quic'\", actual);| Assert.Contains(\"close\", actual);| foreach (var ex in exceptions)| {| Assert.Null(ex);| }| }| }"
      },
      {
        "name": "TcpProxyTest",
        "body": "{| var sender = new TcpNetworkSender(\"tcp://foo:1234\", AddressFamily.Unspecified);| var socket = sender.CreateSocket(\"foo\", AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, TimeSpan.Zero);| Assert.IsType<SocketProxy>(socket);| }"
      },
      {
        "name": "TcpConnectFailureTest",
        "body": "{| var sender = new MyTcpNetworkSender(\"tcp://hostname:123\", AddressFamily.Unspecified)| {| ConnectFailure = 1,| Async = true,| };| sender.Initialize();| byte[] buffer = Encoding.UTF8.GetBytes(\"quick brown fox jumps over the lazy dog\");| var exceptions = new List<Exception>();| var allSent = new ManualResetEvent(false);| for (int i = 1; i < 8; i++)| {| sender.Send(| buffer, 0, i, ex =>| {| lock (exceptions)| {| exceptions.Add(ex);| if (exceptions.Count == 7)| {| allSent.Set();| }| }| });| }| Assert.True(allSent.WaitOne(10000), \"Network Write not completed\");| var mre = new ManualResetEvent(false);| sender.FlushAsync(ex => mre.Set());| Assert.True(mre.WaitOne(10000), \"Network Flush not completed\");| var actual = sender.Log.ToString();| Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);| Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);| Assert.Contains(\"connect async to 0.0.0.0:123\", actual);| Assert.Contains(\"failed\", actual);| foreach (var ex in exceptions)| {| Assert.NotNull(ex);| }| }"
      },
      {
        "name": "TcpSendFailureTest",
        "body": "{| var sender = new MyTcpNetworkSender(\"tcp://hostname:123\", AddressFamily.Unspecified)| {| SendFailureIn = 3, // will cause failure on 3rd send| Async = true,| };| sender.Initialize();| byte[] buffer = Encoding.UTF8.GetBytes(\"quick brown fox jumps over the lazy dog\");| var exceptions = new Exception[9];| var writeFinished = new ManualResetEvent(false);| int remaining = exceptions.Length;| for (int i = 1; i < 10; i++)| {| int pos = i - 1;| sender.Send(| buffer, 0, i, ex =>| {| lock (exceptions)| {| exceptions[pos] = ex;| if (--remaining == 0)| {| writeFinished.Set();| }| }| });| }| var mre = new ManualResetEvent(false);| Assert.True(writeFinished.WaitOne(10000), \"Network Write not completed\");| sender.Close(ex => mre.Set());| Assert.True(mre.WaitOne(10000), \"Network Flush not completed\");| var actual = sender.Log.ToString();| Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);| Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);| Assert.Contains(\"connect async to 0.0.0.0:123\", actual);| Assert.Contains(\"send async 0 1 'q'\", actual);| Assert.Contains(\"send async 0 2 'qu'\", actual);| Assert.Contains(\"send async 0 3 'qui'\", actual);| Assert.Contains(\"failed\", actual);| Assert.Contains(\"close\", actual);| for (int i = 0; i < exceptions.Length; ++i)| {| if (i < 2)| {| Assert.Null(exceptions[i]);| }| else| {| Assert.NotNull(exceptions[i]);| }| }| }"
      }
    ]
  },
  {
    "file": "ApiTests.cs",
    "methods": [
      {
        "name": "PublicEnumsTest",
        "body": "{| foreach (Type type in allTypes)| {| if (!type.IsPublic)| {| continue;| }| if (type.IsEnum || type.IsInterface)| {| typeUsageCount[type] = 0;| }| }| typeUsageCount[typeof(IInstallable)] = 1;| foreach (Type type in allTypes)| {| if (type.IsGenericTypeDefinition)| {| continue;| }| if (type.BaseType != null)| {| IncrementUsageCount(type.BaseType);| }| foreach (var iface in type.GetInterfaces())| {| IncrementUsageCount(iface);| }| foreach (var method in type.GetMethods())| {| if (method.IsGenericMethodDefinition)| {| continue;| }| // Console.WriteLine(\" {0}\", method.Name);| try| {| IncrementUsageCount(method.ReturnType);| foreach (var p in method.GetParameters())| {| IncrementUsageCount(p.ParameterType);| }| }| catch (Exception ex)| {| // this sometimes throws on .NET Compact Framework, but is not fatal| Console.WriteLine(\"EXCEPTION {0}\", ex);| }| }| }| var unusedTypes = new List<Type>();| StringBuilder sb = new StringBuilder();| foreach (var kvp in typeUsageCount)| {| if (kvp.Value == 0)| {| Console.WriteLine(\"Type '{0}' is not used.\", kvp.Key);| unusedTypes.Add(kvp.Key);| sb.Append(kvp.Key.FullName).Append('\\n');| }| }| Assert.Empty(unusedTypes);| }"
      },
      {
        "name": "TypesInInternalNamespaceShouldBeInternalTest",
        "body": "{| var excludes = new HashSet<Type>| {| typeof(NLog.Internal.Xamarin.PreserveAttribute),| };| var notInternalTypes = allTypes| .Where(t => t.Namespace != null && t.Namespace.Contains(\".Internal\"))| .Where(t => !t.IsNested && (t.IsVisible || t.IsPublic))| .Where(n => !excludes.Contains(n))| .Select(t => t.FullName)| .ToList();| Assert.Empty(notInternalTypes);| }"
      },
      {
        "name": "TryGetRawValue_ThreadAgnostic_Attribute_Required",
        "body": "{| foreach (Type type in allTypes)| {| if (typeof(NLog.Internal.IRawValue).IsAssignableFrom(type) && !type.IsInterface)| {| var threadAgnosticAttribute = type.GetCustomAttribute<ThreadAgnosticAttribute>();| Assert.False(threadAgnosticAttribute is null, $\"{type.ToString()} cannot implement IRawValue\");| }| }| }"
      },
      {
        "name": "IStringValueRenderer_AppDomainFixedOutput_Attribute_NotRequired",
        "body": "{| foreach (Type type in allTypes)| {| if (typeof(NLog.Internal.IStringValueRenderer).IsAssignableFrom(type) && !type.IsInterface)| {| var appDomainFixedOutputAttribute = type.GetCustomAttribute<AppDomainFixedOutputAttribute>();| Assert.True(appDomainFixedOutputAttribute is null, $\"{type.ToString()} should not implement IStringValueRenderer\");| }| }| }"
      },
      {
        "name": "RequiredConfigOptionMustBeClass",
        "body": "{| foreach (Type type in allTypes)| {| var properties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);| foreach (var prop in properties)| {| var requiredParameter = prop.GetCustomAttribute<NLog.Config.RequiredParameterAttribute>();| if (requiredParameter != null)| {| Assert.True(prop.PropertyType.IsClass, type.Name);| }| }| }| }"
      },
      {
        "name": "SingleDefaultConfigOption",
        "body": "{| string prevDefaultPropertyName = null;| foreach (Type type in allTypes)| {| prevDefaultPropertyName = null;| var properties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);| foreach (var prop in properties)| {| var defaultParameter = prop.GetCustomAttribute<DefaultParameterAttribute>();| if (defaultParameter != null)| {| Assert.True(prevDefaultPropertyName == null, prevDefaultPropertyName?.ToString());| prevDefaultPropertyName = prop.Name;| Assert.True(type.IsSubclassOf(typeof(NLog.LayoutRenderers.LayoutRenderer)), type.ToString());| }| }| }| }"
      },
      {
        "name": "AppDomainFixedOutput_Attribute_EnsureThreadAgnostic",
        "body": "{| foreach (Type type in allTypes)| {| var appDomainFixedOutputAttribute = type.GetCustomAttribute<AppDomainFixedOutputAttribute>();| if (appDomainFixedOutputAttribute != null)| {| var threadAgnosticAttribute = type.GetCustomAttribute<ThreadAgnosticAttribute>();| Assert.False(threadAgnosticAttribute is null, $\"{type.ToString()} should also have [ThreadAgnostic]\");| }| }| }"
      },
      {
        "name": "WrapperLayoutRenderer_EnsureThreadAgnostic",
        "body": "{| foreach (Type type in allTypes)| {| if (typeof(NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase).IsAssignableFrom(type))| {| if (type.IsAbstract || !type.IsPublic)| continue; // skip non-concrete types, enumerations, and private nested types| Assert.True(type.IsDefined(typeof(ThreadAgnosticAttribute), true), $\"{type.ToString()} is missing [ThreadAgnostic] attribute.\");| }| }| }"
      },
      {
        "name": "ValidateLayoutRendererTypeAlias",
        "body": "{| // These class-names should be repaired with next major version bump| // Do NOT add more incorrect class-names to this exlusion-list| HashSet<string> oldFaultyClassNames = new HashSet<string>()| {| \"GarbageCollectorInfoLayoutRenderer\",| \"ScopeContextNestedStatesLayoutRenderer\",| \"ScopeContextPropertyLayoutRenderer\",| \"ScopeContextTimingLayoutRenderer\",| \"ScopeContextIndentLayoutRenderer\",| \"TraceActivityIdLayoutRenderer\",| \"SpecialFolderApplicationDataLayoutRenderer\",| \"SpecialFolderCommonApplicationDataLayoutRenderer\",| \"SpecialFolderLocalApplicationDataLayoutRenderer\",| \"DirectorySeparatorLayoutRenderer\",| \"LiteralWithRawValueLayoutRenderer\",| \"LocalIpAddressLayoutRenderer\",| \"VariableLayoutRenderer\",| \"ObjectPathRendererWrapper\",| \"PaddingLayoutRendererWrapper\",| };| foreach (Type type in allTypes)| {| if (type.IsSubclassOf(typeof(NLog.LayoutRenderers.LayoutRenderer)))| {| var layoutRendererAttributes = type.GetCustomAttributes<NLog.LayoutRenderers.LayoutRendererAttribute>()?.ToArray() ?? NLog.Internal.ArrayHelper.Empty<NLog.LayoutRenderers.LayoutRendererAttribute>();| if (layoutRendererAttributes.Length == 0)| {| if (type != typeof(NLog.LayoutRenderers.FuncLayoutRenderer) && type != typeof(NLog.LayoutRenderers.FuncThreadAgnosticLayoutRenderer))| {| Assert.True(type.IsAbstract, $\"{type} without LayoutRendererAttribute must be abstract\");| }| }| else| {| Assert.False(type.IsAbstract, $\"{type} with LayoutRendererAttribute cannot be abstract\");| if (!oldFaultyClassNames.Contains(type.Name))| {| if (type.IsSubclassOf(typeof(NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase)))| {| var typeAlias = layoutRendererAttributes.First().Name.Replace(\"-\", \"\");| Assert.Equal(typeAlias + \"LayoutRendererWrapper\", type.Name, StringComparer.OrdinalIgnoreCase);| }| else| {| var typeAlias = layoutRendererAttributes.First().Name.Replace(\"-\", \"\");| Assert.Equal(typeAlias + \"LayoutRenderer\", type.Name, StringComparer.OrdinalIgnoreCase);| }| }| }| }| }| }"
      },
      {
        "name": "ValidateConfigurationItemFactory",
        "body": "{| ConfigurationItemFactory.Default = null; // Reset| var missingTypes = new List<string>();| foreach (Type type in allTypes)| {| if (!type.IsPublic || !type.IsClass || type.IsAbstract)| continue;| if (typeof(NLog.Targets.Target).IsAssignableFrom(type))| {| var configAttribs = type.GetCustomAttributes<NLog.Targets.TargetAttribute>(false);| Assert.NotEmpty(configAttribs);| foreach (var configName in configAttribs)| {| if (!ConfigurationItemFactory.Default.TargetFactory.TryCreateInstance(configName.Name, out var target))| {| Console.WriteLine(configName.Name);| missingTypes.Add(configName.Name);| }| else if (type != target.GetType())| {| Console.WriteLine(type.Name);| missingTypes.Add(type.Name);| }| }| }| else if (typeof(NLog.Layouts.Layout).IsAssignableFrom(type))| {| if (type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(NLog.Layouts.Layout<>)))| continue;| if (type == typeof(NLog.Layouts.XmlElement))| continue;| var configAttribs = type.GetCustomAttributes<NLog.Layouts.LayoutAttribute>(false);| Assert.NotEmpty(configAttribs);| foreach (var configName in configAttribs)| {| if (!ConfigurationItemFactory.Default.LayoutFactory.TryCreateInstance(configName.Name, out var layout))| {| Console.WriteLine(configName.Name);| missingTypes.Add(configName.Name);| }| else if (type != layout.GetType())| {| Console.WriteLine(type.Name);| missingTypes.Add(type.Name);| }| }| }| else if (typeof(NLog.LayoutRenderers.LayoutRenderer).IsAssignableFrom(type))| {| if (type == typeof(NLog.LayoutRenderers.FuncLayoutRenderer) || type == typeof(NLog.LayoutRenderers.FuncThreadAgnosticLayoutRenderer))| continue;| var configAttribs = type.GetCustomAttributes<NLog.LayoutRenderers.LayoutRendererAttribute>(false);| Assert.NotEmpty(configAttribs);| foreach (var configName in configAttribs)| {| if (!ConfigurationItemFactory.Default.LayoutRendererFactory.TryCreateInstance(configName.Name, out var layoutRenderer))| {| Console.WriteLine(configName.Name);| missingTypes.Add(configName.Name);| }| else if (type != layoutRenderer.GetType())| {| Console.WriteLine(type.Name);| missingTypes.Add(type.Name);| }| }| if (typeof(NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase).IsAssignableFrom(type))| {| var wrapperAttribs = type.GetCustomAttributes<NLog.LayoutRenderers.AmbientPropertyAttribute>(false);| if (wrapperAttribs?.Any() == true)| {| foreach (var ambientName in wrapperAttribs)| {| if (!ConfigurationItemFactory.Default.AmbientRendererFactory.TryCreateInstance(ambientName.Name, out var layoutRenderer))| {| Console.WriteLine(ambientName.Name);| missingTypes.Add(ambientName.Name);| }| else if (type != layoutRenderer.GetType())| {| Console.WriteLine(type.Name);| missingTypes.Add(type.Name);| }| }| }| }| }| else if (typeof(NLog.Filters.Filter).IsAssignableFrom(type))| {| if (type == typeof(NLog.Filters.WhenMethodFilter))| continue;| var configAttribs = type.GetCustomAttributes<NLog.Filters.FilterAttribute>(false);| Assert.NotEmpty(configAttribs);| foreach (var configName in configAttribs)| {| if (!ConfigurationItemFactory.Default.FilterFactory.TryCreateInstance(configName.Name, out var filter))| {| Console.WriteLine(configName.Name);| missingTypes.Add(configName.Name);| }| else if (type != filter.GetType())| {| Console.WriteLine(type.Name);| missingTypes.Add(type.Name);| }| }| }| else if (typeof(NLog.Time.TimeSource).IsAssignableFrom(type))| {| var configAttribs = type.GetCustomAttributes<NLog.Time.TimeSourceAttribute>(false);| Assert.NotEmpty(configAttribs);| foreach (var configName in configAttribs)| {| if (!ConfigurationItemFactory.Default.TimeSourceFactory.TryCreateInstance(configName.Name, out var timeSource))| {| Console.WriteLine(configName.Name);| missingTypes.Add(configName.Name);| }| else if (type != timeSource.GetType())| {| Console.WriteLine(type.Name);| missingTypes.Add(type.Name);| }| }| }| }| Assert.Empty(missingTypes);| }"
      }
    ]
  },
  {
    "file": "AsyncHelperTests.cs",
    "methods": [
      {
        "name": "OneTimeOnlyTest1",
        "body": "{| var exceptions = new List<Exception>();| AsyncContinuation cont = exceptions.Add;| cont = AsyncHelpers.PreventMultipleCalls(cont);| // OneTimeOnly(OneTimeOnly(x)) == OneTimeOnly(x)| var cont2 = AsyncHelpers.PreventMultipleCalls(cont);| Assert.Same(cont, cont2);| var sampleException = new ApplicationException(\"some message\");| cont(null);| cont(sampleException);| cont(null);| cont(sampleException);| Assert.Single(exceptions);| Assert.Null(exceptions[0]);| }"
      },
      {
        "name": "OneTimeOnlyTest2",
        "body": "{| var exceptions = new List<Exception>();| AsyncContinuation cont = exceptions.Add;| cont = AsyncHelpers.PreventMultipleCalls(cont);| var sampleException = new ApplicationException(\"some message\");| cont(sampleException);| cont(null);| cont(sampleException);| cont(null);| Assert.Single(exceptions);| Assert.Same(sampleException, exceptions[0]);| }"
      },
      {
        "name": "OneTimeOnlyExceptionInHandlerTest",
        "body": "{| using (new NoThrowNLogExceptions())| {| var exceptions = new List<Exception>();| var sampleException = new ApplicationException(\"some message\");| AsyncContinuation cont = ex => { exceptions.Add(ex); throw sampleException; };| cont = AsyncHelpers.PreventMultipleCalls(cont);| cont(null);| cont(null);| cont(null);| Assert.Single(exceptions);| Assert.Null(exceptions[0]);| }| }"
      },
      {
        "name": "OneTimeOnlyExceptionInHandlerTest_RethrowExceptionEnabled",
        "body": "{| LogManager.ThrowExceptions = true;| var exceptions = new List<Exception>();| var sampleException = new ApplicationException(\"some message\");| AsyncContinuation cont = ex => { exceptions.Add(ex); throw sampleException; };| cont = AsyncHelpers.PreventMultipleCalls(cont);| try| {| cont(null);| }| catch { }| try| {| cont(null);| }| catch { }| try| {| cont(null);| }| catch { }| Assert.Single(exceptions);| Assert.Null(exceptions[0]);| }"
      },
      {
        "name": "ContinuationTimeoutTest",
        "body": "{| RetryingIntegrationTest(3, () =>| {| var resetEvent = new ManualResetEvent(false);| var exceptions = new List<Exception>();| // set up a timer to strike in 1 second| var cont = AsyncHelpers.WithTimeout(ex =>| {| exceptions.Add(ex);| resetEvent.Set();| }, TimeSpan.FromMilliseconds(1));| resetEvent.WaitOne(TimeSpan.FromSeconds(1));| // make sure we got timeout exception| Assert.Single(exceptions);| Assert.IsType<TimeoutException>(exceptions[0]);| Assert.Equal(\"Timeout.\", exceptions[0].Message);| // those will be ignored| cont(null);| cont(new ApplicationException(\"Some exception\"));| cont(null);| cont(new ApplicationException(\"Some exception\"));| Assert.Single(exceptions);| });| }"
      },
      {
        "name": "ContinuationTimeoutNotHitTest",
        "body": "{| var exceptions = new List<Exception>();| // set up a timer to strike| var cont = AsyncHelpers.WithTimeout(AsyncHelpers.PreventMultipleCalls(exceptions.Add), TimeSpan.FromMilliseconds(50));| // call success quickly, hopefully before the timer comes| cont(null);| // sleep to make sure timer event comes| Thread.Sleep(100);| // make sure we got success, not a timer exception| Assert.Single(exceptions);| Assert.Null(exceptions[0]);| // those will be ignored| cont(null);| cont(new ApplicationException(\"Some exception\"));| cont(null);| cont(new ApplicationException(\"Some exception\"));| Assert.Single(exceptions);| Assert.Null(exceptions[0]);| }"
      },
      {
        "name": "ContinuationErrorTimeoutNotHitTest",
        "body": "{| var exceptions = new List<Exception>();| // set up a timer to strike| var cont = AsyncHelpers.WithTimeout(AsyncHelpers.PreventMultipleCalls(exceptions.Add), TimeSpan.FromMilliseconds(50));| var exception = new ApplicationException(\"Foo\");| // call success quickly, hopefully before the timer comes| cont(exception);| // sleep to make sure timer event comes| Thread.Sleep(100);| // make sure we got success, not a timer exception| Assert.Single(exceptions);| Assert.NotNull(exceptions[0]);| Assert.Same(exception, exceptions[0]);| // those will be ignored| cont(null);| cont(new ApplicationException(\"Some exception\"));| cont(null);| cont(new ApplicationException(\"Some exception\"));| Assert.Single(exceptions);| Assert.NotNull(exceptions[0]);| }"
      },
      {
        "name": "RepeatTest1",
        "body": "{| bool finalContinuationInvoked = false;| Exception lastException = null;| AsyncContinuation finalContinuation = ex =>| {| finalContinuationInvoked = true;| lastException = ex;| };| int callCount = 0;| AsyncHelpers.Repeat(10, finalContinuation,| cont =>| {| callCount++;| cont(null);| });| Assert.True(finalContinuationInvoked);| Assert.Null(lastException);| Assert.Equal(10, callCount);| }"
      },
      {
        "name": "RepeatTest2",
        "body": "{| bool finalContinuationInvoked = false;| Exception lastException = null;| Exception sampleException = new ApplicationException(\"Some message\");| AsyncContinuation finalContinuation = ex =>| {| finalContinuationInvoked = true;| lastException = ex;| };| int callCount = 0;| AsyncHelpers.Repeat(10, finalContinuation,| cont =>| {| callCount++;| cont(sampleException);| cont(sampleException);| });| Assert.True(finalContinuationInvoked);| Assert.Same(sampleException, lastException);| Assert.Equal(1, callCount);| }"
      },
      {
        "name": "RepeatTest3",
        "body": "{| using (new NoThrowNLogExceptions())| {| bool finalContinuationInvoked = false;| Exception lastException = null;| Exception sampleException = new ApplicationException(\"Some message\");| AsyncContinuation finalContinuation = ex =>| {| finalContinuationInvoked = true;| lastException = ex;| };| int callCount = 0;| AsyncHelpers.Repeat(10, finalContinuation,| cont =>| {| callCount++;| throw sampleException;| });| Assert.True(finalContinuationInvoked);| Assert.Same(sampleException, lastException);| Assert.Equal(1, callCount);| }| }"
      },
      {
        "name": "ForEachItemSequentiallyTest1",
        "body": "{| bool finalContinuationInvoked = false;| Exception lastException = null;| AsyncContinuation finalContinuation = ex =>| {| finalContinuationInvoked = true;| lastException = ex;| };| int sum = 0;| var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };| AsyncHelpers.ForEachItemSequentially(input, finalContinuation,| (i, cont) =>| {| sum += i;| cont(null);| cont(null);| });| Assert.True(finalContinuationInvoked);| Assert.Null(lastException);| Assert.Equal(55, sum);| }"
      },
      {
        "name": "ForEachItemSequentiallyTest2",
        "body": "{| bool finalContinuationInvoked = false;| Exception lastException = null;| Exception sampleException = new ApplicationException(\"Some message\");| AsyncContinuation finalContinuation = ex =>| {| finalContinuationInvoked = true;| lastException = ex;| };| int sum = 0;| var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };| AsyncHelpers.ForEachItemSequentially(input, finalContinuation,| (i, cont) =>| {| sum += i;| cont(sampleException);| cont(sampleException);| });| Assert.True(finalContinuationInvoked);| Assert.Same(sampleException, lastException);| Assert.Equal(1, sum);| }"
      },
      {
        "name": "ForEachItemSequentiallyTest3",
        "body": "{| using (new NoThrowNLogExceptions())| {| bool finalContinuationInvoked = false;| Exception lastException = null;| Exception sampleException = new ApplicationException(\"Some message\");| AsyncContinuation finalContinuation = ex =>| {| finalContinuationInvoked = true;| lastException = ex;| };| int sum = 0;| var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };| AsyncHelpers.ForEachItemSequentially(input, finalContinuation,| (i, cont) =>| {| sum += i;| throw sampleException;| });| Assert.True(finalContinuationInvoked);| Assert.Same(sampleException, lastException);| Assert.Equal(1, sum);| }| }"
      },
      {
        "name": "ForEachItemInParallelEmptyTest",
        "body": "{| int[] items = ArrayHelper.Empty<int>();| Exception lastException = null;| bool finalContinuationInvoked = false;| AsyncContinuation continuation = ex =>| {| lastException = ex;| finalContinuationInvoked = true;| };| AsyncHelpers.ForEachItemInParallel(items, continuation, (i, cont) => { Assert.Fail(\"Should not be reached\"); });| Assert.True(finalContinuationInvoked);| Assert.Null(lastException);| }"
      },
      {
        "name": "ForEachItemInParallelTest",
        "body": "{| var finalContinuationInvoked = new ManualResetEvent(false);| Exception lastException = null;| AsyncContinuation finalContinuation = ex =>| {| lastException = ex;| finalContinuationInvoked.Set();| };| int sum = 0;| var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };| AsyncHelpers.ForEachItemInParallel(input, finalContinuation,| (i, cont) =>| {| lock (input)| {| sum += i;| }| cont(null);| cont(null);| });| finalContinuationInvoked.WaitOne();| Assert.Null(lastException);| Assert.Equal(55, sum);| }"
      },
      {
        "name": "ForEachItemInParallelSingleFailureTest",
        "body": "{| using (new InternalLoggerScope())| using (new NoThrowNLogExceptions())| {| InternalLogger.LogLevel = LogLevel.Trace;| var finalContinuationInvoked = new ManualResetEvent(false);| Exception lastException = null;| AsyncContinuation finalContinuation = ex =>| {| lastException = ex;| finalContinuationInvoked.Set();| };| int sum = 0;| var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };| AsyncHelpers.ForEachItemInParallel(input, finalContinuation,| (i, cont) =>| {| lock (input)| {| sum += i;| }| if (i == 7)| {| throw new ApplicationException(\"Some failure.\");| }| cont(null);| });| finalContinuationInvoked.WaitOne();| Assert.Equal(55, sum);| Assert.NotNull(lastException);| Assert.IsType<ApplicationException>(lastException);| Assert.Equal(\"Some failure.\", lastException.Message);| }| }"
      },
      {
        "name": "ForEachItemInParallelMultipleFailuresTest",
        "body": "{| using (new NoThrowNLogExceptions())| {| var finalContinuationInvoked = new ManualResetEvent(false);| Exception lastException = null;| AsyncContinuation finalContinuation = ex =>| {| lastException = ex;| finalContinuationInvoked.Set();| };| int sum = 0;| var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };| AsyncHelpers.ForEachItemInParallel(input, finalContinuation,| (i, cont) =>| {| lock (input)| {| sum += i;| }| throw new ApplicationException(\"Some failure.\");| });| finalContinuationInvoked.WaitOne();| Assert.Equal(55, sum);| Assert.NotNull(lastException);| Assert.IsType<NLogRuntimeException>(lastException);| Assert.StartsWith(\"Got multiple exceptions:\\r\\n\", lastException.Message);| }| }"
      },
      {
        "name": "PrecededByTest1",
        "body": "{| int invokedCount1 = 0;| int invokedCount2 = 0;| int sequence = 7;| int invokedCount1Sequence = 0;| int invokedCount2Sequence = 0;| AsyncContinuation originalContinuation = ex =>| {| invokedCount1++;| invokedCount1Sequence = sequence++;| };| AsynchronousAction doSomethingElse = c =>| {| invokedCount2++;| invokedCount2Sequence = sequence++;| c(null);| c(null);| };| AsyncContinuation cont = AsyncHelpers.PrecededBy(originalContinuation, doSomethingElse);| cont(null);| // make sure doSomethingElse was invoked first| // then original continuation| Assert.Equal(7, invokedCount2Sequence);| Assert.Equal(8, invokedCount1Sequence);| Assert.Equal(1, invokedCount1);| Assert.Equal(1, invokedCount2);| }"
      },
      {
        "name": "PrecededByTest2",
        "body": "{| int invokedCount1 = 0;| int invokedCount2 = 0;| int sequence = 7;| int invokedCount1Sequence = 0;| int invokedCount2Sequence = 0;| AsyncContinuation originalContinuation = ex =>| {| invokedCount1++;| invokedCount1Sequence = sequence++;| };| AsynchronousAction doSomethingElse = c =>| {| invokedCount2++;| invokedCount2Sequence = sequence++;| c(null);| c(null);| };| AsyncContinuation cont = AsyncHelpers.PrecededBy(originalContinuation, doSomethingElse);| var sampleException = new ApplicationException(\"Some message.\");| cont(sampleException);| // make sure doSomethingElse was not invoked| Assert.Equal(0, invokedCount2Sequence);| Assert.Equal(7, invokedCount1Sequence);| Assert.Equal(1, invokedCount1);| Assert.Equal(0, invokedCount2);| }"
      }
    ]
  },
  {
    "file": "ConditionEvaluatorTests.cs",
    "methods": [
      {
        "name": "ConditionMethodsTest",
        "body": "{| AssertEvaluationResult(true, \"regex-matches('foo', '^foo$')\");| AssertEvaluationResult(false, \"regex-matches('foo', '^bar$')\");| //Check that calling with empty string is equivalent with not passing the parameter| AssertEvaluationResult(true, \"regex-matches('foo', '^foo$', '')\");| AssertEvaluationResult(false, \"regex-matches('foo', '^bar$', '')\");| //Check that options are parsed correctly| AssertEvaluationResult(true, \"regex-matches('Foo', '^foo$', 'ignorecase')\");| AssertEvaluationResult(false, \"regex-matches('Foo', '^foo$')\");| AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,multiline')\");| AssertEvaluationResult(false, \"regex-matches('foo\\nbar', '^Foo$')\");| Assert.Throws<ConditionEvaluationException>(() => AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,nonexistent')\"));| }"
      }
    ]
  },
  {
    "file": "ConditionParserTests.cs",
    "methods": [
      {
        "name": "ParseNullText",
        "body": "{| Assert.Null(ConditionParser.ParseExpression(null));| }"
      },
      {
        "name": "ParseEmptyText",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"\"));| }"
      },
      {
        "name": "ImplicitOperatorTest",
        "body": "{| ConditionExpression cond = \"true and true\";| Assert.IsType<ConditionAndExpression>(cond);| }"
      },
      {
        "name": "NullLiteralTest",
        "body": "{| Assert.Equal(\"null\", ConditionParser.ParseExpression(\"null\").ToString());| }"
      },
      {
        "name": "BooleanLiteralTest",
        "body": "{| Assert.Equal(\"True\", ConditionParser.ParseExpression(\"true\").ToString());| Assert.Equal(\"True\", ConditionParser.ParseExpression(\"tRuE\").ToString());| Assert.Equal(\"False\", ConditionParser.ParseExpression(\"false\").ToString());| Assert.Equal(\"False\", ConditionParser.ParseExpression(\"fAlSe\").ToString());| }"
      },
      {
        "name": "AndTest",
        "body": "{| Assert.Equal(\"(True and True)\", ConditionParser.ParseExpression(\"true and true\").ToString());| Assert.Equal(\"(True and True)\", ConditionParser.ParseExpression(\"tRuE AND true\").ToString());| Assert.Equal(\"(True and True)\", ConditionParser.ParseExpression(\"tRuE && true\").ToString());| Assert.Equal(\"((True and True) and True)\", ConditionParser.ParseExpression(\"true and true && true\").ToString());| Assert.Equal(\"((True and True) and True)\", ConditionParser.ParseExpression(\"tRuE AND true and true\").ToString());| Assert.Equal(\"((True and True) and True)\", ConditionParser.ParseExpression(\"tRuE && true AND true\").ToString());| }"
      },
      {
        "name": "OrTest",
        "body": "{| Assert.Equal(\"(True or True)\", ConditionParser.ParseExpression(\"true or true\").ToString());| Assert.Equal(\"(True or True)\", ConditionParser.ParseExpression(\"tRuE OR true\").ToString());| Assert.Equal(\"(True or True)\", ConditionParser.ParseExpression(\"tRuE || true\").ToString());| Assert.Equal(\"((True or True) or True)\", ConditionParser.ParseExpression(\"true or true || true\").ToString());| Assert.Equal(\"((True or True) or True)\", ConditionParser.ParseExpression(\"tRuE OR true or true\").ToString());| Assert.Equal(\"((True or True) or True)\", ConditionParser.ParseExpression(\"tRuE || true OR true\").ToString());| }"
      },
      {
        "name": "NotTest",
        "body": "{| Assert.Equal(\"(not True)\", ConditionParser.ParseExpression(\"not true\").ToString());| Assert.Equal(\"(not (not True))\", ConditionParser.ParseExpression(\"not not true\").ToString());| Assert.Equal(\"(not (not (not True)))\", ConditionParser.ParseExpression(\"not not not true\").ToString());| }"
      },
      {
        "name": "StringTest",
        "body": "{| Assert.Equal(\"''\", ConditionParser.ParseExpression(\"''\").ToString());| Assert.Equal(\"'Foo'\", ConditionParser.ParseExpression(\"'Foo'\").ToString());| Assert.Equal(\"'Bar'\", ConditionParser.ParseExpression(\"'Bar'\").ToString());| Assert.Equal(\"'d'Artagnan'\", ConditionParser.ParseExpression(\"'d''Artagnan'\").ToString());| var cle = ConditionParser.ParseExpression(\"'${message} ${level}'\") as ConditionLayoutExpression;| Assert.NotNull(cle);| SimpleLayout sl = cle.Layout as SimpleLayout;| Assert.NotNull(sl);| Assert.Equal(3, sl.Renderers.Count);| Assert.IsType<MessageLayoutRenderer>(sl.Renderers[0]);| Assert.IsType<LiteralLayoutRenderer>(sl.Renderers[1]);| Assert.IsType<LevelLayoutRenderer>(sl.Renderers[2]);| }"
      },
      {
        "name": "LogLevelTest",
        "body": "{| var result = ConditionParser.ParseExpression(\"LogLevel.Info\") as ConditionLiteralExpression;| Assert.NotNull(result);| Assert.Same(LogLevel.Info, result.LiteralValue);| result = ConditionParser.ParseExpression(\"LogLevel.Trace\") as ConditionLiteralExpression;| Assert.NotNull(result);| Assert.Same(LogLevel.Trace, result.LiteralValue);| }"
      },
      {
        "name": "RelationalOperatorTest",
        "body": "{| RelationalOperatorTestInner(\"=\", \"==\");| RelationalOperatorTestInner(\"==\", \"==\");| RelationalOperatorTestInner(\"!=\", \"!=\");| RelationalOperatorTestInner(\"<>\", \"!=\");| RelationalOperatorTestInner(\"<\", \"<\");| RelationalOperatorTestInner(\">\", \">\");| RelationalOperatorTestInner(\"<=\", \"<=\");| RelationalOperatorTestInner(\">=\", \">=\");| }"
      },
      {
        "name": "NumberTest",
        "body": "{| var conditionExpression = ConditionParser.ParseExpression(\"3.141592\");| Assert.Equal(\"3.141592\", conditionExpression.ToString());| Assert.Equal(\"42\", ConditionParser.ParseExpression(\"42\").ToString());| Assert.Equal(\"-42\", ConditionParser.ParseExpression(\"-42\").ToString());| Assert.Equal(\"-3.141592\", ConditionParser.ParseExpression(\"-3.141592\").ToString());| }"
      },
      {
        "name": "ExtraParenthesisTest",
        "body": "{| Assert.Equal(\"3.141592\", ConditionParser.ParseExpression(\"(((3.141592)))\").ToString());| }"
      },
      {
        "name": "MessageTest",
        "body": "{| var result = ConditionParser.ParseExpression(\"message\");| Assert.IsType<ConditionMessageExpression>(result);| Assert.Equal(\"message\", result.ToString());| }"
      },
      {
        "name": "LevelTest",
        "body": "{| var result = ConditionParser.ParseExpression(\"level\");| Assert.IsType<ConditionLevelExpression>(result);| Assert.Equal(\"level\", result.ToString());| }"
      },
      {
        "name": "LoggerTest",
        "body": "{| var result = ConditionParser.ParseExpression(\"logger\");| Assert.IsType<ConditionLoggerNameExpression>(result);| Assert.Equal(\"logger\", result.ToString());| }"
      },
      {
        "name": "ConditionFunctionTests",
        "body": "{| var result = ConditionParser.ParseExpression(\"starts-with(logger, 'x${message}')\") as ConditionMethodExpression;| Assert.NotNull(result);| Assert.Equal(\"starts-with\", result.MethodName);| Assert.Equal(\"starts-with(logger, 'x${message}')\", result.ToString());| Assert.Equal(2, result.MethodParameters.Count);| }"
      },
      {
        "name": "CustomNLogFactoriesTest",
        "body": "{| var configurationItemFactory = new ConfigurationItemFactory();| configurationItemFactory.LayoutRendererFactory.RegisterType<FooLayoutRenderer>(\"foo\");| configurationItemFactory.ConditionMethodFactory.RegisterDefinition(\"check\", typeof(MyConditionMethods).GetMethod(\"CheckIt\"));| var result = ConditionParser.ParseExpression(\"check('${foo}')\", configurationItemFactory);| Assert.NotNull(result);| }"
      },
      {
        "name": "MethodNameWithUnderscores",
        "body": "{| var configurationItemFactory = new ConfigurationItemFactory();| configurationItemFactory.LayoutRendererFactory.RegisterType<FooLayoutRenderer>(\"foo\");| configurationItemFactory.ConditionMethodFactory.RegisterDefinition(\"__check__\", typeof(MyConditionMethods).GetMethod(\"CheckIt\"));| var result = ConditionParser.ParseExpression(\"__check__('${foo}')\", configurationItemFactory);| Assert.NotNull(result);| }"
      },
      {
        "name": "UnbalancedParenthesis1Test",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"check(\"));| }"
      },
      {
        "name": "UnbalancedParenthesis2Test",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"((1)\"));| }"
      },
      {
        "name": "UnbalancedParenthesis3Test",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"(1))\"));| }"
      },
      {
        "name": "LogLevelWithoutAName",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"LogLevel.'somestring'\"));| }"
      },
      {
        "name": "InvalidNumberWithUnaryMinusTest",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"-a31\"));| }"
      },
      {
        "name": "InvalidNumberTest",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"-123.4a\"));| }"
      },
      {
        "name": "UnclosedString",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"'Hello world\"));| }"
      },
      {
        "name": "UnrecognizedToken",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"somecompletelyunrecognizedtoken\"));| }"
      },
      {
        "name": "UnrecognizedPunctuation",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"#\"));| }"
      },
      {
        "name": "UnrecognizedUnicodeChar",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"\\u0090\"));| }"
      },
      {
        "name": "UnrecognizedUnicodeChar2",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"\\u0015\"));| }"
      },
      {
        "name": "UnrecognizedMethod",
        "body": "{| Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"unrecognized-method()\"));| }"
      },
      {
        "name": "TokenizerEOFTest",
        "body": "{| var tokenizer = new ConditionTokenizer(new SimpleStringReader(string.Empty));| Assert.Throws<ConditionParseException>(() => tokenizer.GetNextToken());| }"
      }
    ]
  },
  {
    "file": "ConfigApiTests.cs",
    "methods": [
      {
        "name": "AddTarget_testname",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(\"name1\", new FileTarget { Name = \"File\" });| var allTargets = config.AllTargets;| Assert.NotNull(allTargets);| Assert.Single(allTargets);| //maybe confusing, but the name of the target is not changed, only the one of the key.| Assert.Equal(\"File\", allTargets.First().Name);| Assert.NotNull(config.FindTargetByName<FileTarget>(\"name1\"));| config.RemoveTarget(\"name1\");| allTargets = config.AllTargets;| Assert.Empty(allTargets);| }"
      },
      {
        "name": "AddTarget_WithName_NullNameParam",
        "body": "{| var config = new LoggingConfiguration();| var ex = Assert.Throws<ArgumentNullException>(() => config.AddTarget(name: null, target: new FileTarget { Name = \"name1\" }));| Assert.Equal(\"name\", ex.ParamName);| }"
      },
      {
        "name": "AddTarget_WithName_EmptyNameParam",
        "body": "{| var config = new LoggingConfiguration();| var ex = Assert.Throws<ArgumentException>(() => config.AddTarget(name: \"\", target: new FileTarget { Name = \"name1\" }));| Assert.Equal(\"name\", ex.ParamName);| }"
      },
      {
        "name": "AddTarget_WithName_NullTargetParam",
        "body": "{| var config = new LoggingConfiguration();| var ex = Assert.Throws<ArgumentNullException>(() => config.AddTarget(name: \"Name1\", target: null));| Assert.Equal(\"target\", ex.ParamName);| }"
      },
      {
        "name": "AddTarget_TargetOnly_NullParam",
        "body": "{| var config = new LoggingConfiguration();| var ex = Assert.Throws<ArgumentNullException>(() => config.AddTarget(target: null));| Assert.Equal(\"target\", ex.ParamName);| }"
      },
      {
        "name": "AddTarget_TargetOnly_EmptyName",
        "body": "{| var config = new LoggingConfiguration();| var ex = Assert.Throws<ArgumentException>(() => config.AddTarget(target: new FileTarget { Name = \"\" }));| Assert.Equal(\"target\", ex.ParamName);| }"
      },
      {
        "name": "AddTarget_testname_param",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(\"name1\", new FileTarget { Name = \"name2\" });| var allTargets = config.AllTargets;| Assert.NotNull(allTargets);| Assert.Single(allTargets);| //maybe confusing, but the name of the target is not changed, only the one of the key.| Assert.Equal(\"name2\", allTargets.First().Name);| Assert.NotNull(config.FindTargetByName<FileTarget>(\"name1\"));| }"
      },
      {
        "name": "AddTarget_testname_fromtarget",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(new FileTarget { Name = \"name2\" });| var allTargets = config.AllTargets;| Assert.NotNull(allTargets);| Assert.Single(allTargets);| Assert.Equal(\"name2\", allTargets.First().Name);| Assert.NotNull(config.FindTargetByName<FileTarget>(\"name2\"));| }"
      },
      {
        "name": "AddRule_min_max",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(new FileTarget { Name = \"File\" });| config.AddRule(LogLevel.Info, LogLevel.Error, \"File\", \"*a\");| Assert.NotNull(config.LoggingRules);| Assert.Single(config.LoggingRules);| var rule1 = config.LoggingRules.FirstOrDefault();| Assert.NotNull(rule1);| Assert.False(rule1.Final);| Assert.Equal(\"*a\", rule1.LoggerNamePattern);| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Fatal));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Error));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Warn));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Info));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Debug));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Trace));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Off));| }"
      },
      {
        "name": "AddRule_ruleobject",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(new FileTarget { Name = \"File\" });| LoggingRule rule = new LoggingRule(\"testRule\")| {| LoggerNamePattern = \"testRulePattern\"| };| rule.EnableLoggingForLevels(LogLevel.Info, LogLevel.Error);| rule.Targets.Add(config.FindTargetByName(\"File\"));| rule.Final = true;| config.AddRule(rule);| Assert.NotNull(config.LoggingRules);| Assert.Single(config.LoggingRules);| var lastRule = config.LoggingRules.LastOrDefault();| Assert.Same(rule, lastRule);| }"
      },
      {
        "name": "AddRule_all",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(new FileTarget { Name = \"File\" });| config.AddRuleForAllLevels(\"File\", \"*a\");| Assert.NotNull(config.LoggingRules);| Assert.Single(config.LoggingRules);| var rule1 = config.LoggingRules.FirstOrDefault();| Assert.NotNull(rule1);| Assert.False(rule1.Final);| Assert.Equal(\"*a\", rule1.LoggerNamePattern);| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Fatal));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Error));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Warn));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Info));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Debug));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Trace));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Off));| }"
      },
      {
        "name": "AddRule_onelevel",
        "body": "{| var config = new LoggingConfiguration();| config.AddTarget(new FileTarget { Name = \"File\" });| config.AddRuleForOneLevel(LogLevel.Error, \"File\", \"*a\");| Assert.NotNull(config.LoggingRules);| Assert.Single(config.LoggingRules);| var rule1 = config.LoggingRules.FirstOrDefault();| Assert.NotNull(rule1);| Assert.False(rule1.Final);| Assert.Equal(\"*a\", rule1.LoggerNamePattern);| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Fatal));| Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Error));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Warn));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Info));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Debug));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Trace));| Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Off));| }"
      },
      {
        "name": "AddRule_with_target",
        "body": "{| var config = new LoggingConfiguration();| var fileTarget = new FileTarget { Name = \"File\" };| config.AddRuleForOneLevel(LogLevel.Error, fileTarget, \"*a\");| Assert.NotNull(config.LoggingRules);| Assert.Single(config.LoggingRules);| config.AddTarget(new FileTarget { Name = \"File\" });| var allTargets = config.AllTargets;| Assert.NotNull(allTargets);| Assert.Single(allTargets);| Assert.Equal(\"File\", allTargets.First().Name);| Assert.NotNull(config.FindTargetByName<FileTarget>(\"File\"));| }"
      },
      {
        "name": "AddRule_missingtarget",
        "body": "{| var config = new LoggingConfiguration();| Assert.Throws<NLogConfigurationException>(() => config.AddRuleForOneLevel(LogLevel.Error, \"File\", \"*a\"));| }"
      },
      {
        "name": "CheckAllTargets",
        "body": "{| var config = new LoggingConfiguration();| var fileTarget = new FileTarget { Name = \"File\", FileName = \"file\" };| config.AddRuleForOneLevel(LogLevel.Error, fileTarget, \"*a\");| config.AddTarget(fileTarget);| Assert.Single(config.AllTargets);| Assert.Equal(fileTarget, config.AllTargets[0]);| config.InitializeAll();| Assert.Single(config.AllTargets);| Assert.Equal(fileTarget, config.AllTargets[0]);| }"
      },
      {
        "name": "LogRuleToStringTest_min",
        "body": "{| var target = new FileTarget { Name = \"file1\" };| var loggingRule = new LoggingRule(\"*\", LogLevel.Error, target);| var s = loggingRule.ToString();| Assert.Equal(\"logNamePattern: (:All) levels: [ Error Fatal ] writeTo: [ file1 ]\", s);| }"
      },
      {
        "name": "LogRuleToStringTest_minAndMax",
        "body": "{| var target = new FileTarget { Name = \"file1\" };| var loggingRule = new LoggingRule(\"*\", LogLevel.Debug, LogLevel.Error, target);| var s = loggingRule.ToString();| Assert.Equal(\"logNamePattern: (:All) levels: [ Debug Info Warn Error ] writeTo: [ file1 ]\", s);| }"
      },
      {
        "name": "LogRuleToStringTest_none",
        "body": "{| var target = new FileTarget { Name = \"file1\" };| var loggingRule = new LoggingRule(\"*\", target);| var s = loggingRule.ToString();| Assert.Equal(\"logNamePattern: (:All) levels: [ ] writeTo: [ file1 ]\", s);| }"
      },
      {
        "name": "LogRuleToStringTest_empty",
        "body": "{| var target = new FileTarget { Name = \"file1\" };| var loggingRule = new LoggingRule(\"\", target);| var s = loggingRule.ToString();| Assert.Equal(\"logNamePattern: (:Equals) levels: [ ] writeTo: [ file1 ]\", s);| }"
      },
      {
        "name": "LogRuleToStringTest_filter",
        "body": "{| var target = new FileTarget { Name = \"file1\" };| var loggingRule = new LoggingRule(\"namespace.comp1\", target);| var s = loggingRule.ToString();| Assert.Equal(\"logNamePattern: (namespace.comp1:Equals) levels: [ ] writeTo: [ file1 ]\", s);| }"
      },
      {
        "name": "LogRuleToStringTest_multiple_targets",
        "body": "{| var target = new FileTarget { Name = \"file1\" };| var target2 = new FileTarget { Name = \"file2\" };| var loggingRule = new LoggingRule(\"namespace.comp1\", target);| loggingRule.Targets.Add(target2);| var s = loggingRule.ToString();| Assert.Equal(\"logNamePattern: (namespace.comp1:Equals) levels: [ ] writeTo: [ file1 file2 ]\", s);| }"
      },
      {
        "name": "LogRuleSetLoggingLevels_enables",
        "body": "{| var rule = new LoggingRule();| rule.SetLoggingLevels(LogLevel.Warn, LogLevel.Fatal);| Assert.Equal(rule.Levels, new[] { LogLevel.Warn, LogLevel.Error, LogLevel.Fatal });| }"
      },
      {
        "name": "LogRuleSetLoggingLevels_disables",
        "body": "{| var rule = new LoggingRule();| rule.EnableLoggingForLevels(LogLevel.MinLevel, LogLevel.MaxLevel);| rule.SetLoggingLevels(LogLevel.Warn, LogLevel.Fatal);| Assert.Equal(rule.Levels, new[] { LogLevel.Warn, LogLevel.Error, LogLevel.Fatal });| }"
      },
      {
        "name": "LogRuleSetLoggingLevels_off",
        "body": "{| var rule = new LoggingRule();| rule.EnableLoggingForLevels(LogLevel.MinLevel, LogLevel.MaxLevel);| rule.SetLoggingLevels(LogLevel.Off, LogLevel.Off);| Assert.Equal(rule.Levels, ArrayHelper.Empty<LogLevel>());| }"
      },
      {
        "name": "LogRuleDisableLoggingLevels",
        "body": "{| var rule = new LoggingRule();| rule.EnableLoggingForLevels(LogLevel.MinLevel, LogLevel.MaxLevel);| rule.DisableLoggingForLevels(LogLevel.Warn, LogLevel.Fatal);| Assert.Equal(rule.Levels, new[] { LogLevel.Trace, LogLevel.Debug, LogLevel.Info });| }"
      },
      {
        "name": "ConfigLogRuleWithName",
        "body": "{| var config = new LoggingConfiguration();| var rule = new LoggingRule(\"hello\");| config.LoggingRules.Add(rule);| var ruleLookup = config.FindRuleByName(\"hello\");| Assert.Same(rule, ruleLookup);| Assert.True(config.RemoveRuleByName(\"hello\"));| ruleLookup = config.FindRuleByName(\"hello\");| Assert.Null(ruleLookup);| Assert.False(config.RemoveRuleByName(\"hello\"));| }"
      },
      {
        "name": "FindRuleByName_AfterRename_FindNewOneAndDontFindOld",
        "body": "{| // Arrange| var config = new LoggingConfiguration();| var rule = new LoggingRule(\"hello\");| config.LoggingRules.Add(rule);| // Act| var foundRule1 = config.FindRuleByName(\"hello\");| foundRule1.RuleName = \"world\";| var foundRule2 = config.FindRuleByName(\"hello\");| var foundRule3 = config.FindRuleByName(\"world\");| // Assert| Assert.Null(foundRule2);| Assert.NotNull(foundRule1);| Assert.Same(foundRule1, foundRule3);| }"
      },
      {
        "name": "LoggerNameMatcher_None",
        "body": "{| var matcher = LoggerNameMatcher.Create(null);| Assert.Equal(\"logNamePattern: (:None)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_All",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"*\");| Assert.Equal(\"logNamePattern: (:All)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_Empty",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"\");| Assert.Equal(\"logNamePattern: (:Equals)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_Equals",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"abc\");| Assert.Equal(\"logNamePattern: (abc:Equals)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_StartsWith",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"abc*\");| Assert.Equal(\"logNamePattern: (abc:StartsWith)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_EndsWith",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"*abc\");| Assert.Equal(\"logNamePattern: (abc:EndsWith)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_Contains",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"*abc*\");| Assert.Equal(\"logNamePattern: (abc:Contains)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_MultiplePattern_StarInternal",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"a*bc\");| Assert.Equal(\"logNamePattern: (a*bc:MultiplePattern)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_MultiplePattern_QuestionMark",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"a?bc\");| Assert.Equal(\"logNamePattern: (a?bc:MultiplePattern)\", matcher.ToString());| }"
      },
      {
        "name": "LoggerNameMatcher_MultiplePattern_EscapedChars",
        "body": "{| var matcher = LoggerNameMatcher.Create(\"a?b.c.foo.bar\");| Assert.Equal(\"logNamePattern: (a?b.c.foo.bar:MultiplePattern)\", matcher.ToString());| }"
      }
    ]
  },
  {
    "file": "ConfigurationItemFactoryTests.cs",
    "methods": [
      {
        "name": "ConfigurationItemFactoryTargetTest",
        "body": "{| var itemFactory = new ConfigurationItemFactory();| itemFactory.TargetFactory.RegisterType<MemoryTarget>(nameof(MemoryTarget));| itemFactory.TargetFactory.TryCreateInstance(nameof(MemoryTarget), out var result);| Assert.IsType<MemoryTarget>(result);| }"
      },
      {
        "name": "ConfigurationItemFactoryFailsTest",
        "body": "{| var itemFactory = new ConfigurationItemFactory();| var ex = Assert.ThrowsAny<Exception>(() => itemFactory.GetTargetFactory().CreateInstance(\"Memory-Target\") as MemoryTarget);| Assert.Contains(\"Memory-Target\", ex.Message);| itemFactory.GetTargetFactory().RegisterDefinition(nameof(MemoryTarget), typeof(MemoryTarget));| var result = itemFactory.GetTargetFactory().CreateInstance(\"Memory-Target\");| Assert.IsType<MemoryTarget>(result);| }"
      },
      {
        "name": "ConfigurationItemFactorySimpleTest",
        "body": "{| var itemFactory = new ConfigurationItemFactory();| itemFactory.RegisterType<DebugTarget>();| itemFactory.TargetFactory.TryCreateInstance(\"Debug\", out var result);| Assert.NotNull(result);| }"
      }
    ]
  },
  {
    "file": "CultureInfoTests.cs",
    "methods": [
      {
        "name": "WhenInvariantCultureDefinedThenDefaultCultureIsInvariantCulture",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(\"<nlog useInvariantCulture='true'></nlog>\");| Assert.Equal(CultureInfo.InvariantCulture, configuration.DefaultCultureInfo);| }"
      },
      {
        "name": "DifferentConfigurations_UseDifferentDefaultCulture",
        "body": "{| var currentCulture = CultureInfo.CurrentCulture;| try| {| // set the current thread culture to be definitely different from the InvariantCulture| Thread.CurrentThread.CurrentCulture = GetCultureInfo(\"de-DE\");| var configurationTemplate = @\"<nlog useInvariantCulture='{0}'>|<targets>| <target name='debug' type='Debug' layout='${{message}}' />|</targets>|<rules>| <logger name='*' writeTo='debug'/>|</rules>|</nlog>\";| // configuration with current culture| var logFactory1 = new LogFactory();| var configuration1 = XmlLoggingConfiguration.CreateFromXmlString(string.Format(configurationTemplate, false), logFactory1);| Assert.Null(configuration1.DefaultCultureInfo);| logFactory1.Configuration = configuration1;| // configuration with invariant culture| var logFactory2 = new LogFactory();| var configuration2 = XmlLoggingConfiguration.CreateFromXmlString(string.Format(configurationTemplate, true), logFactory2);| Assert.Equal(CultureInfo.InvariantCulture, configuration2.DefaultCultureInfo);| logFactory2.Configuration = configuration2;| Assert.NotEqual(configuration1.DefaultCultureInfo, configuration2.DefaultCultureInfo);| var testNumber = 3.14;| var testDate = DateTime.Now;| const string formatString = \"{0},{1:d}\";| AssertMessageFormattedWithCulture(logFactory1, CultureInfo.CurrentCulture, formatString, testNumber, testDate);| AssertMessageFormattedWithCulture(logFactory2, CultureInfo.InvariantCulture, formatString, testNumber, testDate);| }| finally| {| // restore current thread culture| Thread.CurrentThread.CurrentCulture = currentCulture;| }| }"
      },
      {
        "name": "EventPropRendererCultureTest",
        "body": "{| string cultureName = \"de-DE\";| string expected = \"1,23\"; // with decimal comma| var logEventInfo = CreateLogEventInfo(cultureName);| logEventInfo.Properties[\"ADouble\"] = 1.23;| var renderer = new EventPropertiesLayoutRenderer();| renderer.Item = \"ADouble\";| string output = renderer.Render(logEventInfo);| Assert.Equal(expected, output);| }"
      },
      {
        "name": "ProcessInfoLayoutRendererCultureTest",
        "body": "{| string cultureName = \"de-DE\";| string expected = \".\"; // dot as date separator (01.10.2008)| string output = string.Empty;| var logEventInfo = CreateLogEventInfo(cultureName);| if (IsLinux())| {| Console.WriteLine(\"[SKIP] CultureInfoTests.ProcessInfoLayoutRendererCultureTest because we are running in Travis\");| }| else| {| var renderer = new ProcessInfoLayoutRenderer();| renderer.Property = ProcessInfoProperty.StartTime;| renderer.Format = \"d\";| output = renderer.Render(logEventInfo);| Assert.Contains(expected, output);| Assert.DoesNotContain(\"/\", output);| Assert.DoesNotContain(\"-\", output);| }| var renderer2 = new ProcessInfoLayoutRenderer();| renderer2.Property = ProcessInfoProperty.PriorityClass;| renderer2.Format = \"d\";| output = renderer2.Render(logEventInfo);| Assert.True(output.Length >= 1);| Assert.Contains(output[0], \"012345678\");| }"
      },
      {
        "name": "AllEventPropRendererCultureTest",
        "body": "{| string cultureName = \"de-DE\";| string expected = \"ADouble=1,23\"; // with decimal comma| var logEventInfo = CreateLogEventInfo(cultureName);| logEventInfo.Properties[\"ADouble\"] = 1.23;| var renderer = new AllEventPropertiesLayoutRenderer();| string output = renderer.Render(logEventInfo);| Assert.Equal(expected, output);| }"
      },
      {
        "name": "ExceptionTest",
        "body": "{| var target = new MemoryTarget { Layout = @\"${exception:format=tostring}\" };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(target);| }).GetCurrentClassLogger();| try| {| throw new InvalidOperationException();| }| catch (Exception ex)| {| Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"en-US\", false);| Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-US\", false);| logger.Error(ex, \"\");|#if NETFRAMEWORK| Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"de-DE\", false);| Thread.CurrentThread.CurrentCulture = new CultureInfo(\"de-DE\", false);|#endif| logger.Error(ex, \"\");| Assert.Equal(2, target.Logs.Count);| Assert.NotNull(target.Logs[0]);| Assert.NotNull(target.Logs[1]);| Assert.Equal(target.Logs[0], target.Logs[1]);| }| }"
      }
    ]
  },
  {
    "file": "ExtensionTests.cs",
    "methods": [
      {
        "name": "ExtensionTest1",
        "body": "{| Assert.NotNull(typeof(FooLayout));| var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <extensions>| <add assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />| </extensions>| <targets>| <target name='t' type='MyTarget' />| <target name='d1' type='Debug' layout='${foo}' />| <target name='d2' type='Debug'>| <layout type='FooLayout' x='1'>| </layout>| </target>| </targets>| <rules>| <logger name='*' writeTo='t'>| <filters>| <whenFoo x='44' action='Log' />| </filters>| </logger>| </rules>|</nlog>\").LogFactory.Configuration;| Target myTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");| var layout = d1Target.Layout as SimpleLayout;| Assert.NotNull(layout);| Assert.Single(layout.Renderers);| Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);| var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");| Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);| Assert.Single(configuration.LoggingRules[0].Filters);| Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);| }"
      },
      {
        "name": "ExtensionTest2",
        "body": "{| var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <extensions>| <add assembly='\" + extensionAssemblyName1 + @\"' />| </extensions>| <targets>| <target name='t' type='MyTarget' />| <target name='d1' type='Debug' layout='${foo}' />| <target name='d2' type='Debug'>| <layout type='FooLayout' x='1'>| </layout>| </target>| </targets>| <rules>| <logger name='*' writeTo='t'>| <filters>| <whenFoo x='44' action='Ignore' />| <when condition='myrandom(10)==3' action='Log' />| </filters>| </logger>| </rules>|</nlog>\").LogFactory.Configuration;| Target myTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");| var layout = d1Target.Layout as SimpleLayout;| Assert.NotNull(layout);| Assert.Single(layout.Renderers);| Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);| var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");| Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);| Assert.Equal(2, configuration.LoggingRules[0].Filters.Count);| Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);| var cbf = configuration.LoggingRules[0].Filters[1] as ConditionBasedFilter;| Assert.NotNull(cbf);| Assert.Equal(\"(myrandom(10) == 3)\", cbf.Condition.ToString());| }"
      },
      {
        "name": "ExtensionWithPrefixLoadTwiceTest",
        "body": "{| var configuration = new LogFactory().Setup().SetupExtensions(ext => ext.RegisterAssembly(extensionAssemblyName1))| .LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <extensions>| <add assembly='\" + extensionAssemblyName1 + @\"' prefix='twice' />| </extensions>| <targets>| <target name='t' type='twice.MyTarget' />| <target name='d1' type='Debug' layout='${foo}' />| <target name='d2' type='Debug'>| <layout type='twice.FooLayout' x='1'>| </layout>| </target>| </targets>| <rules>| <logger name='*' writeTo='t'>| <filters>| <whenFoo x='44' action='Ignore' />| <when condition='myrandom(10)==3' action='Log' />| </filters>| </logger>| </rules>|</nlog>\").LogFactory.Configuration;| Target myTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");| var layout = d1Target.Layout as SimpleLayout;| Assert.NotNull(layout);| Assert.Single(layout.Renderers);| Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);| var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");| Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);| Assert.Equal(2, configuration.LoggingRules[0].Filters.Count);| Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);| var cbf = configuration.LoggingRules[0].Filters[1] as ConditionBasedFilter;| Assert.NotNull(cbf);| Assert.Equal(\"(myrandom(10) == 3)\", cbf.Condition.ToString());| }"
      },
      {
        "name": "ExtensionWithPrefixTest",
        "body": "{| var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <extensions>| <add prefix='myprefix' assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />| </extensions>| <targets>| <target name='t' type='myprefix.MyTarget' />| <target name='d1' type='Debug' layout='${myprefix.foo}' />| <target name='d2' type='Debug'>| <layout type='myprefix.FooLayout' x='1'>| </layout>| </target>| </targets>| <rules>| <logger name='*' writeTo='t'>| <filters>| <myprefix.whenFoo x='44' action='Log' />| </filters>| </logger>| </rules>|</nlog>\").LogFactory.Configuration;| Target myTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");| var layout = d1Target.Layout as SimpleLayout;| Assert.NotNull(layout);| Assert.Single(layout.Renderers);| Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);| var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");| Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);| Assert.Single(configuration.LoggingRules[0].Filters);| Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);| }"
      },
      {
        "name": "ExtensionTest4",
        "body": "{| Assert.NotNull(typeof(FooLayout));| var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <extensions>| <add type='\" + typeof(MyTarget).AssemblyQualifiedName + @\"' />| <add type='\" + typeof(FooLayout).AssemblyQualifiedName + @\"' />| <add type='\" + typeof(FooLayoutRenderer).AssemblyQualifiedName + @\"' />| <add type='\" + typeof(WhenFooFilter).AssemblyQualifiedName + @\"' />| </extensions>| <targets>| <target name='t' type='MyTarget' />| <target name='d1' type='Debug' layout='${foo}' />| <target name='d2' type='Debug'>| <layout type='FooLayout' x='1'>| </layout>| </target>| </targets>| <rules>| <logger name='*' writeTo='t'>| <filters>| <whenFoo x='44' action='Log' />| </filters>| </logger>| </rules>|</nlog>\").LogFactory.Configuration;| Target myTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");| var layout = d1Target.Layout as SimpleLayout;| Assert.NotNull(layout);| Assert.Single(layout.Renderers);| Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);| var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");| Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);| Assert.Single(configuration.LoggingRules[0].Filters);| Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);| }"
      },
      {
        "name": "RegisterNamedTypeLessTest",
        "body": "{| Assert.NotNull(typeof(FooLayout));| var configurationItemFactory = new ConfigurationItemFactory();| configurationItemFactory.GetLayoutFactory().RegisterNamedType(\"foo\", typeof(FooLayout).ToString() + \",\" + typeof(FooLayout).Assembly.GetName().Name);| Assert.NotNull(configurationItemFactory.LayoutFactory.CreateInstance(\"foo\"));| }"
      },
      {
        "name": "ExtensionTest_extensions_not_top_and_used",
        "body": "{| Assert.NotNull(typeof(FooLayout));| var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>| <targets>| <target name='t' type='MyTarget' />| <target name='d1' type='Debug' layout='${foo}' />| <target name='d2' type='Debug'>| <layout type='FooLayout' x='1'>| </layout>| </target>| </targets>| <rules>| <logger name='*' writeTo='t'>| <filters>| <whenFoo x='44' action='Log' />| </filters>| </logger>| </rules>| <extensions>| <add assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />| </extensions>|</nlog>\").LogFactory.Configuration;| Target myTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");| var layout = d1Target.Layout as SimpleLayout;| Assert.NotNull(layout);| Assert.Single(layout.Renderers);| Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);| var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");| Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);| Assert.Single(configuration.LoggingRules[0].Filters);| Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);| }"
      },
      {
        "name": "ExtensionShouldThrowNLogConfiguratonExceptionWhenRegisteringInvalidType",
        "body": "{| var configXml = @\"|<nlog throwConfigExceptions='true'>| <extensions>| <add type='some_type_that_doesnt_exist'/>|</extensions>|</nlog>\";| Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(configXml));| }"
      },
      {
        "name": "ExtensionShouldThrowNLogConfiguratonExceptionWhenRegisteringInvalidAssembly",
        "body": "{| var configXml = @\"|<nlog throwConfigExceptions='true'>| <extensions>| <add assembly='some_assembly_that_doesnt_exist'/>| </extensions>|</nlog>\";| Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(configXml));| }"
      },
      {
        "name": "ExtensionShouldThrowNLogConfiguratonExceptionWhenRegisteringInvalidAssemblyFile",
        "body": "{| var configXml = @\"|<nlog throwConfigExceptions='true'>| <extensions>| <add assemblyfile='some_file_that_doesnt_exist'/>|</extensions>|</nlog>\";| Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(configXml));| }"
      },
      {
        "name": "ExtensionShouldNotThrowWhenRegisteringInvalidTypeIfThrowConfigExceptionsFalse",
        "body": "{| var configXml = @\"|<nlog throwConfigExceptions='false'>| <extensions>| <add type='some_type_that_doesnt_exist'/>| <add assembly='NLog'/>|</extensions>|</nlog>\";| var result = XmlLoggingConfiguration.CreateFromXmlString(configXml);| Assert.NotNull(result);| }"
      },
      {
        "name": "ExtensionShouldNotThrowWhenRegisteringInvalidAssemblyIfThrowConfigExceptionsFalse",
        "body": "{| var configXml = @\"|<nlog throwConfigExceptions='false'>| <extensions>| <add assembly='some_assembly_that_doesnt_exist'/>| </extensions>|</nlog>\";| var result = XmlLoggingConfiguration.CreateFromXmlString(configXml);| Assert.NotNull(result);| }"
      },
      {
        "name": "ExtensionShouldNotThrowWhenRegisteringInvalidAssemblyFileIfThrowConfigExceptionsFalse",
        "body": "{| var configXml = @\"|<nlog throwConfigExceptions='false'>| <extensions>| <add assemblyfile='some_file_that_doesnt_exist'/>|</extensions>|</nlog>\";| var result = XmlLoggingConfiguration.CreateFromXmlString(configXml);| Assert.NotNull(result);| }"
      },
      {
        "name": "CustomXmlNamespaceTest",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true' xmlns:foo='http://bar'>| <targets>| <target name='d' type='foo:Debug' />| </targets>|</nlog>\");| var d1Target = (DebugTarget)configuration.FindTargetByName(\"d\");| Assert.NotNull(d1Target);| }"
      },
      {
        "name": "Extension_should_be_auto_loaded_when_following_NLog_dll_format",
        "body": "{| var fileLocations = AssemblyExtensionLoader.GetAutoLoadingFileLocations().ToArray();| Assert.NotEmpty(fileLocations);| Assert.NotNull(fileLocations[0].Key);| Assert.NotNull(fileLocations[0].Value); // Primary search location is NLog-assembly| Assert.Equal(fileLocations.Length, fileLocations.Select(f => f.Key).Distinct().Count());| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true' autoLoadExtensions='true'>|<targets>| <target name='t' type='AutoLoadTarget' />|</targets>|<rules>| <logger name='*' writeTo='t' />|</rules>|</nlog>\").LogFactory;| var autoLoadedTarget = logFactory.Configuration.FindTargetByName(\"t\");| Assert.Equal(\"NLogAutloadExtension.AutoLoadTarget\", autoLoadedTarget.GetType().ToString());| }"
      },
      {
        "name": "ExtensionTypeWithAssemblyNameCanLoad",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog throwExceptions='true'>|<targets>| <target name='t' type='AutoLoadTarget, NLogAutoLoadExtension' />|</targets>|<rules>| <logger name='*' writeTo='t' />|</rules>|</nlog>\").LogFactory;| var autoLoadedTarget = logFactory.Configuration.FindTargetByName(\"t\");| Assert.Equal(\"NLogAutloadExtension.AutoLoadTarget\", autoLoadedTarget.GetType().ToString());| }"
      },
      {
        "name": "ImplicitConversionOperatorTest",
        "body": "{| var config = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog throwExceptions='true'>| <extensions>| <add assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />| </extensions>| <targets>| <target name='myTarget' type='MyTarget' layout='123' />| </targets>| <rules>| <logger name='*' level='Debug' writeTo='myTarget' />| </rules>| </nlog>\");| var target = config.FindTargetByName<MyTarget>(\"myTarget\");| Assert.NotNull(target);| Assert.Equal(123, target.Layout.X);| }"
      },
      {
        "name": "LoadExtensionFromAppDomain",
        "body": "{| try| {| LoadManuallyLoadedExtensionDll();| InternalLogger.LogLevel = LogLevel.Trace;| var writer = new StringWriter();| InternalLogger.LogWriter = writer;| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <extensions>| <add assembly='Manually-Loaded-Extension' />| </extensions>| <targets>| <target name='t' type='ManuallyLoadedTarget' />| </targets>|</nlog>\");| // We get Exception for normal Assembly-Load only in net452.|#if NETFRAMEWORK && !MONO| var logs = writer.ToString();| Assert.Contains(\"Try find 'Manually-Loaded-Extension' in current domain\", logs);|#endif| // Was AssemblyLoad successful?| var autoLoadedTarget = configuration.FindTargetByName(\"t\");| Assert.Equal(\"ManuallyLoadedExtension.ManuallyLoadedTarget\", autoLoadedTarget.GetType().FullName);| }| finally| {| InternalLogger.Reset();| }| }"
      },
      {
        "name": "FullyQualifiedExtensionTest",
        "body": "{| // Arrange| LoadManuallyLoadedExtensionDll();| // Act| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"<nlog throwConfigExceptions='true'>| <targets>| <target name='t' type='ManuallyLoadedTarget, Manually-Loaded-Extension' />| </targets>| </nlog>\").LogFactory;| // Assert| Assert.NotNull(logFactory.Configuration.FindTargetByName(\"t\"));| }"
      }
    ]
  },
  {
    "file": "IncludeTests.cs",
    "methods": [
      {
        "name": "IncludeTest",
        "body": "{| LogManager.ThrowExceptions = true;| var includeAttrValue = @\"included.nlog\";| IncludeTest_inner(includeAttrValue, GetTempDir());| }"
      },
      {
        "name": "IncludeWildcardTest_relative",
        "body": "{| var includeAttrValue = @\"*.nlog\";| IncludeTest_inner(includeAttrValue, GetTempDir());| }"
      },
      {
        "name": "IncludeWildcardTest_absolute",
        "body": "{| var includeAttrValue = @\"*.nlog\";| var tempPath = GetTempDir();| includeAttrValue = Path.Combine(tempPath, includeAttrValue);| IncludeTest_inner(includeAttrValue, tempPath);| }"
      },
      {
        "name": "IncludeNotExistingTest",
        "body": "{| LogManager.ThrowConfigExceptions = true;| string tempPath = GetTempDir();| Directory.CreateDirectory(tempPath);| using (StreamWriter fs = File.CreateText(Path.Combine(tempPath, \"main.nlog\")))| {| fs.Write(@\"<nlog>| <include file='included.nlog' />| </nlog>\");| }| string fileToLoad = Path.Combine(tempPath, \"main.nlog\");| try| {| Assert.Throws<NLogConfigurationException>(() => new XmlLoggingConfiguration(fileToLoad));| }| finally| {| if (Directory.Exists(tempPath))| Directory.Delete(tempPath, true);| }| }"
      },
      {
        "name": "IncludeNotExistingIgnoredTest",
        "body": "{| var tempPath = GetTempDir();| Directory.CreateDirectory(tempPath);| var config = @\"<nlog>| <include file='included-notpresent.nlog' ignoreErrors='true' />| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\";| CreateConfigFile(tempPath, \"main.nlog\", config);| string fileToLoad = Path.Combine(tempPath, \"main.nlog\");| try| {| LogManager.Configuration = new XmlLoggingConfiguration(fileToLoad);| LogManager.GetLogger(\"A\").Debug(\"aaa\");| AssertDebugLastMessage(\"debug\", \"aaa\");| }| finally| {| if (Directory.Exists(tempPath))| Directory.Delete(tempPath, true);| }| }"
      },
      {
        "name": "IncludeNotExistingIgnoredTest_DoesNotThrow",
        "body": "{| LogManager.ThrowExceptions = true;| var tempPath = GetTempDir();| Directory.CreateDirectory(tempPath);| var config = @\"<nlog>| <include file='included-notpresent.nlog' ignoreErrors='true' />| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\";| CreateConfigFile(tempPath, \"main.nlog\", config);| string fileToLoad = Path.Combine(tempPath, \"main.nlog\");| var ex = Record.Exception(() => new XmlLoggingConfiguration(fileToLoad));| Assert.Null(ex);| }"
      }
    ]
  },
  {
    "file": "InternalLoggingTests.cs",
    "methods": [
      {
        "name": "InternalLoggingConfigTest1",
        "body": "{| InternalLoggingConfigTest(LogLevel.Trace, true, true, LogLevel.Warn, true, true, @\"c:\\temp\\nlog\\file.txt\", true);| }"
      },
      {
        "name": "InternalLoggingConfigTest2",
        "body": "{| InternalLoggingConfigTest(LogLevel.Error, false, false, LogLevel.Info, false, false, @\"c:\\temp\\nlog\\file2.txt\", false);| }"
      },
      {
        "name": "InternalLoggingConfigTes3",
        "body": "{| InternalLoggingConfigTest(LogLevel.Info, false, false, LogLevel.Trace, false, null, @\"c:\\temp\\nlog\\file3.txt\", true);| }"
      },
      {
        "name": "InternalLoggingConfigTestDefaults",
        "body": "{| using (new InternalLoggerScope(true))| {| InternalLogger.LogLevel = LogLevel.Error;| InternalLogger.LogToConsole = true;| InternalLogger.LogToConsoleError = true;| LogManager.GlobalThreshold = LogLevel.Fatal;| LogManager.ThrowExceptions = true;| LogManager.ThrowConfigExceptions = null;| LogManager.AutoShutdown = true;| XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog>|</nlog>\");| Assert.Same(LogLevel.Error, InternalLogger.LogLevel);| Assert.True(InternalLogger.LogToConsole);| Assert.True(InternalLogger.LogToConsoleError);| Assert.Same(LogLevel.Fatal, LogManager.GlobalThreshold);| Assert.True(LogManager.ThrowExceptions);| Assert.Null(LogManager.ThrowConfigExceptions);| Assert.True(LogManager.AutoShutdown);| }| }"
      },
      {
        "name": "InternalLoggingConfig_off_should_be_off",
        "body": "{| using (new InternalLoggerScope())| {| var sb = new StringBuilder();| var stringWriter = new StringWriter(sb);| InternalLogger.LogWriter = stringWriter;| InternalLogger.LogLevel = LogLevel.Info;| string wrongFileName = \"WRONG/***[]???////WRONG\";| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString($@\"<?xml version='1.0' encoding='utf-8' ?>| <nlog internalLogFile='{wrongFileName}'| internalLogLevel='Off'| throwExceptions='true' >| <targets>| <target name='logfile' type='File' fileName='WRONG' />| </targets>| <rules>| <logger name='*' writeTo='logfile' />| </rules>| </nlog>| \");| Assert.Equal(\"\", sb.ToString());| Assert.Equal(LogLevel.Off, InternalLogger.LogLevel);| Assert.False(InternalLogger.ExceptionThrowWhenWriting);| }| }"
      },
      {
        "name": "InternalLoggingInvalidFormatString",
        "body": "{| using (new InternalLoggerScope())| {| var sb = new StringBuilder();| var stringWriter = new StringWriter(sb);| InternalLogger.LogWriter = stringWriter;| InternalLogger.LogLevel = LogLevel.Info;| var invalidFormatString = \"Invalid String.Format({Message})\";| InternalLogger.Warn(invalidFormatString, \"Oops\");| Assert.Contains(invalidFormatString, sb.ToString());| }| }"
      }
    ]
  },
  {
    "file": "PropertyTypeConverterTests.cs",
    "methods": [
      {
        "name": "Convert_IntToNullableIntTest",
        "body": "{| // Act| var result = _sut.Convert(123, typeof(int?), null, null);| // Assert| // int is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<int>(result);| Assert.Equal(123, resultTyped);| }"
      },
      {
        "name": "Convert_NullableIntToIntTest",
        "body": "{| // Act| var result = _sut.Convert((int?)123, typeof(int), null, null);| // Assert| // int is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<int>(result);| Assert.Equal(123, resultTyped);| }"
      },
      {
        "name": "Convert_StringToIntTest",
        "body": "{| // Act| var result = _sut.Convert(\"123\", typeof(int), null, null);| // Assert| var resultTyped = Assert.IsType<int>(result);| Assert.Equal(123, resultTyped);| }"
      },
      {
        "name": "Convert_StringToNullableIntTest",
        "body": "{| // Act| var result = _sut.Convert(\"123\", typeof(int?), null, null);| // Assert| // int is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<int>(result);| Assert.Equal(123, resultTyped);| }"
      },
      {
        "name": "Convert_StringToDecimalTest",
        "body": "{| // Act| var result = _sut.Convert(\"123.2\", typeof(decimal), null, CultureInfo.InvariantCulture);| // Assert| var resultTyped = Assert.IsType<decimal>(result);| Assert.Equal(123.2M, resultTyped);| }"
      },
      {
        "name": "Convert_StringToDecimalWithCultureTest",
        "body": "{| // Act| var result = _sut.Convert(\"123,2\", typeof(decimal), null, new CultureInfo(\"NL-nl\"));| // Assert| var resultTyped = Assert.IsType<decimal>(result);| Assert.Equal(123.2M, resultTyped);| }"
      },
      {
        "name": "Convert_StringToNullableDecimalTest",
        "body": "{| // Act| var result = _sut.Convert(\"123.2\", typeof(decimal?), null, CultureInfo.InvariantCulture);| // Assert| // decimal is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<decimal>(result);| Assert.Equal(123.2M, resultTyped);| }"
      },
      {
        "name": "Convert_StringToDoubleTest",
        "body": "{| // Act| var result = _sut.Convert(\"123.2\", typeof(double), null, CultureInfo.InvariantCulture);| // Assert| var resultTyped = Assert.IsType<double>(result);| Assert.Equal(123.2, resultTyped);| }"
      },
      {
        "name": "Convert_StringToDoubleWithCultureTest",
        "body": "{| // Act| var result = _sut.Convert(\"123,2\", typeof(double), null, new CultureInfo(\"NL-nl\"));| // Assert| var resultTyped = Assert.IsType<double>(result);| Assert.Equal(123.2, resultTyped);| }"
      },
      {
        "name": "Convert_StringToNullableDoubleTest",
        "body": "{| // Act| var result = _sut.Convert(\"123.2\", typeof(double?), null, CultureInfo.InvariantCulture);| // Assert| // double is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<double>(result);| Assert.Equal(123.2, resultTyped);| }"
      },
      {
        "name": "Convert_StringToShortTest",
        "body": "{| // Act| var result = _sut.Convert(\"123\", typeof(short), null, CultureInfo.InvariantCulture);| // Assert| var resultTyped = Assert.IsType<short>(result);| Assert.Equal(123, resultTyped);| }"
      },
      {
        "name": "Convert_StringToNullableShortTest",
        "body": "{| // Act| var result = _sut.Convert(\"123\", typeof(short), null, CultureInfo.InvariantCulture);| // Assert| // short is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<short>(result);| Assert.Equal(123, resultTyped);| }"
      },
      {
        "name": "Convert_FormattableToStringTest",
        "body": "{| // Act| var result = _sut.Convert(123, typeof(string), \"D4\", null);| // Assert| var resultTyped = Assert.IsType<string>(result);| Assert.Equal(\"0123\", resultTyped);| }"
      },
      {
        "name": "Convert_NullableFormattableToStringTest",
        "body": "{| // Arrange| int? nullableInt = 123;| // Act| var result = _sut.Convert(nullableInt, typeof(string), \"D4\", null);| // Assert| var resultTyped = Assert.IsType<string>(result);| Assert.Equal(\"0123\", resultTyped);| }"
      },
      {
        "name": "Convert_StringToDatetimeWithFormat",
        "body": "{| // Arrange| // Act| var result = _sut.Convert(\"2019\", typeof(DateTime), \"yyyy\", null);| // Assert| var resultTyped = Assert.IsType<DateTime>(result);| Assert.Equal(new DateTime(2019, 1, 1), resultTyped);| }"
      },
      {
        "name": "Convert_StringToNullableDatetimeWithFormat",
        "body": "{| // Arrange| // Act| var result = _sut.Convert(\"2019\", typeof(DateTime?), \"yyyy\", null);| // Assert| // datetime is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type| var resultTyped = Assert.IsType<DateTime>(result);| Assert.Equal(new DateTime(2019, 1, 1), resultTyped);| }"
      }
    ]
  },
  {
    "file": "ServiceRepositoryTests.cs",
    "methods": [
      {
        "name": "SideBySideLogFactoryExternalInterfaceTest",
        "body": "{| // Arrange| var logFactory1 = new LogFactory();| const string name1 = \"name1\";| logFactory1.ServiceRepository.RegisterService(typeof(IMyPrettyInterface), new MyPrettyImplementation() { Test = name1 });| var logFactory2 = new LogFactory();| const string name2 = \"name2\";| logFactory2.ServiceRepository.RegisterService(typeof(IMyPrettyInterface), new MyPrettyImplementation { Test = name2 });| // Act| var logFactoryService1 = logFactory1.ServiceRepository.ResolveService<IMyPrettyInterface>();| var logFactoryService2 = logFactory2.ServiceRepository.ResolveService<IMyPrettyInterface>();| // Assert| Assert.Equal(name1, logFactoryService1.ToString());| Assert.Equal(name2, logFactoryService2.ToString());| }"
      },
      {
        "name": "SideBySideLogFactoryInternalInterfaceTest",
        "body": "{| // Arrange| var logFactory1 = new LogFactory();| const string name1 = \"name1\";| InitializeLogFactoryJsonConverter(logFactory1, name1, out var logger1, out var target1);| var logFactory2 = new LogFactory();| const string name2 = \"name2\";| InitializeLogFactoryJsonConverter(logFactory2, name2, out var logger2, out var target2);| // Act| logger1.Info(\"Hello {user}\", \"Kenny\");| logger2.Info(\"Hello {user}\", \"Kenny\");| // Assert| Assert.Equal(\"Kenny\" + \"_\" + name1, target1.LastMessage);| Assert.Equal(\"Kenny\" + \"_\" + name2, target2.LastMessage);| }"
      },
      {
        "name": "HandleDelayedInjectDependenciesFailure",
        "body": "{| using (new NoThrowNLogExceptions())| {| // Arrange| var logFactory = new LogFactory();| logFactory.ThrowConfigExceptions = true;| var logConfig = new LoggingConfiguration(logFactory);| var logTarget = new TargetWithMissingDependency() { Name = \"NeedDependency\" };| logConfig.AddRuleForAllLevels(logTarget);| // Act| logFactory.Configuration = logConfig;| logFactory.GetLogger(\"Test\").Info(\"Test\");| // Assert| Assert.Null(logTarget.LastLogEvent);| }| }"
      },
      {
        "name": "HandleDelayedInjectDependenciesSuccess",
        "body": "{| using (new NoThrowNLogExceptions())| {| // Arrange| var logFactory = new LogFactory();| logFactory.ThrowConfigExceptions = true;| var logConfig = new LoggingConfiguration(logFactory);| var logTarget = new TargetWithMissingDependency() { Name = \"NeedDependency\" };| logConfig.AddRuleForAllLevels(logTarget);| // Act| logFactory.Configuration = logConfig;| logFactory.GetLogger(\"Test\").Info(\"Test\");| logFactory.ServiceRepository.RegisterSingleton<IMisingDependencyClass>(new MisingDependencyClass());| logFactory.GetLogger(\"Test\").Info(\"Test Again\");| // Assert| Assert.NotNull(logTarget.LastLogEvent);| }| }"
      },
      {
        "name": "HandleLayoutRendererDependency",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().SetupExtensions(ext =>| {| ext.RegisterLayoutRenderer<LayoutRendererUsingDependency>();| ext.RegisterServiceProvider(new ExternalServiceRepository(t => t == typeof(IMisingDependencyClass) ? new MisingDependencyClass() : null));| }).LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(new MemoryTarget() { Layout = \"${NeedDependency}\" });| }).LogFactory;| // Act| logFactory.GetLogger(\"Test\").Info(\"Test\");| // Assert| Assert.Equal(\"Success\", (logFactory.Configuration.AllTargets[0] as MemoryTarget).Logs[0]);| }"
      },
      {
        "name": "ResolveShouldCheckExternalServiceProvider",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().SetupExtensions(ext =>| {| ext.RegisterSingletonService<IMyPrettyInterface>(new MyPrettyImplementation());| ext.RegisterSingletonService(typeof(IMyPrettyInterface), new MyPrettyImplementation());| ext.RegisterServiceProvider(new ExternalServiceRepository(t => t == typeof(IMisingDependencyClass) ? new MisingDependencyClass() : null));| }).LogFactory;| // Act| var missingDependency = logFactory.ServiceRepository.ResolveService<IMisingDependencyClass>(false);| var otherDependency = logFactory.ServiceRepository.ResolveService<IMyPrettyInterface>(false);| // Assert| Assert.NotNull(missingDependency);| Assert.NotNull(otherDependency);| }"
      }
    ]
  },
  {
    "file": "TimeConfigurationTests.cs",
    "methods": [
      {
        "name": "DefaultTimeSourceTest",
        "body": "{| Assert.IsType<FastLocalTimeSource>(TimeSource.Current);| XmlLoggingConfiguration.CreateFromXmlString(\"<nlog />\");| Assert.IsType<FastLocalTimeSource>(TimeSource.Current);| }"
      },
      {
        "name": "AccurateLocalTest",
        "body": "{| TestTimeSourceConfiguration<AccurateLocalTimeSource>(\"AccurateLocal\");| }"
      },
      {
        "name": "AccurateUtcTest",
        "body": "{| TestTimeSourceConfiguration<AccurateUtcTimeSource>(\"AccurateUTC\");| }"
      },
      {
        "name": "FastLocalTest",
        "body": "{| TestTimeSourceConfiguration<FastLocalTimeSource>(\"FastLocal\");| }"
      },
      {
        "name": "FastUtcTest",
        "body": "{| TestTimeSourceConfiguration<FastUtcTimeSource>(\"FastUTC\");| }"
      }
    ]
  },
  {
    "file": "VariableTests.cs",
    "methods": [
      {
        "name": "VariablesTest_string_expanding",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='test' value='hello'/>| <targets>| <target type='File' name='test' ArchiveDateFormat='${test}'/>| </targets>|</nlog>\");| var target = configuration.FindTargetByName(\"test\") as FileTarget;| Assert.NotNull(target);| //dont change the ${test} as it isn't a Layout| Assert.NotEqual(typeof(Layout), target.ArchiveDateFormat.GetType());| Assert.Equal(\"hello\", target.ArchiveDateFormat);| }"
      },
      {
        "name": "VariablesTest_WriteTo_expanding",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='test' value='test_target'/>| <targets>| <target type='Debug' name='test_target' />| </targets>| <rules>| <logger writeTo='${test}' />| </rules>|</nlog>\");| var target = configuration.FindTargetByName(\"test_target\");| Assert.NotNull(target);| Assert.Single(configuration.LoggingRules);| Assert.Single(configuration.LoggingRules[0].Targets);| Assert.Same(target, configuration.LoggingRules[0].Targets.First());| }"
      },
      {
        "name": "VariablesTest_minLevel_maxLevel_expanding",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='test1' value='info'/>| <variable name='test2' value='warn'/>| <rules>| <logger minLevel='${test1}' maxLevel='${test2}' final='true' />| </rules>|</nlog>\");| var rule = configuration.LoggingRules[0];| Assert.NotNull(rule);| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Trace));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Debug));| Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Info));| Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Warn));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Error));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Fatal));| }"
      },
      {
        "name": "VariablesTest_Level_expanding",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='test' value='debug'/>| <rules>| <logger level='${test}' final='true' />| </rules>|</nlog>\");| var rule = configuration.LoggingRules[0];| Assert.NotNull(rule);| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Trace));| Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Debug));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Info));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Warn));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Error));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Fatal));| }"
      },
      {
        "name": "VariablesTest_Levels_expanding",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='test' value='debug,fatal'/>| <rules>| <logger levels='${test}' final='true' />| </rules>|</nlog>\");| var rule = configuration.LoggingRules[0];| Assert.NotNull(rule);| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Trace));| Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Debug));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Info));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Warn));| Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Error));| Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Fatal));| }"
      },
      {
        "name": "Xml_configuration_returns_defined_variables",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variables>| <variable name='prefix' value='[[' />| <variable name='suffix' value=']]' />| </variables>|</nlog>\");| var nullEvent = LogEventInfo.CreateNullEvent();| // Act & Assert| Assert.Equal(\"[[\", configuration.Variables[\"prefix\"].Render(nullEvent));| Assert.Equal(\"]]\", configuration.Variables[\"suffix\"].Render(nullEvent));| }"
      },
      {
        "name": "Xml_configuration_with_inner_returns_defined_variables",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='prefix'><layout><![CDATA[|newline|]]></layout></variable>| <variable name='suffix'><layout>]]</layout></variable>|</nlog>\");| var nullEvent = LogEventInfo.CreateNullEvent();| // Act & Assert| Assert.Equal(\"\\nnewline\\n\", configuration.Variables[\"prefix\"].Render(nullEvent).Replace(\"\\r\", \"\"));| Assert.Equal(\"]]\", configuration.Variables[\"suffix\"].Render(nullEvent));| }"
      },
      {
        "name": "Xml_configuration_with_innerLayouts_returns_defined_variables",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='myJson' >| <layout type='JsonLayout'>| <attribute name='short date' layout='${shortdate}' />| <attribute name='message' layout='${message}' />| </layout>| </variable>|</nlog>\");| // Act & Assert| var jsonLayout = Assert.IsType<JsonLayout>(configuration.Variables[\"myJson\"]);| Assert.Equal(2, jsonLayout.Attributes.Count);| Assert.Equal(\"short date\", jsonLayout.Attributes[0].Name);| Assert.NotNull(jsonLayout.Attributes[0].Layout);| }"
      },
      {
        "name": "Xml_configuration_with_inner_returns_defined_variables_withValueElement",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <variable name='prefix'>|<value><![CDATA[|newline|]]></value>|</variable>| <variable name='suffix'><value>]]</value></variable>|</nlog>\");| var nullEvent = LogEventInfo.CreateNullEvent();| // Act & Assert| Assert.Equal(\"\\nnewline\\n\", configuration.Variables[\"prefix\"].Render(nullEvent).Replace(\"\\r\", \"\"));| Assert.Equal(\"]]\", configuration.Variables[\"suffix\"].Render(nullEvent));| }"
      },
      {
        "name": "Xml_configuration_variableWithInnerAndAttribute_attributeHasPrecedence",
        "body": "{| using (new NoThrowNLogExceptions())| {| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog>| <variable name='var1' value='1'><value>2</value></variable>|</nlog>\");| var nullEvent = LogEventInfo.CreateNullEvent();| // Act & Assert| Assert.Equal(\"1\", configuration.Variables[\"var1\"].Render(nullEvent));| }| }"
      },
      {
        "name": "NLogConfigurationExceptionShouldThrown_WhenVariableNodeIsWrittenToWrongPlace",
        "body": "{| LogManager.ThrowConfigExceptions = true;| const string configurationString_VariableNodeIsInnerTargets =| @\"<nlog>| <targets>| <variable name='variableOne' value='${longdate:universalTime=True}Z | ${message}'/>| |<target name='d1' type='Debug' layout='${variableOne}' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='d1'/>| </rules>| </nlog>\";| const string configurationString_VariableNodeIsAfterTargets =| @\"<nlog>| <targets>| <target name='d1' type='Debug' layout='${variableOne}' />| </targets>| <variable name='variableOne' value='${longdate:universalTime=True}Z | ${message}'/>| <rules>| <logger name='*' minlevel='Debug' writeTo='d1'/>| </rules>| </nlog>\";| NLogConfigurationException nlogConfEx_ForInnerTargets = Assert.Throws<NLogConfigurationException>(| () => XmlLoggingConfiguration.CreateFromXmlString(configurationString_VariableNodeIsInnerTargets)| );| NLogConfigurationException nlogConfExForAfterTargets = Assert.Throws<NLogConfigurationException>(| () => XmlLoggingConfiguration.CreateFromXmlString(configurationString_VariableNodeIsAfterTargets)| );| }"
      }
    ]
  },
  {
    "file": "XmlConfigTests.cs",
    "methods": [
      {
        "name": "ParseNLogOptionsDefaultTest",
        "body": "{| using (new InternalLoggerScope())| {| var xml = \"<nlog></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.False(config.AutoReload);| Assert.Equal(\"\", InternalLogger.LogFile);| Assert.False(InternalLogger.LogToConsole);| Assert.False(InternalLogger.LogToConsoleError);| Assert.True(InternalLogger.IncludeTimestamp);| Assert.Null(InternalLogger.LogWriter);| Assert.Equal(LogLevel.Off, InternalLogger.LogLevel);| }| }"
      },
      {
        "name": "ParseNLogOptionsTest",
        "body": "{| using (new InternalLoggerScope())| {| using (new NoThrowNLogExceptions())| {| var xml = \"<nlog logfile='test.txt' internalLogIncludeTimestamp='false' internalLogToConsole='true' internalLogToConsoleError='true'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.False(config.AutoReload);| Assert.Equal(\"\", InternalLogger.LogFile);| Assert.True(InternalLogger.LogToConsole);| Assert.True(InternalLogger.LogToConsoleError);| Assert.False(InternalLogger.IncludeTimestamp);| Assert.Null(InternalLogger.LogWriter);| Assert.Equal(LogLevel.Info, InternalLogger.LogLevel);| }| }| }"
      },
      {
        "name": "ParseNLogInternalLoggerPathTest",
        "body": "{| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${CurrentDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(System.IO.Directory.GetCurrentDirectory(), InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${BaseDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(AppDomain.CurrentDomain.BaseDirectory, InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${TempDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(System.IO.Path.GetTempPath(), InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${ProcessDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(Path.GetDirectoryName(CurrentProcessPath), InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${CommonApplicationDataDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${UserApplicationDataDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var xml = \"<nlog internalLogFile='${UserLocalApplicationDataDir}test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Contains(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), InternalLogger.LogFile);| }| using (new InternalLoggerScope())| {| var userName = Environment.GetEnvironmentVariable(\"USERNAME\") ?? string.Empty;| var xml = \"<nlog internalLogFile='%USERNAME%_test.txt'></nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| if (!string.IsNullOrEmpty(userName))| Assert.Contains(userName, InternalLogger.LogFile);| }| }"
      },
      {
        "name": "InvalidInternalLogLevel_shouldNotSetLevel",
        "body": "{| using (new InternalLoggerScope())| using (new NoThrowNLogExceptions())| {| // Arrange| InternalLogger.LogLevel = LogLevel.Error;| var xml = @\"<nlog internalLogLevel='bogus' >| </nlog>\";| // Act| XmlLoggingConfiguration.CreateFromXmlString(xml);| // Assert| Assert.Equal(LogLevel.Error, InternalLogger.LogLevel);| }| }"
      },
      {
        "name": "InvalidNLogAttributeValues_shouldNotBreakLogging",
        "body": "{| using (new InternalLoggerScope())| using (new NoThrowNLogExceptions())| {| // Arrange| var xml = @\"<nlog internalLogLevel='oops' globalThreshold='noooos'>| <targets>| <target name='debug' type='Debug' layout='${message}' />| </targets>| <rules>| <logger name='*' minlevel='debug' appendto='debug' />| </rules>| </nlog>\";| var logFactory = new LogFactory();| var config = XmlLoggingConfiguration.CreateFromXmlString(xml, logFactory);| logFactory.Configuration = config;| var logger = logFactory.GetLogger(\"InvalidInternalLogLevel_shouldNotBreakLogging\");| // Act| logger.Debug(\"message 1\");| // Assert| logFactory.AssertDebugLastMessage(\"message 1\");| }| }"
      },
      {
        "name": "XmlConfig_ParseUtf8Encoding_WithoutHyphen",
        "body": "{| // Arrange| var xml = @\"<nlog>| <targets>| <target name='file' type='File' encoding='utf8' layout='${message}' fileName='hello.txt' />| </targets>| <rules>| <logger name='*' minlevel='debug' appendto='file' />| </rules>| </nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Single(config.AllTargets);| Assert.Equal(System.Text.Encoding.UTF8, (config.AllTargets[0] as NLog.Targets.FileTarget)?.Encoding);| }"
      },
      {
        "name": "XmlConfig_ParseFilter_WithoutAttributes",
        "body": "{| // Arrange| var xml = @\"<nlog>| <targets>| <target name='debug' type='Debug' layout='${message}' />| </targets>| <rules>| <logger name='*' minlevel='debug' appendto='debug' filterDefaultAction='ignore'>| <filters defaultAction='log'>| <whenContains />| </filters>| </logger>| </rules>| </nlog>\";| var config = XmlLoggingConfiguration.CreateFromXmlString(xml);| Assert.Single(config.LoggingRules);| Assert.Single(config.LoggingRules[0].Filters);| }"
      },
      {
        "name": "RulesBeforeTargetsTest",
        "body": "{| LoggingConfiguration c = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <rules>| <logger name='*' minLevel='Info' writeTo='d1' />| </rules>| <targets>| <target name='d1' type='Debug' />| </targets>| </nlog>\");| Assert.Single(c.LoggingRules);| var rule = c.LoggingRules[0];| Assert.Equal(\"*\", rule.LoggerNamePattern);| Assert.Equal(4, rule.Levels.Count);| Assert.Contains(LogLevel.Info, rule.Levels);| Assert.Contains(LogLevel.Warn, rule.Levels);| Assert.Contains(LogLevel.Error, rule.Levels);| Assert.Contains(LogLevel.Fatal, rule.Levels);| Assert.Single(rule.Targets);| Assert.Same(c.FindTargetByName(\"d1\"), rule.Targets[0]);| Assert.False(rule.Final);| Assert.Empty(rule.Filters);| }"
      },
      {
        "name": "LowerCaseParserTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='debug' layout='${level}' /></targets>| <rules>| <logger name='*' minlevel='info' appendto='debug'>| <filters defaultAction='log'>| <whencontains layout='${message}' substring='msg' action='ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Fatal(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Fatal));| logger.Error(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Error));| logger.Warn(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Warn));| logger.Info(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));| logger.Debug(\"message\");| logger.Debug(\"msg\");| logger.Info(\"msg\");| logger.Warn(\"msg\");| logger.Error(\"msg\");| logger.Fatal(\"msg\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));| }"
      },
      {
        "name": "UpperCaseParserTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <TARGETS><TARGET NAME='DEBUG' TYPE='DEBUG' LAYOUT='${LEVEL}' /></TARGETS>| <RULES>| <LOGGER NAME='*' MINLEVEL='INFO' APPENDTO='DEBUG'>| <FILTERS DEFAULTACTION='LOG'>| <WHENCONTAINS LAYOUT='${MESSAGE}' SUBSTRING='msg' ACTION='IGNORE' />| </FILTERS>| </LOGGER>| </RULES>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Fatal(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Fatal));| logger.Error(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Error));| logger.Warn(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Warn));| logger.Info(\"message\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));| logger.Debug(\"message\");| logger.Debug(\"msg\");| logger.Info(\"msg\");| logger.Warn(\"msg\");| logger.Error(\"msg\");| logger.Fatal(\"msg\");| logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));| }"
      },
      {
        "name": "ShouldWriteLogsOnDuplicateAttributeTest",
        "body": "{| using (new NoThrowNLogExceptions())| {| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='info' minLevel='info' appendto='debug'>| <filters defaultAction='log'>| <whencontains layout='${message}' substring='msg' action='ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| string expectedMesssage = \"some message\";| logger.Info(expectedMesssage);| logFactory.AssertDebugLastMessage(expectedMesssage);| }| }"
      },
      {
        "name": "ShoudThrowExceptionOnDuplicateAttributeWhenOptionIsEnabledTest",
        "body": "{| Assert.Throws<NLogConfigurationException>(() =>| {| new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets><target name='debug' type='debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='info' minLevel='info' appendto='debug'>| <filters defaultAction='log'>| <whencontains layout='${message}' substring='msg' action='ignore' />| </filters>| </logger>| </rules>| </nlog>\");| });| Assert.Throws<NLogConfigurationException>(() =>| {| new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwConfigExceptions='true'>| <targets><target name='debug' type='debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='info' minLevel='info' appendto='debug'>| <filters defaultAction='log'>| <whencontains layout='${message}' substring='msg' action='ignore' />| </filters>| </logger>| </rules>| </nlog>\");| });| }"
      }
    ]
  },
  {
    "file": "ConfigFileLocatorTests.cs",
    "methods": [
      {
        "name": "GetCandidateConfigTest",
        "body": "{| var candidateConfigFilePaths = XmlLoggingConfiguration.GetCandidateConfigFilePaths();| Assert.NotNull(candidateConfigFilePaths);| var count = candidateConfigFilePaths.Count();| Assert.NotEqual(0, count);| }"
      },
      {
        "name": "GetCandidateConfigTest_list_is_readonly",
        "body": "{| Assert.Throws<NotSupportedException>(() =>| {| var list = new List<string> { \"c:\\\\global\\\\temp.config\" };| XmlLoggingConfiguration.SetCandidateConfigFilePaths(list);| var candidateConfigFilePaths = XmlLoggingConfiguration.GetCandidateConfigFilePaths();| var list2 = candidateConfigFilePaths as IList;| list2.Add(\"test\");| });| }"
      },
      {
        "name": "SetCandidateConfigTest",
        "body": "{| var list = new List<string> { \"c:\\\\global\\\\temp.config\" };| XmlLoggingConfiguration.SetCandidateConfigFilePaths(list);| Assert.Single(XmlLoggingConfiguration.GetCandidateConfigFilePaths());| //no side effects| list.Add(\"c:\\\\global\\\\temp2.config\");| Assert.Single(XmlLoggingConfiguration.GetCandidateConfigFilePaths());| }"
      },
      {
        "name": "ResetCandidateConfigTest",
        "body": "{| var countBefore = XmlLoggingConfiguration.GetCandidateConfigFilePaths().Count();| var list = new List<string> { \"c:\\\\global\\\\temp.config\" };| XmlLoggingConfiguration.SetCandidateConfigFilePaths(list);| Assert.Single(XmlLoggingConfiguration.GetCandidateConfigFilePaths());| XmlLoggingConfiguration.ResetCandidateConfigFilePath();| Assert.Equal(countBefore, XmlLoggingConfiguration.GetCandidateConfigFilePaths().Count());| }"
      },
      {
        "name": "LoadConfigFile_EmptyEnvironment_UseCurrentDirectory",
        "body": "{| // Arrange| var appEnvMock = new AppEnvironmentMock(f => true, f => null);| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| // Act| var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();| // Assert loading from current-directory and from nlog-assembly-directory| if (NLog.Internal.PlatformDetector.IsWin32)| Assert.Equal(2, result.Count); // Case insensitive| Assert.Equal(\"NLog.config\", result.First(), StringComparer.OrdinalIgnoreCase);| Assert.Contains(\"NLog.dll.nlog\", result.Last(), StringComparison.OrdinalIgnoreCase);| }"
      },
      {
        "name": "LoadConfigFile_NetCoreUnpublished_UseEntryDirectory",
        "body": "{| // Arrange| var tmpDir = Path.GetTempPath();| var appEnvMock = new AppEnvironmentMock(f => true, f => null)| {| AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),|#if NETFRAMEWORK| AppDomainConfigurationFile = Path.Combine(tmpDir, \"EntryDir\", \"Entry.exe.config\"),|#else| AppDomainConfigurationFile = string.Empty, // NetCore style|#endif| CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"dotnet.exe\"), // NetCore dotnet.exe| EntryAssemblyLocation = Path.Combine(tmpDir, \"EntryDir\"),| EntryAssemblyFileName = \"Entry.dll\"| };| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| // Act| var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();| // Assert base-directory + entry-directory + nlog-assembly-directory| AssertResult(tmpDir, \"EntryDir\", \"EntryDir\", \"Entry\", result);| }"
      },
      {
        "name": "LoadConfigFile_NetCorePublished_UseBaseDirectory",
        "body": "{| // Arrange| var tmpDir = Path.GetTempPath();| var appEnvMock = new AppEnvironmentMock(f => true, f => null)| {| AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),|#if NETFRAMEWORK| AppDomainConfigurationFile = Path.Combine(tmpDir, \"BaseDir\", \"Entry.exe.config\"),|#else| AppDomainConfigurationFile = string.Empty, // .NET 6 single-publish-style| |#endif| CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"),| EntryAssemblyLocation = string.Empty, // .NET 6 single-publish-style| EntryAssemblyFileName = \"Entry.dll\",| };| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| // Act| var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();| // Assert base-directory + process-directory + nlog-assembly-directory| AssertResult(tmpDir, \"BaseDir\", null, \"Entry\", result);| }"
      },
      {
        "name": "LoadConfigFile_NetCorePublished_UseProcessDirectory",
        "body": "{| // Arrange| var tmpDir = Path.GetTempPath();| var appEnvMock = new AppEnvironmentMock(f => true, f => null)| {| AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),|#if NETFRAMEWORK| AppDomainConfigurationFile = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe.config\"),|#else| AppDomainConfigurationFile = string.Empty, // NetCore style |#endif| CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"), // NetCore published exe| EntryAssemblyLocation = Path.Combine(tmpDir, \"ProcessDir\"),| EntryAssemblyFileName = \"Entry.dll\"| };| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| // Act| var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();| // Assert base-directory + process-directory + nlog-assembly-directory| AssertResult(tmpDir, \"ProcessDir\", \"ProcessDir\", \"Entry\", result);| }"
      },
      {
        "name": "LoadConfigFile_NetCoreSingleFilePublish_IgnoreTempDirectory",
        "body": "{| // Arrange| var tmpDir = Path.GetTempPath();| var appEnvMock = new AppEnvironmentMock(f => true, f => null)| {| AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),|#if NETFRAMEWORK| AppDomainConfigurationFile = Path.Combine(tmpDir, \"TempProcessDir\", \"Entry.exe.config\"),|#else| AppDomainConfigurationFile = string.Empty, // NetCore style|#endif| CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"), // NetCore published exe| EntryAssemblyLocation = Path.Combine(tmpDir, \"TempProcessDir\"),| UserTempFilePath = Path.Combine(tmpDir, \"TempProcessDir\"),| EntryAssemblyFileName = \"Entry.dll\"| };| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| // Act| var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();| // Assert base-directory + process-directory + nlog-assembly-directory|#if !NETFRAMEWORK| Assert.Equal(Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe.nlog\"), result.First(), StringComparer.OrdinalIgnoreCase);|#endif| AssertResult(tmpDir, \"TempProcessDir\", \"ProcessDir\", \"Entry\", result);| }"
      },
      {
        "name": "LoadConfigFile_NetCoreSingleFilePublish_IgnoreTmpDirectory",
        "body": "{| // Arrange| var tmpDir = \"/var/tmp/\";| var appEnvMock = new AppEnvironmentMock(f => true, f => null)| {| AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),|#if NETFRAMEWORK| AppDomainConfigurationFile = Path.Combine(tmpDir, \"TempProcessDir\", \"Entry.exe.config\"),|#else| AppDomainConfigurationFile = string.Empty, // NetCore style |#endif| CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"), // NetCore published exe| EntryAssemblyLocation = Path.Combine(tmpDir, \"TempProcessDir\"),| UserTempFilePath = \"/tmp/\",| EntryAssemblyFileName = \"Entry.dll\"| };| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| // Act| var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();| // Assert base-directory + process-directory + nlog-assembly-directory|#if !NETFRAMEWORK| Assert.Equal(Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe.nlog\"), result.First(), StringComparer.OrdinalIgnoreCase);|#endif| AssertResult(tmpDir, \"TempProcessDir\", \"ProcessDir\", \"Entry\", result);| }"
      },
      {
        "name": "ValueWithVariableMustNotCauseInfiniteRecursion",
        "body": "{| // Header will be printed during initialization, before config fully loaded, verify config is not loaded again| var nlogConfigXml = @\"<nlog throwExceptions='true'>| <variable name='hello' value='header' />| <targets>| <target name='debug' type='DebugSystem' header='${var:hello}' />| </targets>| <rules>| <logger name='*' minLevel='trace' writeTo='debug' />| </rules>| </nlog>\";| // Arrange| var appEnvMock = new AppEnvironmentMock(f => true, f => throw new NLogConfigurationException(\"Never allow loading config\"));| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| var logFactory = new LogFactory(fileLoader).Setup().LoadConfigurationFromXml(nlogConfigXml).LogFactory;| // Assert| Assert.NotNull(logFactory.Configuration.FindTargetByName(\"debug\"));| }"
      },
      {
        "name": "CandidateConfigurationFileOnlyLoadedInitially",
        "body": "{| // Arrange| var intialLoad = true;| var appEnvMock = new AppEnvironmentMock(f => true, f =>| {| if (intialLoad)| throw new System.IO.IOException(\"File not found\"); // Non-fatal mock failure| else| throw new NLogConfigurationException(\"Never allow loading config\"); // Fatal mock failure| });| var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);| var logFactory = new LogFactory(fileLoader);| // Act| var firstLogger = logFactory.GetLogger(\"FirstLogger\");| var configuration = logFactory.Configuration;| intialLoad = false; // Change mock to fail fatally, if trying to load NLog config again| var secondLogger = logFactory.GetLogger(\"SecondLogger\");| // Assert| Assert.Null(configuration);| }"
      },
      {
        "name": "MissingConfigFileTest",
        "body": "{| string output = RunTest();| Assert.Equal(missingConfigOutput, output);| }"
      },
      {
        "name": "NLogDotConfigTest",
        "body": "{| File.WriteAllText(Path.Combine(_tempDirectory, \"NLog.config\"), nlogConfigContents);| string output = RunTest();| Assert.Equal(nlogConfigOutput, output);| }"
      },
      {
        "name": "NLogDotDllDotNLogTest",
        "body": "{| File.WriteAllText(Path.Combine(_tempDirectory, \"NLog.dll.nlog\"), nlogDllNLogContents);| string output = RunTest();| Assert.Equal(nlogDllNLogOutput, output);| }"
      },
      {
        "name": "NLogDotDllDotNLogInDirectoryWithSpaces",
        "body": "{| File.WriteAllText(Path.Combine(_tempDirectory, \"NLog.dll.nlog\"), nlogDllNLogContents);| string output = RunTest();| Assert.Equal(nlogDllNLogOutput, output);| }"
      },
      {
        "name": "AppDotConfigTest",
        "body": "{| File.WriteAllText(Path.Combine(_tempDirectory, \"ConfigFileLocator.exe.config\"), appConfigContents);| string output = RunTest();| Assert.Equal(appConfigOutput, output);| }"
      },
      {
        "name": "AppDotNLogTest",
        "body": "{| File.WriteAllText(Path.Combine(_tempDirectory, \"ConfigFileLocator.exe.nlog\"), appNLogContents);| string output = RunTest();| Assert.Equal(appNLogOutput, output);| }"
      },
      {
        "name": "PrecedenceTest",
        "body": "{| var precedence = new[]| {| new| {| File = \"ConfigFileLocator.exe.config\",| Contents = appConfigContents,| Output = appConfigOutput| },| new| {| File = \"ConfigFileLocator.exe.nlog\",| Contents = appNLogContents,| Output = appNLogOutput| },| new| {| File = \"NLog.config\",| Contents = nlogConfigContents,| Output = nlogConfigOutput| },| new| {| File = \"NLog.dll.nlog\",| Contents = nlogDllNLogContents,| Output = nlogDllNLogOutput| },| };| // deploy all files| foreach (var p in precedence)| {| File.WriteAllText(Path.Combine(_tempDirectory, p.File), p.Contents);| }| string output;| // walk files in precedence order and delete config files| foreach (var p in precedence)| {| output = RunTest();| Assert.Equal(p.Output, output);| File.Delete(Path.Combine(_tempDirectory, p.File));| }| output = RunTest();| Assert.Equal(missingConfigOutput, output);| }"
      }
    ]
  },
  {
    "file": "GlobalDiagnosticsContextTests.cs",
    "methods": [
      {
        "name": "GDCTest1",
        "body": "{| GlobalDiagnosticsContext.Clear();| Assert.False(GlobalDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo\"));| Assert.False(GlobalDiagnosticsContext.Contains(\"foo2\"));| Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo2\"));| Assert.Empty(GlobalDiagnosticsContext.GetNames());| GlobalDiagnosticsContext.Set(\"foo\", \"bar\");| GlobalDiagnosticsContext.Set(\"foo2\", \"bar2\");| Assert.True(GlobalDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(\"bar\", GlobalDiagnosticsContext.Get(\"foo\"));| Assert.Equal(2, GlobalDiagnosticsContext.GetNames().Count);| GlobalDiagnosticsContext.Remove(\"foo\");| Assert.False(GlobalDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo\"));| Assert.True(GlobalDiagnosticsContext.Contains(\"foo2\"));| Assert.Equal(\"bar2\", GlobalDiagnosticsContext.Get(\"foo2\"));| Assert.Single(GlobalDiagnosticsContext.GetNames());| Assert.Null(GlobalDiagnosticsContext.GetObject(\"foo3\"));| Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo3\", null));| GlobalDiagnosticsContext.Set(\"foo3\", new { One = 1 });| Assert.NotNull(GlobalDiagnosticsContext.Get(\"foo3\", null));| }"
      }
    ]
  },
  {
    "file": "MappedDiagnosticsContextTests.cs",
    "methods": [
      {
        "name": "MDCTest1",
        "body": "{| List<Exception> exceptions = new List<Exception>();| ManualResetEvent mre = new ManualResetEvent(false);| int counter = 100;| int remaining = counter;| for (int i = 0; i < counter; ++i)| {| ThreadPool.QueueUserWorkItem(| s =>| {| try| {| MappedDiagnosticsContext.Clear();| Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));| Assert.False(MappedDiagnosticsContext.Contains(\"foo2\"));| Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo2\"));| Assert.Empty(MappedDiagnosticsContext.GetNames());| MappedDiagnosticsContext.Set(\"foo\", \"bar\");| MappedDiagnosticsContext.Set(\"foo2\", \"bar2\");| Assert.True(MappedDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(\"bar\", MappedDiagnosticsContext.Get(\"foo\"));| Assert.Equal(2, MappedDiagnosticsContext.GetNames().Count);| MappedDiagnosticsContext.Remove(\"foo\");| Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));| Assert.True(MappedDiagnosticsContext.Contains(\"foo2\"));| Assert.Equal(\"bar2\", MappedDiagnosticsContext.Get(\"foo2\"));| Assert.Single(MappedDiagnosticsContext.GetNames());| Assert.True(MappedDiagnosticsContext.GetNames().Contains(\"foo2\"));| Assert.Null(MappedDiagnosticsContext.GetObject(\"foo3\"));| MappedDiagnosticsContext.Set(\"foo3\", new { One = 1 });| }| catch (Exception exception)| {| lock (exceptions)| {| exceptions.Add(exception);| }| }| finally| {| if (Interlocked.Decrement(ref remaining) == 0)| {| mre.Set();| }| }| });| }| mre.WaitOne();| StringBuilder exceptionsMessage = new StringBuilder();| foreach (var ex in exceptions)| {| if (exceptionsMessage.Length > 0)| {| exceptionsMessage.Append(\"\\r\\n\");| }| exceptionsMessage.Append(ex.ToString());| }| Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());| }"
      },
      {
        "name": "MDCTest2",
        "body": "{| List<Exception> exceptions = new List<Exception>();| ManualResetEvent mre = new ManualResetEvent(false);| int counter = 100;| int remaining = counter;| for (int i = 0; i < counter; ++i)| {| ThreadPool.QueueUserWorkItem(| s =>| {| try| {| MappedDiagnosticsContext.Clear();| Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));| Assert.False(MappedDiagnosticsContext.Contains(\"foo2\"));| Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo2\"));| MappedDiagnosticsContext.Set(\"foo\", \"bar\");| MappedDiagnosticsContext.Set(\"foo2\", \"bar2\");| Assert.True(MappedDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(\"bar\", MappedDiagnosticsContext.Get(\"foo\"));| MappedDiagnosticsContext.Remove(\"foo\");| Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));| Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));| Assert.True(MappedDiagnosticsContext.Contains(\"foo2\"));| Assert.Equal(\"bar2\", MappedDiagnosticsContext.Get(\"foo2\"));| Assert.Null(MappedDiagnosticsContext.GetObject(\"foo3\"));| }| catch (Exception ex)| {| lock (exceptions)| {| exceptions.Add(ex);| }| }| finally| {| if (Interlocked.Decrement(ref remaining) == 0)| {| mre.Set();| }| }| });| }| mre.WaitOne();| StringBuilder exceptionsMessage = new StringBuilder();| foreach (var ex in exceptions)| {| if (exceptionsMessage.Length > 0)| {| exceptionsMessage.Append(\"\\r\\n\");| }| exceptionsMessage.Append(ex.ToString());| }| Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());| }"
      },
      {
        "name": "timer_cannot_inherit_mappedcontext",
        "body": "{| object getObject = null;| string getValue = null;| var mre = new ManualResetEvent(false);| Timer thread = new Timer((s) =>| {| try| {| getObject = MappedDiagnosticsContext.GetObject(\"DoNotExist\");| getValue = MappedDiagnosticsContext.Get(\"DoNotExistEither\");| }| finally| {| mre.Set();| }| });| thread.Change(0, Timeout.Infinite);| mre.WaitOne();| Assert.Null(getObject);| Assert.Empty(getValue);| }"
      },
      {
        "name": "disposable_removes_item",
        "body": "{| const string itemNotRemovedKey = \"itemNotRemovedKey\";| const string itemRemovedKey = \"itemRemovedKey\";| MappedDiagnosticsContext.Clear();| MappedDiagnosticsContext.Set(itemNotRemovedKey, \"itemNotRemoved\");| using (MappedDiagnosticsContext.SetScoped(itemRemovedKey, \"itemRemoved\"))| {| Assert.Equal(MappedDiagnosticsContext.GetNames(), new[] { itemNotRemovedKey, itemRemovedKey });| }| Assert.Equal(MappedDiagnosticsContext.GetNames(), new[] { itemNotRemovedKey });| }"
      },
      {
        "name": "dispose_is_idempotent",
        "body": "{| const string itemKey = \"itemKey\";| MappedDiagnosticsContext.Clear();| IDisposable disposable = MappedDiagnosticsContext.SetScoped(itemKey, \"item1\");| disposable.Dispose();| Assert.False(MappedDiagnosticsContext.Contains(itemKey));| //This item shouldn't be removed since it is not the disposable one| MappedDiagnosticsContext.Set(itemKey, \"item2\");| disposable.Dispose();| Assert.True(MappedDiagnosticsContext.Contains(itemKey));| }"
      }
    ]
  },
  {
    "file": "MappedDiagnosticsLogicalContextTests.cs",
    "methods": [
      {
        "name": "given_item_exists_when_getting_item_should_return_item_for_objecttype_2",
        "body": "{| string key = \"testKey1\";| object value = 5;| MappedDiagnosticsLogicalContext.Set(key, value);| string expected = \"5\";| string actual = MappedDiagnosticsLogicalContext.Get(key);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "given_item_exists_when_getting_item_should_return_item_for_objecttype",
        "body": "{| string key = \"testKey2\";| object value = DateTime.Now;| MappedDiagnosticsLogicalContext.Set(key, value);| object actual = MappedDiagnosticsLogicalContext.GetObject(key);| Assert.Equal(value, actual);| }"
      },
      {
        "name": "given_no_item_exists_when_getting_item_should_return_null",
        "body": "{| Assert.Null(MappedDiagnosticsLogicalContext.GetObject(\"itemThatShouldNotExist\"));| }"
      },
      {
        "name": "given_no_item_exists_when_getting_item_should_return_empty_string",
        "body": "{| Assert.Empty(MappedDiagnosticsLogicalContext.Get(\"itemThatShouldNotExist\"));| }"
      },
      {
        "name": "given_item_exists_when_getting_item_should_return_item",
        "body": "{| const string key = \"Key\";| const string item = \"Item\";| MappedDiagnosticsLogicalContext.Set(key, item);| Assert.Equal(item, MappedDiagnosticsLogicalContext.Get(key));| }"
      },
      {
        "name": "given_item_does_not_exist_when_setting_item_should_contain_item",
        "body": "{| const string key = \"Key\";| const string item = \"Item\";| MappedDiagnosticsLogicalContext.Set(key, item);| Assert.True(MappedDiagnosticsLogicalContext.Contains(key));| }"
      },
      {
        "name": "given_item_exists_when_setting_item_should_not_throw",
        "body": "{| const string key = \"Key\";| const string item = \"Item\";| MappedDiagnosticsLogicalContext.Set(key, item);| var exRecorded = Record.Exception(() => MappedDiagnosticsLogicalContext.Set(key, item));| Assert.Null(exRecorded);| }"
      },
      {
        "name": "given_item_exists_when_setting_item_should_update_item",
        "body": "{| const string key = \"Key\";| const string item = \"Item\";| const string newItem = \"NewItem\";| MappedDiagnosticsLogicalContext.Set(key, item);| MappedDiagnosticsLogicalContext.Set(key, newItem);| Assert.Equal(newItem, MappedDiagnosticsLogicalContext.Get(key));| }"
      },
      {
        "name": "given_no_item_exists_when_getting_items_should_return_empty_collection",
        "body": "{| Assert.Empty(MappedDiagnosticsLogicalContext.GetNames());| }"
      },
      {
        "name": "given_item_exists_when_getting_items_should_return_that_item",
        "body": "{| const string key = \"Key\";| MappedDiagnosticsLogicalContext.Set(key, \"Item\");| Assert.Single(MappedDiagnosticsLogicalContext.GetNames());| Assert.True(MappedDiagnosticsLogicalContext.GetNames().Contains(\"Key\"));| }"
      },
      {
        "name": "given_item_exists_after_removing_item_when_getting_items_should_not_contain_item",
        "body": "{| const string keyThatRemains1 = \"Key1\";| const string keyThatRemains2 = \"Key2\";| const string keyThatIsRemoved = \"KeyR\";| MappedDiagnosticsLogicalContext.Set(keyThatRemains1, \"7\");| MappedDiagnosticsLogicalContext.Set(keyThatIsRemoved, 7);| MappedDiagnosticsLogicalContext.Set(keyThatRemains2, 8);| MappedDiagnosticsLogicalContext.Remove(keyThatIsRemoved);| Assert.Equal(2, MappedDiagnosticsLogicalContext.GetNames().Count);| Assert.False(MappedDiagnosticsLogicalContext.GetNames().Contains(keyThatIsRemoved));| }"
      },
      {
        "name": "given_item_does_not_exist_when_checking_if_context_contains_should_return_false",
        "body": "{| Assert.False(MappedDiagnosticsLogicalContext.Contains(\"keyForItemThatDoesNotExist\"));| }"
      },
      {
        "name": "given_item_exists_when_checking_if_context_contains_should_return_true",
        "body": "{| const string key = \"Key\";| MappedDiagnosticsLogicalContext.Set(key, \"Item\");| Assert.True(MappedDiagnosticsLogicalContext.Contains(key));| }"
      },
      {
        "name": "given_item_exists_when_removing_item_should_not_contain_item",
        "body": "{| const string keyForItemThatShouldExist = \"Key\";| const string itemThatShouldExist = \"Item\";| MappedDiagnosticsLogicalContext.Set(keyForItemThatShouldExist, itemThatShouldExist);| MappedDiagnosticsLogicalContext.Remove(keyForItemThatShouldExist);| Assert.False(MappedDiagnosticsLogicalContext.Contains(keyForItemThatShouldExist));| }"
      },
      {
        "name": "given_item_does_not_exist_when_removing_item_should_not_throw",
        "body": "{| const string keyForItemThatShouldExist = \"Key\";| var exRecorded = Record.Exception(() => MappedDiagnosticsLogicalContext.Remove(keyForItemThatShouldExist));| Assert.Null(exRecorded);| }"
      },
      {
        "name": "given_item_does_not_exist_when_clearing_should_not_throw",
        "body": "{| var exRecorded = Record.Exception(() => MappedDiagnosticsLogicalContext.Clear());| Assert.Null(exRecorded);| }"
      },
      {
        "name": "given_item_exists_when_clearing_should_not_contain_item",
        "body": "{| const string key = \"Key\";| MappedDiagnosticsLogicalContext.Set(key, \"Item\");| MappedDiagnosticsLogicalContext.Clear();| Assert.False(MappedDiagnosticsLogicalContext.Contains(key));| }"
      },
      {
        "name": "given_multiple_threads_running_asynchronously_when_setting_and_getting_values_should_return_thread_specific_values",
        "body": "{| const string key = \"Key\";| const string valueForLogicalThread1 = \"ValueForTask1\";| const string valueForLogicalThread2 = \"ValueForTask2\";| const string valueForLogicalThread3 = \"ValueForTask3\";| MappedDiagnosticsLogicalContext.Clear(true);| var task1 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.Set(key, valueForLogicalThread1);| return MappedDiagnosticsLogicalContext.Get(key);| });| var task2 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.Set(key, valueForLogicalThread2);| return MappedDiagnosticsLogicalContext.Get(key);| });| var task3 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.Set(key, valueForLogicalThread3);| return MappedDiagnosticsLogicalContext.Get(key);| });| Task.WaitAll(task1, task2, task3);| Assert.Equal(valueForLogicalThread1, task1.Result);| Assert.Equal(valueForLogicalThread2, task2.Result);| Assert.Equal(valueForLogicalThread3, task3.Result);| }"
      },
      {
        "name": "parent_thread_assigns_different_values_to_childs",
        "body": "{| const string parentKey = \"ParentKey\";| const string parentValueForLogicalThread1 = \"Parent1\";| const string parentValueForLogicalThread2 = \"Parent2\";| const string childKey = \"ChildKey\";| const string valueForChildThread1 = \"Child1\";| const string valueForChildThread2 = \"Child2\";| MappedDiagnosticsLogicalContext.Clear(true);| var exitAllTasks = new ManualResetEvent(false);| MappedDiagnosticsLogicalContext.Set(parentKey, parentValueForLogicalThread1);| var task1 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.Set(childKey, valueForChildThread1);| exitAllTasks.WaitOne();| return MappedDiagnosticsLogicalContext.Get(parentKey) + \",\" + MappedDiagnosticsLogicalContext.Get(childKey);| });| MappedDiagnosticsLogicalContext.Set(parentKey, parentValueForLogicalThread2);| var task2 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.Set(childKey, valueForChildThread2);| exitAllTasks.WaitOne();| return MappedDiagnosticsLogicalContext.Get(parentKey) + \",\" + MappedDiagnosticsLogicalContext.Get(childKey);| });| exitAllTasks.Set();| Task.WaitAll(task1, task2);| Assert.Equal(parentValueForLogicalThread1 + \",\" + valueForChildThread1, task1.Result);| Assert.Equal(parentValueForLogicalThread2 + \",\" + valueForChildThread2, task2.Result);| }"
      },
      {
        "name": "timer_cannot_inherit_mappedcontext",
        "body": "{| const string parentKey = nameof(timer_cannot_inherit_mappedcontext);| const string parentValueForLogicalThread1 = \"Parent1\";| object getObject = null;| string getValue = null;| var mre = new ManualResetEvent(false);| Timer thread = new Timer((s) =>| {| try| {| getObject = MappedDiagnosticsLogicalContext.GetObject(parentKey);| getValue = MappedDiagnosticsLogicalContext.Get(parentKey);| }| finally| {| mre.Set();| }| });| MappedDiagnosticsLogicalContext.Clear(true);| MappedDiagnosticsLogicalContext.Set(parentKey, parentValueForLogicalThread1);| thread.Change(0, Timeout.Infinite);| mre.WaitOne();| Assert.Null(getObject);| Assert.Empty(getValue);| }"
      },
      {
        "name": "disposable_removes_item",
        "body": "{| const string itemNotRemovedKey = \"itemNotRemovedKey\";| const string itemRemovedKey = \"itemRemovedKey\";| MappedDiagnosticsLogicalContext.Clear();| MappedDiagnosticsLogicalContext.Set(itemNotRemovedKey, \"itemNotRemoved\");| using (MappedDiagnosticsLogicalContext.SetScoped(itemRemovedKey, \"itemRemoved\"))| {| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, itemRemovedKey });| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });| }"
      },
      {
        "name": "dispose_is_idempotent",
        "body": "{| const string itemKey = \"itemKey\";| MappedDiagnosticsLogicalContext.Clear();| IDisposable disposable = MappedDiagnosticsLogicalContext.SetScoped(itemKey, \"item1\");| disposable.Dispose();| Assert.False(MappedDiagnosticsLogicalContext.Contains(itemKey));| //This item shouldn't be removed since it is not the disposable one| MappedDiagnosticsLogicalContext.Set(itemKey, \"item2\");| disposable.Dispose();| Assert.True(MappedDiagnosticsLogicalContext.Contains(itemKey));| }"
      },
      {
        "name": "disposable_multiple_items",
        "body": "{| const string itemNotRemovedKey = \"itemNotRemovedKey\";| const string item1Key = \"item1Key\";| const string item2Key = \"item2Key\";| const string item3Key = \"item3Key\";| const string item4Key = \"item4Key\";| MappedDiagnosticsLogicalContext.Clear();| MappedDiagnosticsLogicalContext.Set(itemNotRemovedKey, \"itemNotRemoved\");| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"1\"),| new KeyValuePair<string, object>(item2Key, \"2\")| }))| {| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, item1Key, item2Key });| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"1\"),| new KeyValuePair<string, object>(item2Key, \"2\"),| new KeyValuePair<string, object>(item3Key, \"3\"),| new KeyValuePair<string, object>(item4Key, \"4\")| }))| {| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, item1Key, item2Key, item3Key, item4Key });| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });| }"
      },
      {
        "name": "disposable_multiple_items_with_restore",
        "body": "{| const string itemNotRemovedKey = \"itemNotRemovedKey\";| const string item1Key = \"item1Key\";| const string item2Key = \"item2Key\";| const string item3Key = \"item3Key\";| const string item4Key = \"item4Key\";| MappedDiagnosticsLogicalContext.Clear();| MappedDiagnosticsLogicalContext.Set(itemNotRemovedKey, \"itemNotRemoved\");| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"1\"),| new KeyValuePair<string, object>(item2Key, \"2\")| }))| {| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, item1Key, item2Key });| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"1\"),| new KeyValuePair<string, object>(item2Key, \"2\"),| new KeyValuePair<string, object>(item3Key, \"3\"),| new KeyValuePair<string, object>(item4Key, \"4\")| }))| {| using (var itemRemover = MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"111\")| }))| {| Assert.Equal(\"111\", MappedDiagnosticsLogicalContext.Get(item1Key));| }| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"01\"),| new KeyValuePair<string, object>(item2Key, \"02\"),| new KeyValuePair<string, object>(item3Key, \"03\"),| new KeyValuePair<string, object>(item4Key, \"04\")| }))| {| Assert.Equal(\"itemNotRemoved\", MappedDiagnosticsLogicalContext.Get(itemNotRemovedKey));| Assert.Equal(\"01\", MappedDiagnosticsLogicalContext.Get(item1Key));| Assert.Equal(\"02\", MappedDiagnosticsLogicalContext.Get(item2Key));| Assert.Equal(\"03\", MappedDiagnosticsLogicalContext.Get(item3Key));| Assert.Equal(\"04\", MappedDiagnosticsLogicalContext.Get(item4Key));| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[]| {| itemNotRemovedKey, item1Key, item2Key, item3Key, item4Key| });| Assert.Equal(\"itemNotRemoved\", MappedDiagnosticsLogicalContext.Get(itemNotRemovedKey));| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(item1Key));| Assert.Equal(\"2\", MappedDiagnosticsLogicalContext.Get(item2Key));| Assert.Equal(\"3\", MappedDiagnosticsLogicalContext.Get(item3Key));| Assert.Equal(\"4\", MappedDiagnosticsLogicalContext.Get(item4Key));| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });| }"
      },
      {
        "name": "disposable_fast_clear_multiple_items",
        "body": "{| const string item1Key = \"item1Key\";| const string item2Key = \"item2Key\";| const string item3Key = \"item3Key\";| const string item4Key = \"item4Key\";| MappedDiagnosticsLogicalContext.Clear();| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"1\"),| new KeyValuePair<string, object>(item2Key, \"2\")| }))| {| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { item1Key, item2Key });| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), ArrayHelper.Empty<string>());| using (MappedDiagnosticsLogicalContext.SetScoped(new[]| {| new KeyValuePair<string, object>(item1Key, \"1\"),| new KeyValuePair<string, object>(item2Key, \"2\"),| new KeyValuePair<string, object>(item3Key, \"3\"),| new KeyValuePair<string, object>(item4Key, \"4\")| }))| {| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { item1Key, item2Key, item3Key, item4Key });| }| Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), ArrayHelper.Empty<string>());| }"
      },
      {
        "name": "given_multiple_set_invocations_mdlc_persists_only_last_value",
        "body": "{| const string key = \"key\";| MappedDiagnosticsLogicalContext.Set(key, \"1\");| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key));| MappedDiagnosticsLogicalContext.Set(key, 2);| MappedDiagnosticsLogicalContext.Set(key, \"3\");| Assert.Equal(\"3\", MappedDiagnosticsLogicalContext.Get(key));| MappedDiagnosticsLogicalContext.Remove(key);| Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));| }"
      },
      {
        "name": "given_multiple_setscoped_with_restore_invocations_mdlc_persists_all_values",
        "body": "{| const string key = \"key\";| using (MappedDiagnosticsLogicalContext.SetScoped(key, \"1\"))| {| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key));| using (MappedDiagnosticsLogicalContext.SetScoped(key, 2))| {| Assert.Equal(2.ToString(), MappedDiagnosticsLogicalContext.Get(key));| using (MappedDiagnosticsLogicalContext.SetScoped(key, null))| {| Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));| }| Assert.Equal(2.ToString(), MappedDiagnosticsLogicalContext.Get(key));| }| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key));| }| Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));| }"
      },
      {
        "name": "given_multiple_multikey_setscoped_with_restore_invocations_mdlc_persists_all_values",
        "body": "{| const string key1 = \"key1\";| const string key2 = \"key2\";| const string key3 = \"key3\";| using (MappedDiagnosticsLogicalContext.SetScoped(key1, \"1\"))| {| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));| using (MappedDiagnosticsLogicalContext.SetScoped(key2, 2))| {| using (MappedDiagnosticsLogicalContext.SetScoped(key3, 3))| {| using (MappedDiagnosticsLogicalContext.SetScoped(key2, 22))| {| Assert.Equal(22.ToString(), MappedDiagnosticsLogicalContext.Get(key2));| }| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));| Assert.Equal(2.ToString(), MappedDiagnosticsLogicalContext.Get(key2));| Assert.Equal(3.ToString(), MappedDiagnosticsLogicalContext.Get(key3));| }| }| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));| }| Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key1)));| }"
      },
      {
        "name": "given_multiple_multikey_setscoped_with_restore_invocations_dispose_differs_than_remove",
        "body": "{| const string key1 = \"key1\";| const string key2 = \"key2\";| const string key3 = \"key3\";| var k1d = MappedDiagnosticsLogicalContext.SetScoped(key1, \"1\");| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));| var k2d = MappedDiagnosticsLogicalContext.SetScoped(key2, 2);| var k3d = MappedDiagnosticsLogicalContext.SetScoped(key3, 3);| var k2d2 = MappedDiagnosticsLogicalContext.SetScoped(key2, 22);| Assert.Equal(22.ToString(), MappedDiagnosticsLogicalContext.Get(key2));| MappedDiagnosticsLogicalContext.Remove(key2);| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));| Assert.NotEqual(2.ToString(), MappedDiagnosticsLogicalContext.Get(key2));| Assert.Equal(3.ToString(), MappedDiagnosticsLogicalContext.Get(key3));| MappedDiagnosticsLogicalContext.Remove(key3);| MappedDiagnosticsLogicalContext.Remove(key2);| Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));| MappedDiagnosticsLogicalContext.Remove(key1);| Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key1)));| }"
      },
      {
        "name": "given_multiple_setscoped_with_restore_invocations_set_reset_value_stack",
        "body": "{| const string key = \"key\";| using (MappedDiagnosticsLogicalContext.SetScoped(key, \"1\"))| {| using (MappedDiagnosticsLogicalContext.SetScoped(key, 2))| {| using (MappedDiagnosticsLogicalContext.SetScoped(key, 3))| {| Assert.Equal(3.ToString(), MappedDiagnosticsLogicalContext.Get(key));| }| // 'Set' does not reset that history of 'SetScoped'| MappedDiagnosticsLogicalContext.Set(key, \"x\");| Assert.Equal(\"x\", MappedDiagnosticsLogicalContext.Get(key));| }| // Disposing will bring back previous value despite being overriden by 'Set'| Assert.Equal(1.ToString(), MappedDiagnosticsLogicalContext.Get(key));| }| Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));| }"
      },
      {
        "name": "given_multiple_threads_running_asynchronously_when_setting_and_getting_values_setscoped_with_restore_should_return_thread_specific_values",
        "body": "{| const string key = \"Key\";| const string initValue = \"InitValue\";| const string valueForLogicalThread1 = \"ValueForTask1\";| const string valueForLogicalThread1Next = \"ValueForTask1Next\";| const string valueForLogicalThread2 = \"ValueForTask2\";| const string valueForLogicalThread3 = \"ValueForTask3\";| MappedDiagnosticsLogicalContext.Clear(true);| MappedDiagnosticsLogicalContext.Set(key, initValue);| Assert.Equal(initValue, MappedDiagnosticsLogicalContext.Get(key));| var task1 = Task.Factory.StartNew(async () =>| {| MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread1);| await Task.Delay(0).ConfigureAwait(false);| MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread1Next);| return MappedDiagnosticsLogicalContext.Get(key);| });| var task2 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread2);| return MappedDiagnosticsLogicalContext.Get(key);| });| var task3 = Task.Factory.StartNew(() =>| {| MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread3);| return MappedDiagnosticsLogicalContext.Get(key);| });| Task.WaitAll(task1, task2, task3);| Assert.Equal(valueForLogicalThread1Next, task1.Result.Result);| Assert.Equal(valueForLogicalThread2, task2.Result);| Assert.Equal(valueForLogicalThread3, task3.Result);| }"
      }
    ]
  },
  {
    "file": "NestedDiagnosticsContextTests.cs",
    "methods": [
      {
        "name": "NDCTest1",
        "body": "{| List<Exception> exceptions = new List<Exception>();| ManualResetEvent mre = new ManualResetEvent(false);| int counter = 100;| int remaining = counter;| for (int i = 0; i < counter; ++i)| {| ThreadPool.QueueUserWorkItem(| s =>| {| try| {| NestedDiagnosticsContext.Clear();| Assert.Equal(string.Empty, NestedDiagnosticsContext.TopMessage);| Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());| AssertContents(NestedDiagnosticsContext.GetAllMessages());| using (NestedDiagnosticsContext.Push(\"foo\"))| {| Assert.Equal(\"foo\", NestedDiagnosticsContext.TopMessage);| AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"foo\");| using (NestedDiagnosticsContext.Push(\"bar\"))| {| AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"bar\", \"foo\");| Assert.Equal(\"bar\", NestedDiagnosticsContext.TopMessage);| NestedDiagnosticsContext.Push(\"baz\");| AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"baz\", \"bar\", \"foo\");| Assert.Equal(\"baz\", NestedDiagnosticsContext.TopMessage);| Assert.Equal(\"baz\", NestedDiagnosticsContext.Pop());| AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"bar\", \"foo\");| Assert.Equal(\"bar\", NestedDiagnosticsContext.TopMessage);| }| AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"foo\");| Assert.Equal(\"foo\", NestedDiagnosticsContext.TopMessage);| }| AssertContents(NestedDiagnosticsContext.GetAllMessages());| Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());| }| catch (Exception ex)| {| lock (exceptions)| {| exceptions.Add(ex);| }| }| finally| {| if (Interlocked.Decrement(ref remaining) == 0)| {| mre.Set();| }| }| });| }| mre.WaitOne();| StringBuilder exceptionsMessage = new StringBuilder();| foreach (var ex in exceptions)| {| if (exceptionsMessage.Length > 0)| {| exceptionsMessage.Append(\"\\r\\n\");| }| exceptionsMessage.Append(ex.ToString());| }| Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());| }"
      },
      {
        "name": "NDCTest2_object",
        "body": "{| List<Exception> exceptions = new List<Exception>();| ManualResetEvent mre = new ManualResetEvent(false);| int counter = 100;| int remaining = counter;| for (int i = 0; i < counter; ++i)| {| ThreadPool.QueueUserWorkItem(| s =>| {| try| {| NestedDiagnosticsContext.Clear();| Assert.Null(NestedDiagnosticsContext.TopObject);| Assert.Null(NestedDiagnosticsContext.PopObject());| AssertContents(NestedDiagnosticsContext.GetAllMessages());| using (NestedDiagnosticsContext.Push(\"foo\"))| {| Assert.Equal(\"foo\", NestedDiagnosticsContext.TopObject);| AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"foo\");| using (NestedDiagnosticsContext.Push(\"bar\"))| {| AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"bar\", \"foo\");| Assert.Equal(\"bar\", NestedDiagnosticsContext.TopObject);| NestedDiagnosticsContext.Push(\"baz\");| AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"baz\", \"bar\", \"foo\");| Assert.Equal(\"baz\", NestedDiagnosticsContext.TopObject);| Assert.Equal(\"baz\", NestedDiagnosticsContext.PopObject());| AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"bar\", \"foo\");| Assert.Equal(\"bar\", NestedDiagnosticsContext.TopObject);| }| AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"foo\");| Assert.Equal(\"foo\", NestedDiagnosticsContext.TopObject);| }| AssertContents(NestedDiagnosticsContext.GetAllMessages());| Assert.Null(NestedDiagnosticsContext.PopObject());| }| catch (Exception ex)| {| lock (exceptions)| {| exceptions.Add(ex);| }| }| finally| {| if (Interlocked.Decrement(ref remaining) == 0)| {| mre.Set();| }| }| });| }| mre.WaitOne();| StringBuilder exceptionsMessage = new StringBuilder();| foreach (var ex in exceptions)| {| if (exceptionsMessage.Length > 0)| {| exceptionsMessage.Append(\"\\r\\n\");| }| exceptionsMessage.Append(ex.ToString());| }| Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());| }"
      }
    ]
  },
  {
    "file": "ConditionBasedFilterTests.cs",
    "methods": [
      {
        "name": "WhenTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <when condition=\"\"contains(message, '${var:environment}')\"\" action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| logFactory.Configuration.Variables[\"environment\"] = \"zzz\"; // Veriy that method-parameters are scanned and initialized with active config| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"zzz\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"ZzzZ\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"Zz\");| logFactory.AssertDebugLastMessage(\"Zz\");| }"
      },
      {
        "name": "WhenLogLevelTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='debug' layout='${message}' /></targets>| <rules>| <logger name='*' minLevel='Debug' writeTo='debug'>| <filters defaultAction='ignore'>| <when condition=\"\"level >= '${scopeproperty:filterlevel:whenEmpty=Off}'\"\" action='Log' />| </filters>| </logger>| </rules>| </nlog>| \").LogFactory;| var logger = logFactory.GetCurrentClassLogger();| logger.Fatal(\"Hello Emptiness\");| logFactory.AssertDebugLastMessage(\"\");| using (logger.PushScopeProperty(\"filterLevel\", LogLevel.Warn))| {| logger.Error(\"Hello can you hear me\");| logFactory.AssertDebugLastMessage(\"Hello can you hear me\");| }| }"
      },
      {
        "name": "WhenExceptionTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='debug' layout='${message}' /></targets>| <rules>| <logger name='*' minLevel='Debug' writeTo='debug'>| <filters defaultAction='ignore'>| <when condition='exception != null' action='Log' />| </filters>| </logger>| </rules>| </nlog>| \").LogFactory;| var logger = logFactory.GetCurrentClassLogger();| logger.Fatal(\"Hello missing Exception\");| logFactory.AssertDebugLastMessage(\"\");| logger.Error(new System.Exception(\"Oh no\"), \"Hello with Exception\");| logFactory.AssertDebugLastMessage(\"Hello with Exception\");| }"
      }
    ]
  },
  {
    "file": "WhenContainsTests.cs",
    "methods": [
      {
        "name": "WhenContainsTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenContains layout='${message}' substring='zzz' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"zzz\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"ZzzZ\");| logFactory.AssertDebugLastMessage(\"ZzzZ\");| Assert.True(logFactory.Configuration.LoggingRules[0].Filters[0] is WhenContainsFilter);| var wcf = (WhenContainsFilter)logFactory.Configuration.LoggingRules[0].Filters[0];| Assert.IsType<SimpleLayout>(wcf.Layout);| Assert.Equal(\"${message}\", ((SimpleLayout)wcf.Layout).Text);| Assert.Equal(\"zzz\", wcf.Substring);| Assert.Equal(FilterResult.Ignore, wcf.Action);| }"
      },
      {
        "name": "WhenContainsInsensitiveTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenContains layout='${message}' substring='zzz' action='Ignore' ignoreCase='true' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"zzz\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"ZzzZ\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"aaa\");| logFactory.AssertDebugLastMessage(\"aaa\");| }"
      },
      {
        "name": "WhenContainsQuoteTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenContains layout='${message}' substring='&apos;' action='Ignore' ignoreCase='true' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"'\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"a'a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"aaa\");| logFactory.AssertDebugLastMessage(\"aaa\");| }"
      },
      {
        "name": "WhenContainsQuoteTestComplex",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <when condition=\"\"contains('${message}', 'Cannot insert the value NULL into column ''Col1')\"\" action=\"\"Log\"\"></when>| <when condition='true' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| var expectedMessage = \"Cannot insert the value NULL into column 'Col1\";| logger.Debug(expectedMessage);| logFactory.AssertDebugLastMessage(expectedMessage);| expectedMessage = \"Cannot insert the value NULL into column 'Col1'\";| logger.Debug(expectedMessage);| logFactory.AssertDebugLastMessage(expectedMessage);| expectedMessage = \"Cannot insert the value NULL into column 'COL1'\";| logger.Debug(expectedMessage);| logFactory.AssertDebugLastMessage(expectedMessage);| logger.Debug(\"Cannot insert the value NULL into column Col1\");| logFactory.AssertDebugLastMessage(expectedMessage);| logger.Debug(\"Test\");| logFactory.AssertDebugLastMessage(expectedMessage);| }"
      },
      {
        "name": "WhenContainsFilterActionMustOverrideDefault",
        "body": "{| var ex = Assert.Throws<NLogConfigurationException>(() =>| {| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='Ignore'>| <whenContains layout='${message}' substring='zzz' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| });| Assert.Contains(\"FilterDefaultAction=Ignore\", ex.InnerException?.Message ?? ex.Message);| }"
      }
    ]
  },
  {
    "file": "WhenEqualTests.cs",
    "methods": [
      {
        "name": "WhenEqualTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenEqual layout='${message}' compareTo='skipme' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"skipme\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"SkipMe\");| logFactory.AssertDebugLastMessage(\"SkipMe\");| }"
      },
      {
        "name": "WhenEqualInsensitiveTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenEqual layout='${message}' compareTo='skipmetoo' action='Ignore' ignoreCase='true' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"skipMeToo\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"skipmetoo\");| logFactory.AssertDebugLastMessage(\"a\");| }"
      }
    ]
  },
  {
    "file": "WhenMethodFilterTests.cs",
    "methods": [
      {
        "name": "WhenMethodFilterAPITest",
        "body": "{| // Stage| var logFactory = new LogFactory();| var logger1 = logFactory.GetLogger(\"Hello\");| var logger2 = logFactory.GetLogger(\"Goodbye\");| var config = new LoggingConfiguration(logFactory);| var target = new NLog.Targets.DebugTarget() { Layout = \"${message}\" };| config.AddRuleForAllLevels(target);| config.LoggingRules.Last().Filters.Add(new WhenMethodFilter((l) => l.LoggerName == logger1.Name ? FilterResult.Ignore : FilterResult.Log));| logFactory.Configuration = config;| // Act 1| logger1.Info(\"Hello World\");| Assert.Empty(target.LastMessage);| // Act 2| logger2.Info(\"Goodbye World\");| Assert.Equal(\"Goodbye World\", target.LastMessage);| }"
      }
    ]
  },
  {
    "file": "WhenNotContainsTests.cs",
    "methods": [
      {
        "name": "WhenNotContainsTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenNotContains layout='${message}' substring='zzz' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"zzz\");| logFactory.AssertDebugLastMessage(\"zzz\");| logger.Debug(\"ZzzZ\");| logFactory.AssertDebugLastMessage(\"zzz\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"zzz\");| }"
      },
      {
        "name": "WhenNotContainsInsensitiveTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenNotContains layout='${message}' substring='zzz' action='Ignore' ignoreCase='true' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"zzz\");| logFactory.AssertDebugLastMessage(\"zzz\");| logger.Debug(\"ZzzZ\");| logFactory.AssertDebugLastMessage(\"ZzzZ\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"ZzzZ\");| logger.Debug(\"aaa\");| logFactory.AssertDebugLastMessage(\"ZzzZ\");| }"
      }
    ]
  },
  {
    "file": "WhenNotEqualTests.cs",
    "methods": [
      {
        "name": "WhenNotEqualTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenNotEqual layout='${message}' compareTo='skipme' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"skipme\");| logFactory.AssertDebugLastMessage(\"skipme\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"skipme\");| logger.Debug(\"SkipMe\");| logFactory.AssertDebugLastMessage(\"skipme\");| }"
      },
      {
        "name": "WhenNotEqualInsensitiveTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenNotEqual layout='${message}' compareTo='skipmetoo' action='Ignore' ignoreCase='true' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"skipMeToo\");| logFactory.AssertDebugLastMessage(\"skipMeToo\");| logger.Debug(\"skipmetoo\");| logFactory.AssertDebugLastMessage(\"skipmetoo\");| logger.Debug(\"dontskipme\");| logFactory.AssertDebugLastMessage(\"skipmetoo\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"skipmetoo\");| }"
      }
    ]
  },
  {
    "file": "WhenRepeatedTests.cs",
    "methods": [
      {
        "name": "WhenRepeatedIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${message}' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| }"
      },
      {
        "name": "WhenRepeatedIgnoreDualTargetTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${message}' />| <target name='debug2' type='Debug' layout='${message}' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug,debug2'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| AssertDebugCounter(\"debug2\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| AssertDebugCounter(\"debug2\", 2);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| AssertDebugCounter(\"debug2\", 2);| }"
      },
      {
        "name": "WhenRepeatedLogAfterTimeoutTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' includeFirst='True' />| </filters>| </logger>| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 0);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 0);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 0);| }"
      },
      {
        "name": "WhenRepeatedTimeoutIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' timeoutSeconds='10' />| </filters>| </logger>| </rules>| </nlog>\");| var defaultTimeSource = Time.TimeSource.Current;| try| {| var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);| Time.TimeSource.Current = timeSource;| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 3);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 4);| }| finally| {| Time.TimeSource.Current = defaultTimeSource; // restore default time source| }| }"
      },
      {
        "name": "WhenRepeatedTimeoutLogAfterTimeoutTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' includeFirst='True' timeoutSeconds='10' />| </filters>| </logger>| </rules>| </nlog>\");| var defaultTimeSource = Time.TimeSource.Current;| try| {| var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);| Time.TimeSource.Current = timeSource;| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 0);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 0);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 0);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 0);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 0);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 1);| }| finally| {| Time.TimeSource.Current = defaultTimeSource; // restore default time source| }| }"
      },
      {
        "name": "WhenRepeatedDefaultFilterCountIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' defaultFilterCacheSize='5' timeoutSeconds='10' />| </filters>| </logger>| </rules>| </nlog>\");| var defaultTimeSource = Time.TimeSource.Current;| try| {| var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);| Time.TimeSource.Current = timeSource;| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 3);| logger.Debug(\"c\");| AssertDebugCounter(\"debug\", 4);| logger.Debug(\"d\");| AssertDebugCounter(\"debug\", 5);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));| logger.Debug(\"e\");| AssertDebugCounter(\"debug\", 6);| logger.Debug(\"f\");| AssertDebugCounter(\"debug\", 7);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 7);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));| for (int i = 0; i < 10; ++i)| {| char charCount = (char)('g' + i);| logger.Debug(charCount.ToString());| AssertDebugCounter(\"debug\", 8 + i);| }| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 18);| }| finally| {| Time.TimeSource.Current = defaultTimeSource; // restore default time source| }| }"
      },
      {
        "name": "WhenRepeatedMaxCacheSizeIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' maxFilterCacheSize='5' defaultFilterCacheSize='5' timeoutSeconds='10' />| </filters>| </logger>| </rules>| </nlog>\");| var defaultTimeSource = Time.TimeSource.Current;| try| {| var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);| Time.TimeSource.Current = timeSource;| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 3);| logger.Debug(\"c\");| AssertDebugCounter(\"debug\", 4);| logger.Debug(\"d\");| AssertDebugCounter(\"debug\", 5);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));| logger.Debug(\"e\");| AssertDebugCounter(\"debug\", 6);| logger.Debug(\"f\");| AssertDebugCounter(\"debug\", 7);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 7);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));| for (int i = 0; i < 10; ++i)| {| char charCount = (char)('g' + i);| logger.Debug(charCount.ToString());| AssertDebugCounter(\"debug\", 8 + i);| }| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 18);| }| finally| {| Time.TimeSource.Current = defaultTimeSource; // restore default time source| }| }"
      },
      {
        "name": "WhenRepeatedLevelIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Error(\"zzz\");| AssertDebugCounter(\"debug\", 3);| logger.Error(\"zzz\");| AssertDebugCounter(\"debug\", 3);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 3);| logger.Fatal(\"zzz\");| AssertDebugCounter(\"debug\", 4);| }"
      },
      {
        "name": "WhenRepeatedMaxLengthIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' maxLength='16' optimizeBufferDefaultLength='16' />| </filters>| </logger>| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzzzzzzzzzzzzzzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzzzzzzzzzzzzzzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"zzzzzzzzzzzzzzzzzzzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 3);| }"
      },
      {
        "name": "WhenRepeatedFilterCountPropertyNameIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}${event-properties:item=hits}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' timeoutSeconds='5' filterCountPropertyName='hits' />| </filters>| </logger>| </rules>| </nlog>\");| var defaultTimeSource = Time.TimeSource.Current;| try| {| var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);| Time.TimeSource.Current = timeSource;| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| AssertDebugLastMessage(\"debug\", \"zzz\");| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 3);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 4);| AssertDebugLastMessage(\"debug\", \"zzz2\");| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 4);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(12));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 5);| AssertDebugLastMessage(\"debug\", \"zzz\");| }| finally| {| Time.TimeSource.Current = defaultTimeSource; // restore default time source| }| }"
      },
      {
        "name": "WhenRepeatedFilterCountAppendFormatIgnoreTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}${event-properties:item=hits}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'>| <filters defaultAction='log'>| <whenRepeated layout='${message}' action='Ignore' timeoutSeconds='5' filterCountMessageAppendFormat=' (Hits: {0})' />| </filters>| </logger>| </rules>| </nlog>\");| var defaultTimeSource = Time.TimeSource.Current;| try| {| var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);| Time.TimeSource.Current = timeSource;| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| AssertDebugCounter(\"debug\", 1);| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| AssertDebugLastMessage(\"debug\", \"zzz\");| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 2);| logger.Debug(\"b\");| AssertDebugCounter(\"debug\", 3);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 4);| AssertDebugLastMessage(\"debug\", \"zzz (Hits: 2)\");| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 4);| timeSource.AddToLocalTime(TimeSpan.FromSeconds(12));| logger.Debug(\"zzz\");| AssertDebugCounter(\"debug\", 5);| AssertDebugLastMessage(\"debug\", \"zzz\");| }| finally| {| Time.TimeSource.Current = defaultTimeSource; // restore default time source| }| }"
      }
    ]
  },
  {
    "file": "LogEventBuilderTests.cs",
    "methods": [
      {
        "name": "TraceWrite",
        "body": "{| LogWrite_internal(() => _logger.ForTraceEvent(), LogLevel.Trace);| }"
      },
      {
        "name": "DebugWrite",
        "body": "{| LogWrite_internal(() => _logger.ForDebugEvent(), LogLevel.Debug);| }"
      },
      {
        "name": "InfoWrite",
        "body": "{| LogWrite_internal(() => _logger.ForInfoEvent(), LogLevel.Info);| }"
      },
      {
        "name": "TraceWriteProperties",
        "body": "{| var props = new Dictionary<string, object>| {| {\"prop1\", \"1\"},| {\"prop2\", \"2\"},| };| _logger.ForTraceEvent()| .Message(\"This is a test fluent message.\")| .Properties(props).Log();| {| var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent message.\");| expectedEvent.Properties[\"prop1\"] = \"1\";| expectedEvent.Properties[\"prop2\"] = \"2\";| AssertLastLogEventTarget(expectedEvent);| }| }"
      },
      {
        "name": "WarnWriteProperties",
        "body": "{| var props = new Dictionary<string, object>| {| {\"prop1\", \"1\"},| {\"prop2\", \"2\"},| };| _logger.ForWarnEvent()| .Message(\"This is a test fluent message.\")| .Properties(props).Log();| {| var expectedEvent = new LogEventInfo(LogLevel.Warn, \"logger1\", \"This is a test fluent message.\");| expectedEvent.Properties[\"prop1\"] = \"1\";| expectedEvent.Properties[\"prop2\"] = \"2\";| AssertLastLogEventTarget(expectedEvent);| }| }"
      },
      {
        "name": "LogWriteProperties",
        "body": "{| var props = new Dictionary<string, object>| {| {\"prop1\", \"1\"},| {\"prop2\", \"2\"},| };| // Loop to verify caller-attribute-caching-lookup| for (int i = 0; i < 2; ++i)| {| _logger.ForLogEvent(LogLevel.Fatal)| .Message(\"This is a test fluent message.\")| .Properties(props).Log();| var expectedEvent = new LogEventInfo(LogLevel.Fatal, \"logger1\", \"This is a test fluent message.\");| expectedEvent.Properties[\"prop1\"] = \"1\";| expectedEvent.Properties[\"prop2\"] = \"2\";| AssertLastLogEventTarget(expectedEvent);|#if !NET35| Assert.Equal(GetType().ToString(), _lastLogEventInfo.CallerClassName);|#endif| }| }"
      },
      {
        "name": "LogOffWriteProperties",
        "body": "{| var props = new Dictionary<string, object>| {| {\"prop1\", \"1\"},| {\"prop2\", \"2\"},| };| var props2 = new Dictionary<string, object>| {| {\"prop1\", \"4\"},| {\"prop2\", \"5\"},| };| _logger.ForLogEvent(LogLevel.Fatal)| .Message(\"This is a test fluent message.\")| .Properties(props).Log();| _logger.ForLogEvent(LogLevel.Off)| .Message(\"dont log this.\")| .Properties(props2).Log();| {| var expectedEvent = new LogEventInfo(LogLevel.Fatal, \"logger1\", \"This is a test fluent message.\");| expectedEvent.Properties[\"prop1\"] = \"1\";| expectedEvent.Properties[\"prop2\"] = \"2\";| AssertLastLogEventTarget(expectedEvent);| }| }"
      },
      {
        "name": "TraceIfWrite",
        "body": "{| _logger.ForTraceEvent()| .Message(\"This is a test fluent message.1\")| .Property(\"Test\", \"TraceWrite\")| .Log();| {| var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent message.1\");| expectedEvent.Properties[\"Test\"] = \"TraceWrite\";| AssertLastLogEventTarget(expectedEvent);| }| int v = 1;| _logger.ForTraceEvent()| .Message(\"This is a test fluent WriteIf message '{0}'.\", DateTime.Now.Ticks)| .Property(\"Test\", \"TraceWrite\")| .Log(v == 1 ? null : LogLevel.Off);| {| var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");| expectedEvent.Properties[\"Test\"] = \"TraceWrite\";| AssertLastLogEventTarget(expectedEvent);| AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");| }| _logger.ForTraceEvent()| .Message(\"dont write this! '{0}'.\", DateTime.Now.Ticks)| .Property(\"Test\", \"TraceWrite\")| .Log(LogLevel.Off);| {| var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");| expectedEvent.Properties[\"Test\"] = \"TraceWrite\";| AssertLastLogEventTarget(expectedEvent);| AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");| }| _logger.ForTraceEvent()| .Message(\"This is a test fluent WriteIf message '{0}'.\", DateTime.Now.Ticks)| .Property(\"Test\", \"TraceWrite\")| .Log(v == 1 ? null : LogLevel.Off);| {| var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");| expectedEvent.Properties[\"Test\"] = \"TraceWrite\";| AssertLastLogEventTarget(expectedEvent);| AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");| }| _logger.ForTraceEvent()| .Message(\"Should Not WriteIf message '{0}'.\", DateTime.Now.Ticks)| .Property(\"Test\", \"TraceWrite\")| .Log(v > 1 ? null : LogLevel.Off);| {| //previous| var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");| expectedEvent.Properties[\"Test\"] = \"TraceWrite\";| AssertLastLogEventTarget(expectedEvent);| AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");| }| }"
      },
      {
        "name": "FatalWrite",
        "body": "{| LogWriteException_internal((ex) => _logger.ForFatalEvent().Exception(ex), LogLevel.Fatal);| }"
      },
      {
        "name": "ErrorWrite",
        "body": "{| LogWriteException_internal((ex) => _logger.ForErrorEvent().Exception(ex), LogLevel.Error);| }"
      },
      {
        "name": "ExceptionWrite",
        "body": "{| LogWriteException_internal((ex) => _logger.ForExceptionEvent(ex), LogLevel.Error);| }"
      },
      {
        "name": "LogBuilder_null_lead_to_ArgumentNullException",
        "body": "{| var logger = LogManager.GetLogger(\"a\");| Assert.Throws<ArgumentNullException>(() => new LogEventBuilder(null, LogLevel.Debug));| Assert.Throws<ArgumentNullException>(() => new LogEventBuilder(null));| Assert.Throws<ArgumentNullException>(() => new LogEventBuilder(logger, null));| var logBuilder = new LogEventBuilder(logger);| Assert.Throws<ArgumentNullException>(() => logBuilder.Properties(null));| Assert.Throws<ArgumentNullException>(() => logBuilder.Property(null, \"b\"));| }"
      },
      {
        "name": "LogBuilder_nLogEventInfo",
        "body": "{| var d = new DateTime(2015, 01, 30, 14, 30, 5);| var logEventInfo = new LogEventBuilder(LogManager.GetLogger(\"a\"), LogLevel.Fatal).TimeStamp(d).LogEvent;| Assert.Equal(\"a\", logEventInfo.LoggerName);| Assert.Equal(LogLevel.Fatal, logEventInfo.Level);| Assert.Equal(d, logEventInfo.TimeStamp);| }"
      },
      {
        "name": "LogBuilder_exception_only",
        "body": "{| var ex = new Exception(\"Exception message1\");| _logger.ForErrorEvent()| .Exception(ex)| .Log();| var expectedEvent = LogEventInfo.Create(LogLevel.Error, \"logger1\", null, ex);| AssertLastLogEventTarget(expectedEvent);| }"
      },
      {
        "name": "LogBuilder_message_overloadsTest",
        "body": "{| LogManager.ThrowExceptions = true;| _logger.ForDebugEvent();| _logger.ForDebugEvent()| .Message(\"Message with {0} arg\", 1)| .Log();| AssertDebugLastMessage(\"t2\", \"Message with 1 arg\");| _logger.ForDebugEvent()| .Message(\"Message with {0} args. {1}\", 2, \"YES\")| .Log();| AssertDebugLastMessage(\"t2\", \"Message with 2 args. YES\");| _logger.ForDebugEvent()| .Message(\"Message with {0} args. {1} {2}\", 3, \":) \", 2)| .Log();| AssertDebugLastMessage(\"t2\", \"Message with 3 args. :) 2\");| _logger.ForDebugEvent()| .Message(\"Message with {0} args. {1} {2}{3}\", \"more\", \":) \", 2, \"b\")| .Log();| AssertDebugLastMessage(\"t2\", \"Message with more args. :) 2b\");| }"
      },
      {
        "name": "LogBuilder_message_cultureTest",
        "body": "{| if (IsLinux())| {| Console.WriteLine(\"[SKIP] LogBuilderTests.LogBuilder_message_cultureTest because we are running in Travis\");| return;| }| LogManager.Configuration.DefaultCultureInfo = GetCultureInfo(\"en-US\");| _logger.ForDebugEvent()| .Message(\"Message with {0} {1} {2} {3}\", 4.1, 4.001, new DateTime(2016, 12, 31), true)| .Log();| AssertDebugLastMessage(\"t2\", \"Message with 4.1 4.001 12/31/2016 12:00:00 AM True\");| _logger.ForDebugEvent()| .Message(GetCultureInfo(\"nl-nl\"), \"Message with {0} {1} {2} {3}\", 4.1, 4.001, new DateTime(2016, 12, 31), true)| .Log();| AssertDebugLastMessage(\"t2\", \"Message with 4,1 4,001 31-12-2016 00:00:00 True\");| }"
      },
      {
        "name": "LogBuilder_Structured_Logging_Test",
        "body": "{| var logEvent = _logger.ForInfoEvent().Property(\"Property1Key\", \"Property1Value\").Message(\"{@message}\", \"My custom message\").LogEvent;| Assert.NotEmpty(logEvent.Properties);| Assert.Contains(\"message\", logEvent.Properties.Keys);| Assert.Contains(\"Property1Key\", logEvent.Properties.Keys);| }"
      },
      {
        "name": "LogBuilder_Callsite_Test",
        "body": "{| var logEvent = _logger.ForInfoEvent().Callsite(nameof(LogEventInfo.CallerClassName), nameof(LogEventInfo.CallerMemberName), nameof(LogEventInfo.CallerFilePath), 42).LogEvent;| Assert.Equal(nameof(LogEventInfo.CallerClassName), logEvent.CallerClassName);| Assert.Equal(nameof(LogEventInfo.CallerMemberName), logEvent.CallerMemberName);| Assert.Equal(nameof(LogEventInfo.CallerFilePath), logEvent.CallerFilePath);| Assert.Equal(42, logEvent.CallerLineNumber);| }"
      }
    ]
  },
  {
    "file": "GetLoggerTests.cs",
    "methods": [
      {
        "name": "GetCurrentClassLoggerTest",
        "body": "{| var logger = LogManager.GetCurrentClassLogger();| Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", logger.Name);| }"
      },
      {
        "name": "GetCurrentClassLoggerLambdaTest",
        "body": "{| System.Linq.Expressions.Expression<Func<Logger>> sum = () => LogManager.GetCurrentClassLogger();| var logger = sum.Compile().Invoke();| Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", logger.Name);| }"
      },
      {
        "name": "TypedGetLoggerTest",
        "body": "{| LogFactory lf = new LogFactory();| MyLogger l1 = (MyLogger)lf.GetLogger(\"AAA\", typeof(MyLogger));| MyLogger l2 = lf.GetLogger<MyLogger>(\"AAA\");| Logger l3 = lf.GetLogger(\"AAA\", typeof(Logger));| Logger l5 = lf.GetLogger(\"AAA\");| Logger l6 = lf.GetLogger(\"AAA\");| Assert.Same(l1, l2);| Assert.Same(l5, l6);| Assert.Same(l3, l5);| Assert.NotSame(l1, l3);| Assert.Equal(\"AAA\", l1.Name);| Assert.Equal(\"AAA\", l3.Name);| }"
      },
      {
        "name": "TypedGetCurrentClassLoggerTest",
        "body": "{| LogFactory lf = new LogFactory();| MyLogger l1 = (MyLogger)lf.GetCurrentClassLogger(typeof(MyLogger));| MyLogger l2 = lf.GetCurrentClassLogger<MyLogger>();| Logger l3 = lf.GetCurrentClassLogger(typeof(Logger));| Logger l5 = lf.GetCurrentClassLogger();| Logger l6 = lf.GetCurrentClassLogger();| Assert.Same(l1, l2);| Assert.Same(l5, l6);| Assert.Same(l3, l5);| Assert.NotSame(l1, l3);| Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", l1.Name);| Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", l3.Name);| }"
      },
      {
        "name": "GenericGetLoggerTest",
        "body": "{| LogFactory<MyLogger> lf = new LogFactory<MyLogger>();| MyLogger l1 = lf.GetLogger(\"AAA\");| MyLogger l2 = lf.GetLogger(\"AAA\");| MyLogger l3 = lf.GetLogger(\"BBB\");| Assert.Same(l1, l2);| Assert.NotSame(l1, l3);| Assert.Equal(\"AAA\", l1.Name);| Assert.Equal(\"BBB\", l3.Name);| }"
      },
      {
        "name": "GenericGetCurrentClassLoggerTest",
        "body": "{| LogFactory<MyLogger> lf = new LogFactory<MyLogger>();| MyLogger l1 = lf.GetCurrentClassLogger();| MyLogger l2 = lf.GetCurrentClassLogger();| Assert.Same(l1, l2);| Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", l1.Name);| }"
      },
      {
        "name": "InvalidLoggerConfiguration_NotThrowsThrowExceptions_NotThrows",
        "body": "{| using (new NoThrowNLogExceptions())| {| var result = LogManager.GetCurrentClassLogger(typeof(InvalidLogger));| Assert.NotNull(result);| }| }"
      },
      {
        "name": "InvalidLoggerConfiguration_ThrowsThrowExceptions_Throws",
        "body": "{| LogManager.ThrowExceptions = true;| Assert.Throws<NLogRuntimeException>(() =>| {| LogManager.GetCurrentClassLogger(typeof(InvalidLogger));| });| }"
      }
    ]
  },
  {
    "file": "AppDomainPartialTrustTests.cs",
    "methods": [
      {
        "name": "MediumTrustWithExternalClass",
        "body": "{| var fileWritePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| try| {| int times = 25;| RunAppDomainTestMethod(fileWritePath, times, true);| // this also checks that thread-volatile layouts| // such as ${threadid} are properly cached and not recalculated| // in logging threads.| var threadID = CurrentManagedThreadId.ToString();| Assert.False(File.Exists(Path.Combine(fileWritePath, \"Trace.txt\")));| AssertFileContents(Path.Combine(fileWritePath, \"Debug.txt\"),| StringRepeat(times, \"aaa \" + threadID + \"\\n\"), Encoding.UTF8);| AssertFileContents(Path.Combine(fileWritePath, \"Info.txt\"),| StringRepeat(times, \"bbb \" + threadID + \"\\n\"), Encoding.UTF8);| AssertFileContents(Path.Combine(fileWritePath, \"Warn.txt\"),| StringRepeat(times, \"ccc \" + threadID + \"\\n\"), Encoding.UTF8);| AssertFileContents(Path.Combine(fileWritePath, \"Error.txt\"),| StringRepeat(times, \"ddd \" + threadID + \"\\n\"), Encoding.UTF8);| AssertFileContents(Path.Combine(fileWritePath, \"Fatal.txt\"),| StringRepeat(times, \"eee \" + threadID + \"\\n\"), Encoding.UTF8);| }| finally| {| if (Directory.Exists(fileWritePath))| Directory.Delete(fileWritePath, true);| }| }"
      },
      {
        "name": "MediumTrustWithExternalClassNoAutoFlush",
        "body": "{| var fileWritePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());| try| {| int times = 5;| RunAppDomainTestMethod(fileWritePath, times, false);| Assert.False(File.Exists(Path.Combine(fileWritePath, \"Trace.txt\")));| Assert.False(File.Exists(Path.Combine(fileWritePath, \"Debug.txt\")));| Assert.False(File.Exists(Path.Combine(fileWritePath, \"Warn.txt\")));| Assert.False(File.Exists(Path.Combine(fileWritePath, \"Error.txt\")));| Assert.False(File.Exists(Path.Combine(fileWritePath, \"Fatal.txt\")));| }| finally| {| if (Directory.Exists(fileWritePath))| Directory.Delete(fileWritePath, true);| }| }"
      }
    ]
  },
  {
    "file": "AsyncLogEventInfoTests.cs",
    "methods": [
      {
        "name": "TestEquals",
        "body": "{| var logEvent1 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");| AsyncContinuation cont1 = new AsyncContinuation(exception => { });| var async1 = new AsyncLogEventInfo(logEvent1, cont1);| var async2 = new AsyncLogEventInfo(logEvent1, cont1);| Assert.True(async1.Equals(async2));| Assert.True(async1 == async2);| Assert.False(async1 != async2);| Assert.Equal(async1.GetHashCode(), async2.GetHashCode());| }"
      },
      {
        "name": "TestNotEquals",
        "body": "{| var logEvent1 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");| AsyncContinuation cont1 = new AsyncContinuation(exception => { });| AsyncContinuation cont2 = new AsyncContinuation(exception => { InternalLogger.Debug(\"test\"); });| var async1 = new AsyncLogEventInfo(logEvent1, cont1);| var async2 = new AsyncLogEventInfo(logEvent1, cont2);| Assert.False(async1.Equals(async2));| Assert.False(async1 == async2);| Assert.True(async1 != async2);| //2 delegates will return the same hashcode, https://stackoverflow.com/questions/6624151/why-do-2-delegate-instances-return-the-same-hashcode| //and that isn't really bad, so ignore this| // Assert.NotEqual(async1.GetHashCode(), async2.GetHashCode());| }"
      },
      {
        "name": "TestNotEquals2",
        "body": "{| var logEvent1 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");| var logEvent2 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");| AsyncContinuation cont = new AsyncContinuation(exception => { });| var async1 = new AsyncLogEventInfo(logEvent1, cont);| var async2 = new AsyncLogEventInfo(logEvent2, cont);| Assert.False(async1.Equals(async2));| Assert.False(async1 == async2);| Assert.True(async1 != async2);| Assert.NotEqual(async1.GetHashCode(), async2.GetHashCode());| }"
      }
    ]
  },
  {
    "file": "ConversionHelpersTests.cs",
    "methods": [
      {
        "name": "EnumParse1_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"Foo\", false, TestEnum.Foo, true);| }"
      },
      {
        "name": "EnumParse2_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"foo\", false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParseDefault_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"BAR\", false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParseDefault2_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"x\", false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParseBar_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"bar\", false, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParseBar2_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\" bar \", false, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParseBar3_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\" \\r\\nbar \", false, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParse_null_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(null, false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse_emptystring_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(string.Empty, false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse_whitespace_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\" \", false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse_wrongInput_ignoreCaseFalse",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"not enum\", false, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse1_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"Foo\", true, TestEnum.Foo, true);| }"
      },
      {
        "name": "EnumParse2_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"foo\", true, TestEnum.Foo, true);| }"
      },
      {
        "name": "EnumParseDefault_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"BAR\", true, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParseDefault2_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"x\", true, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParseBar_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\"bar\", true, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParseBar2_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\" bar \", true, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParseBar3_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\" \\r\\nbar \", true, TestEnum.bar, true);| }"
      },
      {
        "name": "EnumParse_null_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(null, true, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse_emptystring_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(string.Empty, true, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse_whitespace_ignoreCaseTrue",
        "body": "{| TestEnumParseCaseIgnoreCaseParam(\" \", true, TestEnum.Foo, false);| }"
      },
      {
        "name": "EnumParse_ArgumentException_ignoreCaseTrue",
        "body": "{| double result;| Assert.Throws<ArgumentException>(() => ConversionHelpers.TryParseEnum(\"not enum\", true, out result));| }"
      }
    ]
  },
  {
    "file": "FileAppenderCacheTests.cs",
    "methods": [
      {
        "name": "FileAppenderCache_Empty",
        "body": "{| FileAppenderCache cache = FileAppenderCache.Empty;| // An empty FileAppenderCache will have Size = 0 as well as Factory and CreateFileParameters parameters equal to null.| Assert.Equal(0, cache.Size);| Assert.Null(cache.Factory);| Assert.Null(cache.CreateFileParameters);| }"
      },
      {
        "name": "FileAppenderCache_Construction",
        "body": "{| IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget();| FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);| Assert.Equal(3, cache.Size);| Assert.NotNull(cache.Factory);| Assert.NotNull(cache.CreateFileParameters);| }"
      },
      {
        "name": "FileAppenderCache_Allocate",
        "body": "{| // Allocate on an Empty FileAppenderCache.| FileAppenderCache emptyCache = FileAppenderCache.Empty;| Assert.Throws<NullReferenceException>(() => emptyCache.AllocateAppender(\"file.txt\"));| // Construct a on non-empty FileAppenderCache.| IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget();| String tempFile = Path.Combine(| Path.GetTempPath(),| Path.Combine(Guid.NewGuid().ToString(), \"file.txt\")| );| // Allocate an appender.| FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);| BaseFileAppender appender = cache.AllocateAppender(tempFile);| //| // Note: Encoding is ASSUMED to be Unicode. There is no explicit reference to which encoding will be used| // for the file.| //| // Write, flush the content into the file and release the file.| // We need to release the file before invoking AssertFileContents() method.| appender.Write(StringToBytes(\"NLog test string.\"));| appender.Flush();| appender.Close();| // Verify the appender has been allocated correctly.| AssertFileContents(tempFile, \"NLog test string.\", Encoding.Unicode);| }"
      },
      {
        "name": "FileAppenderCache_InvalidateAppender",
        "body": "{| // Invoke InvalidateAppender() on an Empty FileAppenderCache.| FileAppenderCache emptyCache = FileAppenderCache.Empty;| emptyCache.InvalidateAppender(\"file.txt\");| // Construct a on non-empty FileAppenderCache.| IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget();| String tempFile = Path.Combine(| Path.GetTempPath(),| Path.Combine(Guid.NewGuid().ToString(), \"file.txt\")| );| // Allocate an appender.| FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);| BaseFileAppender appender = cache.AllocateAppender(tempFile);| //| // Note: Encoding is ASSUMED to be Unicode. There is no explicit reference to which encoding will be used| // for the file.| //| // Write, flush the content into the file and release the file. This happens through the| // InvalidateAppender() method. We need to release the file before invoking AssertFileContents() method.| appender.Write(StringToBytes(\"NLog test string.\"));| cache.InvalidateAppender(tempFile);| // Verify the appender has been allocated correctly.| AssertFileContents(tempFile, \"NLog test string.\", Encoding.Unicode);| }"
      },
      {
        "name": "FileAppenderCache_CloseAppenders",
        "body": "{| // Invoke CloseAppenders() on an Empty FileAppenderCache.| FileAppenderCache emptyCache = FileAppenderCache.Empty;| emptyCache.CloseAppenders(string.Empty);| emptyCache.CloseExpiredAppenders(DateTime.UtcNow);| IFileAppenderFactory appenderFactory = RetryingMultiProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget();| FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);| // Invoke CloseAppenders() on non-empty FileAppenderCache - Before allocating any appenders.| cache.CloseAppenders(string.Empty);| // Invoke CloseAppenders() on non-empty FileAppenderCache - After allocating N appenders.| cache.AllocateAppender(\"file1.txt\");| cache.AllocateAppender(\"file2.txt\");| cache.CloseAppenders(string.Empty);| // Invoke CloseAppenders() on non-empty FileAppenderCache - After allocating N appenders.| cache.AllocateAppender(\"file1.txt\");| cache.AllocateAppender(\"file2.txt\");| cache.CloseAppenders(string.Empty);| FileAppenderCache cache2 = new FileAppenderCache(3, appenderFactory, fileTarget);| // Invoke CloseAppenders() on non-empty FileAppenderCache - Before allocating any appenders.| cache2.CloseExpiredAppenders(DateTime.UtcNow);| // Invoke CloseAppenders() on non-empty FileAppenderCache - After allocating N appenders.| cache.AllocateAppender(\"file1.txt\");| cache.AllocateAppender(\"file2.txt\");| cache.CloseExpiredAppenders(DateTime.UtcNow.AddMinutes(-1));| var appenderFile1 = cache.InvalidateAppender(\"file1.txt\");| Assert.NotNull(appenderFile1);| var appenderFile2 = cache.InvalidateAppender(\"file2.txt\");| Assert.NotNull(appenderFile2);| cache.AllocateAppender(\"file3.txt\");| cache.AllocateAppender(\"file4.txt\");| cache.CloseExpiredAppenders(DateTime.UtcNow.AddMinutes(1));| var appenderFile3 = cache.InvalidateAppender(\"file3.txt\");| Assert.Null(appenderFile3);| var appenderFile4 = cache.InvalidateAppender(\"file4.txt\");| Assert.Null(appenderFile4);| }"
      },
      {
        "name": "FileAppenderCache_GetFileCharacteristics_Single",
        "body": "{| IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget() { ArchiveNumbering = ArchiveNumberingMode.Date };| FileAppenderCache_GetFileCharacteristics(appenderFactory, fileTarget);| }"
      },
      {
        "name": "FileAppenderCache_GetFileCharacteristics_Multi",
        "body": "{| IFileAppenderFactory appenderFactory = MutexMultiProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget() { ArchiveNumbering = ArchiveNumberingMode.Date, ForceManaged = true };| FileAppenderCache_GetFileCharacteristics(appenderFactory, fileTarget);| }"
      },
      {
        "name": "FileAppenderCache_GetFileCharacteristics_Windows",
        "body": "{| if (NLog.Internal.PlatformDetector.IsWin32)| {| IFileAppenderFactory appenderFactory = WindowsMultiProcessFileAppender.TheFactory;| ICreateFileParameters fileTarget = new FileTarget() { ArchiveNumbering = ArchiveNumberingMode.Date };| FileAppenderCache_GetFileCharacteristics(appenderFactory, fileTarget);| }| }"
      }
    ]
  },
  {
    "file": "GuardTests.cs",
    "methods": [
      {
        "name": "ThrowIfNull_WhenArgumentIsNull_ThrowArgumentNullException",
        "body": "{| object argument = null;| Assert.Throws<ArgumentNullException>(() => Guard.ThrowIfNull(argument));| }"
      },
      {
        "name": "ThrowIfNull_WhenArgumentIsNotNull_ReturnArgument",
        "body": "{| var argument = \"test\";| var result = Guard.ThrowIfNull(argument);| Assert.Equal(argument, result);| }"
      },
      {
        "name": "ThrowIfNullOrEmpty_WhenArgumentIsNull_ThrowArgumentNullException",
        "body": "{| string argument = null;| Assert.Throws<ArgumentNullException>(() => Guard.ThrowIfNullOrEmpty(argument));| }"
      },
      {
        "name": "ThrowIfNullOrEmpty_WhenArgumentIsEmpty_ThrowArgumentNullException",
        "body": "{| var argument = string.Empty;| Assert.Throws<ArgumentNullException>(() => Guard.ThrowIfNullOrEmpty(argument));| }"
      },
      {
        "name": "ThrowIfNullOrEmpty_WhenArgumentIsValid_ReturnArgument",
        "body": "{| var argument = \"test\";| var result = Guard.ThrowIfNull(argument);| Assert.Equal(argument, result);| }"
      }
    ]
  },
  {
    "file": "MruCacheTests.cs",
    "methods": [
      {
        "name": "SimpleCacheAddAndLookupTest",
        "body": "{| MruCache<int, string> mruCache = new MruCache<int, string>(100);| for (int i = 0; i < 100; ++i)| mruCache.TryAddValue(i, i.ToString());| string value;| for (int i = 0; i < 100; ++i)| {| Assert.True(mruCache.TryGetValue(i, out value));| Assert.Equal(i.ToString(), value);| }| Assert.False(mruCache.TryGetValue(101, out value));| }"
      },
      {
        "name": "OverflowCacheAndLookupTest",
        "body": "{| MruCache<int, string> mruCache = new MruCache<int, string>(100);| for (int i = 0; i < 200; ++i)| mruCache.TryAddValue(i, i.ToString());| string value;| for (int i = 0; i < 100; ++i)| {| Assert.False(mruCache.TryGetValue(i, out value));| }| for (int i = 140; i < 200; ++i)| {| Assert.True(mruCache.TryGetValue(i, out value));| Assert.Equal(i.ToString(), value);| }| }"
      },
      {
        "name": "OverflowVersionCacheAndLookupTest",
        "body": "{| string value;| MruCache<int, string> mruCache = new MruCache<int, string>(100);| for (int i = 0; i < 200; ++i)| {| mruCache.TryAddValue(i, i.ToString());| Assert.True(mruCache.TryGetValue(i, out value)); // No longer a virgin| Assert.Equal(i.ToString(), value);| }| for (int i = 0; i < 90; ++i)| {| Assert.False(mruCache.TryGetValue(i, out value));| }| for (int i = 140; i < 200; ++i)| {| Assert.True(mruCache.TryGetValue(i, out value));| Assert.Equal(i.ToString(), value);| }| }"
      },
      {
        "name": "OverflowFreshCacheAndLookupTest",
        "body": "{| string value;| MruCache<int, string> mruCache = new MruCache<int, string>(100);| for (int i = 0; i < 200; ++i)| {| mruCache.TryAddValue(i, i.ToString());| Assert.True(mruCache.TryGetValue(i, out value)); // No longer a virgin| Assert.Equal(i.ToString(), value);| }| for (int j = 0; j < 2; ++j)| {| for (int i = 110; i < 200; ++i)| {| if (!mruCache.TryGetValue(i, out value))| {| mruCache.TryAddValue(i, i.ToString());| Assert.True(mruCache.TryGetValue(i, out value));| }| }| }| for (int i = 300; i < 310; ++i)| {| mruCache.TryAddValue(i, i.ToString());| }| int cacheCount = 0;| for (int i = 110; i < 200; ++i)| {| if (mruCache.TryGetValue(i, out value))| ++cacheCount;| }| Assert.True(cacheCount > 60); // See that old cache was not killed| }"
      },
      {
        "name": "RecentlyUsedLookupTest",
        "body": "{| string value;| MruCache<int, string> mruCache = new MruCache<int, string>(100);| for (int i = 0; i < 200; ++i)| {| mruCache.TryAddValue(i, i.ToString());| for (int j = 0; j < i; j += 10)| {| Assert.True(mruCache.TryGetValue(j, out value));| Assert.Equal(j.ToString(), value);| }| }| for (int j = 0; j < 100; j += 10)| {| Assert.True(mruCache.TryGetValue(j, out value));| Assert.Equal(j.ToString(), value);| }| for (int i = 170; i < 200; ++i)| {| Assert.True(mruCache.TryGetValue(i, out value));| Assert.Equal(i.ToString(), value);| }| }"
      }
    ]
  },
  {
    "file": "PlatformDetectorTests.cs",
    "methods": [
      {
        "name": "IsMonoTest",
        "body": "{|#if MONO| Assert.True(PlatformDetector.IsMono);|#else| Assert.False(PlatformDetector.IsMono);|#endif| }"
      },
      {
        "name": "GetCurrentOSTest",
        "body": "{| var actual = PlatformDetector.CurrentOS;| Assert.NotEqual(RuntimeOS.Unknown, actual);| }"
      }
    ]
  },
  {
    "file": "PropertiesDictionaryTests.cs",
    "methods": [
      {
        "name": "DefaultPropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo();| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Empty(dictionary);| foreach (var item in dictionary)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Keys)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Values)| Assert.Fail(\"Should be empty\");| Assert.DoesNotContain(\"Hello World\", dictionary);| Assert.False(dictionary.ContainsKey(\"Hello World\"));| Assert.False(dictionary.Keys.Contains(\"Hello World\"));| Assert.False(dictionary.Values.Contains(42));| object value;| Assert.False(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Null(value);| Assert.False(dictionary.Remove(\"Hello World\"));| dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);| dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Clear();| }"
      },
      {
        "name": "EmptyEventPropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo();| IDictionary<object, object> dictionary = logEvent.Properties;| dictionary.Add(\"Hello World\", 42);| Assert.True(dictionary.Remove(\"Hello World\"));| Assert.Empty(dictionary);| foreach (var item in dictionary)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Keys)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Values)| Assert.Fail(\"Should be empty\");| Assert.DoesNotContain(\"Hello World\", dictionary);| Assert.False(dictionary.ContainsKey(\"Hello World\"));| Assert.False(dictionary.Keys.Contains(\"Hello World\"));| Assert.False(dictionary.Values.Contains(42));| object value;| Assert.False(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Null(value);| Assert.False(dictionary.Remove(\"Hello World\"));| dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);| dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Clear();| }"
      },
      {
        "name": "EmptyMessagePropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, (IList<MessageTemplateParameter>)null);| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Empty(dictionary);| foreach (var item in dictionary)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Keys)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Values)| Assert.Fail(\"Should be empty\");| Assert.False(dictionary.ContainsKey(\"Hello World\"));| Assert.False(dictionary.Keys.Contains(\"Hello World\"));| Assert.False(dictionary.Values.Contains(42));| Assert.DoesNotContain(\"Hello World\", dictionary);| object value;| Assert.False(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Null(value);| Assert.False(dictionary.Remove(\"Hello World\"));| dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);| dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Clear();| }"
      },
      {
        "name": "EmptyPropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, (IList<MessageTemplateParameter>)null);| IDictionary<object, object> dictionary = logEvent.Properties;| dictionary.Add(\"Hello World\", null);| Assert.True(dictionary.Remove(\"Hello World\"));| Assert.Empty(dictionary);| foreach (var item in dictionary)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Keys)| Assert.Fail(\"Should be empty\");| foreach (var item in dictionary.Values)| Assert.Fail(\"Should be empty\");| Assert.False(dictionary.ContainsKey(\"Hello World\"));| Assert.False(dictionary.Keys.Contains(\"Hello World\"));| Assert.False(dictionary.Values.Contains(42));| Assert.DoesNotContain(\"Hello World\", dictionary);| object value;| Assert.False(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Null(value);| Assert.False(dictionary.Remove(\"Hello World\"));| dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);| dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);| dictionary.Clear();| }"
      },
      {
        "name": "SingleItemEventPropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo();| IDictionary<object, object> dictionary = logEvent.Properties;| dictionary.Add(\"Hello World\", 42);| Assert.Single(dictionary);| foreach (var item in dictionary)| {| Assert.Equal(\"Hello World\", item.Key);| Assert.Equal(42, item.Value);| }| foreach (var item in dictionary.Keys)| Assert.Equal(\"Hello World\", item);| foreach (var item in dictionary.Values)| Assert.Equal(42, item);| AssertContainsInDictionary(dictionary, \"Hello World\", 42);| Assert.True(dictionary.ContainsKey(\"Hello World\"));| Assert.True(dictionary.Keys.Contains(\"Hello World\"));| Assert.True(dictionary.Values.Contains(42));| Assert.False(dictionary.ContainsKey(\"Goodbye World\"));| Assert.False(dictionary.Keys.Contains(\"Goodbye World\"));| Assert.DoesNotContain(\"Goodbye World\", dictionary);| object value;| Assert.True(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Equal(42, value);| Assert.False(dictionary.TryGetValue(\"Goodbye World\", out value));| Assert.Null(value);| var copyToArray = new KeyValuePair<object, object>[1];| dictionary.CopyTo(copyToArray, 0);| Assert.Equal(\"Hello World\", copyToArray[0].Key);| Assert.Equal(42, copyToArray[0].Value);| var copyToValuesArray = new object[1];| dictionary.Values.CopyTo(copyToValuesArray, 0);| Assert.Equal(42, copyToValuesArray[0]);| var copyToKeysArray = new object[1];| dictionary.Keys.CopyTo(copyToKeysArray, 0);| Assert.Equal(\"Hello World\", copyToKeysArray[0]);| Assert.True(dictionary.Remove(\"Hello World\"));| Assert.Empty(dictionary);| dictionary[\"Hello World\"] = 42;| Assert.Single(dictionary);| dictionary.Clear();| Assert.Empty(dictionary);| }"
      },
      {
        "name": "SingleItemMessagePropertiesDictionaryNoLookup",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[] { new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal) });| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Single(dictionary);| foreach (var item in dictionary)| {| Assert.Equal(\"Hello World\", item.Key);| Assert.Equal(42, item.Value);| }| foreach (var item in dictionary.Keys)| Assert.Equal(\"Hello World\", item);| foreach (var item in dictionary.Values)| Assert.Equal(42, item);| var copyToArray = new KeyValuePair<object, object>[1];| dictionary.CopyTo(copyToArray, 0);| Assert.Equal(\"Hello World\", copyToArray[0].Key);| Assert.Equal(42, copyToArray[0].Value);| var copyToValuesArray = new object[1];| dictionary.Values.CopyTo(copyToValuesArray, 0);| Assert.Equal(42, copyToValuesArray[0]);| var copyToKeysArray = new object[1];| dictionary.Keys.CopyTo(copyToKeysArray, 0);| Assert.Equal(\"Hello World\", copyToKeysArray[0]);| dictionary.Clear();| Assert.Empty(dictionary);| }"
      },
      {
        "name": "SingleItemMessagePropertiesDictionaryWithLookup",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[] { new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal) });| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Single(dictionary);| AssertContainsInDictionary(dictionary, \"Hello World\", 42);| Assert.True(dictionary.ContainsKey(\"Hello World\"));| Assert.True(dictionary.Keys.Contains(\"Hello World\"));| Assert.True(dictionary.Values.Contains(42));| Assert.False(dictionary.ContainsKey(\"Goodbye World\"));| Assert.False(dictionary.Keys.Contains(\"Goodbye World\"));| Assert.DoesNotContain(\"Goodbye World\", dictionary);| object value;| Assert.True(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Equal(42, value);| Assert.False(dictionary.TryGetValue(\"Goodbye World\", out value));| Assert.Null(value);| var copyToArray = new KeyValuePair<object, object>[1];| dictionary.CopyTo(copyToArray, 0);| Assert.Equal(\"Hello World\", copyToArray[0].Key);| Assert.Equal(42, copyToArray[0].Value);| var copyToValuesArray = new object[1];| dictionary.Values.CopyTo(copyToValuesArray, 0);| Assert.Equal(42, copyToValuesArray[0]);| var copyToKeysArray = new object[1];| dictionary.Keys.CopyTo(copyToKeysArray, 0);| Assert.Equal(\"Hello World\", copyToKeysArray[0]);| dictionary.Clear();| Assert.Empty(dictionary);| }"
      },
      {
        "name": "MultiItemPropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[] { new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal) });| IDictionary<object, object> dictionary = logEvent.Properties;| dictionary[\"Goodbye World\"] = 666;| Assert.Equal(2, dictionary.Count);| int i = 0;| foreach (var item in dictionary)| {| switch (i++)| {| case 0:| Assert.Equal(\"Hello World\", item.Key);| Assert.Equal(42, item.Value);| break;| case 1:| Assert.Equal(\"Goodbye World\", item.Key);| Assert.Equal(666, item.Value);| break;| }| }| Assert.Equal(2, i);| i = 0;| foreach (var item in dictionary.Keys)| {| switch (i++)| {| case 0:| Assert.Equal(\"Hello World\", item);| break;| case 1:| Assert.Equal(\"Goodbye World\", item);| break;| }| }| Assert.Equal(2, i);| i = 0;| foreach (var item in dictionary.Values)| {| switch (i++)| {| case 0:| Assert.Equal(42, item);| break;| case 1:| Assert.Equal(666, item);| break;| }| }| Assert.True(dictionary.ContainsKey(\"Hello World\"));| AssertContainsInDictionary(dictionary, \"Hello World\", 42);| Assert.True(dictionary.Keys.Contains(\"Hello World\"));| Assert.True(dictionary.Values.Contains(42));| Assert.True(dictionary.ContainsKey(\"Goodbye World\"));| AssertContainsInDictionary(dictionary, \"Goodbye World\", 666);| Assert.True(dictionary.Keys.Contains(\"Goodbye World\"));| Assert.True(dictionary.Values.Contains(666));| Assert.False(dictionary.Keys.Contains(\"Mad World\"));| Assert.False(dictionary.ContainsKey(\"Mad World\"));| object value;| Assert.True(dictionary.TryGetValue(\"Hello World\", out value));| Assert.Equal(42, value);| Assert.True(dictionary.TryGetValue(\"Goodbye World\", out value));| Assert.Equal(666, value);| Assert.False(dictionary.TryGetValue(\"Mad World\", out value));| Assert.Null(value);| var copyToArray = new KeyValuePair<object, object>[2];| dictionary.CopyTo(copyToArray, 0);| Assert.Contains(new KeyValuePair<object, object>(\"Hello World\", 42), copyToArray);| Assert.Contains(new KeyValuePair<object, object>(\"Goodbye World\", 666), copyToArray);| var copyToValuesArray = new object[2];| dictionary.Values.CopyTo(copyToValuesArray, 0);| Assert.Contains(42, copyToValuesArray);| Assert.Contains(666, copyToValuesArray);| var copyToKeysArray = new object[2];| dictionary.Keys.CopyTo(copyToKeysArray, 0);| Assert.Contains(\"Hello World\", copyToKeysArray);| Assert.Contains(\"Goodbye World\", copyToKeysArray);| Assert.True(dictionary.Remove(\"Goodbye World\"));| Assert.Single(dictionary);| dictionary[\"Goodbye World\"] = 666;| Assert.Equal(2, dictionary.Count);| dictionary.Clear();| Assert.Empty(dictionary);| }"
      },
      {
        "name": "OverrideMessagePropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[]| {| new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal),| new MessageTemplateParameter(\"Goodbye World\", 666, null, CaptureType.Normal)| });| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Equal(42, dictionary[\"Hello World\"]);| dictionary[\"Hello World\"] = 999;| Assert.Equal(999, dictionary[\"Hello World\"]);| Assert.True(dictionary.Values.Contains(999));| Assert.True(dictionary.Values.Contains(666));| Assert.False(dictionary.Values.Contains(42));| int i = 0;| foreach (var item in dictionary)| {| switch (i++)| {| case 1:| Assert.Equal(\"Hello World\", item.Key);| Assert.Equal(999, item.Value);| break;| case 0:| Assert.Equal(\"Goodbye World\", item.Key);| Assert.Equal(666, item.Value);| break;| }| }| Assert.Equal(2, i);| i = 0;| foreach (var item in dictionary.Keys)| {| switch (i++)| {| case 1:| Assert.Equal(\"Hello World\", item);| break;| case 0:| Assert.Equal(\"Goodbye World\", item);| break;| }| }| Assert.Equal(2, i);| i = 0;| foreach (var item in dictionary.Values)| {| switch (i++)| {| case 1:| Assert.Equal(999, item);| break;| case 0:| Assert.Equal(666, item);| break;| }| }| dictionary[\"Goodbye World\"] = 42;| i = 0;| foreach (var item in dictionary.Keys)| {| switch (i++)| {| case 0:| Assert.Equal(\"Hello World\", item);| break;| case 1:| Assert.Equal(\"Goodbye World\", item);| break;| }| }| Assert.Equal(2, i);| dictionary.Remove(\"Hello World\");| Assert.Single(dictionary);| dictionary.Remove(\"Goodbye World\");| Assert.Empty(dictionary);| }"
      },
      {
        "name": "NonUniqueMessagePropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[]| {| new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal),| new MessageTemplateParameter(\"Hello World\", 666, null, CaptureType.Normal)| });| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Equal(2, dictionary.Count);| Assert.Equal(42, dictionary[\"Hello World\"]);| Assert.Equal(666, dictionary[\"Hello World_1\"]);| foreach (var property in dictionary)| {| if (property.Value.Equals(42))| Assert.Equal(\"Hello World\", property.Key);| else if (property.Value.Equals(666))| Assert.Equal(\"Hello World_1\", property.Key);| else| Assert.Null(property.Key);| }| }"
      },
      {
        "name": "NonUniqueEventPropertiesDictionary",
        "body": "{| LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[]| {| new KeyValuePair<object,object>(\"Hello World\", 42),| new KeyValuePair<object,object>(\"Hello World\", 666),| });| IDictionary<object, object> dictionary = logEvent.Properties;| Assert.Single(dictionary);| Assert.Equal(666, dictionary[\"Hello World\"]); // Last one wins| }"
      }
    ]
  },
  {
    "file": "PropertyHelperTests.cs",
    "methods": [
      {
        "name": "AssignArrayPropertyFromStringWillResultInNotSupportedExceptionSomeWhereDeep",
        "body": "{| // Arrange| var config = @\"| <nlog throwExceptions='true'>| <targets>| <target name='f' type='File' filename='test.log'>| <layout type='CSVLayout' column='a'>| </layout>| </target>| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='f' />| </rules>| </nlog>\";| // Act| var ex = Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(config));| // Assert| Assert.IsType<NLogConfigurationException>(ex.InnerException);| Assert.IsType<NotSupportedException>(ex.InnerException.InnerException);| Assert.Contains(\"because property of type array and not scalar value\", ex.InnerException.InnerException.Message);| }"
      }
    ]
  },
  {
    "file": "SimpleStringReaderTests.cs",
    "methods": [
      {
        "name": "DebugView_CurrentState_NegativePosition",
        "body": "{| Assert.Throws<IndexOutOfRangeException>(() => new SimpleStringReader(\"abcdef\")| {| Position = -1,| }.CurrentState);| }"
      }
    ]
  },
  {
    "file": "SortHelpersTests.cs",
    "methods": [
      {
        "name": "SingleBucketDictionary_NoBucketTest",
        "body": "{| SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>();| Assert.Empty(dict);| Assert.Empty(dict);| Assert.Equal(0, dict.Count(val => val.Key == \"Bucket1\"));| foreach (var _ in dict)| Assert.False(true);| Assert.Empty(dict.Keys);| foreach (var _ in dict.Keys)| Assert.False(true);| Assert.Empty(dict.Values);| foreach (var _ in dict.Values)| Assert.False(true);| IList<string> bucket;| Assert.False(dict.TryGetValue(\"Bucket1\", out bucket) || bucket != null);| Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);| Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);| Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());| }"
      },
      {
        "name": "SingleBucketDictionary_OneBucketEmptyTest",
        "body": "{| IList<string> bucket = ArrayHelper.Empty<string>();| SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket));| Assert.Single(dict);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket), dict);| Assert.True(dict.ContainsKey(\"Bucket1\"));| Assert.False(dict.ContainsKey(string.Empty));| KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];| dict.CopyTo(copyToResult, 0);| Assert.Equal(\"Bucket1\", copyToResult[0].Key);| Assert.Empty(copyToResult[0].Value);| Assert.Single(dict);| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));| foreach (var item in dict)| {| Assert.Equal(\"Bucket1\", item.Key);| Assert.Empty(item.Value);| }| Assert.Single(dict.Keys);| foreach (var key in dict.Keys)| {| Assert.Equal(\"Bucket1\", key);| }| Assert.Single(dict.Values);| foreach (var val in dict.Values)| {| Assert.Empty(val);| }| Assert.Empty(dict[\"Bucket1\"]);| Assert.True(dict.TryGetValue(\"Bucket1\", out bucket) && bucket.Count == 0);| Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);| Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);| Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());| }"
      },
      {
        "name": "SingleBucketDictionary_OneBucketOneItem",
        "body": "{| IList<string> bucket = new string[] { \"Bucket1Item1\" };| SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket));| Assert.Single(dict);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket), dict);| Assert.True(dict.ContainsKey(\"Bucket1\"));| Assert.False(dict.ContainsKey(string.Empty));| KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];| dict.CopyTo(copyToResult, 0);| Assert.Equal(\"Bucket1\", copyToResult[0].Key);| Assert.Single(copyToResult[0].Value);| Assert.Equal(\"Bucket1Item1\", copyToResult[0].Value[0]);| Assert.Single(dict);| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));| foreach (var item in dict)| {| Assert.Equal(\"Bucket1\", item.Key);| Assert.Single(item.Value);| Assert.Equal(\"Bucket1Item1\", item.Value[0]);| }| Assert.Single(dict.Keys);| foreach (var key in dict.Keys)| {| Assert.Equal(\"Bucket1\", key);| }| Assert.Single(dict.Values);| foreach (var val in dict.Values)| {| Assert.Single(val);| Assert.Equal(\"Bucket1Item1\", val[0]);| }| Assert.Single(dict[\"Bucket1\"]);| Assert.True(dict.TryGetValue(\"Bucket1\", out bucket) && bucket.Count == 1);| Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);| Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);| Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());| }"
      },
      {
        "name": "SingleBucketDictionary_OneBucketTwoItemsTest",
        "body": "{| IList<string> bucket = new string[] { \"Bucket1Item1\", \"Bucket1Item2\" };| SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket));| Assert.Single(dict);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket), dict);| Assert.True(dict.ContainsKey(\"Bucket1\"));| Assert.False(dict.ContainsKey(string.Empty));| KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];| dict.CopyTo(copyToResult, 0);| Assert.Equal(\"Bucket1\", copyToResult[0].Key);| Assert.Equal(2, copyToResult[0].Value.Count);| Assert.Equal(\"Bucket1Item1\", copyToResult[0].Value[0]);| Assert.Equal(\"Bucket1Item2\", copyToResult[0].Value[1]);| Assert.Single(dict);| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));| foreach (var item in dict)| {| Assert.Equal(\"Bucket1\", item.Key);| Assert.Equal(2, item.Value.Count);| Assert.Equal(\"Bucket1Item1\", item.Value[0]);| Assert.Equal(\"Bucket1Item2\", item.Value[1]);| }| Assert.Single(dict.Keys);| foreach (var key in dict.Keys)| {| Assert.Equal(\"Bucket1\", key);| }| Assert.Single(dict.Values);| foreach (var val in dict.Values)| {| Assert.Equal(2, val.Count);| Assert.Equal(\"Bucket1Item1\", val[0]);| Assert.Equal(\"Bucket1Item2\", val[1]);| }| Assert.Equal(2, dict[\"Bucket1\"].Count);| Assert.True(dict.TryGetValue(\"Bucket1\", out bucket) && bucket.Count == 2);| Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);| Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);| Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());| }"
      },
      {
        "name": "SingleBucketDictionary_TwoBucketEmptyTest",
        "body": "{| IList<string> bucket1 = ArrayHelper.Empty<string>();| IList<string> bucket2 = ArrayHelper.Empty<string>();| Dictionary<string, IList<string>> buckets = new Dictionary<string, IList<string>>();| buckets[\"Bucket1\"] = bucket1;| buckets[\"Bucket2\"] = bucket2;| SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(buckets);| Assert.Equal(2, dict.Count);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket1), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket1), dict);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket2\", bucket2), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket2\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket2), dict);| Assert.True(dict.ContainsKey(\"Bucket1\"));| Assert.True(dict.ContainsKey(\"Bucket2\"));| Assert.False(dict.ContainsKey(string.Empty));| KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];| dict.CopyTo(copyToResult, 0);| Assert.Equal(\"Bucket1\", copyToResult[0].Key);| Assert.Equal(\"Bucket2\", copyToResult[1].Key);| Assert.Empty(copyToResult[0].Value);| Assert.Empty(copyToResult[1].Value);| Assert.Equal(2, dict.Count());| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket2\"));| foreach (var item in dict)| {| Assert.True(item.Key == \"Bucket1\" || item.Key == \"Bucket2\");| Assert.Empty(item.Value);| }| Assert.Equal(2, dict.Keys.Count);| foreach (var key in dict.Keys)| {| Assert.True(key == \"Bucket1\" || key == \"Bucket2\");| }| Assert.Equal(2, dict.Values.Count);| foreach (var val in dict.Values)| {| Assert.Empty(val);| }| Assert.Empty(dict[\"Bucket1\"]);| Assert.Empty(dict[\"Bucket2\"]);| Assert.True(dict.TryGetValue(\"Bucket1\", out bucket1) && bucket1.Count == 0);| Assert.True(dict.TryGetValue(\"Bucket2\", out bucket2) && bucket2.Count == 0);| Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());| }"
      },
      {
        "name": "SingleBucketDictionary_TwoBuckettOneItemTest",
        "body": "{| IList<string> bucket1 = new string[] { \"Bucket1Item1\" };| IList<string> bucket2 = new string[] { \"Bucket1Item1\" };| Dictionary<string, IList<string>> buckets = new Dictionary<string, IList<string>>();| buckets[\"Bucket1\"] = bucket1;| buckets[\"Bucket2\"] = bucket2;| SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(buckets);| Assert.Equal(2, dict.Count);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket1), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket1), dict);| Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket2\", bucket2), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket2\", null), dict);| Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket2), dict);| Assert.True(dict.ContainsKey(\"Bucket1\"));| Assert.True(dict.ContainsKey(\"Bucket2\"));| Assert.False(dict.ContainsKey(string.Empty));| KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];| dict.CopyTo(copyToResult, 0);| Assert.Equal(\"Bucket1\", copyToResult[0].Key);| Assert.Equal(\"Bucket2\", copyToResult[1].Key);| Assert.Single(copyToResult[0].Value);| Assert.Single(copyToResult[1].Value);| Assert.Equal(2, dict.Count());| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));| Assert.Equal(1, dict.Count(val => val.Key == \"Bucket2\"));| foreach (var item in dict)| {| Assert.True(item.Key == \"Bucket1\" || item.Key == \"Bucket2\");| Assert.Single(item.Value);| Assert.Equal(\"Bucket1Item1\", item.Value[0]);| }| Assert.Equal(2, dict.Keys.Count);| foreach (var key in dict.Keys)| {| Assert.True(key == \"Bucket1\" || key == \"Bucket2\");| }| Assert.Equal(2, dict.Values.Count);| foreach (var val in dict.Values)| {| Assert.Single(val);| Assert.Equal(\"Bucket1Item1\", val[0]);| }| Assert.Single(dict[\"Bucket1\"]);| Assert.Single(dict[\"Bucket2\"]);| Assert.True(dict.TryGetValue(\"Bucket1\", out bucket1) && bucket1.Count == 1);| Assert.True(dict.TryGetValue(\"Bucket2\", out bucket2) && bucket2.Count == 1);| Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());| }"
      }
    ]
  },
  {
    "file": "StringBuilderPoolTests.cs",
    "methods": [
      {
        "name": "StringBuilderPoolMaxCapacityTest",
        "body": "{| int poolItemCount = 10;| NLog.Internal.StringBuilderPool pool = new NLog.Internal.StringBuilderPool(poolItemCount);| string mediumPayload = new string('A', 40 * 1024);| RecursiveAcquirePoolItems(poolItemCount, pool, mediumPayload, true); // Verify fast-pool + slow-pool must grow| RecursiveAcquirePoolItems(poolItemCount, pool, mediumPayload, false); // Verify fast-pool + slow-pool has kept their capacity| string largePayload = new string('A', 400000);| RecursiveAcquirePoolItems(poolItemCount, pool, largePayload, true);| using (var itemHolder = pool.Acquire())| {| Assert.Equal(0, itemHolder.Item.Length);| Assert.True(largePayload.Length <= itemHolder.Item.Capacity); // Verify fast-pool has kept its capacity| RecursiveAcquirePoolItems(poolItemCount, pool, mediumPayload + \"A\", true); // Verify slow-pool has reset its capacity| }| }"
      }
    ]
  },
  {
    "file": "AllEventPropertiesTests.cs",
    "methods": [
      {
        "name": "AllParametersAreSetToDefault",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| var ev = BuildLogEventWithProperties();| var result = renderer.Render(ev);| Assert.Equal(\"a=1, hello=world, 17=100\", result);| }"
      },
      {
        "name": "CustomSeparator",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| renderer.Separator = \" | \";| var ev = BuildLogEventWithProperties();| var result = renderer.Render(ev);| Assert.Equal(\"a=1 | hello=world | 17=100\", result);| }"
      },
      {
        "name": "CustomFormat",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| renderer.Format = \"[key] is [value]\";| var ev = BuildLogEventWithProperties();| var result = renderer.Render(ev);| Assert.Equal(\"a is 1, hello is world, 17 is 100\", result);| }"
      },
      {
        "name": "NoProperties",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| var ev = new LogEventInfo();| var result = renderer.Render(ev);| Assert.Equal(\"\", result);| }"
      },
      {
        "name": "EventPropertyFormat",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| var ev = new LogEventInfo(LogLevel.Info, null, null, \"{pi:0}\", new object[] { 3.14159265359 });| var result = renderer.Render(ev);| Assert.Equal(\"pi=3\", result);| }"
      },
      {
        "name": "StructuredLoggingProperties",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| var planetProperties = new System.Collections.Generic.Dictionary<string, object>()| {| { \"Name\", \"Earth\" },| { \"PlanetType\", \"Water-world\" },| };| var ev = new LogEventInfo(LogLevel.Info, null, null, \"Hello Planet {@planet}\", new object[] { planetProperties });| var result = renderer.Render(ev);| Assert.Equal(@\"planet=\"\"Name\"\"=\"\"Earth\"\", \"\"PlanetType\"\"=\"\"Water-world\"\"\", result);| }"
      },
      {
        "name": "IncludeScopeProperties",
        "body": "{| var testLayout = new SimpleLayout(\"${all-event-properties:IncludeScopeProperties=true}\");| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = testLayout }).WithAsync();| }).LogFactory;| var ev = new LogEventInfo(LogLevel.Info, null, null, \"{pi:0}\", new object[] { 3.14159265359 });| using (ScopeContext.PushProperty(\"Figure\", \"Circle\"))| {| var logger = logFactory.GetLogger(\"B\");| logger.Debug(ev);| }| var target = logFactory.Configuration.AllTargets.OfType<DebugTarget>().First();| logFactory.Shutdown(); // Flush| var result = target.LastMessage;| Assert.Equal(\"pi=3, Figure=Circle\", result);| }"
      },
      {
        "name": "TestInvalidCustomFormatWithoutKeyPlaceholder",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| var ex = Assert.Throws<ArgumentException>(() => renderer.Format = \"[key is [value]\");| Assert.Equal(\"Invalid format: [key] placeholder is missing.\", ex.Message);| }"
      },
      {
        "name": "TestInvalidCustomFormatWithoutValuePlaceholder",
        "body": "{| var renderer = new AllEventPropertiesLayoutRenderer();| var ex = Assert.Throws<ArgumentException>(() => renderer.Format = \"[key] is [vlue]\");| Assert.Equal(\"Invalid format: [value] placeholder is missing.\", ex.Message);| }"
      },
      {
        "name": "AllEventWithFluent_without_callerInformation",
        "body": "{| //Arrange| LogFactory logFactory = new LogFactory()| .Setup()| .LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = \"${all-event-properties}\" });| })| .LogFactory;| //Act| logFactory.GetCurrentClassLogger()| .WithProperty(\"Test\", \"InfoWrite\")| .WithProperty(\"coolness\", \"200%\")| .WithProperty(\"a\", \"not b\")| .Debug(\"This is a test message '{0}'.\", DateTime.Now.Ticks);| //Assert| logFactory.AssertDebugLastMessage(\"Test=InfoWrite, coolness=200%, a=not b\");| }"
      },
      {
        "name": "WithPropertiesTest",
        "body": "{| //Arrange| LogFactory logFactory = new LogFactory()| .Setup()| .LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = \"${all-event-properties}\" });| })| .LogFactory;| Dictionary<string, object> properties = new Dictionary<string, object>()| {| {\"TestString\", \"myString\" },| {\"TestInt\", 999 }| };| //Act| logFactory.GetCurrentClassLogger()| .WithProperties(properties)| .Debug(\"This is a test message '{0}'.\", DateTime.Now.Ticks);| //Assert| logFactory.AssertDebugLastMessage(\"TestString=myString, TestInt=999\");| }"
      },
      {
        "name": "AllEventWithFluent_with_callerInformation",
        "body": "{| //Arrange| LogFactory logFactory = new LogFactory()| .Setup()| .LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = \"${all-event-properties}${callsite}\" });| })| .LogFactory;| //Act| logFactory.GetCurrentClassLogger()| .WithProperty(\"Test\", \"InfoWrite\")| .WithProperty(\"coolness\", \"200%\")| .WithProperty(\"a\", \"not b\")| .Debug(\"This is a test message '{0}'.\", DateTime.Now.Ticks);| //Assert| logFactory.AssertDebugLastMessageContains(nameof(AllEventWithFluent_with_callerInformation));| logFactory.AssertDebugLastMessageContains(nameof(AllEventPropertiesTests));| }"
      }
    ]
  },
  {
    "file": "AppDomainLayoutRendererTests.cs",
    "methods": [
      {
        "name": "AppDomainTest",
        "body": "{| //example: 0003: NLog.UnitTests| AssertLayoutRendererOutput(\"${appdomain}\", $\"{id:0000}:{friendlyname}\");| }"
      },
      {
        "name": "AppDomainShortFormatTest",
        "body": "{| //example: 03| AssertLayoutRendererOutput(\"${appdomain:format=short}\", $\"{id:00}\");| }"
      },
      {
        "name": "AppDomainTestLongFormatTest",
        "body": "{| //example: 0003: NLog.UnitTests| AssertLayoutRendererOutput(\"${appdomain:format=long}\", $\"{id:0000}:{friendlyname}\");| }"
      },
      {
        "name": "AppDomainTestFriendlyFormatTest",
        "body": "{| //example: NLog.UnitTests| AssertLayoutRendererOutput(\"${appdomain:format=friendly}\", $\"{friendlyname}\");| }"
      },
      {
        "name": "AppDomainCustomFormatTest",
        "body": "{| //example: 0003: NLog.UnitTests| AssertLayoutRendererOutput(\"${appdomain:format={1\\\\}{0\\\\}}\", string.Format(\"{1}{0}\", id, friendlyname));| }"
      }
    ]
  },
  {
    "file": "AppSettingTests.cs",
    "methods": [
      {
        "name": "UseAppSettingTest",
        "body": "{| var configurationManager = new MockConfigurationManager();| const string expected = \"appSettingTestValue\";| configurationManager.AppSettings[\"appSettingTestKey\"] = expected;| var appSettingLayoutRenderer = new AppSettingLayoutRenderer| {| ConfigurationManager = configurationManager,| Item = \"appSettingTestKey\",| };| var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(expected, rendered);| }"
      },
      {
        "name": "AppSettingOverridesDefaultTest",
        "body": "{| var configurationManager = new MockConfigurationManager();| const string expected = \"appSettingTestValue\";| configurationManager.AppSettings[\"appSettingTestKey\"] = expected;| var appSettingLayoutRenderer = new AppSettingLayoutRenderer| {| ConfigurationManager = configurationManager,| Item = \"appSettingTestKey\",| Default = \"UseDefault\",| };| var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(expected, rendered);| }"
      },
      {
        "name": "FallbackToDefaultTest",
        "body": "{| var configurationManager = new MockConfigurationManager();| const string expected = \"UseDefault\";| var appSettingLayoutRenderer = new AppSettingLayoutRenderer| {| ConfigurationManager = configurationManager,| Item = \"notFound\",| Default = \"UseDefault\",| };| var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(expected, rendered);| }"
      },
      {
        "name": "NoAppSettingTest",
        "body": "{| var configurationManager = new MockConfigurationManager();| var appSettingLayoutRenderer = new AppSettingLayoutRenderer| {| ConfigurationManager = configurationManager,| Item = \"notFound\",| };| var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(string.Empty, rendered);| }"
      },
      {
        "name": "UseConnectionStringTest",
        "body": "{| var configurationManager = new MockConfigurationManager();| const string expected = \"Hello Connection\";| configurationManager.ConnectionStrings[\"myConnection\"] = new ConnectionStringSettings() { ConnectionString = expected };| var appSettingLayoutRenderer = new AppSettingLayoutRenderer| {| ConfigurationManager = configurationManager,| Item = \"ConnectionStrings.myConnection\",| };| var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(expected, rendered);| }"
      }
    ]
  },
  {
    "file": "AssemblyVersionTests.cs",
    "methods": [
      {
        "name": "EntryAssemblyVersionTest",
        "body": "{| var assembly = Assembly.GetEntryAssembly();| var assemblyVersion = assembly is null| ? $\"Could not find value for entry assembly and version type {nameof(AssemblyVersionType.Assembly)}\"| : assembly.GetName().Version.ToString();| AssertLayoutRendererOutput(\"${assembly-version}\", assemblyVersion);| }"
      },
      {
        "name": "EntryAssemblyVersionDefaultTest",
        "body": "{| var assembly = Assembly.GetEntryAssembly();| var assemblyVersion = assembly is null| ? \"1.2.3.4\"| : assembly.GetName().Version.ToString();| AssertLayoutRendererOutput(\"${assembly-version:default=1.2.3.4}\", assemblyVersion);| }"
      },
      {
        "name": "AssemblyNameVersionTest",
        "body": "{| AssertLayoutRendererOutput(\"${assembly-version:NLogAutoLoadExtension}\", \"2.0.0.0\");| }"
      },
      {
        "name": "AssemblyNameUnknownVersionTest",
        "body": "{| using (new NoThrowNLogExceptions())| AssertLayoutRendererOutput(\"${assembly-version:FooBar:default=1.2.3.4}\", \"1.2.3.4\");| }"
      },
      {
        "name": "AssemblyNameVersionTypeTest",
        "body": "{| AssertLayoutRendererOutput(\"${assembly-version:name=NLogAutoLoadExtension:type=assembly}\", \"2.0.0.0\");| AssertLayoutRendererOutput(\"${assembly-version:name=NLogAutoLoadExtension:type=file}\", \"2.0.0.1\");| AssertLayoutRendererOutput(\"${assembly-version:name=NLogAutoLoadExtension:type=informational}\", \"2.0.0.2\");| }"
      }
    ]
  },
  {
    "file": "BaseDirTests.cs",
    "methods": [
      {
        "name": "BaseDirTest",
        "body": "{| AssertLayoutRendererOutput(\"${basedir}\", baseDir);| }"
      },
      {
        "name": "BaseDir_FixTempDir_NotRequired",
        "body": "{| AssertLayoutRendererOutput(\"${basedir:fixtempdir=true}\", baseDir);| }"
      },
      {
        "name": "BaseDirCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${basedir:dir=aaa}\", Path.Combine(baseDir, \"aaa\"));| }"
      },
      {
        "name": "BaseDirFileCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${basedir:file=aaa.txt}\", Path.Combine(baseDir, \"aaa.txt\"));| }"
      },
      {
        "name": "BaseDirCurrentProcessTest",
        "body": "{| Layout l = \"${basedir:processdir=true}\";| var dir = l.Render(LogEventInfo.CreateNullEvent());| Assert.NotNull(dir);| Assert.True(Directory.Exists(dir), $\"dir '{dir}' doesn't exists\");| Assert.Equal(Path.GetDirectoryName(CurrentProcessPath), dir);| }"
      },
      {
        "name": "BaseDirDirFileCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${basedir:dir=aaa:file=bbb.txt}\", Path.Combine(baseDir, \"aaa\", \"bbb.txt\"));| }"
      },
      {
        "name": "InjectBaseDirAndCheckConfigPathsTest",
        "body": "{| string fakeBaseDir = @\"y:\\root\\\";| var appEnvironment = new Mocks.AppEnvironmentMock(null, null);| appEnvironment.AppDomainBaseDirectory = fakeBaseDir;| var baseLayoutRenderer = new NLog.LayoutRenderers.BaseDirLayoutRenderer(appEnvironment);| // test1| Assert.Equal(fakeBaseDir, baseLayoutRenderer.Render(LogEventInfo.CreateNullEvent()));| }"
      },
      {
        "name": "BaseDir_FixTempDir_ChoosesProcessDir",
        "body": "{| var tempDir = System.IO.Path.GetTempPath();| var processPath = CurrentProcessPath;| var appEnvironment = new Mocks.AppEnvironmentMock(null, null);| appEnvironment.AppDomainBaseDirectory = tempDir;| appEnvironment.UserTempFilePath = tempDir;| appEnvironment.CurrentProcessFilePath = processPath;| var baseLayoutRenderer = new NLog.LayoutRenderers.BaseDirLayoutRenderer(appEnvironment);| // test1| Assert.Equal(tempDir, baseLayoutRenderer.Render(LogEventInfo.CreateNullEvent()));| // test2| baseLayoutRenderer.FixTempDir = true;| Assert.Equal(Path.GetDirectoryName(processPath), baseLayoutRenderer.Render(LogEventInfo.CreateNullEvent()));| }"
      }
    ]
  },
  {
    "file": "CallSiteFileNameLayoutTests.cs",
    "methods": [
      {
        "name": "ShowFileNameOnlyTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=False}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| var lastMessageArray = lastMessage.Split('|');| Assert.Equal(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);| Assert.Equal(\"msg\", lastMessageArray[1]);| }"
      },
      {
        "name": "CallSiteFileNameNoCaptureStackTraceTest",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-filename:captureStackTrace=False}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Act| logFactory.GetLogger(\"A\").Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\"|msg\");| }"
      },
      {
        "name": "CallSiteFileNameNoCaptureStackTraceWithStackTraceTest",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-filename:captureStackTrace=False}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Act| var logEvent = new LogEventInfo(LogLevel.Info, null, \"msg\");| logEvent.SetStackTrace(new System.Diagnostics.StackTrace(true), 0);| logFactory.GetLogger(\"A\").Log(logEvent);| // Assert| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| var lastMessageArray = lastMessage.Split('|');| Assert.Contains(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);| Assert.Equal(\"msg\", lastMessageArray[1]);| }"
      },
      {
        "name": "ShowFullPathTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=True}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| var lastMessageArray = lastMessage.Split('|');| Assert.Contains(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);| Assert.False(lastMessageArray[0].StartsWith(\"CallSiteFileNameLayoutTests.cs\"));| Assert.True(Path.IsPathRooted(lastMessageArray[0]));| Assert.Equal(\"msg\", lastMessageArray[1]);| }"
      },
      {
        "name": "ShowFileNameOnlyAsyncTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=False}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| AsyncMethod(logFactory).Wait();| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| var lastMessageArray = lastMessage.Split('|');| Assert.Equal(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);| Assert.Equal(\"msg\", lastMessageArray[1]);| }"
      },
      {
        "name": "ShowFullPathAsyncTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=True}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| AsyncMethod(logFactory).Wait();| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| var lastMessageArray = lastMessage.Split('|');| Assert.Contains(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);| Assert.False(lastMessageArray[0].StartsWith(\"CallSiteFileNameLayoutTests.cs\"));| Assert.True(Path.IsPathRooted(lastMessageArray[0]));| Assert.Equal(\"msg\", lastMessageArray[1]);| }"
      }
    ]
  },
  {
    "file": "CallSiteLineNumberTests.cs",
    "methods": [
      {
        "name": "LineNumberOnlyTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-linenumber} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");|#if DEBUG|#line 100000|#endif| logger.Debug(\"msg\");| var linenumber = GetPrevLineNumber();| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| // There's a difference in handling line numbers between .NET and Mono| // We're just interested in checking if it's above 100000| Assert.StartsWith(linenumber.ToString(), lastMessage); // Expect prefix of 10000|#if DEBUG|#line default|#endif| }"
      },
      {
        "name": "LineNumberOnlyAsyncTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-linenumber}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| Func<string> getLastMessage = () => GetDebugLastMessage(\"debug\", logFactory);| logger.Debug(\"msg\");| var lastMessage = getLastMessage();| Assert.NotEqual(0, int.Parse(lastMessage));| WriteMessages(logger, getLastMessage).Wait();| }"
      },
      {
        "name": "LineNumberNoCaptureStackTraceTest",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-linenumber:captureStackTrace=false} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Act| logFactory.GetLogger(\"A\").Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\" msg\");| }"
      },
      {
        "name": "LineNumberNoCaptureStackTraceWithStackTraceTest",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${callsite-linenumber:captureStackTrace=false} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Act| var logEvent = new LogEventInfo(LogLevel.Info, null, \"msg\");| logEvent.SetStackTrace(new System.Diagnostics.StackTrace(true), 0);| logFactory.GetLogger(\"A\").Log(logEvent);| // Assert| logFactory.AssertDebugLastMessageContains(\" msg\");| Assert.NotEqual(\" msg\", GetDebugLastMessage(\"debug\", logFactory));| }"
      }
    ]
  },
  {
    "file": "CounterTests.cs",
    "methods": [
      {
        "name": "DefaultCounterTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${counter} ${counter}' /></targets>| <rules>| <logger name='*' minlevel='Info' writeTo='debug' />| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| logger.Info(\"a\");| AssertDebugLastMessage(\"debug\", \"a 1 1\");| logger.Warn(\"a\");| AssertDebugLastMessage(\"debug\", \"a 2 2\");| logger.Error(\"a\");| AssertDebugLastMessage(\"debug\", \"a 3 3\");| logger.Fatal(\"a\");| AssertDebugLastMessage(\"debug\", \"a 4 4\");| }"
      },
      {
        "name": "LayoutCounterTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${counter:sequence=${event-context:item=context1}} ${counter}' /></targets>| <rules>| <logger name='*' minlevel='Info' writeTo='debug' />| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.WithProperty(\"context1\", \"seq1\").Info(\"a\");| AssertDebugLastMessage(\"debug\", \"a 1 1\");| logger.WithProperty(\"context1\", \"seq1\").Info(\"a\");| AssertDebugLastMessage(\"debug\", \"a 2 2\");| logger.WithProperty(\"context1\", \"seq2\").Info(\"a\");| AssertDebugLastMessage(\"debug\", \"a 1 3\");| logger.WithProperty(\"context1\", \"seq1\").Info(\"a\");| AssertDebugLastMessage(\"debug\", \"a 3 4\");| }"
      },
      {
        "name": "PresetCounterTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${counter:value=1:increment=3} ${counter}' /></targets>| <rules>| <logger name='*' minlevel='Info' writeTo='debug' />| </rules>| </nlog>\");| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"a\");| logger.Info(\"a\");| AssertDebugLastMessage(\"debug\", \"a 1 1\");| logger.Warn(\"a\");| AssertDebugLastMessage(\"debug\", \"a 4 2\");| logger.Error(\"a\");| AssertDebugLastMessage(\"debug\", \"a 7 3\");| logger.Fatal(\"a\");| AssertDebugLastMessage(\"debug\", \"a 10 4\");| }"
      },
      {
        "name": "NamedCounterTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets>| <target name='debug1' type='Debug' layout='${message} ${counter:sequence=aaa}' />| <target name='debug2' type='Debug' layout='${message} ${counter:sequence=bbb}' />| <target name='debug3' type='Debug' layout='${message} ${counter:sequence=aaa}' />| </targets>| <rules>| <logger name='debug1' minlevel='Debug' writeTo='debug1' />| <logger name='debug2' minlevel='Debug' writeTo='debug2' />| <logger name='debug3' minlevel='Debug' writeTo='debug3' />| </rules>| </nlog>\");| LogManager.GetLogger(\"debug1\").Debug(\"a\");| AssertDebugLastMessage(\"debug1\", \"a 1\");| LogManager.GetLogger(\"debug2\").Debug(\"a\");| AssertDebugLastMessage(\"debug2\", \"a 1\");| LogManager.GetLogger(\"debug3\").Debug(\"a\");| AssertDebugLastMessage(\"debug3\", \"a 2\");| }"
      },
      {
        "name": "CounterRawValueTest",
        "body": "{| // Arrange| SimpleLayout l = \"${counter}\";| // Act| var success1 = l.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var value1);| var success2 = l.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var value2);| // Assert| Assert.True(success1, \"success1\");| Assert.True(success2, \"success2\");| Assert.IsType<long>(value1);| Assert.IsType<long>(value2);| Assert.Equal(1L, value1);| Assert.Equal(2L, value2);| }"
      }
    ]
  },
  {
    "file": "CurrentDirTests.cs",
    "methods": [
      {
        "name": "CurrentDirTest",
        "body": "{| AssertLayoutRendererOutput(\"${currentdir}\", _currentDir);| }"
      },
      {
        "name": "CurrentDirCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${currentdir:dir=aaa}\", Path.Combine(_currentDir, \"aaa\"));| }"
      },
      {
        "name": "CurrentDirFileCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${currentdir:file=aaa.txt}\", Path.Combine(_currentDir, \"aaa.txt\"));| }"
      },
      {
        "name": "CurrentDirDirFileCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${currentdir:dir=aaa:file=bbb.txt}\", Path.Combine(_currentDir, \"aaa\", \"bbb.txt\"));| }"
      }
    ]
  },
  {
    "file": "DateTests.cs",
    "methods": [
      {
        "name": "DefaultDateTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${date}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| logFactory.GetLogger(\"d\").Debug(ei);| DateTime dt = DateTime.ParseExact(GetDebugLastMessage(\"debug\", logFactory), \"yyyy/MM/dd HH:mm:ss.fff\", CultureInfo.InvariantCulture);| DateTime now = ei.TimeStamp;| Assert.True(Math.Abs((dt - now).TotalSeconds) < 1);| }"
      },
      {
        "name": "TimeZoneTest",
        "body": "{| var dateLayoutRenderer = new DateLayoutRenderer();| dateLayoutRenderer.Format = \"yyyy-MM-ddTHH:mmK\";| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| var result = dateLayoutRenderer.Render(logEvent);| var offset = TimeZoneInfo.Local;| var offset2 = offset.GetUtcOffset(DateTime.Now);| if (offset2 >= new TimeSpan(0))| {| //+00:00, +01:00 etc| Assert.Contains($\"+{offset2.Hours:D2}:{offset2.Minutes:D2}\", result);| }| else| {| //-01:00, etc| Assert.Contains($\"{offset2.Hours:D2}:{offset2.Minutes:D2}\", result);| }| }"
      },
      {
        "name": "DateFormatExplicitTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${date:format=yyyy-MM-dd}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| logFactory.AssertDebugLastMessage(DateTime.Now.ToString(\"yyyy-MM-dd\"));| }"
      },
      {
        "name": "DateFormatDefaultTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${date:\\thh\\:mm\\:ss:UniversalTime=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var dateTimeUtc = DateTime.UtcNow;| logFactory.GetLogger(\"d\").Log(new LogEventInfo(LogLevel.Info, null, \"Hello\") { TimeStamp = dateTimeUtc });| logFactory.AssertDebugLastMessage(dateTimeUtc.ToString(\"\\thh:mm:ss\", CultureInfo.InvariantCulture));| }"
      },
      {
        "name": "DateFormatInvalidTest",
        "body": "{| Assert.Throws<NLogConfigurationException>(() =>| {| new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwConfigExceptions='true'>| <variable name='logDate' value='${date:format=hh:mm}' />| </nlog>\");| });| }"
      }
    ]
  },
  {
    "file": "DbNullLayoutRendererTests.cs",
    "methods": [
      {
        "name": "TryGetRawValue_emptyEvent_shouldReturnDbNull",
        "body": "{| // Arrange| var renderer = new DbNullLayoutRenderer();| IRawValue rawValueGetter = renderer;| // Act| var result = rawValueGetter.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var resultValue);| // Assert| Assert.Equal(DBNull.Value, resultValue);| Assert.True(result);| }"
      }
    ]
  },
  {
    "file": "DirectorySeparatorLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderTest1",
        "body": "{| // Arrange| var renderer = new DirectorySeparatorLayoutRenderer();| var expected = Path.DirectorySeparatorChar.ToString();| // Act| var result = renderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(expected, result);| }"
      },
      {
        "name": "GetRawValueTest1",
        "body": "{| // Arrange| IRawValue renderer = new DirectorySeparatorLayoutRenderer();| var expected = Path.DirectorySeparatorChar;| // Act| var returnResult = renderer.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var result);| // Assert| Assert.True(returnResult);| Assert.Equal(expected, result);| }"
      }
    ]
  },
  {
    "file": "EnvironmentTests.cs",
    "methods": [
      {
        "name": "EnvironmentTest",
        "body": "{| AssertLayoutRendererOutput(\"${environment:variable=PATH}\", Environment.GetEnvironmentVariable(\"PATH\"));| }"
      },
      {
        "name": "EnvironmentSimpleTest",
        "body": "{| AssertLayoutRendererOutput(\"${environment:PATH}\", Environment.GetEnvironmentVariable(\"PATH\"));| }"
      },
      {
        "name": "Environment_WhenVariableIsLayout_ShouldBeWrittenAsLayout",
        "body": "{| Environment.SetEnvironmentVariable(\"NLOGTEST\", \"${level}\");| AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST}\", \"Info\");| AssertLayoutRendererOutput(\"${environment:NLOGTEST}\", \"Info\");| }"
      },
      {
        "name": "Environment_WhenVariableExists_DoNothing",
        "body": "{| Environment.SetEnvironmentVariable(\"NLOGTEST\", \"ABC1234\");| // Test default value with different variations on variable parameter syntax.| AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST:default=5678}\", \"ABC1234\");| AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=5678}\", \"ABC1234\");| }"
      },
      {
        "name": "Environment_empty",
        "body": "{| using (new NoThrowNLogExceptions())| {| AssertLayoutRendererOutput(\"${environment}\", \"\");| AssertLayoutRendererOutput(\"${environment:noDefault}\", \"\");| }| }"
      },
      {
        "name": "Environment_WhenVariableIsLayoutAndExists_DoNothing",
        "body": "{| Environment.SetEnvironmentVariable(\"NLOGTEST\", \"${level}\");| AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=5678}\", \"Info\");| }"
      },
      {
        "name": "Environment_WhenVariableDoesNotExists_UseDefault",
        "body": "{| if (Environment.GetEnvironmentVariable(\"NLOGTEST\") != null)| {| Environment.SetEnvironmentVariable(\"NLOGTEST\", null);| }| // Test default value with different variations on variable parameter syntax.| AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST:default=1234}\", \"1234\");| AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=5678}\", \"5678\");| }"
      },
      {
        "name": "Environment_WhenDefaultEmpty_EmptyString",
        "body": "{| if (Environment.GetEnvironmentVariable(\"NLOGTEST\") != null)| {| Environment.SetEnvironmentVariable(\"NLOGTEST\", null);| }| // Test default value with different variations on variable parameter syntax.| AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST:default=}\", \"\");| AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=}\", \"\");| }"
      }
    ]
  },
  {
    "file": "EnvironmentUserLayoutRendererTests.cs",
    "methods": [
      {
        "name": "EnvironmentUserTest",
        "body": "{| var userName = Environment.GetEnvironmentVariable(\"USERNAME\");| if (string.IsNullOrEmpty(userName))| userName = Environment.GetEnvironmentVariable(\"USER\") ?? string.Empty;| Layout layout = \"${environment-user}\";| var result = layout.Render(LogEventInfo.CreateNullEvent());| if (!string.IsNullOrEmpty(userName))| {| Assert.Equal(userName, result);| var userDomainName = Environment.GetEnvironmentVariable(\"USERDOMAIN\") ?? string.Empty;| if (!string.IsNullOrEmpty(userDomainName))| {| layout = \"${environment-user:domain=true}\";| result = layout.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(userDomainName + \"\\\\\" + userName, result);| }| }| }"
      }
    ]
  },
  {
    "file": "EventContextTests.cs",
    "methods": [
      {
        "name": "Test1",
        "body": "{| Layout l = \"${event-context:aaa}\";| LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");| // empty| Assert.Equal(\"\", l.Render(lei));| }"
      },
      {
        "name": "Test2",
        "body": "{| Layout l = \"${event-context:aaa}\";| LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");| lei.Properties[\"aaa\"] = \"bbb\";| // empty| Assert.Equal(\"bbb\", l.Render(lei));| }"
      }
    ]
  },
  {
    "file": "EventPropertiesTests.cs",
    "methods": [
      {
        "name": "TestNoProperty",
        "body": "{| Layout layout = \"${event-properties:prop1}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"prop1\", \"bbb\");| // empty| Assert.Equal(\"\", layout.Render(logEvent));| }"
      },
      {
        "name": "TestProperty",
        "body": "{| Layout layout = \"${event-properties:prop1}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = \"bbb\";| Assert.Equal(\"bbb\", layout.Render(logEvent));| }"
      },
      {
        "name": "TestPropertyAlias",
        "body": "{| Layout layout = \"${event-property:prop1}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = \"bbb\";| Assert.Equal(\"bbb\", layout.Render(logEvent));| }"
      },
      {
        "name": "TestNullProperty",
        "body": "{| Layout layout = \"${event-properties:prop1}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = null;| // empty| Assert.Equal(\"\", layout.Render(logEvent));| }"
      },
      {
        "name": "TestPropertyIgnoreCase",
        "body": "{| Layout layout1 = \"${event-property:prop1}\";| Layout layout2 = \"${event-property:Prop1}\";| Layout layout3 = \"${event-property:PROP1}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"PROP1\"] = \"bbb\";| Assert.Equal(\"bbb\", layout1.Render(logEvent));| Assert.Equal(\"bbb\", layout2.Render(logEvent));| Assert.Equal(\"bbb\", layout3.Render(logEvent));| }"
      },
      {
        "name": "TestPropertyCaseSensitive",
        "body": "{| Layout layout1 = \"${event-property:prop1:ignoreCase=false}\";| Layout layout2 = \"${event-property:Prop1:ignoreCase=false}\";| Layout layout3 = \"${event-property:PROP1:ignoreCase=false}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"Prop1\"] = \"aaa\";| logEvent.Properties[\"PROP1\"] = \"bbb\";| Assert.Equal(2, logEvent.Properties.Count);| Assert.Equal(\"aaa\", logEvent.Properties[\"Prop1\"]);| Assert.Equal(\"bbb\", logEvent.Properties[\"PROP1\"]);| Assert.Equal(\"\", layout1.Render(logEvent));| Assert.Equal(\"aaa\", layout2.Render(logEvent));| Assert.Equal(\"bbb\", layout3.Render(logEvent));| }"
      },
      {
        "name": "DateTime",
        "body": "{| Layout layout = \"${event-properties:prop1}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = new DateTime(2020, 2, 21, 23, 1, 0);| Assert.Equal(\"02/21/2020 23:01:00\", layout.Render(logEvent));| }"
      },
      {
        "name": "DateTimeFormat",
        "body": "{| Layout layout = \"${event-properties:prop1:format=yyyy-M-dd}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = new DateTime(2020, 2, 21, 23, 1, 0);| Assert.Equal(\"2020-2-21\", layout.Render(logEvent));| }"
      },
      {
        "name": "DateTimeCulture",
        "body": "{| if (IsLinux())| {| Console.WriteLine(\"[SKIP] EventPropertiesTests.DateTimeCulture because we are running in Travis\");| return;| }| Layout layout = \"${event-properties:prop1:culture=nl-NL}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = new DateTime(2020, 11, 21, 23, 1, 0);| Assert.Equal(\"21-11-2020 23:01:00\", layout.Render(logEvent));| }"
      },
      {
        "name": "JsonFormat",
        "body": "{| Layout layout = \"${event-properties:prop1:format=@}\";| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");| logEvent.Properties[\"prop1\"] = new string[] { \"Hello\", \"World\" };| Assert.Equal(\"[\\\"Hello\\\",\\\"World\\\"]\", layout.Render(logEvent));| }"
      }
    ]
  },
  {
    "file": "ExceptionDataLayoutRendererTests.cs",
    "methods": [
      {
        "name": "ExceptionWithDataItemIsLoggedTest",
        "body": "{| const string exceptionMessage = \"Test exception\";| const string exceptionDataKey = \"testkey\";| const string exceptionDataValue = \"testvalue\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:\" + exceptionDataKey + @\"}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception ex = new ArgumentException(exceptionMessage);| ex.Data.Add(exceptionDataKey, exceptionDataValue);| logFactory.GetCurrentClassLogger().Error(ex, \"msg\");| logFactory.AssertDebugLastMessage(\"debug\", exceptionDataValue);| }"
      },
      {
        "name": "ExceptionWithOutDataIsNotLoggedTest",
        "body": "{| const string exceptionMessage = \"Test exception\";| const string exceptionDataKey = \"testkey\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:\" + exceptionDataKey + @\"}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception ex = new ArgumentException(exceptionMessage);| logFactory.GetCurrentClassLogger().Error(ex, \"msg\");| logFactory.AssertDebugLastMessage(\"\");| }"
      },
      {
        "name": "ExceptionUsingSpecifiedParamLogsProperlyTest",
        "body": "{| const string exceptionMessage = \"I don't like nullref exception!\";| const string exceptionDataKey = \"testkey\";| const string exceptionDataValue = \"testvalue\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:item=\" + exceptionDataKey + @\"}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception ex = new ArgumentException(exceptionMessage);| ex.Data.Add(exceptionDataKey, exceptionDataValue);| logFactory.GetCurrentClassLogger().Error(ex);| logFactory.AssertDebugLastMessage(exceptionDataValue);| }"
      },
      {
        "name": "BadDataForItemResultsInEmptyValueTest",
        "body": "{| const string exceptionMessage = \"I don't like nullref exception!\";| const string exceptionDataKey = \"testkey\";| const string exceptionDataValue = \"testvalue\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:item=@}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception ex = new ArgumentException(exceptionMessage);| ex.Data.Add(exceptionDataKey, exceptionDataValue);| logFactory.GetCurrentClassLogger().Error(ex);| logFactory.AssertDebugLastMessage(\"\");| }"
      },
      {
        "name": "NoDatkeyTest",
        "body": "{| const string exceptionMessage = \"I don't like nullref exception!\";| const string exceptionDataKey = \"testkey\";| const string exceptionDataValue = \"testvalue\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception ex = new ArgumentException(exceptionMessage);| ex.Data.Add(exceptionDataKey, exceptionDataValue);| logFactory.GetCurrentClassLogger().Error(ex);| logFactory.AssertDebugLastMessage(\"\");| }"
      },
      {
        "name": "NoDatkeyUingParamTest",
        "body": "{| const string exceptionMessage = \"I don't like nullref exception!\";| const string exceptionDataKey = \"testkey\";| const string exceptionDataValue = \"testvalue\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:item=}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception ex = new ArgumentException(exceptionMessage);| ex.Data.Add(exceptionDataKey, exceptionDataValue);| logFactory.GetCurrentClassLogger().Error(ex);| logFactory.AssertDebugLastMessage(\"\");| }"
      },
      {
        "name": "BaseExceptionFlippedTest",
        "body": "{| const string exceptionDataKey = \"testkey\";| const string exceptionDataValue = \"testvalue\";| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${exceptiondata:item=\" + exceptionDataKey + @\":BaseException=true}' />| </targets>| <rules>| <logger minlevel='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Exception exceptionToTest;| try| {| try| {| try| {| var except = new ArgumentException(\"Inner Exception\");| except.Data[exceptionDataKey] = exceptionDataValue;| throw except;| }| catch (Exception exception)| {| throw new System.ArgumentException(\"Wrapper1\", exception);| }| }| catch (Exception exception)| {| throw new ApplicationException(\"Wrapper2\", exception);| }| }| catch (Exception ex)| {| exceptionToTest = ex;| }| logFactory.GetCurrentClassLogger().Fatal(exceptionToTest, \"msg\");| logFactory.AssertDebugLastMessage(exceptionDataValue);| }"
      }
    ]
  },
  {
    "file": "FileContentsTests.cs",
    "methods": [
      {
        "name": "FileContentUnicodeTest",
        "body": "{| string content = \"12345\";| string fileName = Guid.NewGuid().ToString(\"N\") + \".txt\";| using (StreamWriter sw = new StreamWriter(fileName, false, Encoding.Unicode))| {| sw.Write(content);| }| AssertLayoutRendererOutput(\"${file-contents:\" + fileName + \":encoding=utf-16}\", content);| File.Delete(fileName);| }"
      },
      {
        "name": "FileContentUTF8Test",
        "body": "{| string content = \"12345\";| string fileName = Guid.NewGuid().ToString(\"N\") + \".txt\";| using (StreamWriter sw = new StreamWriter(fileName, false, Encoding.UTF8))| {| sw.Write(content);| }| AssertLayoutRendererOutput(\"${file-contents:\" + fileName + \":encoding=utf-8}\", content);| File.Delete(fileName);| }"
      },
      {
        "name": "FileContentTest2",
        "body": "{| using (new NoThrowNLogExceptions())| {| AssertLayoutRendererOutput(\"${file-contents:nosuchfile.txt}\", string.Empty);| }| }"
      }
    ]
  },
  {
    "file": "FuncLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RegisterCustomFuncLayoutRendererTest",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().SetupExtensions(ext => ext.RegisterLayoutRenderer<MyFuncLayoutRenderer>(\"the-answer-new\"))| .LoadConfigurationFromXml(@\"<nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' layout= 'TheAnswer=${the-answer-new:Format=D3}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Act| var logger = logFactory.GetCurrentClassLogger();| logger.Debug(\"test1\");| // Assert| AssertDebugLastMessage(\"debug\", \"TheAnswer=042\", logFactory);| }"
      },
      {
        "name": "RegisterCustomFuncLayoutRendererTestOldStyle",
        "body": "{| // Arrange| var funcLayoutRenderer = new MyFuncLayoutRenderer(\"the-answer-new\");| // Act| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterLayoutRenderer(funcLayoutRenderer))| .LoadConfigurationFromXml(@\"<nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' layout= 'TheAnswer=${the-answer-new:Format=D3}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetCurrentClassLogger();| logger.Debug(\"test1\");| // Assert| AssertDebugLastMessage(\"debug\", \"TheAnswer=042\", logFactory);| }"
      }
    ]
  },
  {
    "file": "GDCTests.cs",
    "methods": [
      {
        "name": "GDCTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${gdc:item=myitem} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| GlobalDiagnosticsContext.Set(\"myitem\", \"myvalue\");| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"myvalue a\");| GlobalDiagnosticsContext.Set(\"myitem\", \"value2\");| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"value2 b\");| GlobalDiagnosticsContext.Remove(\"myitem\");| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \" c\");| }"
      },
      {
        "name": "GDCFormatTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${gdc:item=appid:format=@} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| GlobalDiagnosticsContext.Clear();| GlobalDiagnosticsContext.Set(\"appid\", new { AppId = 123 });| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"{\\\"AppId\\\":123} a\");| }"
      },
      {
        "name": "GDCIgnoreCaseTest",
        "body": "{| try| {| string expectedValue = \"Hello\";| GlobalDiagnosticsContext.Clear();| // Act| GlobalDiagnosticsContext.Set(nameof(GDCIgnoreCaseTest), expectedValue);| // Assert| Assert.Equal(expectedValue, GlobalDiagnosticsContext.Get(nameof(GDCIgnoreCaseTest)));| Assert.Equal(expectedValue, GlobalDiagnosticsContext.Get(nameof(GDCIgnoreCaseTest).ToLower()));| }| finally| {| GlobalDiagnosticsContext.Clear();| }| }"
      }
    ]
  },
  {
    "file": "GuidLayoutRendererTest.cs",
    "methods": [
      {
        "name": "GuidTest",
        "body": "{| GuidLayoutRenderer layoutRenderer = new GuidLayoutRenderer();| LogEventInfo logEvent = LogEventInfo.CreateNullEvent();| string newGuid1 = layoutRenderer.Render(logEvent);| string newGuid2 = layoutRenderer.Render(logEvent);| Assert.NotEmpty(newGuid1);| Assert.NotEmpty(newGuid2);| Assert.NotEqual(newGuid1, newGuid2);| }"
      },
      {
        "name": "LogEventGuidTest",
        "body": "{| GuidLayoutRenderer layoutRenderer = new GuidLayoutRenderer() { GeneratedFromLogEvent = true };| LogEventInfo logEvent1 = LogEventInfo.CreateNullEvent();| string newGuid11 = layoutRenderer.Render(logEvent1);| string newGuid12 = layoutRenderer.Render(logEvent1);| Assert.NotEmpty(newGuid11);| Assert.NotEmpty(newGuid12);| Assert.Equal(newGuid11, newGuid12);| LogEventInfo logEvent2 = LogEventInfo.CreateNullEvent();| string newGuid21 = layoutRenderer.Render(logEvent2);| string newGuid22 = layoutRenderer.Render(logEvent2);| Assert.NotEmpty(newGuid21);| Assert.NotEmpty(newGuid22);| Assert.Equal(newGuid21, newGuid22);| Assert.NotEqual(newGuid11, newGuid22);| }"
      }
    ]
  },
  {
    "file": "HostNameLayoutRendererTests.cs",
    "methods": [
      {
        "name": "HostNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${hostname} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Get the actual hostname that the code would use| string h = Environment.GetEnvironmentVariable(\"HOSTNAME\")| ?? System.Net.Dns.GetHostName()| ?? Environment.GetEnvironmentVariable(\"COMPUTERNAME\");| logFactory.GetLogger(\"A\").Debug(\"a log message\");| logFactory.AssertDebugLastMessage(h + \" a log message\");| }"
      }
    ]
  },
  {
    "file": "IdentityTests.cs",
    "methods": [
      {
        "name": "IdentityTest1Async",
        "body": "{| var oldPrincipal = Thread.CurrentPrincipal;| try| {| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<CSharpEventTarget>(\"CSharpEventTarget\"))| .LoadConfigurationFromXml(@\"<?xml version='1.0' encoding='utf-8' ?>|<nlog xmlns='http://www.nlog-project.org/schemas/NLog.xsd'| xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'| internalLogLevel='Debug'| throwExceptions='true' >| <targets async='true'>| <target name='target1' xsi:type='CSharpEventTarget' layout='${identity}' />| </targets>| <rules>| <logger name='*' writeTo='target1' />| </rules>|</nlog>|\").LogFactory;| try| {| var continuationHit = new ManualResetEvent(false);| string rendered = null;| var threadId = CurrentManagedThreadId;| var asyncThreadId = threadId;| LogEventInfo lastLogEvent = null;| var asyncTarget = logFactory.Configuration.FindTargetByName<AsyncTargetWrapper>(\"target1\");| Assert.NotNull(asyncTarget);| var target = asyncTarget.WrappedTarget as CSharpEventTarget;| Assert.NotNull(target);| target.BeforeWrite += (logevent, rendered1, asyncThreadId1) =>| {| //clear in current thread before write| Thread.CurrentPrincipal = new GenericPrincipal(new GenericIdentity(\"ANOTHER user\", \"type\"), null);| };| target.EventWritten += (logevent, rendered1, asyncThreadId1) =>| {| rendered = rendered1;| asyncThreadId = asyncThreadId1;| lastLogEvent = logevent;| continuationHit.Set();| };| Thread.CurrentPrincipal = new GenericPrincipal(new GenericIdentity(\"SOMEDOMAIN\\\\SomeUser\", \"CustomAuth\"), new[] { \"Role1\", \"Role2\" });| var logger = logFactory.GetCurrentClassLogger();| logger.Debug(\"test write\");| Assert.True(continuationHit.WaitOne());| Assert.NotNull(lastLogEvent);| //should be written in another thread.| Assert.NotEqual(threadId, asyncThreadId);| Assert.Equal(\"auth:CustomAuth:SOMEDOMAIN\\\\SomeUser\", rendered);| }| finally| {| logFactory.Shutdown();| }| }| finally| {| InternalLogger.Reset();| Thread.CurrentPrincipal = oldPrincipal;| }| }"
      },
      {
        "name": "IdentityTest2",
        "body": "{| var oldPrincipal = Thread.CurrentPrincipal;| Thread.CurrentPrincipal = new GenericPrincipal(new NotAuthenticatedIdentity(), new[] { \"role1\" });| try| {| var logFactory = new LogFactory().Setup()| .LoadConfigurationFromXml(@\"| <nlog>| <targets><target type='debug' name='debug' layout='${identity}' /></targets>| <rules><logger name='*' writeTo='debug' /></rules>| </nlog>\").LogFactory;| var debugTarget = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| logFactory.GetCurrentClassLogger().Info(\"Test Message\");| Assert.Equal(1, debugTarget.Counter);| Assert.Equal(\"notauth::\", debugTarget.LastMessage);| }| finally| {| Thread.CurrentPrincipal = oldPrincipal;| }| }"
      }
    ]
  },
  {
    "file": "LiteralTests.cs",
    "methods": [
      {
        "name": "LiteralTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='abcd' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"abcd\");| }"
      },
      {
        "name": "LiteralExplicitTextTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${literal:text=a\\=\\:\\}b\\t\\nc\\u003ad}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a=:}b\\t\\nc:d\");| }"
      },
      {
        "name": "LiteralDefaultTextTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${literal:a\\=\\:\\}b\\t\\nc\\u003ad}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a=:}b\\t\\nc:d\");| }"
      }
    ]
  },
  {
    "file": "LocalIpAddressLayoutRendererTests.cs",
    "methods": [
      {
        "name": "LocalIpAddress_CurrentMachine_NotEmpty",
        "body": "{| var ipAddressRenderer = new LocalIpAddressLayoutRenderer();| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| Assert.NotEmpty(result);| }"
      },
      {
        "name": "LocalIpAddress_RendersSuccessfulIp",
        "body": "{| // Arrange| var ipString = \"10.0.1.2\";| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, Mac1)| .WithIp(ipString)| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(ipString, result);| }"
      },
      {
        "name": "LocalIpAddress_OneInterfaceWithMultipleIps_RendersFirstIp",
        "body": "{| // Arrange| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, Mac1)| .WithIp(\"10.0.1.1\")| .WithIp(\"10.0.1.2\")| .WithIp(\"10.0.1.3\")| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(\"10.0.1.1\", result);| }"
      },
      {
        "name": "LocalIpAddress_SkipsLoopback",
        "body": "{| // Arrange| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Loopback, \"F0-E0-D2-C3-B4-A5\")| .WithIp(\"1.2.3.4\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1)| .WithIp(\"10.0.1.2\")| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(\"10.0.1.2\", result);| }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirst",
        "body": "{| // Arrange| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\")| .WithIp(\"10.0.1.1\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1)| .WithIp(\"10.0.1.2\")| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(\"10.0.1.1\", result);| }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstUp",
        "body": "{| // Arrange| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\", OperationalStatus.Dormant)| .WithIp(\"10.0.1.1\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Up)| .WithIp(\"10.0.1.2\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Down)| .WithIp(\"10.0.1.3\", \"10.0.1.0\")| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(\"10.0.1.2\", result);| }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstWithGatewayUp",
        "body": "{| // Arrange| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\", OperationalStatus.Dormant)| .WithIp(\"10.0.1.1\", \"10.0.1.0\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Up)| .WithIp(\"10.0.1.2\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Up)| .WithIp(\"10.0.1.3\", \"10.0.1.0\")| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(\"10.0.1.3\", result);| }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstIpv4",
        "body": "{| // Arrange| var ipString = \"10.0.1.2\";| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\")| .WithIp(\"fe80:0:0:0:200:f8ff:fe21:67cf\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1)| .WithIp(ipString)| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(ipString, result);| }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstIpv6IfRequested",
        "body": "{| // Arrange| var ipv6 = \"fe80::200:f8ff:fe21:67cf\";| var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()| .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\")| .WithIp(\"1.0.10.11\")| .WithInterface(NetworkInterfaceType.Ethernet, Mac1)| .WithIp(ipv6)| .Build();| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock)| { AddressFamily = AddressFamily.InterNetworkV6 };| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(ipv6, result);| }"
      },
      {
        "name": "LocalIpAddress_RetrieverThrowsException_RenderEmptyString",
        "body": "{| var networkInterfaceRetrieverMock = Substitute.For<INetworkInterfaceRetriever>();| networkInterfaceRetrieverMock.AllNetworkInterfaces.Throws(new Exception(\"oops\"));| var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);| // Act| var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());| // Assert| Assert.Equal(string.Empty, result);| }"
      }
    ]
  },
  {
    "file": "LogLevelTests.cs",
    "methods": [
      {
        "name": "LogLevelTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"Debug a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"Info a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"Warn a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"Error a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"Fatal a\");| }"
      },
      {
        "name": "LogLevelUppercaseTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:uppercase=true} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| ILogger logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"DEBUG a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"INFO a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"WARN a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"ERROR a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"FATAL a\");| }"
      },
      {
        "name": "LogLevelSingleCharacterTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=FirstCharacter} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"T a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"D a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"I a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"W a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"E a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"F a\");| }"
      },
      {
        "name": "LogLevelOrdinalTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=Ordinal} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"0 a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"1 a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"2 a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"3 a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"4 a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"5 a\");| }"
      },
      {
        "name": "LogLevelFullNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=FullName} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"Trace a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"Debug a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"Information a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"Warning a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"Error a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"Fatal a\");| }"
      },
      {
        "name": "LogLevelTriLetterTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=TriLetter} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"Trc a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"Dbg a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"Inf a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"Wrn a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"Err a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"Ftl a\");| }"
      },
      {
        "name": "LogLevelGetTypeCodeTest",
        "body": "{| // Arrange| var logLevel = LogLevel.Info;| // Act| var result = Convert.GetTypeCode(logLevel);| // Assert| Assert.Equal(TypeCode.Object, result);| }"
      }
    ]
  },
  {
    "file": "LoggerNameTests.cs",
    "methods": [
      {
        "name": "LoggerNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"A a\");| }"
      },
      {
        "name": "LoggerShortNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger:ShortName=true} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A.B.C\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"C a\");| var renderer = new NLog.LayoutRenderers.LoggerNameLayoutRenderer() { ShortName = true };| var result = renderer.Render(new LogEventInfo() { LoggerName = logger.Name });| Assert.Equal(\"C\", result);| }"
      },
      {
        "name": "LoggerShortNameTest2",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger:ShortName=true} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"C\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"C a\");| var renderer = new NLog.LayoutRenderers.LoggerNameLayoutRenderer() { ShortName = true };| var result = renderer.Render(new LogEventInfo() { LoggerName = logger.Name });| Assert.Equal(\"C\", result);| }"
      },
      {
        "name": "LoggerShortNameTest_false",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger:ShortName=false} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A.B.C\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"A.B.C a\");| }"
      },
      {
        "name": "LoggerPrefixNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger:PrefixName=true} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A.B.C\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"A.B a\");| var layout = new SimpleLayout(\"${logger:PrefixName=true}\");| var result = layout.Render(new LogEventInfo() { LoggerName = logger.Name });| Assert.Equal(\"A.B\", result);| }"
      },
      {
        "name": "LoggerPrefixNameTest2",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger:PrefixName=true} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"C\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"C a\");| var layout = new SimpleLayout(\"${logger:PrefixName=true}\");| var result = layout.Render(new LogEventInfo() { LoggerName = logger.Name });| Assert.Equal(\"C\", result);| }"
      }
    ]
  },
  {
    "file": "LongDateTests.cs",
    "methods": [
      {
        "name": "LongDateTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${longdate}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| string date = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(24, date.Length);| Assert.Equal('-', date[4]);| Assert.Equal('-', date[7]);| Assert.Equal(' ', date[10]);| Assert.Equal(':', date[13]);| Assert.Equal(':', date[16]);| Assert.Equal('.', date[19]);| }"
      },
      {
        "name": "UniversalTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateLocalTimeSource();| var dt = new LongDateLayoutRenderer();| dt.UniversalTime = true;| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(ei.TimeStamp.ToUniversalTime().ToString(\"yyyy-MM-dd HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "LongDateTryGetRawValue",
        "body": "{| // Arrange| SimpleLayout l = \"${longdate:UniversalTime=true}\";| var timestamp = DateTime.Now;| var logEventInfo = LogEventInfo.CreateNullEvent();| logEventInfo.TimeStamp = timestamp;| // Act| var success = l.TryGetRawValue(logEventInfo, out var value);| // Assert| Assert.True(success, \"success\");| Assert.IsType<DateTime>(value);| Assert.Equal(timestamp.ToUniversalTime(), (DateTime)value);| }"
      },
      {
        "name": "LocalTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();| var dt = new LongDateLayoutRenderer();| dt.UniversalTime = false;| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(ei.TimeStamp.ToLocalTime().ToString(\"yyyy-MM-dd HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "DefaultTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();| var dt = new LongDateLayoutRenderer();| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(ei.TimeStamp.ToString(\"yyyy-MM-dd HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "LongDateWithPaddingPadLeftAlignLeft",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${longdate:padding=5:fixedlength=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| string date = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(5, date.Length);| Assert.Equal('-', date[4]);| }"
      },
      {
        "name": "LongDateWithPaddingPadLeftAlignRight",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${longdate:padding=5:fixedlength=true:alignmentOnTruncation=right}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| string date = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(5, date.Length);| Assert.Equal('.', date[0]);| }"
      },
      {
        "name": "LongDateWithPaddingPadRightAlignLeft",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${longdate:padding=-5:fixedlength=true:alignmentOnTruncation=left}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| string date = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(5, date.Length);| Assert.Equal('-', date[4]);| }"
      },
      {
        "name": "LongDateWithPaddingPadRightAlignRight",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${longdate:padding=-5:fixedlength=true:alignmentOnTruncation=right}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| string date = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(5, date.Length);| Assert.Equal('.', date[0]);| }"
      }
    ]
  },
  {
    "file": "MDCTests.cs",
    "methods": [
      {
        "name": "MDCTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${mdc:item=myitem} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| MappedDiagnosticsContext.Clear();| MappedDiagnosticsContext.Set(\"myitem\", \"myvalue\");| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"myvalue a\");| MappedDiagnosticsContext.Set(\"myitem\", \"value2\");| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"value2 b\");| MappedDiagnosticsContext.Remove(\"myitem\");| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \" c\");| }"
      },
      {
        "name": "MDCFormatTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${mdc:item=myitem:format=@} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| MappedDiagnosticsContext.Clear();| MappedDiagnosticsContext.Set(\"myitem\", new { RequestId = 123 });| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"{\\\"RequestId\\\":123} a\");| }"
      }
    ]
  },
  {
    "file": "MdlcLayoutRendererTests.cs",
    "methods": [
      {
        "name": "MdlcLayoutFormatTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${mdlc:item=myitem:format=@} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| MappedDiagnosticsLogicalContext.Clear();| MappedDiagnosticsLogicalContext.Set(\"myitem\", new { RequestId = 123 });| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"{\\\"RequestId\\\":123} a\");| MappedDiagnosticsLogicalContext.Clear();| }"
      },
      {
        "name": "given_item_does_not_exist_when_rendering_item_and_message_should_render_only_message",
        "body": "{| const string message = \"message\";| LogManager.GetLogger(\"A\").Debug(message);| Assert.Equal(message, _target.LastMessage);| }"
      },
      {
        "name": "given_item_exists_when_rendering_item_and_message_should_render_item_and_message",
        "body": "{| const string message = \"message\";| const string key = \"myitem\";| const string item = \"item\";| MappedDiagnosticsLogicalContext.Set(key, item);| LogManager.GetLogger(\"A\").Debug(message);| Assert.Equal(item + message, _target.LastMessage);| }"
      }
    ]
  },
  {
    "file": "MessageTests.cs",
    "methods": [
      {
        "name": "MessageWithoutPaddingTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\"a1\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\"a01/01/2005 00:00:00\");| }"
      },
      {
        "name": "MessageRightPaddingTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:padding=3}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\" a\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\" a1\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\"a01/01/2005 00:00:00\");| }"
      },
      {
        "name": "MessageFixedLengthRightPaddingLeftAlignmentTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:padding=3:fixedlength=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\" a\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\" a1\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\"a01\");| }"
      },
      {
        "name": "MessageFixedLengthRightPaddingRightAlignmentTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:padding=3:fixedlength=true:alignmentOnTruncation=right}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\" a\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\" a1\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\":00\");| }"
      },
      {
        "name": "MessageLeftPaddingTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:padding=-3:padcharacter=x}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"axx\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\"a1x\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\"a01/01/2005 00:00:00\");| }"
      },
      {
        "name": "MessageFixedLengthLeftPaddingLeftAlignmentTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:padding=-3:padcharacter=x:fixedlength=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"axx\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\"a1x\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\"a01\");| }"
      },
      {
        "name": "MessageFixedLengthLeftPaddingRightAlignmentTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:padding=-3:padcharacter=x:fixedlength=true:alignmentOnTruncation=right}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"axx\");| logger.Debug(\"a{0}\", 1);| logFactory.AssertDebugLastMessage(\"a1x\");| logger.Debug(\"a{0}{1}\", 1, \"2\");| logFactory.AssertDebugLastMessage(\"a12\");| logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));| logFactory.AssertDebugLastMessage(\":00\");| }"
      },
      {
        "name": "MessageWithExceptionAndCustomSeparatorTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message:withException=true:exceptionSeparator=,}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| var ex = new InvalidOperationException(\"Exception message.\");|#if !NET35| logger.Debug(new AggregateException(ex), \"Foo\");|#else| logger.Debug(ex, \"Foo\");|#endif| logFactory.AssertDebugLastMessage(\"Foo,\" + ex.ToString());| logger.Debug(ex);| logFactory.AssertDebugLastMessage(ex.ToString());| }"
      },
      {
        "name": "SingleParameterException_OutputsSingleStackTrace",
        "body": "{| // Arrange| var logTarget = new NLog.Targets.DebugTarget(\"debug\") { Layout = \"${message}|${exception}\" };| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(logTarget);| }).LogFactory;| var logger = logFactory.GetLogger(\"SingleParameterException\");| // Act| try| {| logger.Info(\"Hello\");| Exception argumentException = new ArgumentException(\"Holy Moly\");|#if !NET35| argumentException = new AggregateException(argumentException);|#endif| throw argumentException;| }| catch (Exception ex)| {| logger.Fatal(ex);| }| // Assert| Assert.StartsWith(\"System.ArgumentException: Holy Moly|System.ArgumentException\", logTarget.LastMessage);| }"
      }
    ]
  },
  {
    "file": "NDCTests.cs",
    "methods": [
      {
        "name": "NDCTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndc} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| using (NestedDiagnosticsContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma kota c\");| using (NestedDiagnosticsContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"ala ma kota kopytko d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDCTopTestTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndc:topframes=2} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| using (NestedDiagnosticsContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ma kota c\");| using (NestedDiagnosticsContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"kota kopytko d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ma kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDCTop1TestTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndc:topframes=1} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ma b\");| using (NestedDiagnosticsContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"kota c\");| NestedDiagnosticsContext.Push(\"kopytko\");| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"kopytko d\");| Assert.Equal(\"kopytko\", NestedDiagnosticsContext.Pop()); // manual pop| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());| Assert.Equal(string.Empty, NestedDiagnosticsContext.TopMessage);| NestedDiagnosticsContext.Push(\"zzz\");| Assert.Equal(\"zzz\", NestedDiagnosticsContext.TopMessage);| NestedDiagnosticsContext.Clear();| Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());| Assert.Equal(string.Empty, NestedDiagnosticsContext.TopMessage);| }"
      },
      {
        "name": "NDCBottomTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndc:bottomframes=2} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| using (NestedDiagnosticsContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma c\");| using (NestedDiagnosticsContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"ala ma d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDCSeparatorTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndc:separator=\\:} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala:ma b\");| using (NestedDiagnosticsContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");| using (NestedDiagnosticsContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"ala:ma:kota:kopytko d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala:ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      }
    ]
  },
  {
    "file": "NDLCTests.cs",
    "methods": [
      {
        "name": "NdlcGetAllMessages",
        "body": "{| object value = 5;| NestedDiagnosticsLogicalContext.Clear();| var popper = NestedDiagnosticsLogicalContext.Push(value);| string expected = \"5\";| string[] actual = NestedDiagnosticsLogicalContext.GetAllMessages();| Assert.Single(actual);| Assert.Equal(expected, actual[0]);| popper.Dispose();| actual = NestedDiagnosticsLogicalContext.GetAllMessages();| Assert.Empty(actual);| }"
      },
      {
        "name": "NDLCTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsLogicalContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| using (NestedDiagnosticsLogicalContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma kota c\");| using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"ala ma kota kopytko d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDLCTopTestTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc:topframes=2} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsLogicalContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| using (NestedDiagnosticsLogicalContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ma kota c\");| using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"kota kopytko d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ma kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDLCTop1TestTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc:topframes=1} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsLogicalContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ma b\");| using (NestedDiagnosticsLogicalContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"kota c\");| NestedDiagnosticsLogicalContext.Push(\"kopytko\");| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"kopytko d\");| Assert.Equal(\"kopytko\", NestedDiagnosticsLogicalContext.PopObject()); // manual pop| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| Assert.Null(NestedDiagnosticsLogicalContext.Pop()); //inconsistent with NDC - should be string.empty, but for backwardsscomp. Fix in NLog 5| NestedDiagnosticsLogicalContext.Push(\"zzz\");| NestedDiagnosticsLogicalContext.Push(\"yyy\");| Assert.Equal(\"yyy\", NestedDiagnosticsLogicalContext.Pop());| NestedDiagnosticsLogicalContext.Clear();| Assert.Null(NestedDiagnosticsLogicalContext.Pop()); //inconsistent with NDC - should be string.empty, but for backwardsscomp. Fix in NLog 5| }"
      },
      {
        "name": "NDLCBottomTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc:bottomframes=2} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsLogicalContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| using (NestedDiagnosticsLogicalContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma c\");| using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"ala ma d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala ma c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDLCSeparatorTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc:separator=\\:} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| using (NestedDiagnosticsLogicalContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala:ma b\");| using (NestedDiagnosticsLogicalContext.Push(\"kota\"))| {| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");| using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))| {| LogManager.GetLogger(\"A\").Debug(\"d\");| AssertDebugLastMessage(\"debug\", \"ala:ma:kota:kopytko d\");| }| LogManager.GetLogger(\"A\").Debug(\"c\");| AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");| }| LogManager.GetLogger(\"A\").Debug(\"b\");| AssertDebugLastMessage(\"debug\", \"ala:ma b\");| }| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \" 0\");| }"
      },
      {
        "name": "NDLCDeepTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc:topframes=1} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| for (int i = 1; i <= 100; ++i)| NestedDiagnosticsLogicalContext.Push(i);| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \"100 0\");| NestedDiagnosticsLogicalContext.PopObject();| LogManager.GetLogger(\"A\").Debug(\"1\");| AssertDebugLastMessage(\"debug\", \"99 1\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"2\");| AssertDebugLastMessage(\"debug\", \" 2\");| }"
      },
      {
        "name": "NDLCTimingTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc}|${ndlctiming:CurrentScope=false:ScopeBeginTime=true:Format=yyyy-MM-dd HH\\:mm\\:ss}|${ndlctiming:CurrentScope=false:ScopeBeginTime=false:Format=fff}|${ndlctiming:CurrentScope=true:ScopeBeginTime=true:Format=HH\\:mm\\:ss.fff}|${ndlctiming:CurrentScope=true:ScopeBeginTime=false:Format=fffffff}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| NestedDiagnosticsLogicalContext.Clear();| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \"|||||0\");| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| var measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(6, measurements.Length);| Assert.Equal(\"ala\", measurements[0]);| Assert.InRange(int.Parse(measurements[2]), 0, 999);| Assert.InRange(int.Parse(measurements[4]), 0, 9999999);| Assert.Equal(\"a\", measurements[measurements.Length - 1]);| System.Threading.Thread.Sleep(10);| LogManager.GetLogger(\"A\").Debug(\"b\");| measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(\"ala\", measurements[0]);| Assert.InRange(int.Parse(measurements[2]), 10, 999);| Assert.InRange(int.Parse(measurements[4]), 100000, 9999999);| Assert.Equal(\"b\", measurements[measurements.Length - 1]);| using (NestedDiagnosticsLogicalContext.Push(\"ma\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(6, measurements.Length);| Assert.Equal(\"ala ma\", measurements[0]);| Assert.InRange(int.Parse(measurements[2]), 10, 999);| Assert.InRange(int.Parse(measurements[4]), 0, 9999999);| Assert.Equal(\"a\", measurements[measurements.Length - 1]);| System.Threading.Thread.Sleep(10);| LogManager.GetLogger(\"A\").Debug(\"b\");| measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(6, measurements.Length);| Assert.Equal(\"ala ma\", measurements[0]);| Assert.InRange(int.Parse(measurements[2]), 20, 999);| Assert.InRange(int.Parse(measurements[4]), 100000, 9999999);| Assert.Equal(\"b\", measurements[measurements.Length - 1]);| }| LogManager.GetLogger(\"A\").Debug(\"c\");| measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(\"ala\", measurements[0]);| Assert.InRange(int.Parse(measurements[2]), 20, 999);| Assert.InRange(int.Parse(measurements[4]), 200000, 9999999);| Assert.Equal(\"c\", measurements[measurements.Length - 1]);| }| LogManager.GetLogger(\"A\").Debug(\"0\");| AssertDebugLastMessage(\"debug\", \"|||||0\");| }"
      },
      {
        "name": "NDLCAsyncLogging",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc:separator=\\:} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| System.Threading.Tasks.Task task;| using (NestedDiagnosticsLogicalContext.Push(\"ala\"))| {| LogManager.GetLogger(\"A\").Debug(\"a\");| AssertDebugLastMessage(\"debug\", \"ala a\");| task = System.Threading.Tasks.Task.Run(async () => { await System.Threading.Tasks.Task.Delay(50); LogManager.GetLogger(\"B\").Debug(\"b\"); });| }| task.Wait();| AssertDebugLastMessage(\"debug\", \"ala b\");| }"
      }
    ]
  },
  {
    "file": "NLogDirRendererTests.cs",
    "methods": [
      {
        "name": "RenderNLogDir",
        "body": "{| Layout layout = \"${nlogdir}\";| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| Assert.NotNull(actual);| Assert.True(File.Exists(Path.Combine(actual, \"NLog.dll\")), $\"cannot find NLog.dll in '{actual}'\");| }"
      },
      {
        "name": "RenderNLogDir_with_file_and_dir",
        "body": "{| Layout layout = \"${nlogdir:dir=test:file=file1.txt}\";| Layout nlogdirLayout = \"${nlogdir}\";| var nlogDir = nlogdirLayout.Render(LogEventInfo.CreateNullEvent());| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| Assert.NotNull(actual);| Assert.Equal(Path.Combine(Path.Combine(nlogDir, \"test\" + Path.DirectorySeparatorChar), \"file1.txt\"), actual);| }"
      }
    ]
  },
  {
    "file": "ProcessDirTests.cs",
    "methods": [
      {
        "name": "BaseDirCurrentProcessTest",
        "body": "{| AssertLayoutRendererOutput(\"${processdir}\", _processDir);| }"
      },
      {
        "name": "BaseDirCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${processdir:dir=aaa}\", Path.Combine(_processDir, \"aaa\"));| }"
      },
      {
        "name": "BaseDirFileCombineTest",
        "body": "{| AssertLayoutRendererOutput(\"${processdir:file=aaa.txt}\", Path.Combine(_processDir, \"aaa.txt\"));| }"
      }
    ]
  },
  {
    "file": "ProcessIdLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderProcessIdLayoutRenderer",
        "body": "{| Layout layout = \"${processid}\";| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| int number;| if (!int.TryParse(actual, out number))| {| Assert.Fail(\"processid is not a number\");| }| Assert.True(number > 0, \"processid is not > 0\");| }"
      }
    ]
  },
  {
    "file": "ProcessNameLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderProcessNameLayoutRenderer",
        "body": "{| Layout layout = \"${processname}\";| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| Assert.NotNull(actual);| Assert.True(actual.Length > 0, \"actual.Length > 0\");| var lower = actual.ToLower();| //lowercase| var allowedProcessNames = new List<string> { \"vstest.executionengine\", \"xunit\", \"mono-sgen\", \"dotnet\", \"testhost\", \"testhost.x86\", \"testhost.x64\", \"testhost.net452.x86\", \"testhost.net452.x64\", \"testhost.net461.x86\", \"testhost.net461.x64\" };| Assert.True(allowedProcessNames.Any(p => lower.Contains(p)),| $\"validating processname failed. Please add (if correct) '{actual}' to 'allowedProcessNames'\");| }"
      },
      {
        "name": "RenderProcessNameLayoutRenderer_fullname",
        "body": "{| Layout layout = \"${processname:fullname=true}\";| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| Assert.NotNull(actual);| Assert.True(actual.Length > 0, \"actual.Length > 0\");| Assert.True(File.Exists(actual), \"process not found\");| }"
      }
    ]
  },
  {
    "file": "ProcessTimeLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderProcessTimeLayoutRenderer",
        "body": "{| var layout = \"${processtime}\";| var timestamp = LogEventInfo.ZeroDate;| System.Threading.Thread.Sleep(16);| var logEvent = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");| var time = logEvent.TimeStamp.ToUniversalTime() - timestamp;| var expected = time.ToString(\"hh\\\\:mm\\\\:ss\\\\.fff\");| AssertLayoutRendererOutput(layout, logEvent, expected);| }"
      }
    ]
  },
  {
    "file": "ScopeNestedTests.cs",
    "methods": [
      {
        "name": "ScopeNestedTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(\"ala\"))| {| using (logger.PushScopeNested(\"ma\"))| {| logger.Debug(\"b\");| }| }| // Assert| Assert.Equal(\"ala ma b\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedTopTwoTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:topframes=2} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(\"ala\"))| {| using (logger.PushScopeNested(\"ma\"))| {| using (logger.PushScopeNested(\"kota\"))| {| logger.Debug(\"c\");| }| }| }| // Assert| Assert.Equal(\"ma kota c\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedTopOneTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:topframes=1} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(\"ala\"))| {| using (logger.PushScopeNested(\"ma\"))| {| using (logger.PushScopeNested(\"kota\"))| {| logger.Debug(\"c\");| }| }| }| // Assert| Assert.Equal(\"kota c\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedBottomTwoTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:bottomframes=2} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(\"ala\"))| {| using (logger.PushScopeNested(\"ma\"))| {| using (logger.PushScopeNested(\"kota\"))| {| logger.Debug(\"c\");| }| }| }| // Assert| Assert.Equal(\"ala ma c\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedSeparatorTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:separator=\\:} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(\"ala\"))| {| using (logger.PushScopeNested(\"ma\"))| {| using (logger.PushScopeNested(\"kota\"))| {| logger.Debug(\"c\");| }| }| }| // Assert| Assert.Equal(\"ala:ma:kota c\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedSinglePropertyTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:format=@}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(new[] { new KeyValuePair<string, object>(\"Hello\", \"World\") }))| {| logger.Debug(\"c\");| }| // Assert| Assert.Equal(\"[ { \\\"Hello\\\": \\\"World\\\" } ]\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedTwoPropertiesTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:format=@}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(new Dictionary<string, object>() { { \"Hello\", 42 }, { \"Unlucky\", 13 } }))| {| logger.Debug(\"c\");| }| // Assert| Assert.Equal(\"[ { \\\"Hello\\\": 42, \\\"Unlucky\\\": 13 } ]\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedTwoPropertiesNewlineTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested:format=@:separator=\\n}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(new Dictionary<string, object>() { { \"Hello\", 42 }, { \"Unlucky\", 13 } }))| {| logger.Debug(\"c\");| }| // Assert| Assert.Equal(string.Format(\"[{0}{{{0}\\\"Hello\\\": 42,{0}\\\"Unlucky\\\": 13{0}}}{0}]\", \"\\n\"), target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedBeginScopeProperties",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopenested}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| var scopeProperties = new Dictionary<string, object>() { { \"Hello\", 42 }, { \"Unlucky\", 13 } };| using (ScopeContext.PushNestedState(scopeProperties))| {| logger.Debug(\"c\");| }| // Assert| Assert.Equal(scopeProperties.ToString(), target.LastMessage); // Avoid enumerating properties, since available from ScopeContext-Properties| }"
      },
      {
        "name": "ScopeNestedIndentTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopeindent:_}${scopenested} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeNested(\"ala\"))| {| using (logger.PushScopeNested(\"ma\"))| {| using (logger.PushScopeNested(\"kota\"))| {| logger.Debug(\"c\");| }| }| }| // Assert| Assert.Equal(\"___ala ma kota c\", target.LastMessage);| }"
      },
      {
        "name": "ScopeNestedTimingTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${ndlc}|${scopetiming}|${scopetiming:CurrentScope=false:StartTime=true:Format=yyyy-MM-dd HH\\:mm\\:ss}|${scopetiming:CurrentScope=false:StartTime=false:Format=fff}|${scopetiming:CurrentScope=true:StartTime=true:Format=HH\\:mm\\:ss.fff}|${scopetiming:CurrentScope=true:StartTime=false:Format=fffffff}|${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| logger.Debug(\"0\");| string messageNoScope = target.LastMessage;| string messageFirstScope;| string messageFirstScopeSleep;| string messageFirstScopeExit;| string messageSecondScope;| string messageSecondScopeSleep;| Assert.Equal(\"||||||0\", messageNoScope);| using (logger.PushScopeNested(\"ala\"))| {| logger.Debug(\"a\");| messageFirstScope = target.LastMessage;| System.Threading.Thread.Sleep(10);| logger.Debug(\"b\");| messageFirstScopeSleep = target.LastMessage;| using (logger.PushScopeNested(\"ma\"))| {| logger.Debug(\"a\");| messageSecondScope = target.LastMessage;| System.Threading.Thread.Sleep(10);| logger.Debug(\"b\");| messageSecondScopeSleep = target.LastMessage;| }| logger.Debug(\"c\");| messageFirstScopeExit = target.LastMessage;| }| // Assert| var measurements = messageFirstScope.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(7, measurements.Length);| Assert.Equal(\"ala\", measurements[0]);| Assert.InRange(double.Parse(measurements[1]), 0, 999);| Assert.InRange(int.Parse(measurements[3]), 0, 999);| Assert.InRange(int.Parse(measurements[5]), 0, 9999999);| Assert.Equal(\"a\", measurements[measurements.Length - 1]);| measurements = messageFirstScopeSleep.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(7, measurements.Length);| Assert.Equal(\"ala\", measurements[0]);| Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 10, 999);| Assert.InRange(int.Parse(measurements[3]), 10, 999);| Assert.InRange(int.Parse(measurements[5]), 100000, 9999999);| Assert.Equal(\"b\", measurements[measurements.Length - 1]);| measurements = messageSecondScope.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(7, measurements.Length);| Assert.Equal(\"ala ma\", measurements[0]);| Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 10, 999);| Assert.InRange(int.Parse(measurements[3]), 10, 999);| Assert.InRange(int.Parse(measurements[5]), 0, 9999999);| Assert.Equal(\"a\", measurements[measurements.Length - 1]);| measurements = messageSecondScopeSleep.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(7, measurements.Length);| Assert.Equal(\"ala ma\", measurements[0]);| Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 20, 999);| Assert.InRange(int.Parse(measurements[3]), 20, 999);| Assert.InRange(int.Parse(measurements[5]), 100000, 9999999);| Assert.Equal(\"b\", measurements[measurements.Length - 1]);| measurements = messageFirstScopeExit.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);| Assert.Equal(7, measurements.Length);| Assert.Equal(\"ala\", measurements[0]);| Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 20, 999);| Assert.InRange(int.Parse(measurements[3]), 20, 999);| Assert.InRange(int.Parse(measurements[5]), 200000, 9999999);| Assert.Equal(\"c\", measurements[measurements.Length - 1]);| }"
      }
    ]
  },
  {
    "file": "ScopePropertyTests.cs",
    "methods": [
      {
        "name": "ScopePropertyTest",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopeproperty:item=myitem} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeProperty(\"myitem\", \"myvalue\"))| {| logger.Debug(\"a\");| }| // Assert| Assert.Equal(\"myvalue a\", target.LastMessage);| }"
      },
      {
        "name": "ScopePropertyFormatTests",
        "body": "{| // Arrange| ScopeContext.Clear();| var logFactory = new LogFactory();| logFactory.Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${scopeproperty:item=myitem:format=@} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| var logger = logFactory.GetCurrentClassLogger();| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| // Act| using (logger.PushScopeProperty(\"myitem\", new { RequestId = 123 }))| {| logger.Debug(\"a\");| }| // Assert| Assert.Equal(\"{\\\"RequestId\\\":123} a\", target.LastMessage);| }"
      }
    ]
  },
  {
    "file": "SequenceIdLayoutRendererTest.cs",
    "methods": [
      {
        "name": "RenderSequenceIdLayoutRenderer",
        "body": "{| LogEventInfo logEventInfo = new LogEventInfo();| AssertLayoutRendererOutput(\"${sequenceid}\", logEventInfo, logEventInfo.SequenceID.ToString(CultureInfo.InvariantCulture));| }"
      }
    ]
  },
  {
    "file": "ShortDateTests.cs",
    "methods": [
      {
        "name": "UniversalTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateLocalTimeSource();| var layoutRenderer = new ShortDateLayoutRenderer();| layoutRenderer.UniversalTime = true;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(logEvent.TimeStamp.ToUniversalTime().ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "LocalTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();| var layoutRenderer = new ShortDateLayoutRenderer();| layoutRenderer.UniversalTime = false;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(logEvent.TimeStamp.ToLocalTime().ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "ShortDateTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${shortdate}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| logFactory.GetLogger(\"d\").Debug(logEvent);| logFactory.AssertDebugLastMessage(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "OneDigitMonthTest",
        "body": "{| var layoutRenderer = new ShortDateLayoutRenderer();| layoutRenderer.UniversalTime = false;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| logEvent.TimeStamp = new DateTime(2015, 1, 1);| Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));| }"
      },
      {
        "name": "TwoDigitMonthTest",
        "body": "{| var layoutRenderer = new ShortDateLayoutRenderer();| layoutRenderer.UniversalTime = false;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| logEvent.TimeStamp = new DateTime(2015, 12, 1);| Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));| }"
      },
      {
        "name": "OneDigitDayTest",
        "body": "{| var layoutRenderer = new ShortDateLayoutRenderer();| layoutRenderer.UniversalTime = false;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| logEvent.TimeStamp = new DateTime(2015, 1, 1);| Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));| }"
      },
      {
        "name": "TwoDigitDayTest",
        "body": "{| var layoutRenderer = new ShortDateLayoutRenderer();| layoutRenderer.UniversalTime = false;| var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| logEvent.TimeStamp = new DateTime(2015, 12, 12);| Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));| }"
      }
    ]
  },
  {
    "file": "SpecialFolderTests.cs",
    "methods": [
      {
        "name": "SpecialFolderTest",
        "body": "{| foreach (var specialDirString in Enum.GetNames(typeof(Environment.SpecialFolder)))| {| var folder = (Environment.SpecialFolder)Enum.Parse(typeof(Environment.SpecialFolder), specialDirString);| AssertLayoutRendererOutput($\"${{specialfolder:folder={specialDirString}}}\", Environment.GetFolderPath(folder));| }| }"
      },
      {
        "name": "SpecialFolderDirCombineTest",
        "body": "{| AssertLayoutRendererOutput($\"${{specialfolder:folder={sysDirString}:dir=aaa}}\", Path.Combine(sysDir, \"aaa\"));| }"
      },
      {
        "name": "SpecialFolderFileCombineTest",
        "body": "{| AssertLayoutRendererOutput($\"${{specialfolder:folder={sysDirString}:file=aaa.txt}}\", Path.Combine(sysDir, \"aaa.txt\"));| }"
      },
      {
        "name": "SpecialFolderDirFileCombineTest",
        "body": "{| AssertLayoutRendererOutput($\"${{specialfolder:folder={sysDirString}:dir=aaa:file=bbb.txt}}\", Path.Combine(sysDir, \"aaa\", \"bbb.txt\"));| }"
      },
      {
        "name": "SpecialFolderCommonApplicationDataTest",
        "body": "{| AssertLayoutRendererOutput(\"${CommonApplicationDataDir}\", Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData));| }"
      },
      {
        "name": "SpecialFolderUserApplicationDataTest",
        "body": "{| AssertLayoutRendererOutput(\"${UserApplicationDataDir}\", Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData));| }"
      },
      {
        "name": "SpecialFolderUserLocalApplicationDataTest",
        "body": "{| AssertLayoutRendererOutput(\"${UserLocalApplicationDataDir}\", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));| }"
      }
    ]
  },
  {
    "file": "StackTraceRendererTests.cs",
    "methods": [
      {
        "name": "RenderStackTrace",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\" => StackTraceRendererTests.RenderStackTrace => StackTraceRendererTests.RenderMe\");| }"
      },
      {
        "name": "RenderStackTraceAndCallsite",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace} ${callsite:className=false}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\" => StackTraceRendererTests.RenderStackTraceAndCallsite => StackTraceRendererTests.RenderMe\");| }"
      },
      {
        "name": "RenderStackTraceReversed",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:reverse=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.RenderMe => StackTraceRendererTests.RenderStackTraceReversed => \");| }"
      },
      {
        "name": "RenderStackTraceNoCaptureStackTrace",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:captureStackTrace=false}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessage(\"I am: \");| }"
      },
      {
        "name": "RenderStackTraceNoCaptureStackTraceWithStackTrace",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:captureStackTrace=false}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logEvent = new LogEventInfo(LogLevel.Info, null, \"I am:\");| logEvent.SetStackTrace(new System.Diagnostics.StackTrace(true), 0);| logFactory.GetCurrentClassLogger().Log(logEvent);| logFactory.AssertDebugLastMessageContains($\" => {nameof(StackTraceRendererTests)}.{nameof(RenderStackTraceNoCaptureStackTraceWithStackTrace)}\");| }"
      },
      {
        "name": "RenderStackTrace_topframes",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:topframes=2}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessage(\"I am: StackTraceRendererTests.RenderStackTrace_topframes => StackTraceRendererTests.RenderMe\");| }"
      },
      {
        "name": "RenderStackTrace_skipframes",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:skipframes=1}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\" => StackTraceRendererTests.RenderStackTrace_skipframes\");| }"
      },
      {
        "name": "RenderStackTrace_raw",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=Raw}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\"RenderStackTrace_raw at offset \");| logFactory.AssertDebugLastMessageContains(\"RenderMe at offset \");|#if !MONO| logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.cs\");|#endif| string debugLastMessage = GetDebugLastMessage(\"debug\", logFactory);| int index0 = debugLastMessage.IndexOf(\"RenderStackTraceReversed_raw at offset \");| int index1 = debugLastMessage.IndexOf(\"RenderMe at offset \");| Assert.True(index0 < index1);| }"
      },
      {
        "name": "RenderStackTraceSeperator_raw",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=Raw:separator= \\=&gt; }' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\" => RenderStackTraceSeperator_raw at offset \");| logFactory.AssertDebugLastMessageContains(\" => RenderMe at offset \");|#if !MONO| logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.cs\");|#endif| string debugLastMessage = GetDebugLastMessage(\"debug\", logFactory);| int index0 = debugLastMessage.IndexOf(\" => RenderStackTraceSeperator_raw at offset \");| int index1 = debugLastMessage.IndexOf(\" => RenderMe at offset \");| Assert.True(index0 < index1);| }"
      },
      {
        "name": "RenderStackTraceReversed_raw",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=Raw:reverse=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\"RenderMe at offset \");| logFactory.AssertDebugLastMessageContains(\"RenderStackTraceReversed_raw at offset \");|#if !MONO| logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.cs\");|#endif| string debugLastMessage = GetDebugLastMessage(\"debug\", logFactory);| int index0 = debugLastMessage.IndexOf(\"RenderMe at offset \");| int index1 = debugLastMessage.IndexOf(\"RenderStackTraceReversed_raw at offset \");| Assert.True(index0 < index1);| }"
      },
      {
        "name": "RenderStackTrace_DetailedFlat",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=DetailedFlat}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\" => [Void RenderStackTrace_DetailedFlat()] => [Void RenderMe(NLog.LogFactory, System.String)]\");| }"
      },
      {
        "name": "RenderStackTraceReversed_DetailedFlat",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=DetailedFlat:reverse=true}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| RenderMe(logFactory, \"I am:\");| logFactory.AssertDebugLastMessageContains(\"[Void RenderMe(NLog.LogFactory, System.String)] => [Void RenderStackTraceReversed_DetailedFlat()] => \");| }"
      }
    ]
  },
  {
    "file": "TempDirRendererTests.cs",
    "methods": [
      {
        "name": "RenderTempDir",
        "body": "{| Layout layout = \"${tempdir}\";| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| Assert.NotNull(actual);| Assert.Equal(Path.GetTempPath(), actual);| }"
      },
      {
        "name": "RenderTempDir_with_file_and_dir",
        "body": "{| Layout layout = \"${tempdir:dir=test:file=file1.txt}\";| layout.Initialize(null);| string actual = layout.Render(LogEventInfo.CreateNullEvent());| layout.Close();| Assert.NotNull(actual);| Assert.Equal(Path.Combine(Path.Combine(Path.GetTempPath(), \"test\" + Path.DirectorySeparatorChar), \"file1.txt\"), actual);| }"
      }
    ]
  },
  {
    "file": "ThreadNameTests.cs",
    "methods": [
      {
        "name": "ThreadNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${threadname} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| if (string.IsNullOrEmpty(System.Threading.Thread.CurrentThread.Name))| System.Threading.Thread.CurrentThread.Name = \"mythreadname\";| logFactory.GetLogger(\"A\").Debug(\"a\");| logFactory.AssertDebugLastMessage(System.Threading.Thread.CurrentThread.Name + \" a\");| }"
      }
    ]
  },
  {
    "file": "TicksLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderTicksLayoutRenderer",
        "body": "{| Layout layout = \"${ticks}\";| var logEventInfo = LogEventInfo.Create(LogLevel.Debug, \"logger1\", \"test message\");| var now = DateTime.Now;| logEventInfo.TimeStamp = now;| string actual = layout.Render(logEventInfo);| layout.Close();| Assert.NotNull(actual);| Assert.Equal(actual, now.Ticks.ToString(CultureInfo.InvariantCulture));| }"
      }
    ]
  },
  {
    "file": "TimeTests.cs",
    "methods": [
      {
        "name": "UniversalTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateLocalTimeSource();| var dt = new TimeLayoutRenderer();| dt.UniversalTime = true;| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(ei.TimeStamp.ToUniversalTime().ToString(\"HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "LocalTimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();| var dt = new TimeLayoutRenderer();| dt.UniversalTime = false;| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(ei.TimeStamp.ToLocalTime().ToString(\"HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      },
      {
        "name": "LocalTimeGermanTest",
        "body": "{| var dt = new TimeLayoutRenderer() { Culture = new CultureInfo(\"de-DE\") };| dt.UniversalTime = false;| var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");| Assert.Equal(ei.TimeStamp.ToString(\"HH:mm:ss,ffff\", CultureInfo.InvariantCulture), dt.Render(ei));| }"
      },
      {
        "name": "TimeTest",
        "body": "{| var orgTimeSource = NLog.Time.TimeSource.Current;| try| {| NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${time}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.GetLogger(\"d\").Debug(\"zzz\");| string date = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(13, date.Length);| Assert.Equal(':', date[2]);| Assert.Equal(':', date[5]);| Assert.Equal('.', date[8]);| }| finally| {| NLog.Time.TimeSource.Current = orgTimeSource;| }| }"
      }
    ]
  },
  {
    "file": "VariableLayoutRendererTests.cs",
    "methods": [
      {
        "name": "Var_from_xml",
        "body": "{| // Arrange| var logFactory = CreateConfigFromXml();| var logger = logFactory.GetLogger(\"A\");| // Act| logger.Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\"msg and admin=realgoodpassword\");| Assert.Equal(2, logFactory.Configuration.Variables.Count);| Assert.Equal(2, logFactory.Configuration.Variables.Keys.Count);| Assert.Equal(2, logFactory.Configuration.Variables.Values.Count);| Assert.True(logFactory.Configuration.Variables.ContainsKey(\"uSeR\"));| Assert.True(logFactory.Configuration.Variables.TryGetValue(\"passWORD\", out var _));| }"
      },
      {
        "name": "Var_from_xml_and_edit",
        "body": "{| // Arrange| var logFactory = CreateConfigFromXml();| var logger = logFactory.GetLogger(\"A\");| // Act| logFactory.Configuration.Variables[\"password\"] = \"123\";| logger.Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\"msg and admin=123\");| }"
      },
      {
        "name": "Var_from_xml_and_clear",
        "body": "{| // Arrange| var logFactory = CreateConfigFromXml();| var logger = logFactory.GetLogger(\"A\");| // Act| logFactory.Configuration.Variables.Clear();| logger.Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\"msg and =\");| }"
      },
      {
        "name": "Var_with_layout_renderers",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <variable name='user' value='logger=${logger}' />| <variable name='password' value='realgoodpassword' />| <targets>| <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.Configuration.Variables[\"password\"] = \"123\";| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| var lastMessage = GetDebugLastMessage(\"debug\", logFactory);| Assert.Equal(\"msg and logger=A=123\", lastMessage);| }"
      },
      {
        "name": "Var_Layout_Target_CallSite",
        "body": "{| var logFactory = new LogFactory().Setup()| .LoadConfigurationFromXml(@\"<nlog throwExceptions='true'>| <variable name='myvar' value='${callsite}' />| <targets>| <target name='debug' type='Debug' layout='${var:myvar}' />| </targets>| <rules>| <logger name='*' minLevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| // Act| logFactory.GetCurrentClassLogger().Info(\"Hello\");| // Assert| logFactory.AssertDebugLastMessage(GetType().ToString() + \".\" + nameof(Var_Layout_Target_CallSite));| }"
      },
      {
        "name": "Var_with_other_var",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <variable name='user' value='${var:password}=' />| <variable name='password' value='realgoodpassword' />| <targets>| <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.Configuration.Variables[\"password\"] = \"123\";| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logFactory.AssertDebugLastMessage(\"msg and 123==123\");| }"
      },
      {
        "name": "Var_from_api",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| logFactory.Configuration.Variables[\"user\"] = \"admin\";| logFactory.Configuration.Variables[\"password\"] = \"123\";| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logFactory.AssertDebugLastMessage(\"msg and admin=123\");| }"
      },
      {
        "name": "Var_default",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <variable name='user' value='admin' />| <targets>| <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password:default=unknown}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logFactory.AssertDebugLastMessage(\"msg and admin=unknown\");| }"
      },
      {
        "name": "Var_default_after_clear",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <variable name='user' value='admin' />| <variable name='password' value='realgoodpassword' />| <targets>| <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password:default=unknown}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logFactory.Configuration.Variables.Remove(\"password\");| logger.Debug(\"msg\");| logFactory.AssertDebugLastMessage(\"msg and admin=unknown\");| }"
      },
      {
        "name": "Var_default_after_set_null",
        "body": "{| // Arrange| var logFactory = CreateConfigFromXml();| var logger = logFactory.GetLogger(\"A\");| // Act| logFactory.Configuration.Variables[\"password\"] = null;| logger.Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\"msg and admin=\");| }"
      },
      {
        "name": "Var_default_after_set_emptyString",
        "body": "{| // Arrange| var logFactory = CreateConfigFromXml();| var logger = logFactory.GetLogger(\"A\");| // Act| logFactory.Configuration.Variables[\"password\"] = \"\";| logger.Debug(\"msg\");| // Assert| logFactory.AssertDebugLastMessage(\"msg and admin=\");| }"
      },
      {
        "name": "Var_default_after_xml_emptyString",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <variable name='user' value='admin' />| <variable name='password' value='' />| <targets>| <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logFactory.AssertDebugLastMessage(\"msg and admin=\");| }"
      },
      {
        "name": "null_should_be_ok",
        "body": "{| Layout l = \"${var:var1}\";| var config = new LoggingConfiguration();| config.Variables[\"var1\"] = null;| l.Initialize(config);| var result = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(\"\", result);| }"
      },
      {
        "name": "null_should_not_use_default",
        "body": "{| Layout l = \"${var:var1:default=x}\";| var config = new LoggingConfiguration();| config.Variables[\"var1\"] = null;| l.Initialize(config);| var result = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(\"\", result);| }"
      },
      {
        "name": "notset_should_use_default",
        "body": "{| Layout l = \"${var:var1:default=x}\";| var config = new LoggingConfiguration();| l.Initialize(config);| var result = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(\"x\", result);| }"
      },
      {
        "name": "test_with_mockLogManager",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(new DebugTarget| {| Name = \"Debug\",| Layout = \"${message}|${var:var1:default=x}\"| });| builder.Configuration.Variables[\"var1\"] = \"my-mocking-manager\";| }).LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logFactory.AssertDebugLastMessage(\"msg|my-mocking-manager\");| }"
      }
    ]
  },
  {
    "file": "CachedTests.cs",
    "methods": [
      {
        "name": "CachedLayoutRendererWrapper",
        "body": "{| SimpleLayout l = \"${guid}\";| string s1 = l.Render(LogEventInfo.CreateNullEvent());| string s2 = l.Render(LogEventInfo.CreateNullEvent());| string s3;| // normally GUIDs are never the same| Assert.NotEqual(s1, s2);| // but when you apply ${cached}, the guid will only be generated once| l = \"${cached:${guid}:cached=true}\";| s1 = l.Render(LogEventInfo.CreateNullEvent());| s2 = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(s1, s2);| // calling Close() on Layout Renderer will reset the cached value| l.Renderers[0].Close();| s3 = l.Render(LogEventInfo.CreateNullEvent());| Assert.NotEqual(s2, s3);| // unless we use clearcache=none| l = \"${cached:${guid}:cached=true:clearcache=none}\";| s1 = l.Render(LogEventInfo.CreateNullEvent());| l.Renderers[0].Close();| s2 = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(s1, s2);| // another way to achieve the same thing is using cached=true| l = \"${guid:cached=true}\";| s1 = l.Render(LogEventInfo.CreateNullEvent());| s2 = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(s1, s2);| // another way to achieve the same thing is using cached=true| l = \"${guid:cached=false}\";| s1 = l.Render(LogEventInfo.CreateNullEvent());| s2 = l.Render(LogEventInfo.CreateNullEvent());| Assert.NotEqual(s1, s2);| }"
      },
      {
        "name": "CacheKeyTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='debug' layout='${cached:${guid}:cached=true:cachekey=${var:var1}}' /></targets>| <rules>| <logger name='*' minlevel='debug' appendto='debug'>| </logger>| </rules>| </nlog>\");| LogManager.Configuration.Variables[\"var1\"] = \"a\";| var logger = LogManager.GetLogger(\"A\");| logger.Debug(\"msg\");| var s1 = GetDebugLastMessage(\"debug\");| logger.Debug(\"msg\");| var s2 = GetDebugLastMessage(\"debug\");| Assert.NotEmpty(s1);| Assert.Equal(s1, s2);| //change var will reset cache| LogManager.Configuration.Variables[\"var1\"] = \"b\";| logger.Debug(\"msg\");| var s3 = GetDebugLastMessage(\"debug\");| Assert.NotEmpty(s3);| Assert.NotEqual(s1, s3);| }"
      },
      {
        "name": "CachedSecondsTimeoutTest",
        "body": "{| SimpleLayout l = \"${guid:cachedSeconds=60}\";| var s1 = l.Render(LogEventInfo.CreateNullEvent());| var s2 = l.Render(new LogEventInfo());| Assert.Equal(s1, s2);| var s3 = l.Render(new LogEventInfo() { TimeStamp = NLog.Time.TimeSource.Current.Time.AddMinutes(2) });| Assert.NotEqual(s2, s3);| }"
      }
    ]
  },
  {
    "file": "FileSystemNormalizeTests.cs",
    "methods": [
      {
        "name": "FSNormalizeTest1",
        "body": "{| ScopeContext.PushProperty(\"foo\", \"abc.log\");| SimpleLayout l = \"${filesystem-normalize:${scopeproperty:foo}}\";| Assert.Equal(\"abc.log\", l.Render(LogEventInfo.CreateNullEvent()));| ScopeContext.PushProperty(\"foo\", \"\");| Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));| ScopeContext.PushProperty(\"foo\", \"a/b/c\");| Assert.Equal(\"a_b_c\", l.Render(LogEventInfo.CreateNullEvent()));| // all characters outside of alpha/digits/space/_/./- are replaced with _| ScopeContext.PushProperty(\"foo\", \":\\\\/$@#$%^\");| Assert.Equal(\"_________\", l.Render(LogEventInfo.CreateNullEvent()));| }"
      },
      {
        "name": "FSNormalizeTest2",
        "body": "{| ScopeContext.PushProperty(\"foo\", \"abc.log\");| SimpleLayout l = \"${scopeproperty:foo:fsnormalize=true}\";| Assert.Equal(\"abc.log\", l.Render(LogEventInfo.CreateNullEvent()));| ScopeContext.PushProperty(\"foo\", \"\");| Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));| ScopeContext.PushProperty(\"foo\", \"a/b/c\");| Assert.Equal(\"a_b_c\", l.Render(LogEventInfo.CreateNullEvent()));| // all characters outside of alpha/digits/space/_/./- are replaced with _| ScopeContext.PushProperty(\"foo\", \":\\\\/$@#$%^\");| Assert.Equal(\"_________\", l.Render(LogEventInfo.CreateNullEvent()));| }"
      }
    ]
  },
  {
    "file": "JsonEncodeTests.cs",
    "methods": [
      {
        "name": "JsonEncodeTest1",
        "body": "{| ScopeContext.PushProperty(\"foo\", \" abc\\\"\\n\\b\\r\\f\\t/\\u1234\\u5432\\\\xyz \");| SimpleLayout l = \"${json-encode:${scopeproperty:foo}:escapeForwardSlash=true}\";| Assert.Equal(@\" abc\\\"\"\\n\\b\\r\\f\\t\\/\\u1234\\u5432\\\\xyz \", l.Render(LogEventInfo.CreateNullEvent()));| }"
      },
      {
        "name": "JsonHyperlinkEscapeForwardSlashTest",
        "body": "{| SimpleLayout l = \"${json-encode:${event-properties:prop1}:escapeForwardSlash=false}\";| var url = \"https://localhost:5001/api/values\";| var logEventInfo = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"myMessage\");| logEventInfo.Properties[\"prop1\"] = url;| // Act| var result = l.Render(logEventInfo);| // Assert| Assert.Equal(url, result);| }"
      }
    ]
  },
  {
    "file": "LowerCaseLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderLowerCaseLayoutRenderer",
        "body": "{| Layout layout = \"${message:lowercase=true}\";| layout.Initialize(null);| var logEventInfo = LogEventInfo.CreateNullEvent();| logEventInfo.Message = \"Hello test\";| string actual = layout.Render(logEventInfo);| layout.Close();| Assert.NotNull(actual);| Assert.Equal(\"hello test\", actual);| }"
      },
      {
        "name": "RenderLowerCaseLayoutRenderer_false",
        "body": "{| Layout layout = \"${lowercase:Lowercase=false:inner=${message}}\";| layout.Initialize(null);| var logEventInfo = LogEventInfo.CreateNullEvent();| logEventInfo.Message = \"Hello test\";| string actual = layout.Render(logEventInfo);| layout.Close();| Assert.NotNull(actual);| Assert.Equal(\"Hello test\", actual);| }"
      }
    ]
  },
  {
    "file": "OnExceptionTests.cs",
    "methods": [
      {
        "name": "OnExceptionTest1",
        "body": "{| SimpleLayout l = @\"${message}|${onexception:EXCEPTION\\:${exception:format=message}:else=Success}|${logger}\";| // no exception - ${onexception} is ignored completely| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"message|Success|logger\", l.Render(le));| // have exception| var le2 = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| le2.Exception = new InvalidOperationException(\"ExceptionMessage\");| Assert.Equal(\"message|EXCEPTION:ExceptionMessage|logger\", l.Render(le2));| }"
      }
    ]
  },
  {
    "file": "OnHasPropertiesTests.cs",
    "methods": [
      {
        "name": "OnHasPropertiesValid",
        "body": "{| // Arrange| SimpleLayout l = @\"${message:raw=true}${onhasproperties:, Properties\\: ${all-event-properties}:Else=, No Properties}\";| var logevent = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| logevent.Properties[\"Foo\"] = \"Bar\";| // Act| var result = l.Render(logevent);| // Assert| Assert.Equal(\"message, Properties: Foo=Bar\", result);| }"
      },
      {
        "name": "OnHasPropertiesEmpty",
        "body": "{| // Arrange| SimpleLayout l = @\"${message:raw=true}${onhasproperties: Properties\\:${all-event-properties}}\";| var logevent = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| // Act| var result = l.Render(logevent);| // Assert| Assert.Equal(\"message\", result);| }"
      },
      {
        "name": "OnHasPropertiesElse",
        "body": "{| // Arrange| SimpleLayout l = @\"${message:raw=true}${onhasproperties: Properties\\:${all-event-properties}:else=, No Properties}\";| var logevent = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| // Act| var result = l.Render(logevent);| // Assert| Assert.Equal(\"message, No Properties\", result);| }"
      }
    ]
  },
  {
    "file": "PaddingTests.cs",
    "methods": [
      {
        "name": "PositivePaddingWithLeftAlign",
        "body": "{| SimpleLayout l;| var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");| l = @\"${message:padding=16:alignmentOnTruncation=left}\";| Assert.Equal(\" VeryBigMessage\", l.Render(le));| l = @\"${message:padding=15:alignmentOnTruncation=left}\";| Assert.Equal(\" VeryBigMessage\", l.Render(le));| l = @\"${message:padding=14:alignmentOnTruncation=left}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=13:alignmentOnTruncation=left}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=13:alignmentOnTruncation=left:fixedLength=true}\";| Assert.Equal(\"VeryBigMessag\", l.Render(le));| l = @\"${level:padding=6:alignmentOnTruncation=left}\";| Assert.Equal(\" Info\", l.Render(le));| l = @\"${level:padding=5:alignmentOnTruncation=left}\";| Assert.Equal(\" Info\", l.Render(le));| l = @\"${level:padding=4:alignmentOnTruncation=left}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=3:alignmentOnTruncation=left}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=2:alignmentOnTruncation=left}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=2:fixedLength=true:alignmentOnTruncation=left}\";| Assert.Equal(\"In\", l.Render(le));| l = @\"${level:padding=1:fixedLength=true:alignmentOnTruncation=left}\";| Assert.Equal(\"I\", l.Render(le));| l = @\"${logger:padding=5:alignmentOnTruncation=left}\";| Assert.Equal(\" \", l.Render(le));| }"
      },
      {
        "name": "PositivePaddingWithRightAlign",
        "body": "{| SimpleLayout l;| var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");| l = @\"${message:padding=16:alignmentOnTruncation=right}\";| Assert.Equal(\" VeryBigMessage\", l.Render(le));| l = @\"${message:padding=15:alignmentOnTruncation=right}\";| Assert.Equal(\" VeryBigMessage\", l.Render(le));| l = @\"${message:padding=14:alignmentOnTruncation=right}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=13:alignmentOnTruncation=right}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=13:alignmentOnTruncation=right:fixedLength=true}\";| Assert.Equal(\"eryBigMessage\", l.Render(le));| l = @\"${level:padding=6:alignmentOnTruncation=right}\";| Assert.Equal(\" Info\", l.Render(le));| l = @\"${level:padding=5:alignmentOnTruncation=right}\";| Assert.Equal(\" Info\", l.Render(le));| l = @\"${level:padding=4:alignmentOnTruncation=right}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=3:alignmentOnTruncation=right}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=2:fixedLength=true:alignmentOnTruncation=right}\";| Assert.Equal(\"fo\", l.Render(le));| l = @\"${level:padding=1:fixedLength=true:alignmentOnTruncation=right}\";| Assert.Equal(\"o\", l.Render(le));| l = @\"${logger:padding=5:alignmentOnTruncation=right}\";| Assert.Equal(\" \", l.Render(le));| }"
      },
      {
        "name": "NegativePaddingWithLeftAlign",
        "body": "{| SimpleLayout l;| var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");| l = @\"${message:padding=-16:alignmentOnTruncation=left}\";| Assert.Equal(\"VeryBigMessage \", l.Render(le));| l = @\"${message:padding=-15:alignmentOnTruncation=left}\";| Assert.Equal(\"VeryBigMessage \", l.Render(le));| l = @\"${message:padding=-14:alignmentOnTruncation=left}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=-13:alignmentOnTruncation=left}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=-13:alignmentOnTruncation=left:fixedLength=true}\";| Assert.Equal(\"VeryBigMessag\", l.Render(le));| l = @\"${level:padding=-6:alignmentOnTruncation=left}\";| Assert.Equal(\"Info \", l.Render(le));| l = @\"${level:padding=-5:alignmentOnTruncation=left}\";| Assert.Equal(\"Info \", l.Render(le));| l = @\"${level:padding=-4:alignmentOnTruncation=left}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=-3:alignmentOnTruncation=left}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=-2:alignmentOnTruncation=left}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=-2:fixedLength=true:alignmentOnTruncation=left}\";| Assert.Equal(\"In\", l.Render(le));| l = @\"${level:padding=-1:fixedLength=true:alignmentOnTruncation=left}\";| Assert.Equal(\"I\", l.Render(le));| l = @\"${logger:padding=-5:alignmentOnTruncation=left}\";| Assert.Equal(\" \", l.Render(le));| }"
      },
      {
        "name": "NegativePaddingWithRightAlign",
        "body": "{| SimpleLayout l;| var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");| l = @\"${message:padding=-16:alignmentOnTruncation=right}\";| Assert.Equal(\"VeryBigMessage \", l.Render(le));| l = @\"${message:padding=-15:alignmentOnTruncation=right}\";| Assert.Equal(\"VeryBigMessage \", l.Render(le));| l = @\"${message:padding=-14:alignmentOnTruncation=right}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=-13:alignmentOnTruncation=right}\";| Assert.Equal(\"VeryBigMessage\", l.Render(le));| l = @\"${message:padding=-13:alignmentOnTruncation=right:fixedLength=true}\";| Assert.Equal(\"eryBigMessage\", l.Render(le));| l = @\"${level:padding=-6:alignmentOnTruncation=right}\";| Assert.Equal(\"Info \", l.Render(le));| l = @\"${level:padding=-5:alignmentOnTruncation=right}\";| Assert.Equal(\"Info \", l.Render(le));| l = @\"${level:padding=-4:alignmentOnTruncation=right}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=-3:alignmentOnTruncation=right}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=-2:alignmentOnTruncation=right}\";| Assert.Equal(\"Info\", l.Render(le));| l = @\"${level:padding=-2:fixedLength=true:alignmentOnTruncation=right}\";| Assert.Equal(\"fo\", l.Render(le));| l = @\"${level:padding=-1:fixedLength=true:alignmentOnTruncation=right}\";| Assert.Equal(\"o\", l.Render(le));| l = @\"${logger:padding=-5:alignmentOnTruncation=right}\";| Assert.Equal(\" \", l.Render(le));| }"
      },
      {
        "name": "DefaultAlignmentIsLeft",
        "body": "{| SimpleLayout defaultLayout, leftLayout, rightLayout;| var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");| defaultLayout = @\"${message:padding=5:fixedLength=true}\";| leftLayout = @\"${message:padding=5:fixedLength=true:alignmentOnTruncation=left}\";| rightLayout = @\"${message:padding=5:fixedLength=true:alignmentOnTruncation=right}\";| Assert.Equal(leftLayout.Render(le), defaultLayout.Render(le));| Assert.NotEqual(rightLayout.Render(le), defaultLayout.Render(le));| }"
      }
    ]
  },
  {
    "file": "ReplaceNewLinesTests.cs",
    "methods": [
      {
        "name": "ReplaceNewLineWithDefaultTest",
        "body": "{| // Arrange| var foo = \"bar\" + Environment.NewLine + \"123\";| SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar 123\", result);| }"
      },
      {
        "name": "ReplaceNewLineWithDefaultTestUnix",
        "body": "{| // Arrange| var foo = \"bar\\n123\";| SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar 123\", result);| }"
      },
      {
        "name": "ReplaceNewLineWithDefaultTestWindows",
        "body": "{| // Arrange| var foo = \"bar\\r\\n123\";| SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar 123\", result);| }"
      },
      {
        "name": "ReplaceNewLineWithDefaultTestMixed",
        "body": "{| // Arrange| var foo = \"bar\\r\\n123\\nabc\";| SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar 123 abc\", result);| }"
      },
      {
        "name": "ReplaceNewLineWithSpecifiedSeparationStringTest",
        "body": "{| // Arrange| var foo = \"bar\" + System.Environment.NewLine + \"123\";| SimpleLayout l = \"${replace-newlines:replacement=|:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar|123\", result);| }"
      },
      {
        "name": "ReplaceNewLineOneLineTest",
        "body": "{| // Arrange| var foo = \"bar123\";| SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar123\", result);| }"
      },
      {
        "name": "ReplaceNewLineWithNoEmptySeparationStringTest",
        "body": "{| // Arrange| var foo = \"bar\" + System.Environment.NewLine + \"123\";| SimpleLayout l = \"${replace-newlines:replacement=:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar123\", result);| }"
      },
      {
        "name": "ReplaceNewLineWithNewLineSeparationStringTest",
        "body": "{| // Arrange| var foo = \"bar\\r\\n123\\n\";| SimpleLayout l = \"${replace-newlines:replacement=\\\\r\\\\n:${event-properties:foo}}\";| // Act| var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));| // Assert| Assert.Equal(\"bar\\r\\n123\\r\\n\", result);| }"
      }
    ]
  },
  {
    "file": "ReplaceTests.cs",
    "methods": [
      {
        "name": "ReplaceTestWithoutRegEx",
        "body": "{| // Arrange| SimpleLayout layout = @\"${replace:inner=${message}:searchFor=foo:replaceWith=BAR}\";| // Act| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));| // Assert| Assert.Equal(\" BAR bar bar BAR bar FOO\", result);| }"
      },
      {
        "name": "ReplaceTestIgnoreCaseWithoutRegEx",
        "body": "{| // Arrange| SimpleLayout layout = @\"${replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true}\";| // Act| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));| // Assert| Assert.Equal(\" BAR bar bar BAR bar BAR\", result);| }"
      },
      {
        "name": "ReplaceTestWholeWordsWithoutRegEx",
        "body": "{| // Arrange| SimpleLayout layout = @\"${replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true:WholeWords=true}\";| // Act| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"foo bar bar foobar barfoo bar FOO\"));| // Assert| Assert.Equal(\"BAR bar bar foobar barfoo bar BAR\", result);| }"
      }
    ]
  },
  {
    "file": "Rot13Tests.cs",
    "methods": [
      {
        "name": "Test1",
        "body": "{| Assert.Equal(\"NOPQRSTUVWXYZABCDEFGHIJKLM\",| Rot13LayoutRendererWrapper.DecodeRot13(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));| Assert.Equal(\"nopqrstuvwxyzabcdefghijklm0123456789\",| Rot13LayoutRendererWrapper.DecodeRot13(\"abcdefghijklmnopqrstuvwxyz0123456789\"));| Assert.Equal(\"How can you tell an extrovert from an introvert at NSA? Va gur ryringbef, gur rkgebiregf ybbx ng gur BGURE thl'f fubrf.\",| Rot13LayoutRendererWrapper.DecodeRot13(| \"Ubj pna lbh gryy na rkgebireg sebz na vagebireg ng AFN? In the elevators, the extroverts look at the OTHER guy's shoes.\"));| }"
      },
      {
        "name": "Test2",
        "body": "{| Layout l = \"${rot13:HELLO}\";| LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");| Assert.Equal(\"URYYB\", l.Render(lei));| }"
      },
      {
        "name": "Test3",
        "body": "{| Layout l = \"${rot13:text=HELLO}\";| LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");| Assert.Equal(\"URYYB\", l.Render(lei));| }"
      },
      {
        "name": "Test4",
        "body": "{| Layout l = \"${rot13:${event-context:aaa}}\";| LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");| lei.Properties[\"aaa\"] = \"HELLO\";| Assert.Equal(\"URYYB\", l.Render(lei));| }"
      },
      {
        "name": "Test5",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='debug' type='Debug' layout='${rot13:${mdc:A}}' />| <target name='debug2' type='Debug' layout='${rot13:${rot13:${scopeproperty:A}}}' />| </targets>| <rules>| <logger name='*' levels='Trace' writeTo='debug,debug2' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"NLog.UnitTests.LayoutRenderers.Rot13Tests\");| using (logger.PushScopeProperty(\"A\", \"Foo.Bar!\"))| {| logger.Trace(\"aaa\");| }| logFactory.AssertDebugLastMessage(\"Debug\", \"Sbb.One!\");| // double rot-13 should be identity| logFactory.AssertDebugLastMessage(\"debug2\", \"Foo.Bar!\");| }"
      }
    ]
  },
  {
    "file": "TrimWhiteSpaceTests.cs",
    "methods": [
      {
        "name": "TrimWhiteSpaceTest1",
        "body": "{| ScopeContext.PushProperty(\"foo\", \" bar \");| SimpleLayout l = \"${trim-whitespace:${scopeproperty:foo}}\";| Assert.Equal(\"bar\", l.Render(LogEventInfo.CreateNullEvent()));| ScopeContext.PushProperty(\"foo\", \"\");| Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));| ScopeContext.PushProperty(\"foo\", \" \");| Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));| }"
      }
    ]
  },
  {
    "file": "UpperCaseLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderUpperCaseLayoutRenderer",
        "body": "{| Layout layout = \"${message:uppercase=true}\";| layout.Initialize(null);| var logEventInfo = LogEventInfo.CreateNullEvent();| logEventInfo.Message = \"Hello test\";| string actual = layout.Render(logEventInfo);| layout.Close();| Assert.NotNull(actual);| Assert.Equal(\"HELLO TEST\", actual);| }"
      },
      {
        "name": "RenderUpperCaseLayoutRenderer_false",
        "body": "{| Layout layout = \"${uppercase:uppercase=false:inner=${message}}\";| layout.Initialize(null);| var logEventInfo = LogEventInfo.CreateNullEvent();| logEventInfo.Message = \"Hello test\";| string actual = layout.Render(logEventInfo);| layout.Close();| Assert.NotNull(actual);| Assert.Equal(\"Hello test\", actual);| }"
      }
    ]
  },
  {
    "file": "WhenEmptyTests.cs",
    "methods": [
      {
        "name": "CoalesceTest",
        "body": "{| SimpleLayout l = @\"${message:whenEmpty=<no message>}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"message\", l.Render(le));| // empty log message| var le2 = LogEventInfo.Create(LogLevel.Info, \"logger\", \"\");| Assert.Equal(\"<no message>\", l.Render(le2));| }"
      },
      {
        "name": "CoalesceWithANestedLayout",
        "body": "{| SimpleLayout l = @\"${message:whenEmpty=${logger} emitted empty message}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"message\", l.Render(le));| // empty log message| var le2 = LogEventInfo.Create(LogLevel.Info, \"mylogger\", \"\");| Assert.Equal(\"mylogger emitted empty message\", l.Render(le2));| }"
      },
      {
        "name": "WhenEmpty_MissingInner_ShouldNotThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| SimpleLayout l = @\"${whenEmpty:whenEmpty=${literal:text=c:\\logs\\}:inner=${environment:LOG_DIR_XXX}}api.log\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| LogManager.ThrowExceptions = true;| Assert.Equal(\"api.log\", l.Render(le));| }| }"
      }
    ]
  },
  {
    "file": "WhenTests.cs",
    "methods": [
      {
        "name": "PositiveWhenTest",
        "body": "{| SimpleLayout l = @\"${message:when=logger=='logger'}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"message\", l.Render(le));| }"
      },
      {
        "name": "NegativeWhenTest",
        "body": "{| SimpleLayout l = @\"${message:when=logger=='logger'}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger2\", \"message\");| Assert.Equal(\"\", l.Render(le));| }"
      },
      {
        "name": "ComplexWhenTest",
        "body": "{| // condition is pretty complex here and includes nested layout renderers| // we are testing here that layout parsers property invokes Condition parser to consume the right number of characters| SimpleLayout l = @\"${message:when='${pad:${logger}:padding=10:padCharacter=X}'=='XXXXlogger':padding=-10:padCharacter=Y}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"messageYYY\", l.Render(le));| }"
      },
      {
        "name": "ComplexWhenTest2",
        "body": "{| // condition is pretty complex here and includes nested layout renderers| // we are testing here that layout parsers property invokes Condition parser to consume the right number of characters| SimpleLayout l = @\"${message:padding=-10:padCharacter=Y:when='${pad:${logger}:padding=10:padCharacter=X}'=='XXXXlogger'}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"messageYYY\", l.Render(le));| }"
      },
      {
        "name": "WhenElseCase",
        "body": "{| //else cannot be invoked ambiently. First param is inner| SimpleLayout l = @\"${when:good:when=logger=='logger':else=better}\";| {| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"good\", l.Render(le));| }| {| var le = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message\");| Assert.Equal(\"better\", l.Render(le));| }| }"
      },
      {
        "name": "WhenElseCase_empty_when",
        "body": "{| using (new NoThrowNLogExceptions())| {| //else cannot be invoked ambiently. First param is inner| SimpleLayout l = @\"${when:good:else=better}\";| {| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"good\", l.Render(le));| }| {| var le = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message\");| Assert.Equal(\"good\", l.Render(le));| }| }| }"
      },
      {
        "name": "WhenElseCase_noIf",
        "body": "{| //else cannot be invoked ambiently. First param is inner| SimpleLayout l = @\"${when:when=logger=='logger':else=better}\";| {| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");| Assert.Equal(\"\", l.Render(le));| }| {| var le = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message\");| Assert.Equal(\"better\", l.Render(le));| }| }"
      },
      {
        "name": "WhenLogLevelConditionTestLayoutRenderer",
        "body": "{| //else cannot be invoked ambiently. First param is inner| SimpleLayout l = @\"${when:when=level<=LogLevel.Info:inner=Good:else=Bad}\";| {| var le = LogEventInfo.Create(LogLevel.Debug, \"logger\", \"message\");| Assert.Equal(\"Good\", l.Render(le));| }| {| var le = LogEventInfo.Create(LogLevel.Error, \"logger1\", \"message\");| Assert.Equal(\"Bad\", l.Render(le));| }| }"
      },
      {
        "name": "WhenLogLevelConditionTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets><target name='debug' type='Debug' layout='${level} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug'>| <filters>| <when condition=\"\"level>=LogLevel.Info\"\" action=\"\"Log\"\"></when>| <when condition='true' action='Ignore' />| </filters>| </logger>| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Fatal(\"Test\");| logFactory.AssertDebugLastMessage(\"Fatal Test\");| logger.Error(\"Test\");| logFactory.AssertDebugLastMessage(\"Error Test\");| logger.Warn(\"Test\");| logFactory.AssertDebugLastMessage(\"Warn Test\");| logger.Info(\"Test\");| logFactory.AssertDebugLastMessage(\"Info Test\");| logger.Debug(\"Test\");| logFactory.AssertDebugLastMessage(\"Info Test\");| logger.Trace(\"Test\");| logFactory.AssertDebugLastMessage(\"Info Test\");| }"
      },
      {
        "name": "WhenNumericAndPropertyConditionTest",
        "body": "{| //else cannot be invoked ambiently. First param is inner| SimpleLayout l = @\"${when:when=100 < '${event-properties:item=Elapsed}':inner=Slow:else=Fast}\";| // WhenNumericAndPropertyConditionTest_inner(l, \"a\", false);| WhenNumericAndPropertyConditionTest_inner(l, 101, false);| WhenNumericAndPropertyConditionTest_inner(l, 11, true);| WhenNumericAndPropertyConditionTest_inner(l, 100, true);| WhenNumericAndPropertyConditionTest_inner(l, 1, true);| WhenNumericAndPropertyConditionTest_inner(l, 2, true);| WhenNumericAndPropertyConditionTest_inner(l, 20, true);| WhenNumericAndPropertyConditionTest_inner(l, 100000, false);| }"
      }
    ]
  },
  {
    "file": "WrapLineTests.cs",
    "methods": [
      {
        "name": "WrapLineWithInnerLayoutDefaultTest",
        "body": "{| ScopeContext.PushProperty(\"foo\", \"foobar\");| SimpleLayout le = \"${wrapline:${scopeproperty:foo}:WrapLine=3}\";| Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", le.Render(LogEventInfo.CreateNullEvent()));| }"
      },
      {
        "name": "WrapLineWithInnerLayoutTest",
        "body": "{| ScopeContext.PushProperty(\"foo\", \"foobar\");| SimpleLayout le = \"${wrapline:Inner=${scopeproperty:foo}:WrapLine=3}\";| Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", le.Render(LogEventInfo.CreateNullEvent()));| }"
      },
      {
        "name": "WrapLineAtPositionOnceTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=3}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");| Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", l.Render(le));| }"
      },
      {
        "name": "WrapLineAtPositionOnceTextLengthNotMultipleTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=3}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"fooba\");| Assert.Equal(\"foo\" + System.Environment.NewLine + \"ba\", l.Render(le));| }"
      },
      {
        "name": "WrapLineMultipleTimesTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=3}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobarbaz\");| Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\" + System.Environment.NewLine + \"baz\", l.Render(le));| }"
      },
      {
        "name": "WrapLineMultipleTimesTextLengthNotMultipleTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=3}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobarba\");| Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\" + System.Environment.NewLine + \"ba\", l.Render(le));| }"
      },
      {
        "name": "WrapLineAtPositionAtExactTextLengthTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=6}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");| Assert.Equal(\"foobar\", l.Render(le));| }"
      },
      {
        "name": "WrapLineAtPositionGreaterThanTextLengthTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=10}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");| Assert.Equal(\"foobar\", l.Render(le));| }"
      },
      {
        "name": "WrapLineAtPositionZeroTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=0}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");| Assert.Equal(\"foobar\", l.Render(le));| }"
      },
      {
        "name": "WrapLineAtNegativePositionTest",
        "body": "{| SimpleLayout l = \"${message:wrapline=0}\";| var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");| Assert.Equal(\"foobar\", l.Render(le));| }"
      },
      {
        "name": "WrapLineFromConfig",
        "body": "{| var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"|<nlog throwExceptions='true'>| <targets>| <target name='d1' type='Debug' layout='${message:wrapline=3}' />| </targets>| <rules>| <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />| </rules>|</nlog>\");| var d1 = configuration.FindTargetByName(\"d1\") as DebugTarget;| Assert.NotNull(d1);| var layout = d1.Layout as SimpleLayout;| Assert.NotNull(layout);| var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"foobar\"));| Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", result);| }"
      }
    ]
  },
  {
    "file": "XmlEncodeTests.cs",
    "methods": [
      {
        "name": "XmlEncodeTest1",
        "body": "{| ScopeContext.PushProperty(\"foo\", \" abc<>&'\\\"def \");| SimpleLayout l = \"${xml-encode:${scopeproperty:foo}}\";| Assert.Equal(\" abc&lt;&gt;&amp;&apos;&quot;def \", l.Render(LogEventInfo.CreateNullEvent()));| }"
      }
    ]
  },
  {
    "file": "CompoundLayoutTests.cs",
    "methods": [
      {
        "name": "CodeCompoundLayoutIsRenderedCorrectly",
        "body": "{| var compoundLayout = new CompoundLayout| {| Layouts =| {| new SimpleLayout(\"Long date - ${longdate}\"),| new SimpleLayout(\"|Before| \"),| new JsonLayout| {| Attributes =| {| new JsonAttribute(\"short_date\", \"${shortdate}\"),| new JsonAttribute(\"message\", \"${message}\"),| }| },| new SimpleLayout(\" |After|\"),| new SimpleLayout(\"Last - ${level}\")| }| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 20, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello, world\"| };| const string expected = \"Long date - 2010-01-20 12:34:56.0000|Before| { \\\"short_date\\\": \\\"2010-01-20\\\", \\\"message\\\": \\\"hello, world\\\" } |After|Last - Info\";| var actual = compoundLayout.Render(logEventInfo);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "XmlCompoundLayoutWithVariables",
        "body": "{| const string configXml = @\"|<nlog>| <variable name='jsonLayoutv0.1'>| <layout type='JsonLayout'>| <attribute name='short_date' layout='${shortdate}' />| <attribute name='message' layout='${message}' />| </layout>| </variable>| <variable name='compoundLayoutv0.1'>| <layout type='CompoundLayout'>| <layout type='SimpleLayout' text='|Before| ' />| <layout type='${jsonLayoutv0.1}' />| <layout type='SimpleLayout' text=' |After|' />| </layout>| </variable>| <targets>| <target name='compoundFile1' type='File' fileName='log.txt'>| <layout type='CompoundLayout'>| <layout type='SimpleLayout' text='|Before| ' />| <layout type='${jsonLayoutv0.1}' />| <layout type='SimpleLayout' text=' |After|' />| </layout>| </target>| <target name='compoundFile2' type='file' fileName='other.txt'>| <layout type='${compoundLayoutv0.1}' />| </target>| </targets>| <rules>| </rules>|</nlog>|\";| var config = XmlLoggingConfiguration.CreateFromXmlString(configXml);| Assert.NotNull(config);| var target = config.FindTargetByName<FileTarget>(\"compoundFile1\");| Assert.NotNull(target);| var compoundLayout = target.Layout as CompoundLayout;| Assert.NotNull(compoundLayout);| var layouts = compoundLayout.Layouts;| Assert.Equal(3, layouts.Count);| Assert.Equal(typeof(SimpleLayout), layouts[0].GetType());| Assert.Equal(typeof(JsonLayout), layouts[1].GetType());| Assert.Equal(typeof(SimpleLayout), layouts[2].GetType());| var innerJsonLayout = (JsonLayout)layouts[1];| Assert.Equal(typeof(JsonLayout), innerJsonLayout.GetType());| Assert.Equal(2, innerJsonLayout.Attributes.Count);| Assert.Equal(\"${shortdate}\", innerJsonLayout.Attributes[0].Layout.ToString());| Assert.Equal(\"${message}\", innerJsonLayout.Attributes[1].Layout.ToString());| target = config.FindTargetByName<FileTarget>(\"compoundFile2\");| Assert.NotNull(target);| compoundLayout = target.Layout as CompoundLayout;| Assert.NotNull(compoundLayout);| layouts = compoundLayout.Layouts;| Assert.Equal(3, layouts.Count);| Assert.Equal(typeof(SimpleLayout), layouts[0].GetType());| Assert.Equal(typeof(JsonLayout), layouts[1].GetType());| Assert.Equal(typeof(SimpleLayout), layouts[2].GetType());| innerJsonLayout = (JsonLayout)layouts[1];| Assert.Equal(typeof(JsonLayout), innerJsonLayout.GetType());| Assert.Equal(2, innerJsonLayout.Attributes.Count);| Assert.Equal(\"${shortdate}\", innerJsonLayout.Attributes[0].Layout.ToString());| Assert.Equal(\"${message}\", innerJsonLayout.Attributes[1].Layout.ToString());| }"
      },
      {
        "name": "XmlCompoundLayoutIsRenderedCorrectly",
        "body": "{| const string configXml = @\"|<nlog>| <targets>| <target name='compoundFile' type='File' fileName='log.txt'>| <layout type='CompoundLayout'>| <layout type='SimpleLayout' text='Long date - ${longdate}' />| <layout type='SimpleLayout' text='|Before| ' />| <layout type='JsonLayout'>| <attribute name='short_date' layout='${shortdate}' />| <attribute name='message' layout='${message}' />| </layout>| <layout type='SimpleLayout' text=' |After|' />| <layout type='SimpleLayout' text='Last - ${level}' />| </layout>| </target>| </targets>| <rules>| </rules>|</nlog>|\";| var config = XmlLoggingConfiguration.CreateFromXmlString(configXml);| Assert.NotNull(config);| var target = config.FindTargetByName<FileTarget>(\"compoundFile\");| Assert.NotNull(target);| var compoundLayout = target.Layout as CompoundLayout;| Assert.NotNull(compoundLayout);| var layouts = compoundLayout.Layouts;| Assert.NotNull(layouts);| Assert.Equal(5, layouts.Count);| Assert.Equal(typeof(SimpleLayout), layouts[0].GetType());| Assert.Equal(typeof(SimpleLayout), layouts[1].GetType());| var innerJsonLayout = (JsonLayout)layouts[2];| Assert.Equal(typeof(JsonLayout), innerJsonLayout.GetType());| Assert.Equal(2, innerJsonLayout.Attributes.Count);| Assert.Equal(\"${shortdate}\", innerJsonLayout.Attributes[0].Layout.ToString());| Assert.Equal(\"${message}\", innerJsonLayout.Attributes[1].Layout.ToString());| Assert.Equal(typeof(SimpleLayout), layouts[3].GetType());| Assert.Equal(typeof(SimpleLayout), layouts[4].GetType());| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 20, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello, world\"| };| const string expected = \"Long date - 2010-01-20 12:34:56.0000|Before| { \\\"short_date\\\": \\\"2010-01-20\\\", \\\"message\\\": \\\"hello, world\\\" } |After|Last - Info\";| var actual = compoundLayout.Render(logEventInfo);| Assert.Equal(expected, actual);| }"
      }
    ]
  },
  {
    "file": "CsvLayoutTests.cs",
    "methods": [
      {
        "name": "EndToEndTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='m' type='Memory'>| <layout type='CSVLayout'>| <column name='level' layout='${level}' />| <column name='message' layout='${message}' />| <column name='counter' layout='${counter}' />| <delimiter>Comma</delimiter>| </layout>| </target>| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='m' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logger.Info(\"msg2\");| logger.Warn(\"Message with, a comma\");| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.MemoryTarget>(\"m\");| Assert.NotNull(target);| Assert.Equal(4, target.Logs.Count);| Assert.Equal(\"level,message,counter\", target.Logs[0]);| Assert.Equal(\"Debug,msg,1\", target.Logs[1]);| Assert.Equal(\"Info,msg2,2\", target.Logs[2]);| Assert.Equal(\"Warn,\\\"Message with, a comma\\\",3\", target.Logs[3]);| }"
      },
      {
        "name": "CustomHeaderTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='m' type='Memory'>| <layout type='CSVLayout'>| <header>headertest</header>| <column name='level' layout='${level}' quoting='Nothing' />| <column name='message' layout='${message}' />| <column name='counter' layout='${counter}' />| <delimiter>Comma</delimiter>| </layout>| </target>| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='m' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logger.Info(\"msg2\");| logger.Warn(\"Message with, a comma\");| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.MemoryTarget>(\"m\");| Assert.NotNull(target);| Assert.Equal(4, target.Logs.Count);| Assert.Equal(\"headertest\", target.Logs[0]);| Assert.Equal(\"Debug,msg,1\", target.Logs[1]);| Assert.Equal(\"Info,msg2,2\", target.Logs[2]);| Assert.Equal(\"Warn,\\\"Message with, a comma\\\",3\", target.Logs[3]);| }"
      },
      {
        "name": "NoHeadersTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target name='m' type='Memory'>| <layout type='CSVLayout' withHeader='false'>| <delimiter>Comma</delimiter>| <column name='level' layout='${level}' />| <column name='message' layout='${message}' />| <column name='counter' layout='${counter}' />| </layout>| </target>| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='m' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"msg\");| logger.Info(\"msg2\");| logger.Warn(\"Message with, a comma\");| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.MemoryTarget>(\"m\");| Assert.NotNull(target);| Assert.Equal(3, target.Logs.Count);| Assert.Equal(\"Debug,msg,1\", target.Logs[0]);| Assert.Equal(\"Info,msg2,2\", target.Logs[1]);| Assert.Equal(\"Warn,\\\"Message with, a comma\\\",3\", target.Logs[2]);| }"
      },
      {
        "name": "CsvLayoutRenderingNoQuoting",
        "body": "{| var delimiters = new Dictionary<CsvColumnDelimiterMode, string>| {| { CsvColumnDelimiterMode.Auto, CultureInfo.CurrentCulture.TextInfo.ListSeparator },| { CsvColumnDelimiterMode.Comma, \",\" },| { CsvColumnDelimiterMode.Semicolon, \";\" },| { CsvColumnDelimiterMode.Space, \" \" },| { CsvColumnDelimiterMode.Tab, \"\\t\" },| { CsvColumnDelimiterMode.Pipe, \"|\" },| { CsvColumnDelimiterMode.Custom, \"zzz\" },| };| foreach (var delim in delimiters)| {| var csvLayout = new CsvLayout()| {| Quoting = CsvQuotingMode.Nothing,| Columns =| {| new CsvColumn(\"date\", \"${longdate}\"),| new CsvColumn(\"level\", \"${level}\"),| new CsvColumn(\"message;text\", \"${message}\"),| },| Delimiter = delim.Key,| CustomColumnDelimiter = \"zzz\",| };| var ev = new LogEventInfo();| ev.TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56);| ev.Level = LogLevel.Info;| ev.Message = string.Concat(csvLayout.QuoteChar, \"hello, world\", csvLayout.QuoteChar);| string sep = delim.Value;| Assert.Equal(\"2010-01-01 12:34:56.0000\" + sep + \"Info\" + sep + \"\\\"hello, world\\\"\", csvLayout.Render(ev));| Assert.Equal(\"date\" + sep + \"level\" + sep + \"message;text\", csvLayout.Header.Render(ev));| }| }"
      },
      {
        "name": "CsvLayoutRenderingFullQuoting",
        "body": "{| var delimiters = new Dictionary<CsvColumnDelimiterMode, string>| {| { CsvColumnDelimiterMode.Auto, CultureInfo.CurrentCulture.TextInfo.ListSeparator },| { CsvColumnDelimiterMode.Comma, \",\" },| { CsvColumnDelimiterMode.Semicolon, \";\" },| { CsvColumnDelimiterMode.Space, \" \" },| { CsvColumnDelimiterMode.Tab, \"\\t\" },| { CsvColumnDelimiterMode.Pipe, \"|\" },| { CsvColumnDelimiterMode.Custom, \"zzz\" },| };| foreach (var delim in delimiters)| {| var csvLayout = new CsvLayout()| {| Quoting = CsvQuotingMode.All,| Columns =| {| new CsvColumn(\"date\", \"${longdate}\"),| new CsvColumn(\"level\", \"${level}\"),| new CsvColumn(\"message;text\", \"${message}\"),| },| QuoteChar = \"'\",| Delimiter = delim.Key,| CustomColumnDelimiter = \"zzz\",| };| var ev = new LogEventInfo();| ev.TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56);| ev.Level = LogLevel.Info;| ev.Message = string.Concat(csvLayout.QuoteChar, \"hello, world\", csvLayout.QuoteChar);| string sep = delim.Value;| Assert.Equal(\"'2010-01-01 12:34:56.0000'\" + sep + \"'Info'\" + sep + \"'''hello, world'''\", csvLayout.Render(ev));| Assert.Equal(\"'date'\" + sep + \"'level'\" + sep + \"'message;text'\", csvLayout.Header.Render(ev));| }| }"
      },
      {
        "name": "CsvLayoutRenderingAutoQuoting",
        "body": "{| var csvLayout = new CsvLayout()| {| Quoting = CsvQuotingMode.Auto,| Columns =| {| new CsvColumn(\"date\", \"${longdate}\"),| new CsvColumn(\"level\", \"${level}\"),| new CsvColumn(\"message;text\", \"${message}\"),| },| QuoteChar = \"'\",| Delimiter = CsvColumnDelimiterMode.Semicolon,| };| // no quoting| Assert.Equal(| \"2010-01-01 12:34:56.0000;Info;hello, world\",| csvLayout.Render(new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello, world\"| }));| // multi-line string - requires quoting| Assert.Equal(| \"2010-01-01 12:34:56.0000;Info;'hello\\rworld'\",| csvLayout.Render(new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\rworld\"| }));| // multi-line string - requires quoting| Assert.Equal(| \"2010-01-01 12:34:56.0000;Info;'hello\\nworld'\",| csvLayout.Render(new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\nworld\"| }));| // quote character used in string, will be quoted and doubled| Assert.Equal(| \"2010-01-01 12:34:56.0000;Info;'hello''world'\",| csvLayout.Render(new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello'world\"| }));| Assert.Equal(\"date;level;'message;text'\", csvLayout.Header.Render(LogEventInfo.CreateNullEvent()));| }"
      },
      {
        "name": "CsvLayoutCachingTest",
        "body": "{| var csvLayout = new CsvLayout()| {| Quoting = CsvQuotingMode.Auto,| Columns =| {| new CsvColumn(\"date\", \"${longdate}\"),| new CsvColumn(\"level\", \"${level}\"),| new CsvColumn(\"message\", \"${message}\"),| new CsvColumn(\"threadid\", \"${threadid}\"),| },| QuoteChar = \"'\",| Delimiter = CsvColumnDelimiterMode.Semicolon,| };| var e1 = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello, world\"| };| var e2 = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 57),| Level = LogLevel.Info,| Message = \"hello, world\"| };| var r11 = csvLayout.Render(e1);| var r12 = csvLayout.Render(e1);| var r21 = csvLayout.Render(e2);| var r22 = csvLayout.Render(e2);| var h11 = csvLayout.Header.Render(e1);| var h12 = csvLayout.Header.Render(e1);| var h21 = csvLayout.Header.Render(e2);| var h22 = csvLayout.Header.Render(e2);| Assert.Same(r11, r12);| Assert.Same(r21, r22);| Assert.NotSame(r11, r21);| Assert.NotSame(r12, r22);| Assert.Equal(h11, h21);| Assert.Same(h11, h12);| Assert.Same(h21, h22);| }"
      }
    ]
  },
  {
    "file": "JsonArrayLayoutTests.cs",
    "methods": [
      {
        "name": "JsonArrayLayoutRendering",
        "body": "{| var jsonLayout = new JsonArrayLayout()| {| Items =| {| new SimpleLayout(\"${longdate}\"),| new SimpleLayout(\"${level}\"),| new SimpleLayout(\"${message}\"),| }| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\n world\",| };| Assert.Equal(\"[ \\\"2010-01-01T12:34:56Z\\\", \\\"Info\\\", \\\"hello\\\\n world\\\" ]\", jsonLayout.Render(logEventInfo));| }"
      },
      {
        "name": "JsonArrayLayoutRenderingFromXml",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target type='Debug' name='Debug'>| <layout type='JsonArrayLayout'>| <item type='SimpleLayout' text='${longdate}' />| <item type='SimpleLayout' text='${level}' />| <item type='SimpleLayout' text='${message}' />| </layout>| </target>| </targets>| <rules>| <logger writeTo='Debug' />| </rules>| </nlog>| \").LogFactory;| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\n world\",| };| logFactory.GetCurrentClassLogger().Log(logEventInfo);| logFactory.AssertDebugLastMessage(\"[ \\\"2010-01-01T12:34:56Z\\\", \\\"Info\\\", \\\"hello\\\\n world\\\" ]\");| }"
      },
      {
        "name": "JsonArrayLayoutRenderingNoSpaces",
        "body": "{| var jsonLayout = new JsonArrayLayout()| {| Items =| {| new SimpleLayout(\"${longdate}\"),| new SimpleLayout(\"${level}\"),| new SimpleLayout(\"${message}\"),| },| SuppressSpaces = true,| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\n world\",| };| Assert.Equal(\"[\\\"2010-01-01T12:34:56Z\\\",\\\"Info\\\",\\\"hello\\\\n world\\\"]\", jsonLayout.Render(logEventInfo));| }"
      },
      {
        "name": "JsonArrayLayoutRenderingNotEmpty",
        "body": "{| var jsonLayout = new JsonArrayLayout()| {| Items =| {| new JsonLayout() { IncludeEventProperties = true, RenderEmptyObject = false },| }| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\n world\",| };| Assert.Equal(\"[ ]\", jsonLayout.Render(logEventInfo));| }"
      },
      {
        "name": "JsonArrayLayoutRenderingEmpty",
        "body": "{| var jsonLayout = new JsonArrayLayout()| {| Items =| {| new JsonLayout() { IncludeEventProperties = true, RenderEmptyObject = false },| },| RenderEmptyObject = false,| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\n world\",| };| Assert.Equal(\"\", jsonLayout.Render(logEventInfo));| }"
      },
      {
        "name": "JsonArrayLayoutObjectRendering",
        "body": "{| var jsonLayout = new JsonArrayLayout()| {| Items =| {| new JsonLayout() { Attributes = { new JsonAttribute(\"date\", \"${longdate}\") } },| new JsonLayout() { Attributes = { new JsonAttribute(\"level\", \"${level}\") } },| new JsonLayout() { Attributes = { new JsonAttribute(\"message\", \"${message}\") } },| }| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello\\n world\",| };| Assert.Equal(\"[ { \\\"date\\\": \\\"2010-01-01 12:34:56.0000\\\" }, { \\\"level\\\": \\\"Info\\\" }, { \\\"message\\\": \\\"hello\\\\n world\\\" } ]\", jsonLayout.Render(logEventInfo));| }"
      }
    ]
  },
  {
    "file": "SimpleLayoutOutputTests.cs",
    "methods": [
      {
        "name": "VeryLongRendererOutput",
        "body": "{| int stringLength = 100000;| SimpleLayout l = new string('x', stringLength) + \"${message}\";| string output = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(new string('x', stringLength), output);| string output2 = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(new string('x', stringLength), output);| Assert.NotSame(output, output2);| }"
      },
      {
        "name": "LayoutRendererThrows",
        "body": "{| using (new NoThrowNLogExceptions())| {| ConfigurationItemFactory configurationItemFactory = new ConfigurationItemFactory();| configurationItemFactory.LayoutRendererFactory.RegisterType<ThrowsExceptionRenderer>(\"throwsException\");| SimpleLayout l = new SimpleLayout(\"xx${throwsException}yy\", configurationItemFactory);| string output = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(\"xxyy\", output);| }| }"
      },
      {
        "name": "SimpleLayoutCachingTest",
        "body": "{| var l = new SimpleLayout(\"xx${threadid}yy\");| var ev = LogEventInfo.CreateNullEvent();| string output1 = l.Render(ev);| string output2 = l.Render(ev);| Assert.Same(output1, output2);| }"
      },
      {
        "name": "SimpleLayoutToStringTest",
        "body": "{| var l = new SimpleLayout(\"xx${level}yy\");| Assert.Equal(\"xx${level}yy\", l.ToString());| var l2 = new SimpleLayout(ArrayHelper.Empty<LayoutRenderer>(), \"someFakeText\", ConfigurationItemFactory.Default);| Assert.Equal(\"someFakeText\", l2.ToString());| var l3 = new SimpleLayout(\"\");| Assert.Equal(\"\", l3.ToString());| }"
      },
      {
        "name": "LayoutRendererThrows2",
        "body": "{| string internalLogOutput = RunAndCaptureInternalLog(| () =>| {| using (new NoThrowNLogExceptions())| {| ConfigurationItemFactory configurationItemFactory = new ConfigurationItemFactory();| configurationItemFactory.LayoutRendererFactory.RegisterType<ThrowsExceptionRenderer>(\"throwsException\");| SimpleLayout l = new SimpleLayout(\"xx${throwsException:msg1}yy${throwsException:msg2}zz\", configurationItemFactory);| string output = l.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(\"xxyyzz\", output);| }| },| LogLevel.Warn);| Assert.Contains(\"msg1\", internalLogOutput);| Assert.Contains(\"msg2\", internalLogOutput);| }"
      },
      {
        "name": "LayoutInitTest1",
        "body": "{| var lr = new MockLayout();| Assert.Equal(0, lr.InitCount);| Assert.Equal(0, lr.CloseCount);| // make sure render will call Init| lr.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(1, lr.InitCount);| Assert.Equal(0, lr.CloseCount);| lr.Close();| Assert.Equal(1, lr.InitCount);| Assert.Equal(1, lr.CloseCount);| // second call to Close() will be ignored| lr.Close();| Assert.Equal(1, lr.InitCount);| Assert.Equal(1, lr.CloseCount);| }"
      },
      {
        "name": "LayoutInitTest2",
        "body": "{| var lr = new MockLayout();| Assert.Equal(0, lr.InitCount);| Assert.Equal(0, lr.CloseCount);| // calls to Close() will be ignored because| lr.Close();| Assert.Equal(0, lr.InitCount);| Assert.Equal(0, lr.CloseCount);| lr.Initialize(null);| Assert.Equal(1, lr.InitCount);| // make sure render will not call another Init| lr.Render(LogEventInfo.CreateNullEvent());| Assert.Equal(1, lr.InitCount);| Assert.Equal(0, lr.CloseCount);| lr.Close();| Assert.Equal(1, lr.InitCount);| Assert.Equal(1, lr.CloseCount);| }"
      },
      {
        "name": "TryGetRawValue_SingleLayoutRender_ShouldGiveRawValue",
        "body": "{| // Arrange| SimpleLayout l = \"${sequenceid}\";| var logEventInfo = LogEventInfo.CreateNullEvent();| // Act| var success = l.TryGetRawValue(logEventInfo, out var value);| // Assert| Assert.True(success, \"success\");| Assert.IsType<int>(value);| Assert.True((int)value >= 0, \"(int)value >= 0\");| }"
      },
      {
        "name": "TryGetRawValue_MultipleLayoutRender_ShouldGiveNullRawValue",
        "body": "{| // Arrange| SimpleLayout l = \"${sequenceid} \";| var logEventInfo = LogEventInfo.CreateNullEvent();| // Act| var success = l.TryGetRawValue(logEventInfo, out var value);| // Assert| Assert.False(success);| Assert.Null(value);| }"
      },
      {
        "name": "TryGetRawValue_MutableLayoutRender_ShouldGiveNullRawValue",
        "body": "{| // Arrange| SimpleLayout l = \"${event-properties:builder}\";| var logEventInfo = LogEventInfo.CreateNullEvent();| logEventInfo.Properties[\"builder\"] = new StringBuilder(\"mybuilder\");| l.Precalculate(logEventInfo);| // Act| var success = l.TryGetRawValue(logEventInfo, out var value);| // Assert| Assert.False(success);| Assert.Null(value);| }"
      },
      {
        "name": "TryGetRawValue_ImmutableLayoutRender_ShouldGiveRawValue",
        "body": "{| // Arrange| SimpleLayout l = \"${event-properties:correlationid}\";| var logEventInfo = LogEventInfo.CreateNullEvent();| var correlationId = Guid.NewGuid();| logEventInfo.Properties[\"correlationid\"] = correlationId;| l.Precalculate(logEventInfo);| // Act| var success = l.TryGetRawValue(logEventInfo, out var value);| // Assert| Assert.True(success, \"success\");| Assert.IsType<Guid>(value);| Assert.Equal(correlationId, value);| }"
      },
      {
        "name": "TryGetRawValue_WhenEmpty_ShouldNotFailWithNullException",
        "body": "{| // Arrange| SimpleLayout l = \"${event-properties:eventId:whenEmpty=0}\";| var logEventInfo = LogEventInfo.CreateNullEvent();| l.Precalculate(logEventInfo);| // Act| var success = l.TryGetRawValue(logEventInfo, out var value);| // Assert| Assert.False(success, \"Missing EventId\");| }"
      }
    ]
  },
  {
    "file": "ThreadAgnosticTests.cs",
    "methods": [
      {
        "name": "ThreadAgnosticTest",
        "body": "{| Layout l = new SimpleLayout(\"${message}\");| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "NonThreadAgnosticTest",
        "body": "{| Layout l = new SimpleLayout(\"${threadname}\");| l.Initialize(null);| Assert.False(l.ThreadAgnostic);| }"
      },
      {
        "name": "AgnosticPlusNonAgnostic",
        "body": "{| Layout l = new SimpleLayout(\"${message}${threadname}\");| l.Initialize(null);| Assert.False(l.ThreadAgnostic);| }"
      },
      {
        "name": "AgnosticPlusAgnostic",
        "body": "{| Layout l = new SimpleLayout(\"${message}${level}${logger}\");| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "WrapperOverAgnostic",
        "body": "{| Layout l = new SimpleLayout(\"${rot13:${message}}\");| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "DoubleWrapperOverAgnostic",
        "body": "{| Layout l = new SimpleLayout(\"${lowercase:${rot13:${message}}}\");| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "TripleWrapperOverAgnostic",
        "body": "{| Layout l = new SimpleLayout(\"${uppercase:${lowercase:${rot13:${message}}}}\");| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "TripleWrapperOverNonAgnostic",
        "body": "{| Layout l = new SimpleLayout(\"${uppercase:${lowercase:${rot13:${message}${threadname}}}}\");| l.Initialize(null);| Assert.False(l.ThreadAgnostic);| }"
      },
      {
        "name": "ComplexAgnosticWithCondition",
        "body": "{| Layout l = @\"${message:padding=-10:padCharacter=Y:when='${pad:${logger}:padding=10:padCharacter=X}'=='XXXXlogger'}\";| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "ComplexNonAgnosticWithCondition",
        "body": "{| Layout l = @\"${message:padding=-10:padCharacter=Y:when='${pad:${threadname}:padding=10:padCharacter=X}'=='XXXXlogger'}\";| l.Initialize(null);| Assert.False(l.ThreadAgnostic);| }"
      },
      {
        "name": "CsvThreadAgnostic",
        "body": "{| CsvLayout l = new CsvLayout()| {| Columns =| {| new CsvColumn(\"name1\", \"${message}\"),| new CsvColumn(\"name2\", \"${level}\"),| new CsvColumn(\"name3\", \"${longdate}\"),| },| };| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      },
      {
        "name": "CsvNonAgnostic",
        "body": "{| CsvLayout l = new CsvLayout()| {| Columns =| {| new CsvColumn(\"name1\", \"${message}\"),| new CsvColumn(\"name2\", \"${threadname}\"),| new CsvColumn(\"name3\", \"${longdate}\"),| },| };| l.Initialize(null);| Assert.False(l.ThreadAgnostic);| }"
      },
      {
        "name": "CustomNotAgnosticTests",
        "body": "{| var cif = new ConfigurationItemFactory();| cif.LayoutRendererFactory.RegisterType<CustomRendererNonAgnostic>(\"customNotAgnostic\");| Layout l = new SimpleLayout(\"${customNotAgnostic}\", cif);| l.Initialize(null);| Assert.False(l.ThreadAgnostic);| }"
      },
      {
        "name": "CustomAgnosticTests",
        "body": "{| var cif = new ConfigurationItemFactory();| cif.LayoutRendererFactory.RegisterType<CustomRendererAgnostic>(\"customAgnostic\");| Layout l = new SimpleLayout(\"${customAgnostic}\", cif);| l.Initialize(null);| Assert.True(l.ThreadAgnostic);| }"
      }
    ]
  },
  {
    "file": "XmlLayoutTests.cs",
    "methods": [
      {
        "name": "XmlLayoutRendering",
        "body": "{| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"date\", \"${longdate}\"),| new XmlElement(\"level\", \"${level}\"),| new XmlElement(\"message\", \"${message}\"),| },| IndentXml = true,| IncludeEventProperties = true,| };| var logEventInfo = new LogEventInfo| {| TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),| Level = LogLevel.Info,| Message = \"hello, world\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = \"nlogPropertyValue\";| Assert.Equal(string.Format(System.Globalization.CultureInfo.InvariantCulture, @\"<logevent>{0}{1}<date>2010-01-01 12:34:56.0000</date>{0}{1}<level>Info</level>{0}{1}<message>hello, world</message>{0}{1}<property key=\"\"nlogPropertyKey\"\">nlogPropertyValue</property>{0}</logevent>\", Environment.NewLine, \" \"), xmlLayout.Render(logEventInfo));| }"
      },
      {
        "name": "XmlLayoutLog4j",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='debug'>| <layout type='xmllayout' elementName='log4j:event' propertiesElementName='log4j:data' propertiesElementKeyAttribute='name' propertiesElementValueAttribute='value' includeAllProperties='true' includeMdc='true' includeMdlc='true' excludeProperties='BADPROPERTYKEY' >| <attribute name='logger' layout='${logger}' includeEmptyValue='true' />| <attribute name='level' layout='${uppercase:${level}}' includeEmptyValue='true' />| <element name='log4j:message' value='${message}' />| <element name='log4j:throwable' value='${exception:format=tostring}' />| <element name='log4j:locationInfo'>| <attribute name='class' layout='${callsite:methodName=false}' includeEmptyValue='true' />| </element>| </layout>| </target>| </targets>| <rules>| <logger name='*' minlevel='debug' appendto='debug' />| </rules>| </nlog>\").LogFactory;| ScopeContext.Clear();| ScopeContext.PushProperty(\"foo1\", \"bar1\");| ScopeContext.PushProperty(\"foo2\", \"bar2\");| ScopeContext.PushProperty(\"foo3\", \"bar3\");| var logger = logFactory.GetLogger(\"hello\");| var logEventInfo = LogEventInfo.Create(LogLevel.Debug, \"A\", null, null, \"some message\");| logEventInfo.Properties[\"nlogPropertyKey\"] = \"<nlog\\r\\nPropertyValue>\";| logEventInfo.Properties[\"badPropertyKey\"] = \"NOT ME\";| logger.Log(logEventInfo);| var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");| Assert.Equal(@\"<log4j:event logger=\"\"A\"\" level=\"\"DEBUG\"\"><log4j:message>some message</log4j:message><log4j:locationInfo class=\"\"NLog.UnitTests.Layouts.XmlLayoutTests\"\"/><log4j:data name=\"\"foo1\"\" value=\"\"bar1\"\"/><log4j:data name=\"\"foo2\"\" value=\"\"bar2\"\"/><log4j:data name=\"\"foo3\"\" value=\"\"bar3\"\"/><log4j:data name=\"\"nlogPropertyKey\"\" value=\"\"&lt;nlog&#13;&#10;PropertyValue&gt;\"\"/></log4j:event>\", target.LastMessage);| }"
      },
      {
        "name": "XmlLayout_EncodeValue_RenderXmlMessage",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"message\", \"${message}\"),| },| };| var logEventInfo = new LogEventInfo { Message = @\"<hello planet=\"\"earth\"\"/>\" };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>&lt;hello planet=&quot;earth&quot;/&gt;</message></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_SkipEncodeValue_RenderXmlMessage",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"message\", \"${message}\") { Encode = false }| },| };| var logEventInfo = new LogEventInfo { Message = @\"<hello planet=\"\"earth\"\"/>\" };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message><hello planet=\"\"earth\"\"/></message></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_IncludeEmptyValue_RenderEmptyValue",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"message\", \"${message}\") { IncludeEmptyValue = true },| },| IncludeEventProperties = true,| IncludeEmptyValue = true,| };| var logEventInfo = new LogEventInfo| {| Message = \"\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = null;| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message></message><property key=\"\"nlogPropertyKey\"\">null</property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_NoIndent_RendersOneLine",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"level\", \"${level}\"),| new XmlElement(\"message\", \"${message}\"),| },| IndentXml = false,| IncludeEventProperties = true,| };| var logEventInfo = new LogEventInfo| {| Message = \"message 1\",| Level = LogLevel.Debug| };| logEventInfo.Properties[\"prop1\"] = \"a\";| logEventInfo.Properties[\"prop2\"] = \"b\";| logEventInfo.Properties[\"prop3\"] = \"c\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected =| @\"<logevent><level>Debug</level><message>message 1</message><property key=\"\"prop1\"\">a</property><property key=\"\"prop2\"\">b</property><property key=\"\"prop3\"\">c</property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_ExcludeProperties_RenderNotProperty",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"message\", \"${message}\"),| },| IncludeEventProperties = true,| ExcludeProperties = new HashSet<string> { \"prop2\" }| };| var logEventInfo = new LogEventInfo| {| Message = \"message 1\"| };| logEventInfo.Properties[\"prop1\"] = \"a\";| logEventInfo.Properties[\"prop2\"] = \"b\";| logEventInfo.Properties[\"prop3\"] = \"c\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>message 1</message><property key=\"\"prop1\"\">a</property><property key=\"\"prop3\"\">c</property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_OnlyLogEventProperties_RenderRootCorrect",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| IncludeEventProperties = true,| };| var logEventInfo = new LogEventInfo| {| Message = \"message 1\"| };| logEventInfo.Properties[\"prop1\"] = \"a\";| logEventInfo.Properties[\"prop2\"] = \"b\";| logEventInfo.Properties[\"prop3\"] = \"c\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><property key=\"\"prop1\"\">a</property><property key=\"\"prop2\"\">b</property><property key=\"\"prop3\"\">c</property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_InvalidXmlPropertyName_RenderNameCorrect",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| IncludeEventProperties = true,| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| };| var logEventInfo = new LogEventInfo| {| Message = \"message 1\"| };| logEventInfo.Properties[\"1prop\"] = \"a\";| logEventInfo.Properties[\"_2prop\"] = \"b\";| logEventInfo.Properties[\" 3prop\"] = \"c\";| logEventInfo.Properties[\"_4 prop\"] = \"d\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><_1prop>a</_1prop><_2prop>b</_2prop><_3prop>c</_3prop><_4_prop>d</_4_prop></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesAttributeNames_RenderPropertyName",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| IncludeEventProperties = true,| PropertiesElementName = \"p\",| PropertiesElementKeyAttribute = \"k\",| PropertiesElementValueAttribute = \"v\",| };| var logEventInfo = new LogEventInfo| {| Message = \"message 1\"| };| logEventInfo.Properties[\"prop1\"] = \"a\";| logEventInfo.Properties[\"prop2\"] = \"b\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><p k=\"\"prop1\"\" v=\"\"a\"\"/><p k=\"\"prop2\"\" v=\"\"b\"\"/></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyName",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| IncludeEventProperties = true,| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| PropertiesElementValueAttribute = \"v\",| };| var logEventInfo = new LogEventInfo| {| Message = \"message 1\"| };| logEventInfo.Properties[\"prop1\"] = \"a\";| logEventInfo.Properties[\"prop2\"] = \"b\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><prop1 v=\"\"a\"\"/><prop2 v=\"\"b\"\"/></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_DoubleNestedElements_RendersAllElements",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements =| {| new XmlElement(\"message\", \"${message}\")| {| Elements =| {| new XmlElement(\"level\", \"${level}\")| },| IncludeEventProperties = true,| }| },| };| var logEventInfo = new LogEventInfo| {| Level = LogLevel.Debug,| Message = \"message 1\"| };| logEventInfo.Properties[\"prop1\"] = \"a\";| logEventInfo.Properties[\"prop2\"] = \"b\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| string expected = @\"<logevent><message>message 1<level>Debug</level><property key=\"\"prop1\"\">a</property><property key=\"\"prop2\"\">b</property></message></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyDictionary",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| IncludeEventProperties = true,| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new Dictionary<string, object> { { \"Hello\", \"World\" } };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><property key=\"\"Hello\"\">World</property></property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyDictionary",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| IncludeEventProperties = true,| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new Dictionary<string, object> { { \"Hello\", \"World\" } };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><Hello>World</Hello></nlogPropertyKey></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyList",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| IncludeEventProperties = true,| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new[] { \"Hello\", \"World\" };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><item>Hello</item><item>World</item></property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyList",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| IncludeEventProperties = true,| PropertiesCollectionItemName = \"node\",| PropertiesElementValueAttribute = \"value\",| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new[] { \"Hello\", \"World\" };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><node value=\"\"Hello\"\"/><node value=\"\"World\"\"/></nlogPropertyKey></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyObject",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| IncludeEventProperties = true,| };| var guid = Guid.NewGuid();| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new { Id = guid, Name = \"Hello World\", Elements = new[] { \"Earth\", \"Wind\", \"Fire\" } };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><property key=\"\"Id\"\">\" + guid.ToString() + @\"</property><property key=\"\"Name\"\">Hello World</property><property key=\"\"Elements\"\"><item>Earth</item><item>Wind</item><item>Fire</item></property></property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyObject",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| IncludeEventProperties = true,| };| var guid = Guid.NewGuid();| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new { Id = guid, Name = \"Hello World\", Elements = new[] { \"Earth\", \"Wind\", \"Fire\" } };| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><Id>\" + guid.ToString() + @\"</Id><Name>Hello World</Name><Elements><item>Earth</item><item>Wind</item><item>Fire</item></Elements></nlogPropertyKey></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyExpando",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| IncludeEventProperties = true,| };| dynamic object1 = new System.Dynamic.ExpandoObject();| object1.Id = 123;| object1.Name = \"test name\";| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = object1;| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><property key=\"\"Id\"\">123</property><property key=\"\"Name\"\">test name</property></property></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderSafeXml",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| IncludeEventProperties = true,| MaxRecursionLimit = 10,| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster < message\"| };| logEventInfo.Properties[\"<xmltag>\"] = \"<xmltag>\";| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster &lt; message</message><_xmltag_>&lt;xmltag&gt;</_xmltag_></logevent>\";| Assert.Equal(expected, result);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderInfiniteLoop",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| IncludeEventProperties = true,| MaxRecursionLimit = 10,| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| logEventInfo.Properties[\"nlogPropertyKey\"] = new TestList();| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| var cnt = System.Text.RegularExpressions.Regex.Matches(result, \"<item>alpha</item><item>bravo</item>\").Count;| Assert.Equal(10, cnt);| }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderTrickyDictionary",
        "body": "{| // Arrange| var xmlLayout = new XmlLayout()| {| Elements = { new XmlElement(\"message\", \"${message}\") },| PropertiesElementName = \"{0}\",| PropertiesElementKeyAttribute = \"\",| IncludeEventProperties = true,| MaxRecursionLimit = 10,| };| var logEventInfo = new LogEventInfo| {| Message = \"Monster message\"| };| IDictionary<object, object> testDictionary = new Internal.TrickyTestDictionary();| testDictionary.Add(\"key1\", 13);| testDictionary.Add(\"key 2\", 1.3m);| logEventInfo.Properties[\"nlogPropertyKey\"] = testDictionary;| // Act| var result = xmlLayout.Render(logEventInfo);| // Assert| const string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><key1>13</key1><key_2>1.3</key_2></nlogPropertyKey></logevent>\";| Assert.Equal(expected, result);| }"
      }
    ]
  },
  {
    "file": "LogFactoryTests.cs",
    "methods": [
      {
        "name": "Flush_DoNotThrowExceptionsAndTimeout_DoesNotThrow",
        "body": "{| // Arrange| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml($@\"| <nlog throwExceptions='false'>| <targets>| <target type='BufferingWrapper' name='test'>| <target type='MethodCall' name='test_wrapped' methodName='{nameof(TestClass.GenerateTimeout)}' className='{typeof(TestClass).AssemblyQualifiedName}' />| </target>| </targets>| <rules>| <logger name='*' minlevel='Debug' writeto='test'></logger>| </rules>| </nlog>\").LogFactory;| Logger logger = logFactory.GetCurrentClassLogger();| logger.Info(\"Prepare Timeout\");| Exception timeoutException = null;| ManualResetEvent manualResetEvent = new ManualResetEvent(false);| // Act| logger.Factory.Flush(TimeSpan.FromMilliseconds(1));| logger.Factory.Flush(ex => { timeoutException = ex; manualResetEvent.Set(); }, TimeSpan.FromMilliseconds(1));| // Assert| Assert.True(manualResetEvent.WaitOne(5000));| Assert.NotNull(timeoutException);| }"
      },
      {
        "name": "InvalidXMLConfiguration_DoesNotThrowErrorWhen_ThrowExceptionFlagIsNotSet",
        "body": "{| using (new NoThrowNLogExceptions())| {| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog internalLogIncludeTimestamp='IamNotBooleanValue'>| <targets><target type='Debug' name='test' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeto='test'></logger>| </rules>| </nlog>\").LogFactory;| Assert.NotNull(logFactory.Configuration);| }| }"
      },
      {
        "name": "InvalidXMLConfiguration_ThrowErrorWhen_ThrowExceptionFlagIsSet",
        "body": "{| Boolean ExceptionThrown = false;| try| {| new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog internalLogIncludeTimestamp='IamNotBooleanValue'>| <targets><target type='Debug' name='test' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeto='test'></logger>| </rules>| </nlog>\");| }| catch (Exception)| {| ExceptionThrown = true;| }| Assert.True(ExceptionThrown);| }"
      },
      {
        "name": "Configuration_InaccessibleNLog_doesNotThrowException",
        "body": "{| string tempDirectory = null;| try| {| // Arrange| var logFactory = CreateEmptyNLogFile(out tempDirectory, out var configFile);| using (OpenStream(configFile))| {| // Act| var loggingConfig = logFactory.Configuration;| // Assert| Assert.Null(loggingConfig);| }| // Assert| Assert.NotNull(logFactory.Configuration);| }| finally| {| if (tempDirectory != null && Directory.Exists(tempDirectory))| Directory.Delete(tempDirectory, true);| }| }"
      },
      {
        "name": "LoadConfiguration_InaccessibleNLog_throwException",
        "body": "{| string tempDirectory = null;| try| {| // Arrange| var logFactory = CreateEmptyNLogFile(out tempDirectory, out var configFile);| using (OpenStream(configFile))| {| // Act| var ex = Record.Exception(() => logFactory.LoadConfiguration(configFile));| // Assert| Assert.IsType<FileNotFoundException>(ex);| }| // Assert| Assert.NotNull(logFactory.LoadConfiguration(configFile).Configuration);| }| finally| {| if (tempDirectory != null && Directory.Exists(tempDirectory))| Directory.Delete(tempDirectory, true);| }| }"
      },
      {
        "name": "SecondaryLogFactoryDoesNotTakePrimaryLogFactoryLock",
        "body": "{| File.WriteAllText(\"NLog.config\", \"<nlog />\");| try| {| bool threadTerminated;| var primaryLogFactory = LogManager.LogFactory;| var primaryLogFactoryLock = primaryLogFactory._syncRoot;| // Simulate a potential deadlock.| // If the creation of the new LogFactory takes the lock of the global LogFactory, the thread will deadlock.| lock (primaryLogFactoryLock)| {| var thread = new Thread(() =>| {| (new LogFactory()).GetCurrentClassLogger();| });| thread.Start();| threadTerminated = thread.Join(TimeSpan.FromSeconds(1));| }| Assert.True(threadTerminated);| }| finally| {| try| {| File.Delete(\"NLog.config\");| }| catch { }| }| }"
      },
      {
        "name": "NewAttrOnNLogLevelShouldNotThrowError",
        "body": "{| using (new NoThrowNLogExceptions())| {| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog imAnewAttribute='noError'>| <targets><target type='file' name='f1' filename='test.log' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeto='f1'></logger>| </rules>| </nlog>\").LogFactory;| Assert.NotNull(logFactory.Configuration);| }| }"
      },
      {
        "name": "SuspendAndResumeLogging_InOrder",
        "body": "{| LogFactory factory = new LogFactory();| // In order Suspend => Resume [Case 1]| Assert.True(factory.IsLoggingEnabled());| factory.SuspendLogging();| Assert.False(factory.IsLoggingEnabled());| factory.ResumeLogging();| Assert.True(factory.IsLoggingEnabled());| // In order Suspend => Resume [Case 2]| using (var factory2 = new LogFactory())| {| Assert.True(factory.IsLoggingEnabled());| factory.SuspendLogging();| Assert.False(factory.IsLoggingEnabled());| factory.ResumeLogging();| Assert.True(factory.IsLoggingEnabled());| }| }"
      },
      {
        "name": "SuspendAndResumeLogging_OutOfOrder",
        "body": "{| LogFactory factory = new LogFactory();| // Out of order Resume => Suspend => (Suspend => Resume)| factory.ResumeLogging();| Assert.True(factory.IsLoggingEnabled());| factory.SuspendLogging();| Assert.True(factory.IsLoggingEnabled());| factory.SuspendLogging();| Assert.False(factory.IsLoggingEnabled());| factory.ResumeLogging();| Assert.True(factory.IsLoggingEnabled());| }"
      },
      {
        "name": "LogFactory_GetLoggerWithNull_ShouldThrow",
        "body": "{| LogFactory factory = new LogFactory();| Assert.Throws<ArgumentNullException>(() => factory.GetLogger(null));| }"
      },
      {
        "name": "PurgeObsoleteLoggersTest",
        "body": "{| var factory = new LogFactory();| var logger = GetWeakReferenceToTemporaryLogger(factory);| Assert.NotNull(logger);| GC.Collect();| GC.WaitForPendingFinalizers();| factory.ReconfigExistingLoggers(true);| var loggerKeysCount = factory.ResetLoggerCache();| Assert.Equal(0, loggerKeysCount);| logger = GetWeakReferenceToTemporaryLogger(factory);| GC.Collect();| GC.WaitForPendingFinalizers();| factory.ReconfigExistingLoggers();| factory.ReconfigExistingLoggers(false);| loggerKeysCount = factory.ResetLoggerCache();| Assert.Equal(1, loggerKeysCount);| }"
      }
    ]
  },
  {
    "file": "LogLevelTests.cs",
    "methods": [
      {
        "name": "LogLevelTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"Debug a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"Info a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"Warn a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"Error a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"Fatal a\");| }"
      },
      {
        "name": "LogLevelUppercaseTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:uppercase=true} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| ILogger logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"DEBUG a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"INFO a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"WARN a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"ERROR a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"FATAL a\");| }"
      },
      {
        "name": "LogLevelSingleCharacterTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=FirstCharacter} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"T a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"D a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"I a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"W a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"E a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"F a\");| }"
      },
      {
        "name": "LogLevelOrdinalTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=Ordinal} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"0 a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"1 a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"2 a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"3 a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"4 a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"5 a\");| }"
      },
      {
        "name": "LogLevelFullNameTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=FullName} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"Trace a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"Debug a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"Information a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"Warning a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"Error a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"Fatal a\");| }"
      },
      {
        "name": "LogLevelTriLetterTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${level:format=TriLetter} ${message}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Trace(\"a\");| logFactory.AssertDebugLastMessage(\"Trc a\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"Dbg a\");| logger.Info(\"a\");| logFactory.AssertDebugLastMessage(\"Inf a\");| logger.Warn(\"a\");| logFactory.AssertDebugLastMessage(\"Wrn a\");| logger.Error(\"a\");| logFactory.AssertDebugLastMessage(\"Err a\");| logger.Fatal(\"a\");| logFactory.AssertDebugLastMessage(\"Ftl a\");| }"
      },
      {
        "name": "LogLevelGetTypeCodeTest",
        "body": "{| // Arrange| var logLevel = LogLevel.Info;| // Act| var result = Convert.GetTypeCode(logLevel);| // Assert| Assert.Equal(TypeCode.Object, result);| }"
      }
    ]
  },
  {
    "file": "LogManagerTests.cs",
    "methods": [
      {
        "name": "GetLoggerTest",
        "body": "{| var loggerA = LogManager.GetLogger(\"A\");| var loggerA2 = LogManager.GetLogger(\"A\");| var loggerB = LogManager.GetLogger(\"B\");| Assert.Same(loggerA, loggerA2);| Assert.NotSame(loggerA, loggerB);| Assert.Equal(\"A\", loggerA.Name);| Assert.Equal(\"B\", loggerB.Name);| }"
      },
      {
        "name": "GarbageCollectionTest",
        "body": "{| string uniqueLoggerName = Guid.NewGuid().ToString();| var loggerA1 = LogManager.GetLogger(uniqueLoggerName);| GC.Collect();| var loggerA2 = LogManager.GetLogger(uniqueLoggerName);| Assert.Same(loggerA1, loggerA2);| }"
      },
      {
        "name": "GarbageCollection2Test",
        "body": "{| WeakReference wr = GetWeakReferenceToTemporaryLogger();| // nobody's holding a reference to this Logger anymore, so GC.Collect(2) should free it| GC.Collect(2, GCCollectionMode.Forced, true);| Assert.False(wr.IsAlive);| }"
      },
      {
        "name": "NullLoggerTest",
        "body": "{| var logger = LogManager.CreateNullLogger();| Assert.Equal(String.Empty, logger.Name);| }"
      },
      {
        "name": "GlobalThresholdTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog globalThreshold='Info'>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Assert.Equal(LogLevel.Info, logFactory.GlobalThreshold);| // nothing gets logged because of globalThreshold| logFactory.GetLogger(\"A\").Debug(\"xxx\");| logFactory.AssertDebugLastMessage(\"debug\", \"\");| // lower the threshold| logFactory.GlobalThreshold = LogLevel.Trace;| logFactory.GetLogger(\"A\").Debug(\"yyy\");| logFactory.AssertDebugLastMessage(\"debug\", \"yyy\");| // raise the threshold| logFactory.GlobalThreshold = LogLevel.Info;| // this should be yyy, meaning that the target is in place| // only rules have been modified.| logFactory.GetLogger(\"A\").Debug(\"zzz\");| logFactory.AssertDebugLastMessage(\"debug\", \"yyy\");| }"
      },
      {
        "name": "DisableLoggingTest_UsingStatement",
        "body": "{| const string LoggerConfig = @\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='DisableLoggingTest_UsingStatement_A' levels='Trace' writeTo='debug' />| <logger name='DisableLoggingTest_UsingStatement_B' levels='Error' writeTo='debug' />| </rules>| </nlog>\";| // Disable/Enable logging should affect ALL the loggers.| var loggerA = LogManager.GetLogger(\"DisableLoggingTest_UsingStatement_A\");| var loggerB = LogManager.GetLogger(\"DisableLoggingTest_UsingStatement_B\");| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(LoggerConfig);| // The starting state for logging is enable.| Assert.True(LogManager.IsLoggingEnabled());| loggerA.Trace(\"TTT\");| AssertDebugLastMessage(\"debug\", \"TTT\");| loggerB.Error(\"EEE\");| AssertDebugLastMessage(\"debug\", \"EEE\");| loggerA.Trace(\"---\");| AssertDebugLastMessage(\"debug\", \"---\");| using (LogManager.SuspendLogging())| {| Assert.False(LogManager.IsLoggingEnabled());| // The last of LastMessage outside using statement should be returned.| loggerA.Trace(\"TTT\");| AssertDebugLastMessage(\"debug\", \"---\");| loggerB.Error(\"EEE\");| AssertDebugLastMessage(\"debug\", \"---\");| }| Assert.True(LogManager.IsLoggingEnabled());| loggerA.Trace(\"TTT\");| AssertDebugLastMessage(\"debug\", \"TTT\");| loggerB.Error(\"EEE\");| AssertDebugLastMessage(\"debug\", \"EEE\");| LogManager.Shutdown();| LogManager.Configuration = null;| }"
      },
      {
        "name": "DisableLoggingTest_WithoutUsingStatement",
        "body": "{| const string LoggerConfig = @\"| <nlog>| <targets><target name='debug' type='Debug' layout='${message}' /></targets>| <rules>| <logger name='DisableLoggingTest_WithoutUsingStatement_A' levels='Trace' writeTo='debug' />| <logger name='DisableLoggingTest_WithoutUsingStatement_B' levels='Error' writeTo='debug' />| </rules>| </nlog>\";| // Disable/Enable logging should affect ALL the loggers.| var loggerA = LogManager.GetLogger(\"DisableLoggingTest_WithoutUsingStatement_A\");| var loggerB = LogManager.GetLogger(\"DisableLoggingTest_WithoutUsingStatement_B\");| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(LoggerConfig);| // The starting state for logging is enable.| Assert.True(LogManager.IsLoggingEnabled());| loggerA.Trace(\"TTT\");| AssertDebugLastMessage(\"debug\", \"TTT\");| loggerB.Error(\"EEE\");| AssertDebugLastMessage(\"debug\", \"EEE\");| loggerA.Trace(\"---\");| AssertDebugLastMessage(\"debug\", \"---\");| LogManager.SuspendLogging();| Assert.False(LogManager.IsLoggingEnabled());| // The last value of LastMessage before DisableLogging() should be returned.| loggerA.Trace(\"TTT\");| AssertDebugLastMessage(\"debug\", \"---\");| loggerB.Error(\"EEE\");| AssertDebugLastMessage(\"debug\", \"---\");| LogManager.ResumeLogging();| Assert.True(LogManager.IsLoggingEnabled());| loggerA.Trace(\"TTT\");| AssertDebugLastMessage(\"debug\", \"TTT\");| loggerB.Error(\"EEE\");| AssertDebugLastMessage(\"debug\", \"EEE\");| LogManager.Shutdown();| LogManager.Configuration = null;| }"
      },
      {
        "name": "GivenCurrentClass_WhenGetCurrentClassLogger_ThenLoggerShouldBeCurrentClass",
        "body": "{| var logger = LogManager.GetCurrentClassLogger();| Assert.Equal(GetType().FullName, logger.Name);| }"
      },
      {
        "name": "GetCurrentClassLogger_static_class",
        "body": "{| ImAStaticClass.DummyToInvokeInitializers();| Assert.Equal(typeof(ImAStaticClass).FullName, ImAStaticClass.Logger.Name);| }"
      },
      {
        "name": "GetCurrentClassLogger_abstract_class",
        "body": "{| var instance = new InheritedFromAbstractClass();| Assert.Equal(instance.BaseName, instance.Logger.Name);| Assert.Equal(instance.BaseName, instance.LoggerType.Name);| Assert.Equal(instance.InheritedName, instance.LoggerInherited.Name);| Assert.Equal(instance.InheritedName, instance.LoggerTypeInherited.Name);| }"
      },
      {
        "name": "GetCurrentClassLogger_abstract_class_with_parameter",
        "body": "{| var instance = new InheritedFromAbstractClass(\"Hello\", null);| Assert.Equal(instance.BaseName, instance.Logger.Name);| Assert.Equal(instance.BaseName, instance.LoggerType.Name);| Assert.Equal(instance.InheritedName, instance.LoggerInherited.Name);| Assert.Equal(instance.InheritedName, instance.LoggerTypeInherited.Name);| }"
      },
      {
        "name": "GetLogger_wrong_loggertype_should_continue",
        "body": "{| using (new NoThrowNLogExceptions())| {| var instance = LogManager.GetLogger(\"a\", typeof(ImNotALogger));| Assert.NotNull(instance);| }| }"
      },
      {
        "name": "GetLogger_wrong_loggertype_should_continue_even_if_class_is_static",
        "body": "{| using (new NoThrowNLogExceptions())| {| var instance = LogManager.GetLogger(\"a\", typeof(ImAStaticClass));| Assert.NotNull(instance);| }| }"
      },
      {
        "name": "GivenLazyClass_WhenGetCurrentClassLogger_ThenLoggerNameShouldBeCurrentClass",
        "body": "{| var logger = new Lazy<Logger>(LogManager.GetCurrentClassLogger);| Assert.Equal(GetType().FullName, logger.Value.Name);| }"
      },
      {
        "name": "ThreadSafe_Shutdown",
        "body": "{| LogManager.Configuration = new LoggingConfiguration();| LogManager.ThrowExceptions = true;| LogManager.Configuration.AddTarget(\"memory\", new NLog.Targets.Wrappers.BufferingTargetWrapper(new MemoryTarget() { MaxLogsCount = 500 }, 5, 1));| LogManager.Configuration.LoggingRules.Add(new LoggingRule(\"*\", LogLevel.Debug, LogManager.Configuration.FindTargetByName(\"memory\")));| LogManager.Configuration.AddTarget(\"memory2\", new NLog.Targets.Wrappers.BufferingTargetWrapper(new MemoryTarget() { MaxLogsCount = 500 }, 5, 1));| LogManager.Configuration.LoggingRules.Add(new LoggingRule(\"*\", LogLevel.Debug, LogManager.Configuration.FindTargetByName(\"memory2\")));| var stopFlag = false;| var exceptionThrown = false;| Task.Run(() => { try { var logger = LogManager.GetLogger(\"Hello\"); while (!stopFlag) { logger.Debug(\"Hello World\"); System.Threading.Thread.Sleep(1); } } catch { exceptionThrown = true; } });| Task.Run(() => { try { var logger = LogManager.GetLogger(\"Hello\"); while (!stopFlag) { logger.Debug(\"Hello World\"); System.Threading.Thread.Sleep(1); } } catch { exceptionThrown = true; } });| System.Threading.Thread.Sleep(20);| LogManager.Shutdown(); // Shutdown active LoggingConfiguration| System.Threading.Thread.Sleep(20);| stopFlag = true;| System.Threading.Thread.Sleep(20);| Assert.False(exceptionThrown);| }"
      },
      {
        "name": "ThreadSafe_getCurrentClassLogger_test",
        "body": "{| MemoryTarget mTarget = new MemoryTarget() { Name = \"memory\", MaxLogsCount = 1000 };| MemoryTarget mTarget2 = new MemoryTarget() { Name = \"memory2\", MaxLogsCount = 1000 };| var task1 = Task.Run(() =>| {| //need for init| LogManager.Configuration = new LoggingConfiguration();| LogManager.Configuration.AddTarget(mTarget.Name, mTarget);| LogManager.Configuration.AddRuleForAllLevels(mTarget.Name);| System.Threading.Thread.Sleep(1);| LogManager.ReconfigExistingLoggers();| System.Threading.Thread.Sleep(1);| mTarget.Layout = @\"${date:format=HH\\:mm\\:ss}|${level:uppercase=true}|${message} ${exception:format=tostring}\";| });| var task2 = task1.ContinueWith((t) =>| {| LogManager.Configuration.AddTarget(mTarget2.Name, mTarget2);| LogManager.Configuration.AddRuleForAllLevels(mTarget2.Name);| System.Threading.Thread.Sleep(1);| LogManager.ReconfigExistingLoggers();| System.Threading.Thread.Sleep(1);| mTarget2.Layout = @\"${date:format=HH\\:mm\\:ss}|${level:uppercase=true}|${message} ${exception:format=tostring}\";| });| System.Threading.Thread.Sleep(1);| Parallel.For(0, 8, new ParallelOptions() { MaxDegreeOfParallelism = 8 }, (e) =>| {| bool task1Complete = false, task2Complete = false;| for (int i = 0; i < 100; ++i)| {| if (i > 25 && !task1Complete)| {| task1.Wait(5000);| task1Complete = true;| }| if (i > 75 && !task2Complete)| {| task2.Wait(5000);| task2Complete = true;| }| // Multiple threads initializing new loggers while configuration is changing| var loggerA = LogManager.GetLogger(e + \"A\" + i);| loggerA.Info(\"Hi there {0}\", e);| var loggerB = LogManager.GetLogger(e + \"B\" + i);| loggerB.Info(\"Hi there {0}\", e);| var loggerC = LogManager.GetLogger(e + \"C\" + i);| loggerC.Info(\"Hi there {0}\", e);| var loggerD = LogManager.GetLogger(e + \"D\" + i);| loggerD.Info(\"Hi there {0}\", e);| };| });| Assert.NotEqual(0, mTarget.Logs.Count + mTarget2.Logs.Count);| }"
      },
      {
        "name": "RemovedTargetShouldNotLog",
        "body": "{| var config = new LoggingConfiguration();| var targetA = new MemoryTarget(\"TargetA\") { Layout = \"A | ${message}\", MaxLogsCount = 1 };| var targetB = new MemoryTarget(\"TargetB\") { Layout = \"B | ${message}\", MaxLogsCount = 1 };| config.AddRule(LogLevel.Debug, LogLevel.Fatal, targetA);| config.AddRule(LogLevel.Debug, LogLevel.Fatal, targetB);| LogManager.Configuration = config;| Assert.Equal(new[] { \"TargetA\", \"TargetB\" }, LogManager.Configuration.ConfiguredNamedTargets.Select(target => target.Name));| Assert.NotNull(LogManager.Configuration.FindTargetByName(\"TargetA\"));| Assert.NotNull(LogManager.Configuration.FindTargetByName(\"TargetB\"));| var logger = LogManager.GetCurrentClassLogger();| logger.Info(\"Hello World\");| Assert.Equal(\"A | Hello World\", targetA.Logs.LastOrDefault());| Assert.Equal(\"B | Hello World\", targetB.Logs.LastOrDefault());| // Remove the first target from the configuration| LogManager.Configuration.RemoveTarget(\"TargetA\");| Assert.Equal(new[] { \"TargetB\" }, LogManager.Configuration.ConfiguredNamedTargets.Select(target => target.Name));| Assert.Null(LogManager.Configuration.FindTargetByName(\"TargetA\"));| Assert.NotNull(LogManager.Configuration.FindTargetByName(\"TargetB\"));| logger.Info(\"Goodbye World\");| Assert.Equal(\"A | Hello World\", targetA.Logs.LastOrDefault()); // Flushed and closed| Assert.Equal(\"B | Goodbye World\", targetB.Logs.LastOrDefault());| }"
      }
    ]
  },
  {
    "file": "LogMessageFormatterTests.cs",
    "methods": [
      {
        "name": "ExtensionsLoggingFormatTest",
        "body": "{| LogEventInfo logEventInfo = new LogEventInfo(LogLevel.Info, \"MyLogger\", \"Login request from {Username} for {Application}\", new[]| {| new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal),| new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal)| });| logEventInfo.Parameters = new object[] { \"Login request from John for BestApplicationEver\" };| logEventInfo.MessageFormatter = (logEvent) =>| {| if (logEvent.Parameters != null && logEvent.Parameters.Length > 0)| {| return logEvent.Parameters[logEvent.Parameters.Length - 1] as string ?? logEvent.Message;| }| return logEvent.Message;| };| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' >| <layout type='JsonLayout' IncludeAllProperties='true'>| <attribute name='LogMessage' layout='${message:raw=true}' />| </layout>| </target>| </targets>| <rules>| <logger name='*' levels='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Log(logEventInfo);| logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"Login request from {Username} for {Application}\\\", \\\"Username\\\": \\\"John\\\", \\\"Application\\\": \\\"BestApplicationEver\\\" }\");| Assert.Equal(\"Login request from John for BestApplicationEver\", logEventInfo.FormattedMessage);| AssertContainsInDictionary(logEventInfo.Properties, \"Username\", \"John\");| AssertContainsInDictionary(logEventInfo.Properties, \"Application\", \"BestApplicationEver\");| Assert.Contains(new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);| Assert.Contains(new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);| }"
      },
      {
        "name": "ExtensionsLoggingPreFormatTest",
        "body": "{| LogEventInfo logEventInfo1 = new LogEventInfo(LogLevel.Info, \"MyLogger\", \"Login request from John for BestApplicationEver\", \"Login request from {Username} for {Application}\", new[]| {| new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal),| new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal)| });| LogEventInfo logEventInfo2 = new LogEventInfo(LogLevel.Info, \"MyLogger\", \"Login request from John for BestApplicationEver\", \"Login request from {Username} for {Application}\", new[]|{| new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal),| new MessageTemplateParameter(\"Application\", new StringBuilder(\"BestApplicationEver\", 32), null, CaptureType.Normal)| });| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='buffer' type='BufferingWrapper'>| <target name='debug' type='Debug' >| <layout type='JsonLayout' IncludeAllProperties='true' maxRecursionLimit='0'>| <attribute name='LogMessage' layout='${message:raw=true}' />| </layout>| </target>| </target>| </targets>| <rules>| <logger name='*' levels='Info' writeTo='buffer' />| </rules>| </nlog>\").LogFactory;| var debugTarget = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\");| var logger = logFactory.GetLogger(\"A\");| logger.Log(logEventInfo2);| logFactory.Flush();| var result2 = debugTarget.Layout.Render(logEventInfo2);| Assert.Same(result2, debugTarget.LastMessage);| logger.Log(logEventInfo1);| logFactory.Flush();| var result1 = debugTarget.Layout.Render(logEventInfo1);| Assert.NotSame(result1, debugTarget.LastMessage);| logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"Login request from {Username} for {Application}\\\", \\\"Username\\\": \\\"John\\\", \\\"Application\\\": \\\"BestApplicationEver\\\" }\");| Assert.Equal(\"Login request from John for BestApplicationEver\", logEventInfo1.FormattedMessage);| AssertContainsInDictionary(logEventInfo1.Properties, \"Username\", \"John\");| AssertContainsInDictionary(logEventInfo1.Properties, \"Application\", \"BestApplicationEver\");| Assert.Contains(new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal), logEventInfo1.MessageTemplateParameters);| Assert.Contains(new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal), logEventInfo1.MessageTemplateParameters);| }"
      },
      {
        "name": "NormalStringFormatTest",
        "body": "{| LogEventInfo logEventInfo = new LogEventInfo(LogLevel.Info, \"MyLogger\", null, \"{0:X} - Login request from {1} for {2} with userid {0}\", new object[]| {| 42,| \"John\",| \"BestApplicationEver\"| });| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' >| <layout type='JsonLayout' IncludeAllProperties='true'>| <attribute name='LogMessage' layout='${message:raw=true}' />| </layout>| </target>| </targets>| <rules>| <logger name='*' levels='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Log(logEventInfo);| logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"{0:X} - Login request from {1} for {2} with userid {0}\\\" }\");| Assert.Equal(\"2A - Login request from John for BestApplicationEver with userid 42\", logEventInfo.FormattedMessage);| Assert.Contains(new MessageTemplateParameter(\"0\", 42, \"X\", CaptureType.Normal), logEventInfo.MessageTemplateParameters);| Assert.Contains(new MessageTemplateParameter(\"1\", \"John\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);| Assert.Contains(new MessageTemplateParameter(\"2\", \"BestApplicationEver\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);| Assert.Contains(new MessageTemplateParameter(\"0\", 42, null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);| }"
      },
      {
        "name": "MessageTemplateFormatTest",
        "body": "{| LogEventInfo logEventInfo = new LogEventInfo(LogLevel.Info, \"MyLogger\", null, \"Login request from {@Username} for {Application:l}\", new object[]| {| \"John\",| \"BestApplicationEver\"| });| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='Debug' >| <layout type='JsonLayout' IncludeAllProperties='true'>| <attribute name='LogMessage' layout='${message:raw=true}' />| </layout>| </target>| </targets>| <rules>| <logger name='*' levels='Info' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| logger.Log(logEventInfo);| logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"Login request from {@Username} for {Application:l}\\\", \\\"Username\\\": \\\"John\\\", \\\"Application\\\": \\\"BestApplicationEver\\\" }\");| Assert.Equal(\"Login request from \\\"John\\\" for BestApplicationEver\", logEventInfo.FormattedMessage);| AssertContainsInDictionary(logEventInfo.Properties, \"Username\", \"John\");| AssertContainsInDictionary(logEventInfo.Properties, \"Application\", \"BestApplicationEver\");| Assert.Contains(new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Serialize), logEventInfo.MessageTemplateParameters);| Assert.Contains(new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", \"l\", CaptureType.Normal), logEventInfo.MessageTemplateParameters);| }"
      }
    ]
  },
  {
    "file": "ValueFormatterTest.cs",
    "methods": [
      {
        "name": "TestSerialisationOfStringToJsonIsSuccessful",
        "body": "{| var str = \"Test\";| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(str, string.Empty, CaptureType.Serialize, null, builder);| Assert.True(result);| Assert.Equal(\"\\\"Test\\\"\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfClassObjectToJsonIsSuccessful",
        "body": "{| var @class = new Test2();| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Serialize, null, builder);| Assert.True(result);| Assert.Equal(\"{\\\"Str\\\":\\\"Test\\\", \\\"Integer\\\":1}\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfRecursiveClassObjectToJsonIsSuccessful",
        "body": "{| var @class = new RecursiveTest(0);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Serialize, null, builder);| Assert.True(result);| var actual = builder.ToString();| var deepestInteger = @\"\"\"Integer\"\":10\";| Assert.Contains(deepestInteger, actual);| var deepestNext = @\"\"\"Next\"\":\"\"NLog.UnitTests.MessageTemplates.ValueFormatterTest+RecursiveTest\"\"\";| Assert.Contains(deepestNext, actual);| }"
      },
      {
        "name": "TestStringifyOfStringIsSuccessful",
        "body": "{| var @class = \"str\";| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Stringify, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"\\\"str\\\"\", builder.ToString());| }"
      },
      {
        "name": "TestStringifyOfIFormatableObjectIsSuccessful",
        "body": "{| var @class = new Test();| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Stringify, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"\\\"Test\\\"\", builder.ToString());| }"
      },
      {
        "name": "TestStringifyOfNonIFormatableObjectIsSuccessful",
        "body": "{| var @class = new Test1();| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Stringify, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| var expectedValue = $\"\\\"{typeof(Test1).FullName}\\\"\";| Assert.Equal(expectedValue, builder.ToString());| }"
      },
      {
        "name": "TestSerializationOfListObjectIsSuccessful",
        "body": "{| var list = new List<int>() { 1, 2, 3, 4, 5, 6 };| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"1, 2, 3, 4, 5, 6\", builder.ToString());| }"
      },
      {
        "name": "TestSerializationOfDictionaryObjectIsSuccessful",
        "body": "{| var list = new Dictionary<int, object>() { { 1, new Test() }, { 2, new Test1() } };| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal($\"1=Test, 2={typeof(Test1).FullName}\", builder.ToString());| }"
      },
      {
        "name": "TestSerializationOfCollectionOfListObjectWithDepth2IsNotSuccessful",
        "body": "{| var list = new List<List<List<List<int>>>>() { new List<List<List<int>>>() { new List<List<int>>() { new List<int>() { 1, 2 }, new List<int>() { 3, 4 } }, new List<List<int>>() { new List<int>() { 4, 5 }, new List<int>() { 6, 7 } } } };| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.NotEqual(\"1,2,3,4,5,6,7\", builder.ToString());| }"
      },
      {
        "name": "TestSerializationWillbeSkippedForElementsThatHaveRepeatedElements",
        "body": "{| var list = new List<List<List<List<int>>>>() { new List<List<List<int>>>() { new List<List<int>>() { new List<int>() { 1, 2 }, new List<int>() { 1, 2 } }, new List<List<int>>() { new List<int>() { 1, 2 }, new List<int>() { 1, 2 } } } };| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.NotEqual(\"1,2\", builder.ToString());| }"
      },
      {
        "name": "TestSerializationWillBeSuccessfulForNullObjects",
        "body": "{| object list = null;| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"NULL\", builder.ToString());| }"
      },
      {
        "name": "TestSerializationOfStringIsSuccessful",
        "body": "{| var @class = \"str\";| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"\\\"str\\\"\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfIConvertibleObjectIsSuccessful",
        "body": "{| var @class = new Test(TypeCode.Object);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"Test\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfIConvertibleStringObjectIsSuccessful",
        "body": "{| var @class = new Test(TypeCode.String);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| var expectedValue = $\"\\\"{typeof(Test).FullName}\\\"\";| Assert.Equal(expectedValue, builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfIConvertibleBooleanObjectIsSuccessful",
        "body": "{| var @class = new Test(TypeCode.Boolean);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"true\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfIConvertibleCharObjectIsSuccessful",
        "body": "{| var @class = new Test(TypeCode.Char);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"\\\"t\\\"\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfIConvertibleEnumObjectIsSuccessful",
        "body": "{| var @class = new Test(TypeCode.Byte);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class.Data, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"Foo\", builder.ToString());| }"
      },
      {
        "name": "TestSerialisationOfIConvertibleDateTimeObjectIsSuccessful",
        "body": "{| var @class = new Test(TypeCode.DateTime);| StringBuilder builder = new StringBuilder();| var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);| Assert.True(result);| Assert.Equal(\"Test\", builder.ToString());| }"
      }
    ]
  },
  {
    "file": "NLogTraceListenerTests.cs",
    "methods": [
      {
        "name": "TraceWriteTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\" });| Trace.Write(\"Hello\");| AssertDebugLastMessage(\"debug\", \"Logger1 Debug Hello \");| Trace.Write(\"Hello\", \"Cat1\");| AssertDebugLastMessage(\"debug\", \"Logger1 Debug Cat1: Hello \");| Trace.Write(3.1415);| AssertDebugLastMessage(\"debug\", $\"Logger1 Debug {3.1415} \");| Trace.Write(3.1415, \"Cat2\");| AssertDebugLastMessage(\"debug\", $\"Logger1 Debug Cat2: {3.1415} \");| }"
      },
      {
        "name": "TraceWriteLineTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\" });| Trace.WriteLine(\"Hello\");| AssertDebugLastMessage(\"debug\", \"Logger1 Debug Hello \");| Trace.WriteLine(\"Hello\", \"Cat1\");| AssertDebugLastMessage(\"debug\", \"Logger1 Debug Cat1: Hello \");| Trace.WriteLine(3.1415);| AssertDebugLastMessage(\"debug\", $\"Logger1 Debug {3.1415} \");| Trace.WriteLine(3.1415, \"Cat2\");| AssertDebugLastMessage(\"debug\", $\"Logger1 Debug Cat2: {3.1415} \");| }"
      },
      {
        "name": "TraceWriteNonDefaultLevelTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });| Trace.Write(\"Hello\");| AssertDebugLastMessage(\"debug\", \"Logger1 Trace Hello \");| }"
      },
      {
        "name": "TraceConfiguration",
        "body": "{| var listener = new NLogTraceListener();| listener.Attributes.Add(\"defaultLogLevel\", \"Warn\");| listener.Attributes.Add(\"forceLogLevel\", \"Error\");| listener.Attributes.Add(\"autoLoggerName\", \"1\");| listener.Attributes.Add(\"DISABLEFLUSH\", \"true\");| Assert.Equal(LogLevel.Warn, listener.DefaultLogLevel);| Assert.Equal(LogLevel.Error, listener.ForceLogLevel);| Assert.True(listener.AutoLoggerName);| Assert.True(listener.DisableFlush);| }"
      },
      {
        "name": "TraceFailTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\" });| Trace.Fail(\"Message\");| AssertDebugLastMessage(\"debug\", \"Logger1 Error Message Error\");| Trace.Fail(\"Message\", \"Detailed Message\");| AssertDebugLastMessage(\"debug\", \"Logger1 Error Message Detailed Message Error\");| }"
      },
      {
        "name": "AutoLoggerNameTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", AutoLoggerName = true });| Trace.Write(\"Hello\");| AssertDebugLastMessage(\"debug\", GetType().FullName + \" Debug Hello \");| }"
      },
      {
        "name": "TraceDataTests",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| TraceSource ts = CreateTraceSource();| ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });| ts.TraceData(TraceEventType.Critical, 123, 42);| AssertDebugLastMessage(\"debug\", \"MySource1 Fatal 42 123 Critical\");| ts.TraceData(TraceEventType.Critical, 145, 42, 3.14, \"foo\");| AssertDebugLastMessage(\"debug\", $\"MySource1 Fatal 42, {3.14.ToString(CultureInfo.CurrentCulture)}, foo 145 Critical\");| }"
      },
      {
        "name": "LogInformationTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| TraceSource ts = CreateTraceSource();| ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });| ts.TraceInformation(\"Quick brown fox\");| AssertDebugLastMessage(\"debug\", \"MySource1 Info Quick brown fox Information\");| ts.TraceInformation(\"Mary had {0} lamb\", \"a little\");| AssertDebugLastMessage(\"debug\", \"MySource1 Info Mary had a little lamb Information\");| }"
      },
      {
        "name": "TraceEventTests",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| TraceSource ts = CreateTraceSource();| ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });| ts.TraceEvent(TraceEventType.Information, 123, \"Quick brown {0} jumps over the lazy {1}.\", \"fox\", \"dog\");| AssertDebugLastMessage(\"debug\", \"MySource1 Info Quick brown fox jumps over the lazy dog. 123 Information\");| ts.TraceEvent(TraceEventType.Information, 123);| AssertDebugLastMessage(\"debug\", \"MySource1 Info 123 Information\");| ts.TraceEvent(TraceEventType.Verbose, 145, \"Bar\");| AssertDebugLastMessage(\"debug\", \"MySource1 Trace Bar 145 \");| ts.TraceEvent(TraceEventType.Error, 145, \"Foo\");| AssertDebugLastMessage(\"debug\", \"MySource1 Error Foo 145 Error\");| ts.TraceEvent(TraceEventType.Suspend, 145, \"Bar\");| AssertDebugLastMessage(\"debug\", \"MySource1 Debug Bar 145 Suspend\");| ts.TraceEvent(TraceEventType.Resume, 145, \"Foo\");| AssertDebugLastMessage(\"debug\", \"MySource1 Debug Foo 145 Resume\");| ts.TraceEvent(TraceEventType.Warning, 145, \"Bar\");| AssertDebugLastMessage(\"debug\", \"MySource1 Warn Bar 145 Warning\");| ts.TraceEvent(TraceEventType.Critical, 145, \"Foo\");| AssertDebugLastMessage(\"debug\", \"MySource1 Fatal Foo 145 Critical\");| }"
      },
      {
        "name": "ForceLogLevelTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| TraceSource ts = CreateTraceSource();| ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace, ForceLogLevel = LogLevel.Warn });| // force all logs to be Warn, DefaultLogLevel has no effect on TraceSource| ts.TraceInformation(\"Quick brown fox\");| AssertDebugLastMessage(\"debug\", \"MySource1 Warn Quick brown fox Information\");| ts.TraceInformation(\"Mary had {0} lamb\", \"a little\");| AssertDebugLastMessage(\"debug\", \"MySource1 Warn Mary had a little lamb Information\");| }"
      },
      {
        "name": "FilterTraceTest",
        "body": "{| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| TraceSource ts = CreateTraceSource();| ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace, ForceLogLevel = LogLevel.Warn, Filter = new EventTypeFilter(SourceLevels.Error) });| // force all logs to be Warn, DefaultLogLevel has no effect on TraceSource| ts.TraceEvent(TraceEventType.Error, 0, \"Quick brown fox\");| AssertDebugLastMessage(\"debug\", \"MySource1 Warn Quick brown fox Error\");| ts.TraceInformation(\"Mary had {0} lamb\", \"a little\");| AssertDebugLastMessage(\"debug\", \"MySource1 Warn Quick brown fox Error\");| }"
      },
      {
        "name": "GlobalAllFilterTraceTest",
        "body": "{| try| {| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", Filter = new EventTypeFilter(SourceLevels.Verbose) });| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| Trace.WriteLine(\"Quick brown fox\");| AssertDebugLastMessage(\"debug\", \"Logger1 Debug Quick brown fox \");| Trace.WriteLine(new ArgumentException(\"Mary had a little lamb\"));| AssertDebugLastMessage(\"debug\", \"Logger1 Debug System.ArgumentException: Mary had a little lamb \");| Trace.Write(\"Quick brown fox\");| AssertDebugLastMessage(\"debug\", \"Logger1 Debug Quick brown fox \");| Trace.Write(new ArgumentException(\"Mary had a little lamb\"));| AssertDebugLastMessage(\"debug\", \"Logger1 Debug System.ArgumentException: Mary had a little lamb \");| Trace.Flush();| }| finally| {| Trace.Listeners.Clear();| }| }"
      },
      {
        "name": "GlobalInfoFilterTraceTest",
        "body": "{| try| {| Trace.Listeners.Clear();| Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", Filter = new EventTypeFilter(SourceLevels.Information) });| LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"| <nlog>| <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='debug' />| </rules>| </nlog>\");| Trace.TraceInformation(\"Mary had a little lamb\");| AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb Information\");| Trace.WriteLine(\"Quick brown fox\");| AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb Information\");| Trace.WriteLine(new ArgumentException(\"Mary had a little lamb\"));| AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb Information\");| Trace.Write(\"Quick brown fox\");| AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb Information\");| Trace.Write(new ArgumentException(\"Mary had a little lamb\"));| AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb Information\");| Trace.Flush();| }| finally| {| Trace.Listeners.Clear();| }| }"
      },
      {
        "name": "TraceTargetWriteLineTest",
        "body": "{| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteToTrace(layout: \"${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}\", rawWrite: true);| }).GetLogger(\"MySource1\");| var sw = new System.IO.StringWriter();| try| {| Trace.Listeners.Clear();| Trace.Listeners.Add(new TextWriterTraceListener(sw));| foreach (var logLevel in LogLevel.AllLevels)| {| if (logLevel == LogLevel.Off)| continue;| logger.Log(logLevel, \"Quick brown fox\");| Trace.Flush();| Assert.Equal($\"MySource1 {logLevel} Quick brown fox \" + Environment.NewLine, sw.GetStringBuilder().ToString());| sw.GetStringBuilder().Length = 0;| }| Trace.Flush();| }| finally| {| Trace.Listeners.Clear();| }| }"
      }
    ]
  },
  {
    "file": "RegressionTests.cs",
    "methods": [
      {
        "name": "Bug4655UnableToReconfigureExistingLoggers",
        "body": "{| var debugTarget1 = new DebugTarget();| var debugTarget2 = new DebugTarget();| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(debugTarget1);| }).LogFactory;| var logger = logFactory.GetLogger(Guid.NewGuid().ToString(\"N\"));| logger.Info(\"foo\");| Assert.Equal(1, debugTarget1.Counter);| Assert.Equal(0, debugTarget2.Counter);| logFactory.Configuration.AddTarget(\"DesktopConsole\", debugTarget2);| logFactory.Configuration.LoggingRules.Add(new LoggingRule(\"*\", LogLevel.Debug, debugTarget2));| logFactory.ReconfigExistingLoggers();| logger.Info(\"foo\");| Assert.Equal(2, debugTarget1.Counter);| Assert.Equal(1, debugTarget2.Counter);| }"
      },
      {
        "name": "Bug5965StackOverflow",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"|<nlog xmlns='http://www.nlog-project.org/schemas/NLog.xsd'| xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>| <targets>| <target name='file' xsi:type='AsyncWrapper' queueLimit='5000' overflowAction='Discard' >| <target xsi:type='Debug'>| <layout xsi:type='CSVLayout'>| <column name='counter' layout='${counter}' />| <column name='time' layout='${longdate}' />| <column name='message' layout='${message}' />| </layout>| </target>| </target>| </targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='file' />| </rules>|</nlog>\").LogFactory;| var log = logFactory.GetLogger(\"x\");| log.Fatal(\"Test\");| Assert.NotNull(logFactory.Configuration);| logFactory.Configuration = null;| }"
      }
    ]
  },
  {
    "file": "AsyncTaskTargetTest.cs",
    "methods": [
      {
        "name": "AsyncTaskTarget_TestLogging",
        "body": "{| var asyncTarget = new AsyncTaskTestTarget { Layout = \"${threadid}|${level}|${message}|${mdlc:item=Test}\" };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| int managedThreadId = 0;| Task task;| using (ScopeContext.PushProperty(\"Test\", 42))| {| task = Task.Run(() =>| {| managedThreadId = CurrentManagedThreadId;| logger.Trace(\"TTT\");| logger.Debug(\"DDD\");| logger.Info(\"III\");| logger.Warn(\"WWW\");| logger.Error(\"EEE\");| logger.Fatal(\"FFF\");| });| }| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| task.Wait();| logger.Factory.Flush();| Assert.Equal(6, asyncTarget.Logs.Count);| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| Assert.StartsWith(managedThreadId.ToString() + \"|\", logEventMessage);| Assert.EndsWith(\"|42\", logEventMessage);| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_SkipAsyncTargetWrapper",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<AsyncTaskTestTarget>(\"AsyncTaskTest\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets async='true'>| <target name='asyncDebug' type='AsyncTaskTest' />| <target name='debug' type='Debug' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Assert.NotNull(logFactory.Configuration.FindTargetByName<AsyncTaskTestTarget>(\"asyncDebug\"));| Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.AsyncTargetWrapper>(\"debug\"));| }"
      },
      {
        "name": "AsyncTaskTarget_SkipDefaultAsyncWrapper",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<AsyncTaskTestTarget>(\"AsyncTaskTest\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <default-wrapper type='AsyncWrapper' />| <target name='asyncDebug' type='AsyncTaskTest' />| <target name='debug' type='Debug' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Assert.NotNull(logFactory.Configuration.FindTargetByName<AsyncTaskTestTarget>(\"asyncDebug\"));| Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.AsyncTargetWrapper>(\"debug\"));| }"
      },
      {
        "name": "AsyncTaskTarget_AllowDefaultBufferWrapper",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<AsyncTaskTestTarget>(\"AsyncTaskTest\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <default-wrapper type='BufferingWrapper' />| <target name='asyncDebug' type='AsyncTaskTest' />| <target name='debug' type='Debug' />| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.BufferingTargetWrapper>(\"asyncDebug\"));| Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.BufferingTargetWrapper>(\"debug\"));| }"
      },
      {
        "name": "AsyncTaskTarget_TestAsyncException",
        "body": "{| var asyncTarget = new AsyncTaskTestTarget| {| Layout = \"${level}\",| RetryDelayMilliseconds = 50| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| foreach (var logLevel in LogLevel.AllLoggingLevels)| logger.Log(logLevel, logLevel == LogLevel.Debug ? \"ASYNCEXCEPTION\" : logLevel.Name.ToUpperInvariant());| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);| int ordinal = 0;| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| var logLevel = LogLevel.FromString(logEventMessage);| Assert.NotEqual(LogLevel.Debug, logLevel);| Assert.Equal(ordinal++, logLevel.Ordinal);| if (ordinal == LogLevel.Debug.Ordinal)| ++ordinal;| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestTimeout",
        "body": "{| RetryingIntegrationTest(3, () =>| {| var asyncTarget = new AsyncTaskTestTarget| {| Layout = \"${level}\",| TaskTimeoutSeconds = 1| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| logger.Trace(\"TTT\");| logger.Debug(\"TIMEOUT\");| logger.Info(\"III\");| logger.Warn(\"WWW\");| logger.Error(\"EEE\");| logger.Fatal(\"FFF\");| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(5, asyncTarget.Logs.Count);| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| Assert.DoesNotContain(\"Debug|\", logEventMessage);| }| logger.Factory.Configuration = null;| });| }"
      },
      {
        "name": "AsyncTaskTarget_TestRetryAsyncException",
        "body": "{| var asyncTarget = new AsyncTaskTestTarget| {| Layout = \"${level}\",| RetryDelayMilliseconds = 10,| RetryCount = 3| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| foreach (var logLevel in LogLevel.AllLoggingLevels)| logger.Log(logLevel, logLevel == LogLevel.Debug ? \"ASYNCEXCEPTION\" : logLevel.Name.ToUpperInvariant());| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);| Assert.Equal(LogLevel.MaxLevel.Ordinal + 4, asyncTarget.WriteTasks);| int ordinal = 0;| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| var logLevel = LogLevel.FromString(logEventMessage);| Assert.NotEqual(LogLevel.Debug, logLevel);| Assert.Equal(ordinal++, logLevel.Ordinal);| if (ordinal == LogLevel.Debug.Ordinal)| ++ordinal;| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestRetryException",
        "body": "{| var asyncTarget = new AsyncTaskTestTarget| {| Layout = \"${level}\",| RetryDelayMilliseconds = 10,| RetryCount = 3| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| foreach (var logLevel in LogLevel.AllLoggingLevels)| logger.Log(logLevel, logLevel == LogLevel.Debug ? \"EXCEPTION\" : logLevel.Name.ToUpperInvariant());| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);| Assert.Equal(LogLevel.MaxLevel.Ordinal + 4, asyncTarget.WriteTasks);| int ordinal = 0;| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| var logLevel = LogLevel.FromString(logEventMessage);| Assert.NotEqual(LogLevel.Debug, logLevel);| Assert.Equal(ordinal++, logLevel.Ordinal);| if (ordinal == LogLevel.Debug.Ordinal)| ++ordinal;| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestFallbackException",
        "body": "{| var asyncTarget = new AsyncTaskTestTarget| {| Layout = \"${level}\",| RetryDelayMilliseconds = 10,| RetryCount = 1| };| var fallbacKTarget = new MemoryTarget() { Layout = \"${level}\" };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget).WithFallback(fallbacKTarget);| }).GetCurrentClassLogger();| foreach (var logLevel in LogLevel.AllLoggingLevels)| logger.Log(logLevel, logLevel == LogLevel.Debug ? \"EXCEPTION\" : logLevel.Name.ToUpperInvariant());| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);| Assert.Equal(LogLevel.MaxLevel.Ordinal + 2, asyncTarget.WriteTasks);| Assert.Single(fallbacKTarget.Logs);| Assert.Equal(LogLevel.Debug.ToString(), fallbacKTarget.Logs[0]);| int ordinal = 0;| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| var logLevel = LogLevel.FromString(logEventMessage);| Assert.NotEqual(LogLevel.Debug, logLevel);| Assert.Equal(ordinal++, logLevel.Ordinal);| if (ordinal == LogLevel.Debug.Ordinal)| ++ordinal;| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestBatchWriting",
        "body": "{| var asyncTarget = new AsyncTaskBatchTestTarget| {| Layout = \"${level}\",| BatchSize = 3,| TaskDelayMilliseconds = 10| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| foreach (var logLevel in LogLevel.AllLoggingLevels)| logger.Log(logLevel, logLevel.Name.ToUpperInvariant());| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(LogLevel.MaxLevel.Ordinal + 1, asyncTarget.Logs.Count);| Assert.Equal(LogLevel.MaxLevel.Ordinal / 2, asyncTarget.WriteTasks);| int ordinal = 0;| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| var logLevel = LogLevel.FromString(logEventMessage);| Assert.Equal(ordinal++, logLevel.Ordinal);| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestBatchRetryTimings",
        "body": "{| var asyncTarget = new AsyncTaskBatchExceptionTestTarget| {| Layout = \"${level}\",| BatchSize = 10,| TaskDelayMilliseconds = 10,| RetryCount = 5,| RetryDelayMilliseconds = 3| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| logger.Log(LogLevel.Info, \"test\");| logger.Factory.Flush();| // The zero at the end of the array is used when there will be no more retries.| Assert.Equal(new[] { 3, 6, 12, 24, 48, 0 }, asyncTarget.retryDelayLog);| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestFakeBatchWriting",
        "body": "{| var asyncTarget = new AsyncTaskTestTarget| {| Layout = \"${level}\",| BatchSize = 3,| TaskDelayMilliseconds = 10| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| foreach (var logLevel in LogLevel.AllLoggingLevels)| logger.Log(logLevel, logLevel.Name.ToUpperInvariant());| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| logger.Factory.Flush();| Assert.Equal(LogLevel.MaxLevel.Ordinal + 1, asyncTarget.Logs.Count);| Assert.Equal(LogLevel.MaxLevel.Ordinal + 1, asyncTarget.WriteTasks);| int ordinal = 0;| while (asyncTarget.Logs.TryDequeue(out var logEventMessage))| {| var logLevel = LogLevel.FromString(logEventMessage);| Assert.Equal(ordinal++, logLevel.Ordinal);| }| logger.Factory.Configuration = null;| }"
      },
      {
        "name": "AsyncTaskTarget_TestSlowBatchWriting",
        "body": "{| var asyncTarget = new AsyncTaskBatchTestTarget| {| Layout = \"${level}\",| TaskDelayMilliseconds = 200| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| DateTime utcNow = DateTime.UtcNow;| logger.Log(LogLevel.Info, LogLevel.Info.ToString().ToUpperInvariant());| logger.Log(LogLevel.Fatal, \"SLEEP\");| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.Single(asyncTarget.Logs);| logger.Log(LogLevel.Error, LogLevel.Error.ToString().ToUpperInvariant());| asyncTarget.Dispose(); // Trigger fast shutdown| logger.Factory.Configuration = null;| TimeSpan shutdownTime = DateTime.UtcNow - utcNow;| Assert.True(shutdownTime < TimeSpan.FromSeconds(4), $\"Shutdown took {shutdownTime.TotalMilliseconds} msec\");| }"
      },
      {
        "name": "AsyncTaskTarget_TestThrottleOnTaskDelay",
        "body": "{| var asyncTarget = new AsyncTaskBatchTestTarget| {| Layout = \"${level}\",| TaskDelayMilliseconds = 50,| BatchSize = 10,| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncTarget);| }).GetCurrentClassLogger();| for (int i = 0; i < 5; ++i)| {| for (int j = 0; j < 10; ++j)| {| logger.Log(LogLevel.Info, i.ToString());| Thread.Sleep(20);| }| Assert.True(asyncTarget.WaitForWriteEvent());| }| Assert.True(asyncTarget.Logs.Count > 25, $\"{asyncTarget.Logs.Count} LogEvents are too few after {asyncTarget.WriteTasks} writes\");| Assert.True(asyncTarget.WriteTasks < 20, $\"{asyncTarget.WriteTasks} writes are too many.\");| }"
      },
      {
        "name": "AsynTaskTarget_AutoFlushWrapper",
        "body": "{| var asyncTarget = new AsyncTaskBatchTestTarget| {| Layout = \"${level}\",| TaskDelayMilliseconds = 5000,| BatchSize = 10,| };| var autoFlush = new NLog.Targets.Wrappers.AutoFlushTargetWrapper(\"autoflush\", asyncTarget);| autoFlush.Condition = \"level > LogLevel.Warn\";| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(autoFlush);| }).GetCurrentClassLogger();| logger.Info(\"Hello World\");| Assert.Empty(asyncTarget.Logs);| logger.Error(\"Goodbye World\");| Assert.True(asyncTarget.WaitForWriteEvent());| Assert.NotEmpty(asyncTarget.Logs);| }"
      },
      {
        "name": "AsyncTaskTarget_FlushWhenBlocked",
        "body": "{| // Arrange| var logFactory = new LogFactory();| var logConfig = new LoggingConfiguration(logFactory);| var asyncTarget = new AsyncTaskBatchTestTarget| {| Layout = \"${level}\",| TaskDelayMilliseconds = 10000,| BatchSize = 10,| QueueLimit = 10,| OverflowAction = NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction.Block,| };| logConfig.AddRuleForAllLevels(asyncTarget);| logFactory.Configuration = logConfig;| var logger = logFactory.GetLogger(nameof(AsyncTaskTarget_FlushWhenBlocked));| // Act| for (int i = 0; i < 10; ++i)| logger.Info(\"Testing {0}\", i);| logFactory.Flush(TimeSpan.FromSeconds(5));| // Assert| Assert.Equal(1, asyncTarget.WriteTasks);| }"
      },
      {
        "name": "AsyncTaskTarget_MissingDependency_EnqueueLogEvents",
        "body": "{| using (new NoThrowNLogExceptions())| {| // Arrange| var logFactory = new LogFactory();| logFactory.ThrowConfigExceptions = true;| var logConfig = new LoggingConfiguration(logFactory);| var asyncTarget = new AsyncTaskTestTarget() { Name = \"asynctarget\", RequiredDependency = typeof(IMisingDependencyClass) };| logConfig.AddRuleForAllLevels(asyncTarget);| logFactory.Configuration = logConfig;| var logger = logFactory.GetLogger(nameof(AsyncTaskTarget_MissingDependency_EnqueueLogEvents));| // Act| logger.Info(\"Hello World\");| Assert.False(asyncTarget.WaitForWriteEvent(50));| logFactory.ServiceRepository.RegisterService(typeof(IMisingDependencyClass), new MisingDependencyClass());| // Assert| Assert.True(asyncTarget.WaitForWriteEvent());| }| }"
      }
    ]
  },
  {
    "file": "ConsoleTargetTests.cs",
    "methods": [
      {
        "name": "ConsoleOutWriteLineTest",
        "body": "{| ConsoleOutTest(false);| }"
      },
      {
        "name": "ConsoleOutWriteBufferTest",
        "body": "{| ConsoleOutTest(true);| }"
      },
      {
        "name": "ConsoleErrorTest",
        "body": "{| var target = new ConsoleTarget()| {| Header = \"-- header --\",| Layout = \"${logger} ${message}\",| Footer = \"-- footer --\",| StdErr = true,| };| var consoleErrorWriter = new StringWriter();| TextWriter oldConsoleErrorWriter = Console.Error;| Console.SetError(consoleErrorWriter);| try| {| var exceptions = new List<Exception>();| target.Initialize(null);| target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message1\").WithContinuation(exceptions.Add));| target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message2\").WithContinuation(exceptions.Add));| target.WriteAsyncLogEvents(| new LogEventInfo(LogLevel.Info, \"Logger1\", \"message3\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"message4\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"message5\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"message6\").WithContinuation(exceptions.Add));| Assert.Equal(6, exceptions.Count);| target.Flush((ex) => { });| target.Close();| }| finally| {| Console.SetError(oldConsoleErrorWriter);| }| string expectedResult = string.Format(\"-- header --{0}Logger1 message1{0}Logger1 message2{0}Logger1 message3{0}Logger2 message4{0}Logger2 message5{0}Logger1 message6{0}-- footer --{0}\", Environment.NewLine);| Assert.Equal(expectedResult, consoleErrorWriter.ToString());| }"
      },
      {
        "name": "SetupBuilder_WriteToConsole",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfiguration(c =>| {| c.ForLogger().FilterMinLevel(LogLevel.Error).WriteToConsole(\"${message}\", stderr: true);| }).LogFactory;| var consoleErrorWriter = new StringWriter();| TextWriter oldConsoleErrorWriter = Console.Error;| Console.SetError(consoleErrorWriter);| try| {| logFactory.GetCurrentClassLogger().Error(\"Abort\");| logFactory.GetCurrentClassLogger().Info(\"Continue\");| }| finally| {| Console.SetError(oldConsoleErrorWriter);| }| Assert.Equal($\"Abort{System.Environment.NewLine}\", consoleErrorWriter.ToString());| }"
      },
      {
        "name": "ConsoleEncodingTest",
        "body": "{| var consoleOutputEncoding = Console.OutputEncoding;| var target = new ConsoleTarget()| {| Header = \"-- header --\",| Layout = \"${logger} ${message}\",| Footer = \"-- footer --\",| Encoding = System.Text.Encoding.UTF8| };| Assert.Equal(System.Text.Encoding.UTF8, target.Encoding);| var consoleOutWriter = new StringWriter();| TextWriter oldConsoleOutWriter = Console.Out;| Console.SetOut(consoleOutWriter);| try| {| var exceptions = new List<Exception>();| target.Initialize(null);| // Not really testing whether Console.OutputEncoding works, but just that it is configured without breaking ConsoleTarget| Assert.Equal(System.Text.Encoding.UTF8, Console.OutputEncoding);| Assert.Equal(System.Text.Encoding.UTF8, target.Encoding);| target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message1\").WithContinuation(exceptions.Add));| target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message2\").WithContinuation(exceptions.Add));| Assert.Equal(2, exceptions.Count);| target.Encoding = consoleOutputEncoding;| Assert.Equal(consoleOutputEncoding, Console.OutputEncoding);| target.Close();| }| finally| {| Console.OutputEncoding = consoleOutputEncoding;| Console.SetOut(oldConsoleOutWriter);| }| string expectedResult = string.Format(\"-- header --{0}Logger1 message1{0}Logger1 message2{0}-- footer --{0}\", Environment.NewLine);| Assert.Equal(expectedResult, consoleOutWriter.ToString());| }"
      },
      {
        "name": "ConsoleRaceCondtionIgnoreTest",
        "body": "{| var configXml = @\"| <nlog throwExceptions='true'>| <targets>| <target name='console' type='console' layout='${message}' />| <target name='consoleError' type='console' layout='${message}' error='true' />| </targets>| <rules>| <logger name='*' minlevel='Trace' writeTo='console,consoleError' />| </rules>| </nlog>\";| var success = ConsoleRaceCondtionIgnoreInnerTest(configXml);| Assert.True(success);| }"
      }
    ]
  },
  {
    "file": "DebugSystemTargetTests.cs",
    "methods": [
      {
        "name": "DebugWriteLineTest",
        "body": "{| var sw = new System.IO.StringWriter();| try| {| // Arrange|#if NETFRAMEWORK| Debug.Listeners.Clear();| Debug.Listeners.Add(new TextWriterTraceListener(sw));|#endif| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteToDebug();| }).LogFactory;| // Act| logFactory.GetCurrentClassLogger().Info(\"Hello World\");| // Assert| Assert.Single(logFactory.Configuration.AllTargets);|#if NETFRAMEWORK| Assert.Contains(\"Hello World\", sw.ToString());|#endif| }| finally| {|#if NETFRAMEWORK| Debug.Listeners.Clear();|#endif| }| }"
      },
      {
        "name": "DebugWriteLineHeaderFooterTest",
        "body": "{| var sw = new System.IO.StringWriter();| try| {| // Arrange|#if NETFRAMEWORK| Debug.Listeners.Clear();| Debug.Listeners.Add(new TextWriterTraceListener(sw));|#endif| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <target type='debugsystem' name='Debug' layout='${message}'>| <header>Startup</header>| <footer>Shutdown</footer>| </target>| </targets>| <rules>| <logger name='*' writeTo='Debug' />| </rules>| </nlog>\").LogFactory;| // Act| logFactory.GetCurrentClassLogger().Info(\"Hello World\");| // Assert| Assert.Single(logFactory.Configuration.AllTargets);|#if NETFRAMEWORK| Assert.Contains(\"Startup\", sw.ToString());| Assert.Contains(\"Hello World\", sw.ToString());| Assert.DoesNotContain(\"Shutdown\", sw.ToString());| logFactory.Shutdown();| Assert.Contains(\"Shutdown\", sw.ToString());|#endif| }| finally| {|#if NETFRAMEWORK| Debug.Listeners.Clear();|#endif| }| }"
      }
    ]
  },
  {
    "file": "DefaultJsonSerializerClassTests.cs",
    "methods": [
      {
        "name": "SimpleValue_RegistersSerializeAsToString_ConvertsValue",
        "body": "{| var logFactory = new LogFactory();| logFactory.Setup().SetupSerialization(s => s.RegisterObjectTransformation<System.IO.MemoryStream>(o => o.Capacity));| var testObject = new System.IO.MemoryStream(42);| var sb = new StringBuilder();| var options = new JsonSerializeOptions();| var jsonSerializer = new DefaultJsonSerializer(logFactory.ServiceRepository);| jsonSerializer.SerializeObject(testObject, sb, options);| Assert.Equal($\"{testObject.Capacity}\", sb.ToString());| }"
      },
      {
        "name": "IExcludedInterfaceSerializer_RegistersSerializeAsToString_InvokesToString",
        "body": "{| var testObject = BuildSampleObject();| var sb = new StringBuilder();| var options = new JsonSerializeOptions();| var logFactory = new LogFactory();| logFactory.Setup().SetupSerialization(s => s.RegisterObjectTransformation<IExcludedInterface>(o => o.ToString()));| var jsonSerializer = new DefaultJsonSerializer(logFactory.ServiceRepository);| jsonSerializer.SerializeObject(testObject, sb, options);| const string expectedValue =| @\"{\"\"S\"\":\"\"sample\"\", \"\"Excluded\"\":\"\"Skipped\"\", \"\"Included\"\":{\"\"IncludedString\"\":\"\"serialized\"\"}}\";| Assert.Equal(expectedValue, sb.ToString());| }"
      },
      {
        "name": "ExcludedClassSerializer_RegistersSerializeAsToString_InvokesToString",
        "body": "{| var testObject = BuildSampleObject();| var sb = new StringBuilder();| var options = new JsonSerializeOptions();| var logFactory = new LogFactory();| logFactory.Setup().SetupSerialization(s => s.RegisterObjectTransformation(typeof(ExcludedClass), o => o.ToString()));| var jsonSerializer = new DefaultJsonSerializer(logFactory.ServiceRepository);| jsonSerializer.SerializeObject(testObject, sb, options);| const string expectedValue =| @\"{\"\"S\"\":\"\"sample\"\", \"\"Excluded\"\":\"\"Skipped\"\", \"\"Included\"\":{\"\"IncludedString\"\":\"\"serialized\"\"}}\";| Assert.Equal(expectedValue, sb.ToString());| }"
      }
    ]
  },
  {
    "file": "DefaultJsonSerializerLegacyTests.cs",
    "methods": [
      {
        "name": "SerializeEnumInt_Test",
        "body": "{| var val = ExceptionRenderingFormat.Method;| var actual = SerializeObjectWithOptions(val, new JsonSerializeOptions() { EnumAsInteger = true });| Assert.Equal(\"4\", actual);| }"
      }
    ]
  },
  {
    "file": "DefaultJsonSerializerTestsBase.cs",
    "methods": [
      {
        "name": "SingleLineString_Test",
        "body": "{| var text = \"This is, sort of, surprising the 1. time you see that test-result.\";| var expected = \"\\\"This is, sort of, surprising the 1. time you see that test-result.\\\"\";| var actual = SerializeObject(text);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "MultiLineString_Test",
        "body": "{| var text = \"First line followed by Windows line break\\r\\nNow this is second with UNIX\\nand third at last\";| var expected = \"\\\"First line followed by Windows line break\\\\r\\\\nNow this is second with UNIX\\\\nand third at last\\\"\";| var actual = SerializeObject(text);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "StringWithTabBackSpaceFormfeed_Test",
        "body": "{| var text = \"A tab\\tis followed by a feed\\fand finally cancel last character\\b\";| var expected = \"\\\"A tab\\\\tis followed by a feed\\\\fand finally cancel last character\\\\b\\\"\";| var actual = SerializeObject(text);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "StringWithSlashAndQuotes_Test",
        "body": "{| var text = \"This sentence/text is \\\"normal\\\", we think.\";| var expected = \"\\\"This sentence/text is \\\\\\\"normal\\\\\\\", we think.\\\"\";| var actual = SerializeObject(text);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "SerializeUnicode_test",
        "body": "{| var actual = SerializeObject(\"\");| Assert.Equal(\"\\\"\\\"\", actual);| }"
      },
      {
        "name": "SerializeUnicodeInAnomObject_test",
        "body": "{| var item = new| {| text = \"\"| };| var actual = SerializeObject(item);| Assert.Equal(\"{\\\"text\\\":\\\"\\\"}\", actual);| }"
      },
      {
        "name": "ReferenceLoopInDictionary_Test",
        "body": "{| var d = new Dictionary<string, object>();| d.Add(\"First\", 17);| d.Add(\"Loop\", d);| var target = new Dictionary<string, object>| {| {\"Name\", \"TestObject\" },| {\"Assets\" , d }| };| var expected = \"{\\\"Name\\\":\\\"TestObject\\\",\\\"Assets\\\":{\\\"First\\\":17}}\";| var actual = SerializeObject(target);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "ReferenceLoopInList_Test",
        "body": "{| var d = new List<object>();| d.Add(17);| d.Add(d);| d.Add(3.14);| var target = new List<object>| {| {\"TestObject\" },| {d }| };| var expected = \"[\\\"TestObject\\\",[17,3.14]]\";| var actual = SerializeObject(target);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "InfiniteLoop_Test",
        "body": "{| var d = new TestList();| var actual = SerializeObject(d);| var cnt = Regex.Matches(actual, \"\\\\[\\\"alpha\\\",\\\"bravo\\\"\\\\]\").Count;| Assert.Equal(10, cnt);| }"
      },
      {
        "name": "StringWithMixedControlCharacters_Test",
        "body": "{| var text = \"First\\\\Second\\tand\" + (char)3 + \"for\" + (char)0x1f + \"with\" + (char)0x10 + \"but\" + (char)0x0d + \"and no\" + (char)0x20;| var expected = \"\\\"First\\\\\\\\Second\\\\tand\\\\u0003for\\\\u001fwith\\\\u0010but\\\\rand no \\\"\";| var actual = SerializeObject(text);| Assert.Equal(expected, actual);| }"
      },
      {
        "name": "SerializeBool_Test",
        "body": "{| var actual = SerializeObject(true);| Assert.Equal(\"true\", actual);| actual = SerializeObject(false);| Assert.Equal(\"false\", actual);| }"
      },
      {
        "name": "SerializeNumberDecimal_Test",
        "body": "{| var actual = SerializeObject(-1M);| Assert.Equal(\"-1.0\", actual);| actual = SerializeObject(0M);| Assert.Equal(\"0.0\", actual);| actual = SerializeObject(1M);| Assert.Equal(\"1.0\", actual);| actual = SerializeObject(2M);| Assert.Equal(\"2.0\", actual);| actual = SerializeObject(3M);| Assert.Equal(\"3.0\", actual);| actual = SerializeObject(4M);| Assert.Equal(\"4.0\", actual);| actual = SerializeObject(5M);| Assert.Equal(\"5.0\", actual);| actual = SerializeObject(6M);| Assert.Equal(\"6.0\", actual);| actual = SerializeObject(7M);| Assert.Equal(\"7.0\", actual);| actual = SerializeObject(8M);| Assert.Equal(\"8.0\", actual);| actual = SerializeObject(9M);| Assert.Equal(\"9.0\", actual);| actual = SerializeObject(3.14159265M);| Assert.Equal(\"3.14159265\", actual);| }"
      },
      {
        "name": "SerializeDateTime_Test",
        "body": "{| DateTime utcNow = DateTime.UtcNow;| utcNow = utcNow.AddTicks(-utcNow.Ticks % TimeSpan.TicksPerSecond);| var actual = SerializeObject(utcNow);| Assert.Equal(\"\\\"\" + utcNow.ToString(\"yyyy-MM-ddTHH:mm:ssZ\", CultureInfo.InvariantCulture) + \"\\\"\", actual);| }"
      },
      {
        "name": "SerializeDateTime_Test2",
        "body": "{| var culture = System.Threading.Thread.CurrentThread.CurrentCulture;| try| {| System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-GB\"); // uses \".\" instead of \":\" for time| var val = new DateTime(2016, 12, 31);| var actual = SerializeObject(val);| Assert.Equal(\"\\\"\" + \"2016-12-31T00:00:00Z\" + \"\\\"\", actual);| }| finally| {| // Restore| System.Threading.Thread.CurrentThread.CurrentCulture = culture;| }| }"
      },
      {
        "name": "SerializeDateTimeOffset_Test",
        "body": "{| var culture = System.Threading.Thread.CurrentThread.CurrentCulture;| try| {| System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-GB\"); // uses \".\" instead of \":\" for time| var val = new DateTimeOffset(new DateTime(2016, 12, 31, 2, 30, 59), new TimeSpan(4, 30, 0));| var actual = SerializeObject(val);| Assert.Equal(\"\\\"\" + \"2016-12-31 02:30:59 +04:30\" + \"\\\"\", actual);| }| finally| {| // Restore| System.Threading.Thread.CurrentThread.CurrentCulture = culture;| }| }"
      },
      {
        "name": "SerializeTime_Test",
        "body": "{| var actual = SerializeObject(new TimeSpan(1, 2, 3, 4));| Assert.Equal(\"\\\"1.02:03:04\\\"\", actual);| }"
      },
      {
        "name": "SerializeTime2_Test",
        "body": "{| var actual = SerializeObject(new TimeSpan(0, 2, 3, 4));| Assert.Equal(\"\\\"02:03:04\\\"\", actual);| }"
      },
      {
        "name": "SerializeTime3_Test",
        "body": "{| var culture = System.Threading.Thread.CurrentThread.CurrentCulture;| try| {| System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-GB\"); // uses \".\" instead of \":\" for time| var actual = SerializeObject(new TimeSpan(0, 0, 2, 3, 4));| Assert.Equal(\"\\\"00:02:03.0040000\\\"\", actual);| }| finally| {| // Restore| System.Threading.Thread.CurrentThread.CurrentCulture = culture;| }| }"
      },
      {
        "name": "SerializeEmptyDict_Test",
        "body": "{| var actual = SerializeObject(new Dictionary<string, int>());| Assert.Equal(\"{}\", actual);| }"
      },
      {
        "name": "SerializeDict_Test",
        "body": "{| var dictionary = new Dictionary<string, object>();| dictionary.Add(\"key1\", 13);| dictionary.Add(\"key 2\", 1.3m);| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"key1\\\":13,\\\"key 2\\\":1.3}\", actual);| }"
      },
      {
        "name": "SerializeCustomNullDict_Test",
        "body": "{| var dictionary = new Dictionary<string, object>();| dictionary.Add(\"key1\", 13);| dictionary.Add(\"key 2\", new CustomNullProperty());| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"key1\\\":13,\\\"key 2\\\":null}\", actual);| }"
      },
      {
        "name": "SerializeTrickyDict_Test",
        "body": "{| IDictionary<object, object> dictionary = new Internal.TrickyTestDictionary();| dictionary.Add(\"key1\", 13);| dictionary.Add(\"key 2\", 1.3m);| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"key1\\\":13,\\\"key 2\\\":1.3}\", actual);| }"
      },
      {
        "name": "SerializeExpandoDict_Test",
        "body": "{| IDictionary<string, IFormattable> dictionary = new Internal.ExpandoTestDictionary();| dictionary.Add(\"key 2\", 1.3m);| dictionary.Add(\"level\", LogLevel.Info);| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"key 2\\\":1.3, \\\"level\\\":\\\"Info\\\"}\", actual);| }"
      },
      {
        "name": "SerializEmptyExpandoDict_Test",
        "body": "{| IDictionary<string, IFormattable> dictionary = new Internal.ExpandoTestDictionary();| var actual = SerializeObject(dictionary);| Assert.Equal(\"{}\", actual);| }"
      },
      {
        "name": "SerializeReadOnlyExpandoDict_Test",
        "body": "{| var dictionary = new Dictionary<string, object>();| dictionary.Add(\"key 2\", 1.3m);| dictionary.Add(\"level\", LogLevel.Info);| var readonlyDictionary = new Internal.ReadOnlyExpandoTestDictionary(dictionary);| var actual = SerializeObject(readonlyDictionary);| Assert.Equal(\"{\\\"key 2\\\":1.3, \\\"level\\\":\\\"Info\\\"}\", actual);| }"
      },
      {
        "name": "SerializeIntegerKeyDict_Test",
        "body": "{| var dictionary = new Dictionary<int, string>();| dictionary.Add(1, \"One\");| dictionary.Add(2, \"Two\");| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"1\\\":\\\"One\\\",\\\"2\\\":\\\"Two\\\"}\", actual);| }"
      },
      {
        "name": "SerializeEnumKeyDict_Test",
        "body": "{| var dictionary = new Dictionary<ExceptionRenderingFormat, int>();| dictionary.Add(ExceptionRenderingFormat.Method, 4);| dictionary.Add(ExceptionRenderingFormat.StackTrace, 5);| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"Method\\\":4,\\\"StackTrace\\\":5}\", actual);| }"
      },
      {
        "name": "SerializeObjectKeyDict_Test",
        "body": "{| var dictionary = new Dictionary<object, string>();| dictionary.Add(new { Name = \"Hello\" }, \"World\");| dictionary.Add(new { Name = \"Goodbye\" }, \"Money\");| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"{ Name = Hello }\\\":\\\"World\\\",\\\"{ Name = Goodbye }\\\":\\\"Money\\\"}\", actual);| }"
      },
      {
        "name": "SerializeBadStringKeyDict_Test",
        "body": "{| var dictionary = new Dictionary<string, string>();| dictionary.Add(\"\\t\", \"Tab\");| dictionary.Add(\"\\n\", \"Newline\");| var actual = SerializeObject(dictionary);| Assert.Equal(\"{\\\"\\\\t\\\":\\\"Tab\\\",\\\"\\\\n\\\":\\\"Newline\\\"}\", actual);| }"
      },
      {
        "name": "SerializeNull_Test",
        "body": "{| var actual = SerializeObject(null);| Assert.Equal(\"null\", actual);| }"
      },
      {
        "name": "SerializeGuid_Test",
        "body": "{| Guid newGuid = Guid.NewGuid();| var actual = SerializeObject(newGuid);| Assert.Equal(\"\\\"\" + newGuid.ToString() + \"\\\"\", actual);| }"
      },
      {
        "name": "SerializeEnum_Test",
        "body": "{| var val = ExceptionRenderingFormat.Method;| var actual = SerializeObject(val);| Assert.Equal(\"\\\"Method\\\"\", actual);| }"
      },
      {
        "name": "SerializeFlagEnum_Test",
        "body": "{| var val = UrlHelper.EscapeEncodingOptions.LegacyRfc2396 | UrlHelper.EscapeEncodingOptions.LowerCaseHex;| var actual = SerializeObject(val);| Assert.Equal(\"\\\"LegacyRfc2396, LowerCaseHex\\\"\", actual);| }"
      },
      {
        "name": "SerializeObject_Test",
        "body": "{| var object1 = new TestObject(\"object1\");| var object2 = new TestObject(\"object2\");| object1.Linked = object2;| var actual = SerializeObject(object1);| Assert.Equal(\"{\\\"Name\\\":\\\"object1\\\", \\\"Linked\\\":{\\\"Name\\\":\\\"object2\\\"}}\", actual);| }"
      },
      {
        "name": "SerializeRecusiveObject_Test",
        "body": "{| var object1 = new TestObject(\"object1\");| object1.Linked = object1;| var actual = SerializeObject(object1);| Assert.Equal(\"{\\\"Name\\\":\\\"object1\\\"}\", actual);| }"
      },
      {
        "name": "SerializeListObject_Test",
        "body": "{| var object1 = new TestObject(\"object1\");| var object2 = new TestObject(\"object2\");| object1.Linked = object2;| var list = new[] { object1, object2 };| var actual = SerializeObject(list);| Assert.Equal(\"[{\\\"Name\\\":\\\"object1\\\", \\\"Linked\\\":{\\\"Name\\\":\\\"object2\\\"}},{\\\"Name\\\":\\\"object2\\\"}]\", actual);| }"
      },
      {
        "name": "SerializeNoPropsObject_Test",
        "body": "{| var object1 = new NoPropsObject();| var actual = SerializeObject(object1);| Assert.Equal(\"\\\"something\\\"\", actual);| }"
      },
      {
        "name": "SerializeObjectWithExceptionAndPrivateSetter_Test",
        "body": "{| var object1 = new ObjectWithExceptionAndPrivateSetter(\"test name\");| var actual = SerializeObject(object1);| Assert.Equal(\"{\\\"Name\\\":\\\"test name\\\"}\", actual);| }"
      },
      {
        "name": "SerializeValueTuple_Test",
        "body": "{| // Could perform reflection on fields, but one have to lookup TupleElementNamesAttribute to get names| // ValueTuples are for internal usage, better to use AnonymousObject for key/value-pairs| var object1 = (Name: \"test name\", Id: 1);| var actual = SerializeObject(object1);| Assert.Equal(\"\\\"(test name, 1)\\\"\", actual);| }"
      },
      {
        "name": "SerializeAnonymousObject_Test",
        "body": "{| var object1 = new { Id = 123, Name = \"test name\" };| var actual = SerializeObject(object1);| Assert.Equal(\"{\\\"Id\\\":123, \\\"Name\\\":\\\"test name\\\"}\", actual);| }"
      },
      {
        "name": "SerializeExpandoObject_Test",
        "body": "{| dynamic object1 = new ExpandoObject();| object1.Id = 123;| object1.Name = \"test name\";| var actual = SerializeObject(object1);| Assert.Equal(\"{\\\"Id\\\":123, \\\"Name\\\":\\\"test name\\\"}\", actual);| }"
      },
      {
        "name": "SerializeDynamicObject_Test",
        "body": "{| var object1 = new MyDynamicClass();| var actual = SerializeObject(object1);| Assert.Equal(\"{\\\"Id\\\":123, \\\"Name\\\":\\\"test name\\\"}\", actual);| }"
      },
      {
        "name": "SingleItemOptimizedHashSetTest",
        "body": "{| var hashSet = default(NLog.Internal.SingleItemOptimizedHashSet<object>);| Assert.Empty(hashSet);| Assert.DoesNotContain(new object(), hashSet);| foreach (var obj in hashSet)| throw new Exception(\"Wrong\");| hashSet.Clear();| Assert.Empty(hashSet);| hashSet.Add(new object());| Assert.Single(hashSet);| hashSet.Add(new object());| Assert.Equal(2, hashSet.Count);| foreach (var obj in hashSet)| Assert.Contains(obj, hashSet);| object[] objArray = new object[2];| hashSet.CopyTo(objArray, 0);| foreach (var obj in objArray)| {| Assert.NotNull(obj);| hashSet.Remove(obj);| }| Assert.Empty(hashSet);| hashSet.Clear();| Assert.Empty(hashSet);| }"
      }
    ]
  },
  {
    "file": "LineEndingModeTests.cs",
    "methods": [
      {
        "name": "LineEndingModeEqualityTest",
        "body": "{| LineEndingMode modeDefault = LineEndingMode.Default;| LineEndingMode modeNone = LineEndingMode.None;| LineEndingMode modeLF = LineEndingMode.LF;| LineEndingMode modeCRLF = LineEndingMode.CRLF;| LineEndingMode modeNull = LineEndingMode.Null;| Assert.True(LineEndingMode.Default == modeDefault);| Assert.True(LineEndingMode.None == modeNone);| Assert.True(LineEndingMode.LF == modeLF);| Assert.True(LineEndingMode.Null == modeNull);| Assert.False(LineEndingMode.Default == modeNone);| Assert.False(LineEndingMode.None == modeLF);| Assert.False(LineEndingMode.None == modeCRLF);| Assert.False(LineEndingMode.None == modeNull);| Assert.False(LineEndingMode.None == (object)new { });| Assert.False(LineEndingMode.None is null);| Assert.True(LineEndingMode.Default.Equals(modeDefault));| Assert.True(LineEndingMode.None.Equals(modeNone));| Assert.True(LineEndingMode.LF.Equals(modeLF));| Assert.True(LineEndingMode.Null.Equals(modeNull));| Assert.False(LineEndingMode.Default.Equals(modeNone));| Assert.False(LineEndingMode.None.Equals(modeLF));| Assert.False(LineEndingMode.None.Equals(modeCRLF));| Assert.False(LineEndingMode.None.Equals(modeNull));| Assert.False(LineEndingMode.None.Equals(new { }));| Assert.False(LineEndingMode.None.Equals(null));| // Handle running tests on different operating systems| if (modeCRLF.NewLineCharacters == Environment.NewLine)| {| Assert.False(LineEndingMode.LF == modeDefault);| Assert.True(LineEndingMode.CRLF == modeDefault);| }| else| {| Assert.True(LineEndingMode.LF == modeDefault);| Assert.False(LineEndingMode.CRLF == modeDefault);| }| }"
      },
      {
        "name": "LineEndingModeInequalityTest",
        "body": "{| LineEndingMode modeDefault = LineEndingMode.Default;| LineEndingMode modeNone = LineEndingMode.None;| LineEndingMode modeLF = LineEndingMode.LF;| LineEndingMode modeCRLF = LineEndingMode.CRLF;| LineEndingMode modeNull = LineEndingMode.Null;| Assert.True(LineEndingMode.Default != modeNone);| Assert.True(LineEndingMode.None != modeLF);| Assert.True(LineEndingMode.None != modeCRLF);| Assert.True(LineEndingMode.None != modeNull);| Assert.False(LineEndingMode.Default != modeDefault);| Assert.False(LineEndingMode.None != modeNone);| Assert.False(LineEndingMode.LF != modeLF);| Assert.False(LineEndingMode.CRLF != modeCRLF);| Assert.False(LineEndingMode.Null != modeNull);| Assert.True(null != LineEndingMode.LF);| Assert.True(null != modeLF);| Assert.True(LineEndingMode.LF != null);| Assert.True(modeLF != null);| Assert.True(null != LineEndingMode.CRLF);| Assert.True(null != modeCRLF);| Assert.True(LineEndingMode.CRLF != null);| Assert.True(modeCRLF != null);| Assert.True(null != LineEndingMode.Null);| Assert.True(null != modeNull);| Assert.True(LineEndingMode.Null != null);| Assert.True(modeNull != null);| // Handle running tests on different operating systems| if (modeCRLF.NewLineCharacters == Environment.NewLine)| {| Assert.True(LineEndingMode.LF != modeDefault);| }| else| {| Assert.True(LineEndingMode.CRLF != modeDefault);| }| }"
      },
      {
        "name": "LineEndingModeNullComparison",
        "body": "{| LineEndingMode mode1 = LineEndingMode.LF;| Assert.False(mode1 is null);| Assert.True(mode1 != null);| Assert.False(null == mode1);| Assert.True(null != mode1);| LineEndingMode mode2 = null;| Assert.True(mode2 is null);| Assert.False(mode2 != null);| Assert.True(null == mode2);| Assert.False(null != mode2);| }"
      },
      {
        "name": "LineEndingModeToStringTest",
        "body": "{| Assert.Equal(\"None\", LineEndingMode.None.ToString());| Assert.Equal(\"Default\", LineEndingMode.Default.ToString());| Assert.Equal(\"CRLF\", LineEndingMode.CRLF.ToString());| Assert.Equal(\"CR\", LineEndingMode.CR.ToString());| Assert.Equal(\"LF\", LineEndingMode.LF.ToString());| Assert.Equal(\"Null\", LineEndingMode.Null.ToString());| }"
      }
    ]
  },
  {
    "file": "MemoryTargetTests.cs",
    "methods": [
      {
        "name": "MemoryTarget_LogLevelTest",
        "body": "{| var memoryTarget = new MemoryTarget| {| Layout = \"${level} ${message}\"| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(memoryTarget);| }).GetCurrentClassLogger();| Assert.Empty(memoryTarget.Logs);| logger.Trace(\"TTT\");| logger.Debug(\"DDD\");| logger.Info(\"III\");| logger.Warn(\"WWW\");| logger.Error(\"EEE\");| logger.Fatal(\"FFF\");| logger.Factory.Configuration = null;| Assert.Equal(6, memoryTarget.Logs.Count);| Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);| Assert.Equal(\"Debug DDD\", memoryTarget.Logs[1]);| Assert.Equal(\"Info III\", memoryTarget.Logs[2]);| Assert.Equal(\"Warn WWW\", memoryTarget.Logs[3]);| Assert.Equal(\"Error EEE\", memoryTarget.Logs[4]);| Assert.Equal(\"Fatal FFF\", memoryTarget.Logs[5]);| }"
      },
      {
        "name": "MemoryTarget_ReconfigureTest_SameTarget_ExpectLogsEmptied",
        "body": "{| var memoryTarget = new MemoryTarget| {| Layout = \"${level} ${message}\"| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(memoryTarget);| }).GetCurrentClassLogger();| logger.Debug(\"DDD\");| logger.Info(\"III\");| logger.Warn(\"WWW\");| Assert.Equal(3, memoryTarget.Logs.Count);| Assert.Equal(\"Debug DDD\", memoryTarget.Logs[0]);| Assert.Equal(\"Info III\", memoryTarget.Logs[1]);| Assert.Equal(\"Warn WWW\", memoryTarget.Logs[2]);| logger.Factory.Configuration = null;| // Reconfigure the logger to use a new MemoryTarget.| memoryTarget = new MemoryTarget| {| Layout = \"${level} ${message}\"| };| logger.Factory.Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(memoryTarget);| }).GetCurrentClassLogger();| logger.Trace(\"TTT\");| logger.Error(\"EEE\");| logger.Fatal(\"FFF\");| Assert.Equal(3, memoryTarget.Logs.Count);| Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);| Assert.Equal(\"Error EEE\", memoryTarget.Logs[1]);| Assert.Equal(\"Fatal FFF\", memoryTarget.Logs[2]);| }"
      },
      {
        "name": "MemoryTarget_ClearLogsTest",
        "body": "{| var memoryTarget = new MemoryTarget| {| Layout = \"${level} ${message}\"| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(memoryTarget);| }).GetCurrentClassLogger();| logger.Warn(\"WWW\");| logger.Error(\"EEE\");| logger.Fatal(\"FFF\");| memoryTarget.Logs.Clear();| logger.Trace(\"TTT\");| logger.Debug(\"DDD\");| logger.Info(\"III\");| logger.Factory.Configuration = null;| Assert.Equal(3, memoryTarget.Logs.Count);| Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);| Assert.Equal(\"Debug DDD\", memoryTarget.Logs[1]);| Assert.Equal(\"Info III\", memoryTarget.Logs[2]);| Assert.True(memoryTarget.Logs.All(l => !string.IsNullOrEmpty(l)));| Assert.True(memoryTarget.Logs.Contains(memoryTarget.Logs[0]));| Assert.False(memoryTarget.Logs.Contains(string.Empty));| Assert.True(memoryTarget.Logs.Remove(memoryTarget.Logs[0]));| Assert.False(memoryTarget.Logs.Remove(string.Empty));| Assert.Equal(2, memoryTarget.Logs.Count);| Assert.Equal(0, memoryTarget.Logs.IndexOf(memoryTarget.Logs[0]));| Assert.Equal(1, memoryTarget.Logs.IndexOf(memoryTarget.Logs[1]));| Assert.Equal(-1, memoryTarget.Logs.IndexOf(string.Empty));| memoryTarget.Logs.RemoveAt(1);| Assert.Single(memoryTarget.Logs);| memoryTarget.Logs[0] = \"Hello World\";| Assert.Contains(\"Hello World\", memoryTarget.Logs);| memoryTarget.Logs.Insert(1, \"Goodbye World\");| Assert.Equal(\"Hello World\", memoryTarget.Logs[0]);| Assert.Equal(\"Goodbye World\", memoryTarget.Logs[1]);| Assert.Equal(2, memoryTarget.Logs.Count);| }"
      },
      {
        "name": "MemoryTarget_NullMessageTest",
        "body": "{| var memoryTarget = new MemoryTarget| {| Layout = \"${level} ${message}\"| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(memoryTarget);| }).GetCurrentClassLogger();| string nullMessage = null;| logger.Trace(\"TTT\");| logger.Debug((String)null);| logger.Info(\"III\");| logger.Warn(nullMessage);| logger.Error(\"EEE\");| logger.Factory.Configuration = null;| Assert.Equal(5, memoryTarget.Logs.Count);| Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);| Assert.Equal(\"Debug \", memoryTarget.Logs[1]);| Assert.Equal(\"Info III\", memoryTarget.Logs[2]);| Assert.Equal(\"Warn \", memoryTarget.Logs[3]);| Assert.Equal(\"Error EEE\", memoryTarget.Logs[4]);| }"
      },
      {
        "name": "MemoryTarget_EmptyMessageTest",
        "body": "{| var memoryTarget = new MemoryTarget| {| Layout = \"${level} ${message}\"| };| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(memoryTarget);| }).GetCurrentClassLogger();| logger.Trace(\"TTT\");| logger.Debug(String.Empty);| logger.Info(\"III\");| logger.Warn(\"\");| logger.Error(\"EEE\");| logger.Factory.Configuration = null;| Assert.Equal(5, memoryTarget.Logs.Count);| Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);| Assert.Equal(\"Debug \", memoryTarget.Logs[1]);| Assert.Equal(\"Info III\", memoryTarget.Logs[2]);| Assert.Equal(\"Warn \", memoryTarget.Logs[3]);| Assert.Equal(\"Error EEE\", memoryTarget.Logs[4]);| }"
      }
    ]
  },
  {
    "file": "MethodCallTests.cs",
    "methods": [
      {
        "name": "TestMethodCall1",
        "body": "{| TestMethodCall(new MethodCallRecord(\"StaticAndPublic\", \"test1\", 2), \"StaticAndPublic\", CorrectClassName);| }"
      },
      {
        "name": "TestMethodCall2",
        "body": "{| //Type AssemblyQualifiedName| //to find, use typeof(MethodCallTests).AssemblyQualifiedName| TestMethodCall(new MethodCallRecord(\"StaticAndPublic\", \"test1\", 2), \"StaticAndPublic\", \"NLog.UnitTests.Targets.MethodCallTests, NLog.UnitTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b793d3de60bec2b9\");| }"
      },
      {
        "name": "PrivateMethodDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"NonStaticAndPublic\", CorrectClassName);| }| }"
      },
      {
        "name": "WrongClassDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"StaticAndPublic\", \"NLog.UnitTests222.Targets.CallTest, NLog.UnitTests\");| }| }"
      },
      {
        "name": "WrongMethodDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"WrongStaticAndPublic\", CorrectClassName);| }| }"
      },
      {
        "name": "EmptyClassDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"\", \"\");| }| }"
      },
      {
        "name": "WrongParametersDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"StaticAndPublicWrongParameters\", CorrectClassName);| }| }"
      },
      {
        "name": "TooLessParametersDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"StaticAndPublicTooLessParameters\", CorrectClassName);| }| }"
      },
      {
        "name": "TooManyParametersDontThrow",
        "body": "{| using (new NoThrowNLogExceptions())| {| TestMethodCall(null, \"StaticAndPublicTooManyParameters\", CorrectClassName);| }| }"
      },
      {
        "name": "OptionalParameters",
        "body": "{| TestMethodCall(new MethodCallRecord(\"StaticAndPublicOptional\", \"test1\", 2, \"fixedValue\"), \"StaticAndPublicOptional\", CorrectClassName);| }"
      },
      {
        "name": "FluentDelegateConfiguration",
        "body": "{| string expectedMessage = \"Hello World\";| string actualMessage = string.Empty;| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| var target = new MethodCallTarget(\"Hello\", (logEvent, parameters) => { actualMessage = logEvent.Message; });| builder.ForLogger().WriteTo(target);| }).LogFactory;| logFactory.GetCurrentClassLogger().Debug(expectedMessage);| logFactory.GetCurrentClassLogger().Debug(expectedMessage); // Bonus call to verify compiled expression tree works| Assert.Equal(expectedMessage, actualMessage);| }"
      }
    ]
  },
  {
    "file": "TargetWithContextTest.cs",
    "methods": [
      {
        "name": "TargetWithContextAsyncTest",
        "body": "{| CustomTargetWithContext target = new CustomTargetWithContext();| target.ContextProperties.Add(new TargetPropertyWithContext(\"threadid\", \"${threadid}\"));| target.IncludeScopeProperties = true;| target.IncludeGdc = true;| target.IncludeScopeNested = true;| target.IncludeCallSite = true;| AsyncTargetWrapper wrapper = new AsyncTargetWrapper();| wrapper.WrappedTarget = target;| wrapper.TimeToSleepBetweenBatches = 0;| var logger = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(wrapper);| }).GetLogger(\"Example\");| GlobalDiagnosticsContext.Clear();| ScopeContext.Clear();| GlobalDiagnosticsContext.Set(\"TestKey\", \"Hello Global World\");| GlobalDiagnosticsContext.Set(\"GlobalKey\", \"Hello Global World\");| ScopeContext.PushProperty(\"TestKey\", \"Hello Async World\");| ScopeContext.PushProperty(\"AsyncKey\", \"Hello Async World\");| logger.Debug(\"log message\");| Assert.True(WaitForLastMessage(target));| Assert.NotEqual(0, target.LastMessage.Length);| Assert.NotNull(target.LastCombinedProperties);| Assert.NotEmpty(target.LastCombinedProperties);| Assert.Equal(5, target.LastCombinedProperties.Count);| Assert.Contains(new KeyValuePair<string, object>(\"GlobalKey\", \"Hello Global World\"), target.LastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"AsyncKey\", \"Hello Async World\"), target.LastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"TestKey\", \"Hello Async World\"), target.LastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"TestKey_1\", \"Hello Global World\"), target.LastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"threadid\", CurrentManagedThreadId.ToString()), target.LastCombinedProperties);| }"
      },
      {
        "name": "TargetWithContextMdcSerializeTest",
        "body": "{| MappedDiagnosticsContext.Clear();| MappedDiagnosticsContext.Set(\"TestKey\", new { a = \"b\" });| CustomTargetWithContext target = new CustomTargetWithContext() { IncludeMdc = true, SkipAssert = true };| WriteAndAssertSingleKey(target);| }"
      },
      {
        "name": "TargetWithContextMdlcSerializeTest",
        "body": "{| MappedDiagnosticsLogicalContext.Clear();| MappedDiagnosticsLogicalContext.Set(\"TestKey\", new { a = \"b\" });| CustomTargetWithContext target = new CustomTargetWithContext() { IncludeMdlc = true, SkipAssert = true };| WriteAndAssertSingleKey(target);| }"
      },
      {
        "name": "TargetWithContextNdcSerializeTest",
        "body": "{| NestedDiagnosticsContext.Clear();| NestedDiagnosticsContext.Push(new { a = \"b\" });| CustomTargetWithContext target = new CustomTargetWithContext() { IncludeNdc = true, SkipAssert = true };| WriteAndAssertSingleKey(target);| }"
      },
      {
        "name": "TargetWithContextNdlcSerializeTest",
        "body": "{| NestedDiagnosticsLogicalContext.Clear();| NestedDiagnosticsLogicalContext.Push(new { a = \"b\" });| CustomTargetWithContext target = new CustomTargetWithContext() { IncludeNdlc = true, SkipAssert = true };| WriteAndAssertSingleKey(target);| }"
      },
      {
        "name": "TargetWithContextConfigTest",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <target name='debug' type='contexttarget' includeCallSite='true'>| <contextproperty name='threadid' layout='${threadid}' hello='world' />| </target>| </targets>| <rules>| <logger name='*' levels='Error' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| ScopeContext.Clear();| logger.Error(\"log message\");| var target = logFactory.Configuration.FindTargetByName(\"debug\") as CustomTargetWithContext;| Assert.NotEqual(0, target.LastMessage.Length);| var lastCombinedProperties = target.LastCombinedProperties;| Assert.NotEmpty(lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"threadid\", CurrentManagedThreadId.ToString()), lastCombinedProperties);| }"
      },
      {
        "name": "TargetWithContextAsyncPropertyTest",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />| <target name='debug' type='contexttarget' includeCallSite='true' includeEventProperties='true' excludeProperties='password' />| </targets>| <rules>| <logger name='*' levels='Error' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();| LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Error, logger.Name, \"Hello\");| logEvent.Properties[\"name\"] = \"Kenny\";| logEvent.Properties[\"password\"] = \"123Password\";| logger.Error(logEvent);| logFactory.Flush();| Assert.NotEqual(0, target.LastMessage.Length);| var lastCombinedProperties = target.LastCombinedProperties;| Assert.Single(lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"name\", \"Kenny\"), lastCombinedProperties);| logger.Error(\"Hello {name}\", \"Cartman\");| logEvent.Properties[\"Password\"] = \"123Password\";| logFactory.Flush();| lastCombinedProperties = target.LastCombinedProperties;| Assert.Single(lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"name\", \"Cartman\"), lastCombinedProperties);| }"
      },
      {
        "name": "TargetWithContextAsyncBufferScopePropertyTest",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />| <target name='debug_buffer' type='BufferingWrapper'>| <target name='debug' type='contexttarget' includeCallSite='true' includeScopeProperties='true' excludeProperties='password' />| </target>| </targets>| <rules>| <logger name='*' levels='Error' writeTo='debug_buffer' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();| using (logger.PushScopeProperty(\"name\", \"Kenny\"))| using (logger.PushScopeProperty(\"password\", \"123Password\"))| {| logger.Error(\"Hello\");| }| logFactory.Flush();| Assert.NotEqual(0, target.LastMessage.Length);| var lastCombinedProperties = target.LastCombinedProperties;| Assert.Single(lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"name\", \"Kenny\"), lastCombinedProperties);| }"
      },
      {
        "name": "TargetWithContextJsonTest",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />| <target name='debug' type='contexttarget' includeCallSite='true'>| <layout type='JsonLayout' includeScopeProperties='true'>| <attribute name='level' layout='${level:upperCase=true}'/>| <attribute name='message' layout='${message}' />| <attribute name='exception' layout='${exception}' />| <attribute name='threadid' layout='${threadid}' />| </layout>| </target>| </targets>| <rules>| <logger name='*' levels='Error' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| ScopeContext.Clear();| ScopeContext.PushProperty(\"TestKey\", \"Hello Thread World\");| logger.Error(\"log message\");| var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();| System.Threading.Thread.Sleep(1);| for (int i = 0; i < 1000; ++i)| {| if (target.LastMessage != null)| break;| System.Threading.Thread.Sleep(1);| }| Assert.NotEqual(0, target.LastMessage.Length);| Assert.Contains(CurrentManagedThreadId.ToString(), target.LastMessage);| var lastCombinedProperties = target.LastCombinedProperties;| Assert.Empty(lastCombinedProperties);| }"
      },
      {
        "name": "TargetWithContextPropertyTypeTest",
        "body": "{| var logFactory = new LogFactory().Setup()| .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))| .LoadConfigurationFromXml(@\"| <nlog throwExceptions='true'>| <targets>| <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />| <target name='debug' type='contexttarget' includeCallSite='true'>| <contextproperty name='threadid' layout='${threadid}' propertyType='System.Int32' />| <contextproperty name='processid' layout='${processid}' propertyType='System.Int32' />| <contextproperty name='timestamp' layout='${date}' propertyType='System.DateTime' />| <contextproperty name='int-non-existing' layout='${event-properties:non-existing}' propertyType='System.Int32' includeEmptyValue='true' />| <contextproperty name='int-non-existing-empty' layout='${event-properties:non-existing}' propertyType='System.Int32' includeEmptyValue='false' />| <contextproperty name='string-non-existing' layout='${event-properties:non-existing}' propertyType='System.String' includeEmptyValue='true' />| <contextproperty name='object-non-existing' layout='${event-properties:non-existing}' propertyType='System.Object' includeEmptyValue='true' />| <contextproperty name='object-non-existing-empty' layout='${event-properties:non-existing}' propertyType='System.Object' includeEmptyValue='false' />| </target>| </targets>| <rules>| <logger name='*' levels='Error' writeTo='debug' />| </rules>| </nlog>\").LogFactory;| var logger = logFactory.GetLogger(\"A\");| ScopeContext.Clear();| var logEvent = new LogEventInfo() { Message = \"log message\" };| logger.Error(logEvent);| logFactory.Flush();| var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();| Assert.NotEqual(0, target.LastMessage.Length);| var lastCombinedProperties = target.LastCombinedProperties;| Assert.NotEmpty(lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"threadid\", CurrentManagedThreadId), lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"processid\", CurrentProcessId), lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"int-non-existing\", 0), lastCombinedProperties);| Assert.DoesNotContain(\"int-non-existing-empty\", lastCombinedProperties.Keys);| Assert.Contains(new KeyValuePair<string, object>(\"string-non-existing\", \"\"), lastCombinedProperties);| Assert.Contains(new KeyValuePair<string, object>(\"object-non-existing\", null), lastCombinedProperties);| Assert.DoesNotContain(\"object-non-existing-empty\", lastCombinedProperties.Keys);| }"
      }
    ]
  },
  {
    "file": "AsyncRequestQueueTests.cs",
    "methods": [
      {
        "name": "AsyncRequestQueueWithDiscardBehaviorTest",
        "body": "{| var ev1 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev2 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev3 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev4 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var queue = new AsyncRequestQueue(3, AsyncTargetWrapperOverflowAction.Discard);| Assert.Equal(3, queue.RequestLimit);| Assert.Equal(AsyncTargetWrapperOverflowAction.Discard, queue.OnOverflow);| Assert.Equal(0, queue.RequestCount);| queue.Enqueue(ev1);| Assert.Equal(1, queue.RequestCount);| queue.Enqueue(ev2);| Assert.Equal(2, queue.RequestCount);| queue.Enqueue(ev3);| Assert.Equal(3, queue.RequestCount);| queue.Enqueue(ev4);| Assert.Equal(3, queue.RequestCount);| AsyncLogEventInfo[] logEventInfos = queue.DequeueBatch(10);| Assert.Equal(0, queue.RequestCount);| // ev1 is lost| Assert.Same(logEventInfos[0].LogEvent, ev2.LogEvent);| Assert.Same(logEventInfos[1].LogEvent, ev3.LogEvent);| Assert.Same(logEventInfos[2].LogEvent, ev4.LogEvent);| Assert.Same(logEventInfos[0].Continuation, ev2.Continuation);| Assert.Same(logEventInfos[1].Continuation, ev3.Continuation);| Assert.Same(logEventInfos[2].Continuation, ev4.Continuation);| }"
      },
      {
        "name": "AsyncRequestQueueWithGrowBehaviorTest",
        "body": "{| var ev1 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev2 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev3 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev4 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var queue = new AsyncRequestQueue(3, AsyncTargetWrapperOverflowAction.Grow);| Assert.Equal(3, queue.RequestLimit);| Assert.Equal(AsyncTargetWrapperOverflowAction.Grow, queue.OnOverflow);| Assert.Equal(0, queue.RequestCount);| queue.Enqueue(ev1);| Assert.Equal(1, queue.RequestCount);| queue.Enqueue(ev2);| Assert.Equal(2, queue.RequestCount);| queue.Enqueue(ev3);| Assert.Equal(3, queue.RequestCount);| queue.Enqueue(ev4);| Assert.Equal(4, queue.RequestCount);| AsyncLogEventInfo[] logEventInfos = queue.DequeueBatch(10);| int result = logEventInfos.Length;| Assert.Equal(4, result);| Assert.Equal(0, queue.RequestCount);| // ev1 is lost| Assert.Same(logEventInfos[0].LogEvent, ev1.LogEvent);| Assert.Same(logEventInfos[1].LogEvent, ev2.LogEvent);| Assert.Same(logEventInfos[2].LogEvent, ev3.LogEvent);| Assert.Same(logEventInfos[3].LogEvent, ev4.LogEvent);| Assert.Same(logEventInfos[0].Continuation, ev1.Continuation);| Assert.Same(logEventInfos[1].Continuation, ev2.Continuation);| Assert.Same(logEventInfos[2].Continuation, ev3.Continuation);| Assert.Same(logEventInfos[3].Continuation, ev4.Continuation);| }"
      },
      {
        "name": "AsyncRequestQueueWithBlockBehavior",
        "body": "{| var queue = new AsyncRequestQueue(10, AsyncTargetWrapperOverflowAction.Block);| ManualResetEvent producerFinished = new ManualResetEvent(false);| int pushingEvent = 0;| ThreadPool.QueueUserWorkItem(| s =>| {| // producer thread| for (int i = 0; i < 1000; ++i)| {| AsyncLogEventInfo logEvent = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| logEvent.LogEvent.Message = \"msg\" + i;| // Console.WriteLine(\"Pushing event {0}\", i);| pushingEvent = i;| queue.Enqueue(logEvent);| }| producerFinished.Set();| });| // consumer thread| AsyncLogEventInfo[] logEventInfos;| int total = 0;| while (total < 500)| {| int left = 500 - total;| logEventInfos = queue.DequeueBatch(left);| int got = logEventInfos.Length;| Assert.True(got <= queue.RequestLimit);| total += got;| }| Thread.Sleep(500);| // producer is blocked on trying to push event #510| Assert.Equal(510, pushingEvent);| queue.DequeueBatch(1);| total++;| Thread.Sleep(500);| // producer is now blocked on trying to push event #511| Assert.Equal(511, pushingEvent);| while (total < 1000)| {| int left = 1000 - total;| logEventInfos = queue.DequeueBatch(left);| int got = logEventInfos.Length;| Assert.True(got <= queue.RequestLimit);| total += got;| }| // producer should now finish| producerFinished.WaitOne();| }"
      },
      {
        "name": "AsyncRequestQueueClearTest",
        "body": "{| var ev1 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev2 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev3 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var ev4 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });| var queue = new AsyncRequestQueue(3, AsyncTargetWrapperOverflowAction.Grow);| Assert.Equal(3, queue.RequestLimit);| Assert.Equal(AsyncTargetWrapperOverflowAction.Grow, queue.OnOverflow);| Assert.Equal(0, queue.RequestCount);| queue.Enqueue(ev1);| Assert.Equal(1, queue.RequestCount);| queue.Enqueue(ev2);| Assert.Equal(2, queue.RequestCount);| queue.Enqueue(ev3);| Assert.Equal(3, queue.RequestCount);| queue.Enqueue(ev4);| Assert.Equal(4, queue.RequestCount);| queue.Clear();| Assert.Equal(0, queue.RequestCount);| AsyncLogEventInfo[] logEventInfos;| logEventInfos = queue.DequeueBatch(10);| int result = logEventInfos.Length;| Assert.Equal(0, result);| Assert.Equal(0, queue.RequestCount);| }"
      },
      {
        "name": "RaiseEventLogEventQueueGrow_OnLogItems",
        "body": "{| const int RequestsLimit = 2;| const int EventsCount = 5;| const int ExpectedCountOfGrovingTimes = 2;| const int ExpectedFinalSize = 8;| int grovingItemsCount = 0;| AsyncRequestQueue requestQueue = new AsyncRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Grow);| requestQueue.LogEventQueueGrow += (o, e) => { grovingItemsCount++; };| for (int i = 0; i < EventsCount; i++)| {| requestQueue.Enqueue(new AsyncLogEventInfo());| }| Assert.Equal(ExpectedCountOfGrovingTimes, grovingItemsCount);| Assert.Equal(ExpectedFinalSize, requestQueue.RequestLimit);| }"
      },
      {
        "name": "RaiseEventLogEventDropped_OnLogItems",
        "body": "{| const int RequestsLimit = 2;| const int EventsCount = 5;| int discardedItemsCount = 0;| int ExpectedDiscardedItemsCount = EventsCount - RequestsLimit;| AsyncRequestQueue requestQueue = new AsyncRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Discard);| requestQueue.LogEventDropped += (o, e) => { discardedItemsCount++; };| for (int i = 0; i < EventsCount; i++)| {| requestQueue.Enqueue(new AsyncLogEventInfo());| }| Assert.Equal(ExpectedDiscardedItemsCount, discardedItemsCount);| }"
      }
    ]
  },
  {
    "file": "AsyncTargetWrapperTests.cs",
    "methods": [
      {
        "name": "AsyncTargetWrapperInitTest",
        "body": "{| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper(myTarget, 300, AsyncTargetWrapperOverflowAction.Grow);| Assert.Equal(AsyncTargetWrapperOverflowAction.Grow, targetWrapper.OverflowAction);| Assert.Equal(300, targetWrapper.QueueLimit);| Assert.Equal(1, targetWrapper.TimeToSleepBetweenBatches);| Assert.Equal(200, targetWrapper.BatchSize);| }"
      },
      {
        "name": "AsyncTargetWrapperInitTest2",
        "body": "{| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper()| {| WrappedTarget = myTarget,| };| Assert.Equal(AsyncTargetWrapperOverflowAction.Discard, targetWrapper.OverflowAction);| Assert.Equal(10000, targetWrapper.QueueLimit);| Assert.Equal(1, targetWrapper.TimeToSleepBetweenBatches);| Assert.Equal(200, targetWrapper.BatchSize);| }"
      },
      {
        "name": "AsyncTargetWrapperSyncTest_WithLock_WhenTimeToSleepBetweenBatchesIsEqualToZero",
        "body": "{| RetryingIntegrationTest(3, () =>| {| AsyncTargetWrapperSyncTest_WhenTimeToSleepBetweenBatchesIsEqualToZero(true);| });| }"
      },
      {
        "name": "AsyncTargetWrapperSyncTest_NoLock_WhenTimeToSleepBetweenBatchesIsEqualToZero",
        "body": "{| RetryingIntegrationTest(3, () =>| {| AsyncTargetWrapperSyncTest_WhenTimeToSleepBetweenBatchesIsEqualToZero(false); | });| }"
      },
      {
        "name": "AsyncTargetWrapperSyncTest1",
        "body": "{| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper| {| WrappedTarget = myTarget,| Name = \"AsyncTargetWrapperSyncTest1_Wrapper\",| };| targetWrapper.Initialize(null);| myTarget.Initialize(null);| try| {| var logEvent = new LogEventInfo();| Exception lastException = null;| ManualResetEvent continuationHit = new ManualResetEvent(false);| Thread continuationThread = null;| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationThread = Thread.CurrentThread;| continuationHit.Set();| };| targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| // continuation was not hit| Assert.True(continuationHit.WaitOne(5000));| Assert.NotSame(continuationThread, Thread.CurrentThread);| Assert.Null(lastException);| Assert.Equal(1, myTarget.WriteCount);| continuationHit.Reset();| targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.NotSame(continuationThread, Thread.CurrentThread);| Assert.Null(lastException);| Assert.Equal(2, myTarget.WriteCount);| }| finally| {| myTarget.Close();| targetWrapper.Close();| }| }"
      },
      {
        "name": "AsyncTargetWrapperAsyncTest1",
        "body": "{| var myTarget = new MyAsyncTarget();| var targetWrapper = new AsyncTargetWrapper(myTarget) { Name = \"AsyncTargetWrapperAsyncTest1_Wrapper\" };| targetWrapper.Initialize(null);| myTarget.Initialize(null);| try| {| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.Null(lastException);| Assert.Equal(1, myTarget.WriteCount);| continuationHit.Reset();| targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.Null(lastException);| Assert.Equal(2, myTarget.WriteCount);| }| finally| {| myTarget.Close();| targetWrapper.Close();| }| }"
      },
      {
        "name": "AsyncTargetWrapperAsyncWithExceptionTest1",
        "body": "{| var myTarget = new MyAsyncTarget| {| ThrowExceptions = true,| };| var targetWrapper = new AsyncTargetWrapper(myTarget) { Name = \"AsyncTargetWrapperAsyncWithExceptionTest1_Wrapper\" };| targetWrapper.Initialize(null);| myTarget.Initialize(null);| try| {| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.NotNull(lastException);| Assert.IsType<InvalidOperationException>(lastException);| // no flush on exception| Assert.Equal(0, myTarget.FlushCount);| Assert.Equal(1, myTarget.WriteCount);| continuationHit.Reset();| lastException = null;| targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.NotNull(lastException);| Assert.IsType<InvalidOperationException>(lastException);| Assert.Equal(0, myTarget.FlushCount);| Assert.Equal(2, myTarget.WriteCount);| }| finally| {| myTarget.Close();| targetWrapper.Close();| }| }"
      },
      {
        "name": "AsyncTargetWrapperFlushTest",
        "body": "{| RetryingIntegrationTest(3, () =>| {| var myTarget = new MyAsyncTarget| {| ThrowExceptions = true| };| var targetWrapper = new AsyncTargetWrapper(myTarget)| {| Name = \"AsyncTargetWrapperFlushTest_Wrapper\",| OverflowAction = AsyncTargetWrapperOverflowAction.Grow| };| targetWrapper.Initialize(null);| myTarget.Initialize(null);| try| {| List<Exception> exceptions = new List<Exception>();| int eventCount = 5000;| for (int i = 0; i < eventCount; ++i)| {| targetWrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(| ex =>| {| lock (exceptions)| {| exceptions.Add(ex);| }| }));| }| Exception lastException = null;| ManualResetEvent mre = new ManualResetEvent(false);| string internalLog = RunAndCaptureInternalLog(| () =>| {| targetWrapper.Flush(| cont =>| {| try| {| // by this time all continuations should be completed| Assert.Equal(eventCount, exceptions.Count);| // with just 1 flush of the target| Assert.Equal(1, myTarget.FlushCount);| // and all writes should be accounted for| Assert.Equal(eventCount, myTarget.WriteCount);| }| catch (Exception ex)| {| lastException = ex;| }| finally| {| mre.Set();| }| });| Assert.True(mre.WaitOne(5000), InternalLogger.LogWriter?.ToString() ?? string.Empty);| },| LogLevel.Trace);| Assert.True(lastException is null, lastException?.ToString() + \"\\r\\n\" + internalLog);| }| finally| {| myTarget.Close();| targetWrapper.Close();| }| });| }"
      },
      {
        "name": "AsyncTargetWrapperCloseTest",
        "body": "{| var myTarget = new MyAsyncTarget| {| ThrowExceptions = true| };| var targetWrapper = new AsyncTargetWrapper(myTarget)| {| OverflowAction = AsyncTargetWrapperOverflowAction.Grow,| TimeToSleepBetweenBatches = 1000,| Name = \"AsyncTargetWrapperCloseTest_Wrapper\",| };| targetWrapper.Initialize(null);| myTarget.Initialize(null);| var writeOnClose = new ManualResetEvent(false);| targetWrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => { writeOnClose.Set(); }));| // quickly close the target before the timer elapses| targetWrapper.Close();| Assert.True(writeOnClose.WaitOne(5000));| }"
      },
      {
        "name": "AsyncTargetWrapperExceptionTest",
        "body": "{| var targetWrapper = new AsyncTargetWrapper| {| OverflowAction = AsyncTargetWrapperOverflowAction.Grow,| TimeToSleepBetweenBatches = 500,| WrappedTarget = new DebugTarget(),| Name = \"AsyncTargetWrapperExceptionTest_Wrapper\"| };| using (new NoThrowNLogExceptions())| {| targetWrapper.Initialize(null);| // null out wrapped target - will cause exception on the timer thread| targetWrapper.WrappedTarget = null;| string internalLog = RunAndCaptureInternalLog(| () =>| {| targetWrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => { }));| targetWrapper.Close();| },| LogLevel.Trace);| Assert.True(internalLog.Contains(\"WrappedTarget is NULL\"), internalLog);| }| }"
      },
      {
        "name": "FlushingMultipleTimesSimultaneous",
        "body": "{| var asyncTarget = new AsyncTargetWrapper| {| TimeToSleepBetweenBatches = 1000,| WrappedTarget = new DebugTarget(),| Name = \"FlushingMultipleTimesSimultaneous_Wrapper\"| };| asyncTarget.Initialize(null);| try| {| asyncTarget.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => { }));| var firstContinuationCalled = false;| var secondContinuationCalled = false;| var firstContinuationResetEvent = new ManualResetEvent(false);| var secondContinuationResetEvent = new ManualResetEvent(false);| asyncTarget.Flush(ex =>| {| firstContinuationCalled = true;| firstContinuationResetEvent.Set();| });| asyncTarget.Flush(ex =>| {| secondContinuationCalled = true;| secondContinuationResetEvent.Set();| });| Assert.True(firstContinuationResetEvent.WaitOne(5000), nameof(firstContinuationResetEvent));| Assert.True(secondContinuationResetEvent.WaitOne(5000), nameof(secondContinuationResetEvent));| Assert.True(firstContinuationCalled);| Assert.True(secondContinuationCalled);| }| finally| {| asyncTarget.Close();| }| }"
      },
      {
        "name": "LogEventDropped_OnRequestqueueOverflow",
        "body": "{| int queueLimit = 2;| int loggedEventCount = 5;| int eventsCounter = 0;| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper()| {| WrappedTarget = myTarget,| QueueLimit = queueLimit,| TimeToSleepBetweenBatches = 500, // Make it slow| OverflowAction = AsyncTargetWrapperOverflowAction.Discard,| };| var logFactory = new LogFactory();| var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);| loggingConfig.AddRuleForAllLevels(targetWrapper);| logFactory.Configuration = loggingConfig;| var logger = logFactory.GetLogger(\"Test\");| try| {| targetWrapper.LogEventDropped += (o, e) => { eventsCounter++; };| for (int i = 0; i < loggedEventCount; i++)| {| logger.Info(\"Hello\");| }| Assert.Equal(loggedEventCount - queueLimit, eventsCounter);| }| finally| {| logFactory.Configuration = null;| }| }"
      },
      {
        "name": "LogEventNotDropped_IfOverflowActionBlock",
        "body": "{| int queueLimit = 2;| int loggedEventCount = 5;| int eventsCounter = 0;| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper()| {| WrappedTarget = myTarget,| QueueLimit = queueLimit,| OverflowAction = AsyncTargetWrapperOverflowAction.Block| };| var logFactory = new LogFactory();| var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);| loggingConfig.AddRuleForAllLevels(targetWrapper);| logFactory.Configuration = loggingConfig;| var logger = logFactory.GetLogger(\"Test\");| try| {| targetWrapper.LogEventDropped += (o, e) => { eventsCounter++; };| for (int i = 0; i < loggedEventCount; i++)| {| logger.Info(\"Hello\");| }| Assert.Equal(0, eventsCounter);| }| finally| {| logFactory.Configuration = null;| }| }"
      },
      {
        "name": "LogEventNotDropped_IfOverflowActionGrow",
        "body": "{| int queueLimit = 2;| int loggedEventCount = 5;| int eventsCounter = 0;| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper()| {| WrappedTarget = myTarget,| QueueLimit = queueLimit,| OverflowAction = AsyncTargetWrapperOverflowAction.Grow| };| var logFactory = new LogFactory();| var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);| loggingConfig.AddRuleForAllLevels(targetWrapper);| logFactory.Configuration = loggingConfig;| var logger = logFactory.GetLogger(\"Test\");| try| {| targetWrapper.LogEventDropped += (o, e) => { eventsCounter++; };| for (int i = 0; i < loggedEventCount; i++)| {| logger.Info(\"Hello\");| }| Assert.Equal(0, eventsCounter);| }| finally| {| logFactory.Configuration = null;| }| }"
      },
      {
        "name": "EventQueueGrow_OnQueueGrow",
        "body": "{| int queueLimit = 2;| int loggedEventCount = 10;| int expectedGrowingNumber = 3;| int eventsCounter = 0;| var myTarget = new MyTarget();| var targetWrapper = new AsyncTargetWrapper()| {| WrappedTarget = myTarget,| QueueLimit = queueLimit,| TimeToSleepBetweenBatches = 500, // Make it slow| OverflowAction = AsyncTargetWrapperOverflowAction.Grow,| };| var logFactory = new LogFactory();| var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);| loggingConfig.AddRuleForAllLevels(targetWrapper);| logFactory.Configuration = loggingConfig;| var logger = logFactory.GetLogger(\"Test\");| try| {| targetWrapper.EventQueueGrow += (o, e) => { eventsCounter++; };| for (int i = 0; i < loggedEventCount; i++)| {| logger.Info(\"Hello\");| }| Assert.Equal(expectedGrowingNumber, eventsCounter);| }| finally| {| logFactory.Configuration = null;| }| }"
      },
      {
        "name": "EnqueuQueueBlock_WithLock_OnClose_ReleasesWriters",
        "body": "{| EnqueuQueueBlock_OnClose_ReleasesWriters(true);| }"
      },
      {
        "name": "EnqueuQueueBlock_NoLock_OnClose_ReleasesWriters",
        "body": "{| EnqueuQueueBlock_OnClose_ReleasesWriters(false);| }"
      },
      {
        "name": "AsyncTargetWrapper_MissingDependency_EnqueueLogEvents",
        "body": "{| using (new NoThrowNLogExceptions())| {| // Arrange| var logFactory = new LogFactory();| logFactory.ThrowConfigExceptions = true;| var logConfig = new LoggingConfiguration(logFactory);| var asyncTarget = new MyTarget() { Name = \"asynctarget\", RequiredDependency = typeof(IMisingDependencyClass) };| logConfig.AddRuleForAllLevels(new AsyncTargetWrapper(\"wrapper\", asyncTarget));| logFactory.Configuration = logConfig;| var logger = logFactory.GetLogger(nameof(AsyncTargetWrapper_MissingDependency_EnqueueLogEvents));| // Act| logger.Info(\"Hello World\");| Assert.False(asyncTarget.WaitForWriteEvent(50));| logFactory.ServiceRepository.RegisterService(typeof(IMisingDependencyClass), new MisingDependencyClass());| // Assert| Assert.True(asyncTarget.WaitForWriteEvent());| }| }"
      }
    ]
  },
  {
    "file": "AutoFlushTargetWrapperTests.cs",
    "methods": [
      {
        "name": "AutoFlushTargetWrapperSyncTest1",
        "body": "{| var myTarget = new MyTarget();| var wrapper = new AutoFlushTargetWrapper| {| WrappedTarget = myTarget,| };| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| bool continuationHit = false;| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit = true;| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit);| Assert.Null(lastException);| Assert.Equal(1, myTarget.FlushCount);| Assert.Equal(1, myTarget.WriteCount);| continuationHit = false;| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit);| Assert.Null(lastException);| Assert.Equal(2, myTarget.WriteCount);| Assert.Equal(2, myTarget.FlushCount);| }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncTest1",
        "body": "{| var myTarget = new MyAsyncTarget();| var wrapper = new AutoFlushTargetWrapper(myTarget);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.Null(lastException);| Assert.Equal(1, myTarget.FlushCount);| Assert.Equal(1, myTarget.WriteCount);| continuationHit.Reset();| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.Null(lastException);| Assert.Equal(2, myTarget.WriteCount);| Assert.Equal(2, myTarget.FlushCount);| }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncTest2",
        "body": "{| var myTarget = new MyAsyncTarget();| var wrapper = new AutoFlushTargetWrapper(myTarget);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| // Schedule 100 writes, where each write on completion schedules followup-flush (in random order)| const int expectedWriteCount = 100;| const int expectedFlushCount = expectedWriteCount + 3;| for (int i = 0; i < expectedWriteCount; ++i)| {| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(ex => lastException = ex));| }| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| continuationHit.Set();| };| // Schedule 1st flush (can complete before follow-flushes)| wrapper.Flush(ex => { });| Assert.Null(lastException);| // Schedule 2nd flush (can complete before follow-flushes)| wrapper.Flush(continuation);| Assert.Null(lastException);| Assert.True(continuationHit.WaitOne(5000));| Assert.Null(lastException);| // Schedule 3rd flush (can complete before follow-flushes)| wrapper.Flush(ex => { });| Assert.Null(lastException);| for (int i = 0; i < 500; ++i)| {| if (myTarget.WriteCount == expectedWriteCount && myTarget.FlushCount == expectedFlushCount)| break;| Thread.Sleep(10);| }| Assert.Equal(expectedWriteCount, myTarget.WriteCount);| Assert.Equal(expectedFlushCount, myTarget.FlushCount);| }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncTest3",
        "body": "{| var myTarget = new MyAsyncTarget();| var wrapper = new AutoFlushTargetWrapper(myTarget) { AsyncFlush = false };| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| for (int i = 0; i < 100; ++i)| {| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(ex => lastException = ex));| }| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| continuationHit.Set();| };| wrapper.Flush(ex => { });| Assert.Null(lastException);| wrapper.Flush(continuation);| Assert.Null(lastException);| Assert.True(continuationHit.WaitOne(5000));| Assert.Null(lastException);| wrapper.Flush(ex => { }); // Executed right away| Assert.Null(lastException);| Assert.Equal(100, myTarget.WriteCount);| Assert.Equal(103, myTarget.FlushCount);| }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncWithExceptionTest1",
        "body": "{| var myTarget = new MyAsyncTarget| {| ThrowExceptions = true,| };| var wrapper = new AutoFlushTargetWrapper(myTarget);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.NotNull(lastException);| Assert.IsType<InvalidOperationException>(lastException);| // no flush on exception| Assert.Equal(0, myTarget.FlushCount);| Assert.Equal(1, myTarget.WriteCount);| continuationHit.Reset();| lastException = null;| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit.WaitOne(5000));| Assert.NotNull(lastException);| Assert.IsType<InvalidOperationException>(lastException);| Assert.Equal(0, myTarget.FlushCount);| Assert.Equal(2, myTarget.WriteCount);| }"
      },
      {
        "name": "AutoFlushConditionConfigurationTest",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"<nlog>| <targets>| <target type='AutoFlushWrapper' condition='level >= LogLevel.Debug' name='FlushOnError'>| <target name='d2' type='Debug' />| </target>| </targets>| <rules>| <logger name='*' level='Warn' writeTo='FlushOnError'>| </logger>| </rules>| </nlog>\").LogFactory;| var target = logFactory.Configuration.FindTargetByName(\"FlushOnError\") as AutoFlushTargetWrapper;| Assert.NotNull(target);| Assert.NotNull(target.Condition);| Assert.Equal(\"(level >= Debug)\", target.Condition.ToString());| Assert.Equal(\"d2\", target.WrappedTarget.Name);| }"
      },
      {
        "name": "AutoFlushOnConditionTest",
        "body": "{| var testTarget = new MyTarget();| var autoFlushWrapper = new AutoFlushTargetWrapper(testTarget);| autoFlushWrapper.Condition = \"level > LogLevel.Info\";| testTarget.Initialize(null);| autoFlushWrapper.Initialize(null);| AsyncContinuation continuation = ex => { };| autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Info, \"*\", \"test\").WithContinuation(continuation));| autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Warn, \"*\", \"test\").WithContinuation(continuation));| autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Error, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(4, testTarget.WriteCount);| Assert.Equal(2, testTarget.FlushCount);| }"
      },
      {
        "name": "MultipleConditionalAutoFlushWrappersTest",
        "body": "{| var testTarget = new MyTarget();| var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(testTarget);| autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";| var autoFlushOnMessageWrapper = new AutoFlushTargetWrapper(autoFlushOnLevelWrapper);| autoFlushOnMessageWrapper.Condition = \"contains('${message}','FlushThis')\";| testTarget.Initialize(null);| autoFlushOnLevelWrapper.Initialize(null);| autoFlushOnMessageWrapper.Initialize(null);| AsyncContinuation continuation = ex => { };| autoFlushOnMessageWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(1, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| autoFlushOnMessageWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Fatal, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| autoFlushOnMessageWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"Please FlushThis\").WithContinuation(continuation));| Assert.Equal(3, testTarget.WriteCount);| Assert.Equal(2, testTarget.FlushCount);| }"
      },
      {
        "name": "BufferingAutoFlushWrapperTest",
        "body": "{| var testTarget = new MyTarget();| var bufferingTargetWrapper = new BufferingTargetWrapper(testTarget, 100);| var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(bufferingTargetWrapper);| autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";| testTarget.Initialize(null);| bufferingTargetWrapper.Initialize(null);| autoFlushOnLevelWrapper.Initialize(null);| AsyncContinuation continuation = ex => { };| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(0, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Fatal, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"Please do not FlushThis\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| autoFlushOnLevelWrapper.Flush(continuation);| Assert.Equal(3, testTarget.WriteCount);| Assert.Equal(2, testTarget.FlushCount);| }"
      },
      {
        "name": "IgnoreExplicitAutoFlushWrapperTest",
        "body": "{| var testTarget = new MyTarget();| var bufferingTargetWrapper = new BufferingTargetWrapper(testTarget, 100);| var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(bufferingTargetWrapper);| autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";| autoFlushOnLevelWrapper.FlushOnConditionOnly = true;| testTarget.Initialize(null);| bufferingTargetWrapper.Initialize(null);| autoFlushOnLevelWrapper.Initialize(null);| AsyncContinuation continuation = ex => { };| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(0, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Fatal, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"Ignore on Explict Flush\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| autoFlushOnLevelWrapper.Flush(continuation);| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| }"
      },
      {
        "name": "ExplicitFlushWaitsForAutoFlushWrapperCompletionTest",
        "body": "{| var testTarget = new MyTarget();| var bufferingTargetWrapper = new BufferingTargetWrapper(testTarget, 100);| var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(bufferingTargetWrapper);| autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";| autoFlushOnLevelWrapper.FlushOnConditionOnly = true;| testTarget.Initialize(null);| bufferingTargetWrapper.Initialize(null);| autoFlushOnLevelWrapper.Initialize(null);| AsyncContinuation continuation = ex => { };| var flushCompleted = false;| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(0, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| autoFlushOnLevelWrapper.Flush((ex) => flushCompleted = true);| Assert.True(flushCompleted);| Assert.Equal(0, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| flushCompleted = false;| var manualResetEvent = new ManualResetEvent(false);| testTarget.FlushEvent = (arg) =>| {| Task.Run(() => manualResetEvent.WaitOne(10000)).ContinueWith(t => arg(null));| };| autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Error, \"*\", \"test\").WithContinuation(continuation));| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(0, testTarget.FlushCount);| autoFlushOnLevelWrapper.Flush((ex) => flushCompleted = true);| Assert.False(flushCompleted);| Assert.Equal(0, testTarget.FlushCount);| manualResetEvent.Set();| for (int i = 0; i < 500; ++i)| {| if (flushCompleted && testTarget.FlushCount > 0)| break;| Thread.Sleep(10);| }| Assert.Equal(2, testTarget.WriteCount);| Assert.Equal(1, testTarget.FlushCount);| }"
      }
    ]
  },
  {
    "file": "BufferingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "BufferingTargetWrapperSyncTest1",
        "body": "{| var myTarget = new MyTarget();| var targetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| BufferSize = 10,| };| InitializeTargets(myTarget, targetWrapper);| const int totalEvents = 100;| var continuationHit = new bool[totalEvents];| var lastException = new Exception[totalEvents];| var continuationThread = new Thread[totalEvents];| var hitCount = 0;| CreateContinuationFunc createAsyncContinuation =| eventNumber =>| ex =>| {| lastException[eventNumber] = ex;| continuationThread[eventNumber] = Thread.CurrentThread;| continuationHit[eventNumber] = true;| Interlocked.Increment(ref hitCount);| };| // write 9 events - they will all be buffered and no final continuation will be reached| var eventCounter = 0;| for (var i = 0; i < 9; ++i)| {| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| }| Assert.Equal(0, hitCount);| Assert.Equal(0, myTarget.WriteCount);| // write one more event - everything will be flushed| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| Assert.Equal(10, hitCount);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(10, myTarget.BufferedTotalEvents);| Assert.Equal(10, myTarget.WriteCount);| for (var i = 0; i < hitCount; ++i)| {| Assert.Same(Thread.CurrentThread, continuationThread[i]);| Assert.Null(lastException[i]);| }| // write 9 more events - they will all be buffered and no final continuation will be reached| for (var i = 0; i < 9; ++i)| {| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| }| // no change| Assert.Equal(10, hitCount);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(10, myTarget.BufferedTotalEvents);| Assert.Equal(10, myTarget.WriteCount);| Exception flushException = null;| var flushHit = new ManualResetEvent(false);| targetWrapper.Flush(| ex =>| {| flushException = ex;| flushHit.Set();| });| Assert.True(flushHit.WaitOne(5000), \"Wait Flush Timeout\");| Assert.Null(flushException);| // make sure remaining events were written| Assert.Equal(19, hitCount);| Assert.Equal(2, myTarget.BufferedWriteCount);| Assert.Equal(19, myTarget.BufferedTotalEvents);| Assert.Equal(19, myTarget.WriteCount);| Assert.Equal(1, myTarget.FlushCount);| // flushes happen on the same thread| for (var i = 10; i < hitCount; ++i)| {| Assert.NotNull(continuationThread[i]);| Assert.Same(Thread.CurrentThread, continuationThread[i]);| Assert.Null(lastException[i]);| }| // flush again - should just invoke Flush() on the wrapped target| flushHit.Reset();| targetWrapper.Flush(| ex =>| {| flushException = ex;| flushHit.Set();| });| Assert.True(flushHit.WaitOne(5000), \"Wait Again Flush Timeout\");| Assert.Equal(19, hitCount);| Assert.Equal(2, myTarget.BufferedWriteCount);| Assert.Equal(19, myTarget.BufferedTotalEvents);| Assert.Equal(19, myTarget.WriteCount);| Assert.Equal(2, myTarget.FlushCount);| targetWrapper.Close();| myTarget.Close();| }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithTimedFlushTest",
        "body": "{| var myTarget = new MyTarget();| var targetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| BufferSize = 10,| FlushTimeout = 50,| };| var writeHit = new ManualResetEvent(false);| InitializeTargets(myTarget, targetWrapper);| const int totalEvents = 100;| var continuationHit = new bool[totalEvents];| var lastException = new Exception[totalEvents];| var continuationThread = new Thread[totalEvents];| var hitCount = 0;| CreateContinuationFunc createAsyncContinuation =| eventNumber =>| ex =>| {| lastException[eventNumber] = ex;| continuationThread[eventNumber] = Thread.CurrentThread;| continuationHit[eventNumber] = true;| Interlocked.Increment(ref hitCount);| writeHit.Set();| };| // write 9 events - they will all be buffered and no final continuation will be reached| var eventCounter = 0;| for (var i = 0; i < 9; ++i)| {| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| }| Assert.Equal(0, hitCount);| Assert.Equal(0, myTarget.WriteCount);| // sleep and wait for the trigger timer to flush all events| Assert.True(writeHit.WaitOne(5000), \"Wait Write Timeout\");| WaitAndAssertExpectedValue(ref hitCount, 9);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(9, myTarget.BufferedTotalEvents);| Assert.Equal(9, myTarget.WriteCount);| for (var i = 0; i < hitCount; ++i)| {| Assert.NotSame(Thread.CurrentThread, continuationThread[i]);| Assert.Null(lastException[i]);| }| // write 11 more events, 10 will be hit immediately because the buffer will fill up| // 1 will be pending| for (var i = 0; i < 11; ++i)| {| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| }| Assert.Equal(19, hitCount);| Assert.Equal(2, myTarget.BufferedWriteCount);| Assert.Equal(19, myTarget.BufferedTotalEvents);| Assert.Equal(19, myTarget.WriteCount);| // sleep and wait for the remaining one to be flushed| WaitAndAssertExpectedValue(ref hitCount, 20);| Assert.Equal(3, myTarget.BufferedWriteCount);| Assert.Equal(20, myTarget.BufferedTotalEvents);| Assert.Equal(20, myTarget.WriteCount);| }"
      },
      {
        "name": "BufferingTargetWrapperAsyncTest1",
        "body": "{| RetryingIntegrationTest(3, () =>| {| var myTarget = new MyAsyncTarget();| var targetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| BufferSize = 10,| };| var writeHit = new ManualResetEvent(false);| InitializeTargets(myTarget, targetWrapper);| const int totalEvents = 100;| var continuationHit = new bool[totalEvents];| var lastException = new Exception[totalEvents];| var continuationThread = new Thread[totalEvents];| var hitCount = 0;| CreateContinuationFunc createAsyncContinuation =| eventNumber =>| ex =>| {| lastException[eventNumber] = ex;| continuationThread[eventNumber] = Thread.CurrentThread;| continuationHit[eventNumber] = true;| Interlocked.Increment(ref hitCount);| writeHit.Set();| };| // write 9 events - they will all be buffered and no final continuation will be reached| var eventCounter = 0;| for (var i = 0; i < 9; ++i)| {| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| }| Assert.Equal(0, hitCount);| // write one more event - everything will be flushed| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| Assert.True(writeHit.WaitOne(5000), \"Wait Write Timeout\");| WaitAndAssertExpectedValue(ref hitCount, 10);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(10, myTarget.BufferedTotalEvents);| for (var i = 0; i < hitCount; ++i)| {| Assert.NotSame(Thread.CurrentThread, continuationThread[i]);| Assert.Null(lastException[i]);| }| // write 9 more events - they will all be buffered and no final continuation will be reached| for (var i = 0; i < 9; ++i)| {| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| }| // no change| Assert.Equal(10, hitCount);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(10, myTarget.BufferedTotalEvents);| Exception flushException = null;| var flushHit = new ManualResetEvent(false);| targetWrapper.Flush(| ex =>| {| flushException = ex;| flushHit.Set();| });| Assert.True(flushHit.WaitOne(5000), \"Wait Flush Timeout\");| Assert.Null(flushException);| // make sure remaining events were written| Assert.Equal(19, hitCount);| Assert.Equal(2, myTarget.BufferedWriteCount);| Assert.Equal(19, myTarget.BufferedTotalEvents);| // flushes happen on another thread| for (var i = 10; i < hitCount; ++i)| {| Assert.NotNull(continuationThread[i]);| Assert.NotSame(Thread.CurrentThread, continuationThread[i]);| Assert.Null(lastException[i]);| }| // flush again - should not do anything| flushHit.Reset();| targetWrapper.Flush(| ex =>| {| flushException = ex;| flushHit.Set();| });| Assert.True(flushHit.WaitOne(5000), \"Wait Again Flush Timeout\");| Assert.Equal(19, hitCount);| Assert.Equal(2, myTarget.BufferedWriteCount);| Assert.Equal(19, myTarget.BufferedTotalEvents);| targetWrapper.Close();| myTarget.Close();| });| }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithTimedFlushNonSlidingTest",
        "body": "{| RetryingIntegrationTest(3, () =>| {| var myTarget = new MyTarget();| var targetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| BufferSize = 10,| FlushTimeout = 400,| SlidingTimeout = false,| };| InitializeTargets(myTarget, targetWrapper);| const int totalEvents = 100;| var continuationHit = new bool[totalEvents];| var lastException = new Exception[totalEvents];| var continuationThread = new Thread[totalEvents];| var hitCount = 0;| var resetEvent = new ManualResetEvent(false);| CreateContinuationFunc createAsyncContinuation =| eventNumber =>| ex =>| {| lastException[eventNumber] = ex;| continuationThread[eventNumber] = Thread.CurrentThread;| continuationHit[eventNumber] = true;| Interlocked.Increment(ref hitCount);| if (eventNumber > 0)| {| resetEvent.Set();| }| };| var eventCounter = 0;| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| Assert.Equal(0, hitCount);| Assert.Equal(0, myTarget.WriteCount);| targetWrapper.WriteAsyncLogEvent(| new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| Assert.True(resetEvent.WaitOne(5000), \"Wait Write Timeout\");| Assert.Equal(2, hitCount);| Assert.Equal(2, myTarget.WriteCount);| });| }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithTimedFlushSlidingTest",
        "body": "{| var myTarget = new MyTarget();| var targetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| BufferSize = 10,| FlushTimeout = 400,| };| var writeEvent = new ManualResetEvent(false);| InitializeTargets(myTarget, targetWrapper);| const int totalEvents = 100;| var continuationHit = new bool[totalEvents];| var lastException = new Exception[totalEvents];| var continuationThread = new Thread[totalEvents];| var hitCount = 0;| CreateContinuationFunc createAsyncContinuation =| eventNumber =>| ex =>| {| lastException[eventNumber] = ex;| continuationThread[eventNumber] = Thread.CurrentThread;| continuationHit[eventNumber] = true;| Interlocked.Increment(ref hitCount);| writeEvent.Set();| };| var eventCounter = 0;| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| Thread.Sleep(100);| Assert.Equal(0, hitCount);| Assert.Equal(0, myTarget.WriteCount);| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));| Thread.Sleep(100);| Assert.Equal(0, hitCount);| Assert.Equal(0, myTarget.WriteCount);| Assert.True(writeEvent.WaitOne(5000), \"Wait Write Timeout\");| WaitAndAssertExpectedValue(ref hitCount, 2);| Assert.Equal(2, myTarget.WriteCount);| }"
      },
      {
        "name": "WhenWrappedTargetThrowsExceptionThisIsHandled",
        "body": "{| using (new NoThrowNLogExceptions())| {| var myTarget = new MyTarget { ThrowException = true };| var bufferingTargetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| FlushTimeout = -1| };| InitializeTargets(myTarget, bufferingTargetWrapper);| bufferingTargetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(_ => { }));| var flushHit = new ManualResetEvent(false);| bufferingTargetWrapper.Flush(ex => flushHit.Set());| Assert.True(flushHit.WaitOne(5000), \"Wait Flush Timeout\");| Assert.Equal(1, myTarget.FlushCount);| }| }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithOverflowDiscardTest",
        "body": "{| const int totalEvents = 15;| const int bufferSize = 10;| var myTarget = new MyTarget();| var targetWrapper = new BufferingTargetWrapper| {| WrappedTarget = myTarget,| BufferSize = bufferSize,| OverflowAction = BufferingTargetWrapperOverflowAction.Discard| };| InitializeTargets(myTarget, targetWrapper);| var continuationHit = new bool[totalEvents];| var hitCount = 0;| CreateContinuationFunc createAsyncContinuation =| eventNumber =>| ex =>| {| continuationHit[eventNumber] = true;| Interlocked.Increment(ref hitCount);| };| Assert.Equal(0, myTarget.WriteCount);| for (int i = 0; i < totalEvents; i++)| {| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(i)));| }| // No events should be written to the wrapped target unless flushing manually.| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(0, myTarget.BufferedWriteCount);| Assert.Equal(0, myTarget.BufferedTotalEvents);| targetWrapper.Flush(e => { });| Assert.Equal(bufferSize, hitCount);| Assert.Equal(bufferSize, myTarget.WriteCount);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(bufferSize, myTarget.BufferedTotalEvents);| // Validate that we dropped the oldest events.| Assert.False(continuationHit[totalEvents - bufferSize - 1]);| Assert.True(continuationHit[totalEvents - bufferSize]);| // Make sure the events do not stay in the buffer.| targetWrapper.Flush(e => { });| Assert.Equal(bufferSize, hitCount);| Assert.Equal(bufferSize, myTarget.WriteCount);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(bufferSize, myTarget.BufferedTotalEvents);| // Make sure that events are discarded when closing target (config-reload + shutdown)| targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(totalEvents)));| targetWrapper.Close();| Assert.Equal(bufferSize, hitCount);| Assert.Equal(bufferSize, myTarget.WriteCount);| Assert.Equal(1, myTarget.BufferedWriteCount);| Assert.Equal(bufferSize, myTarget.BufferedTotalEvents);| }"
      }
    ]
  },
  {
    "file": "ConcurrentRequestQueueTests.cs",
    "methods": [
      {
        "name": "RaiseEventLogEventQueueGrow_OnLogItems",
        "body": "{| const int RequestsLimit = 2;| const int EventsCount = 5;| const int ExpectedCountOfGrovingTimes = 2;| const int ExpectedFinalSize = 8;| int grovingItemsCount = 0;| ConcurrentRequestQueue requestQueue = new ConcurrentRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Grow);| requestQueue.LogEventQueueGrow += (o, e) => { grovingItemsCount++; };| for (int i = 0; i < EventsCount; i++)| {| requestQueue.Enqueue(new AsyncLogEventInfo());| }| Assert.Equal(ExpectedCountOfGrovingTimes, grovingItemsCount);| Assert.Equal(ExpectedFinalSize, requestQueue.RequestLimit);| }"
      },
      {
        "name": "RaiseEventLogEventDropped_OnLogItems",
        "body": "{| const int RequestsLimit = 2;| const int EventsCount = 5;| int discardedItemsCount = 0;| int ExpectedDiscardedItemsCount = EventsCount - RequestsLimit;| ConcurrentRequestQueue requestQueue = new ConcurrentRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Discard);| requestQueue.LogEventDropped += (o, e) => { discardedItemsCount++; };| for (int i = 0; i < EventsCount; i++)| {| requestQueue.Enqueue(new AsyncLogEventInfo());| }| Assert.Equal(ExpectedDiscardedItemsCount, discardedItemsCount);| }"
      }
    ]
  },
  {
    "file": "FallbackGroupTargetTests.cs",
    "methods": [
      {
        "name": "FirstTargetWorks_Write_AllEventsAreWrittenToFirstTarget",
        "body": "{| var myTarget1 = new MyTarget();| var myTarget2 = new MyTarget();| var myTarget3 = new MyTarget();| var wrapper = CreateAndInitializeFallbackGroupTarget(false, myTarget1, myTarget2, myTarget3);| WriteAndAssertNoExceptions(wrapper);| Assert.Equal(10, myTarget1.WriteCount);| Assert.Equal(0, myTarget2.WriteCount);| Assert.Equal(0, myTarget3.WriteCount);| AssertNoFlushException(wrapper);| }"
      },
      {
        "name": "FirstTargetFails_Write_SecondTargetWritesAllEvents",
        "body": "{| using (new NoThrowNLogExceptions())| {| var myTarget1 = new MyTarget { FailCounter = 1 };| var myTarget2 = new MyTarget();| var myTarget3 = new MyTarget();| var wrapper = CreateAndInitializeFallbackGroupTarget(false, myTarget1, myTarget2, myTarget3);| WriteAndAssertNoExceptions(wrapper);| Assert.Equal(1, myTarget1.WriteCount);| Assert.Equal(10, myTarget2.WriteCount);| Assert.Equal(0, myTarget3.WriteCount);| AssertNoFlushException(wrapper);| }| }"
      },
      {
        "name": "FirstTwoTargetsFails_Write_ThirdTargetWritesAllEvents",
        "body": "{| using (new NoThrowNLogExceptions())| {| var myTarget1 = new MyTarget { FailCounter = 1 };| var myTarget2 = new MyTarget { FailCounter = 1 };| var myTarget3 = new MyTarget();| var wrapper = CreateAndInitializeFallbackGroupTarget(false, myTarget1, myTarget2, myTarget3);| WriteAndAssertNoExceptions(wrapper);| Assert.Equal(1, myTarget1.WriteCount);| Assert.Equal(1, myTarget2.WriteCount);| Assert.Equal(10, myTarget3.WriteCount);| AssertNoFlushException(wrapper);| }| }"
      },
      {
        "name": "ReturnToFirstOnSuccessAndSecondTargetSucceeds_Write_ReturnToFirstTargetOnSuccess",
        "body": "{| using (new NoThrowNLogExceptions())| {| var myTarget1 = new MyTarget { FailCounter = 1 };| var myTarget2 = new MyTarget();| var myTarget3 = new MyTarget();| var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1, myTarget2, myTarget3);| WriteAndAssertNoExceptions(wrapper);| Assert.Equal(10, myTarget1.WriteCount);| Assert.Equal(1, myTarget2.WriteCount);| Assert.Equal(0, myTarget3.WriteCount);| AssertNoFlushException(wrapper);| }| }"
      },
      {
        "name": "FallbackGroupTargetSyncTest5",
        "body": "{| using (new NoThrowNLogExceptions())| {| // fail once| var myTarget1 = new MyTarget { FailCounter = 3 };| var myTarget2 = new MyTarget { FailCounter = 3 };| var myTarget3 = new MyTarget { FailCounter = 3 };| var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1, myTarget2, myTarget3);| var exceptions = new List<Exception>();| // no exceptions| for (var i = 0; i < 10; ++i)| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| Assert.Equal(10, exceptions.Count);| for (var i = 0; i < 10; ++i)| {| if (i < 3)| {| Assert.NotNull(exceptions[i]);| }| else| {| Assert.Null(exceptions[i]);| }| }| Assert.Equal(10, myTarget1.WriteCount);| Assert.Equal(3, myTarget2.WriteCount);| Assert.Equal(3, myTarget3.WriteCount);| AssertNoFlushException(wrapper);| }| }"
      },
      {
        "name": "FallbackGroupTargetSyncTest6",
        "body": "{| using (new NoThrowNLogExceptions())| {| // fail once| var myTarget1 = new MyTarget { FailCounter = 10 };| var myTarget2 = new MyTarget { FailCounter = 3 };| var myTarget3 = new MyTarget { FailCounter = 3 };| var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1, myTarget2, myTarget3);| var exceptions = new List<Exception>();| // no exceptions| for (var i = 0; i < 10; ++i)| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| Assert.Equal(10, exceptions.Count);| for (var i = 0; i < 10; ++i)| {| if (i < 3)| {| // for the first 3 rounds, no target is available| Assert.NotNull(exceptions[i]);| Assert.IsType<ApplicationException>(exceptions[i]);| Assert.Equal(\"Some failure.\", exceptions[i].Message);| }| else| {| Assert.Null(exceptions[i]);| }| }| Assert.Equal(10, myTarget1.WriteCount);| Assert.Equal(10, myTarget2.WriteCount);| Assert.Equal(3, myTarget3.WriteCount);| AssertNoFlushException(wrapper);| Assert.Equal(1, myTarget1.FlushCount);| Assert.Equal(1, myTarget2.FlushCount);| Assert.Equal(1, myTarget3.FlushCount);| }| }"
      },
      {
        "name": "FallbackGroupWithBufferingTargets_ReturnToFirstOnSuccess",
        "body": "{| FallbackGroupWithBufferingTargets(true);| }"
      },
      {
        "name": "FallbackGroupWithBufferingTargets_DoNotReturnToFirstOnSuccess",
        "body": "{| FallbackGroupWithBufferingTargets(false);| }"
      },
      {
        "name": "FallbackGroupTargetAsyncTest",
        "body": "{| using (new NoThrowNLogExceptions())| {| var myTarget1 = new MyTarget { FailCounter = int.MaxValue }; // Always failing.| var myTarget1Async = new AsyncTargetWrapper(myTarget1) { TimeToSleepBetweenBatches = 0 }; // Always failing.| var myTarget2 = new MyTarget() { Layout = \"${ndlc}\" };| var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1Async, myTarget2);| var exceptions = new List<Exception>();| // no exceptions| for (var i = 0; i < 10; ++i)| {| using (ScopeContext.PushNestedState(\"Hello World\"))| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| }| ManualResetEvent resetEvent = new ManualResetEvent(false);| myTarget1Async.Flush((ex) => { Assert.Null(ex); resetEvent.Set(); });| resetEvent.WaitOne(1000);| Assert.Equal(10, exceptions.Count);| for (var i = 0; i < 10; ++i)| {| Assert.Null(exceptions[i]);| }| Assert.Equal(10, myTarget2.WriteCount);| AssertNoFlushException(wrapper);| }| }"
      }
    ]
  },
  {
    "file": "FilteringTargetWrapperTests.cs",
    "methods": [
      {
        "name": "FilteringTargetWrapperSyncTest1",
        "body": "{| var myMockCondition = new MyMockCondition(true);| var myTarget = new MyTarget();| var wrapper = new FilteringTargetWrapper| {| WrappedTarget = myTarget,| Condition = myMockCondition,| };| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| bool continuationHit = false;| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit = true;| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.Equal(1, myMockCondition.CallCount);| Assert.True(continuationHit);| Assert.Null(lastException);| Assert.Equal(1, myTarget.WriteCount);| continuationHit = false;| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit);| Assert.Null(lastException);| Assert.Equal(2, myTarget.WriteCount);| Assert.Equal(2, myMockCondition.CallCount);| }"
      },
      {
        "name": "FilteringTargetWrapperAsyncTest1",
        "body": "{| var myMockCondition = new MyMockCondition(true);| var myTarget = new MyAsyncTarget();| var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.Null(lastException);| Assert.Equal(1, myTarget.WriteCount);| Assert.Equal(1, myMockCondition.CallCount);| continuationHit.Reset();| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.Null(lastException);| Assert.Equal(2, myTarget.WriteCount);| Assert.Equal(2, myMockCondition.CallCount);| }"
      },
      {
        "name": "FilteringTargetWrapperAsyncWithExceptionTest1",
        "body": "{| var myMockCondition = new MyMockCondition(true);| var myTarget = new MyAsyncTarget| {| ThrowExceptions = true,| };| var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.NotNull(lastException);| Assert.IsType<InvalidOperationException>(lastException);| Assert.Equal(1, myTarget.WriteCount);| Assert.Equal(1, myMockCondition.CallCount);| continuationHit.Reset();| lastException = null;| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.NotNull(lastException);| Assert.IsType<InvalidOperationException>(lastException);| Assert.Equal(2, myTarget.WriteCount);| Assert.Equal(2, myMockCondition.CallCount);| }"
      },
      {
        "name": "FilteringTargetWrapperSyncTest2",
        "body": "{| var myMockCondition = new MyMockCondition(false);| var myTarget = new MyTarget();| var wrapper = new FilteringTargetWrapper| {| WrappedTarget = myTarget,| Condition = myMockCondition,| };| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| bool continuationHit = false;| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit = true;| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.Equal(1, myMockCondition.CallCount);| Assert.True(continuationHit);| Assert.Null(lastException);| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(1, myMockCondition.CallCount);| continuationHit = false;| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| Assert.True(continuationHit);| Assert.Null(lastException);| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(2, myMockCondition.CallCount);| }"
      },
      {
        "name": "FilteringTargetWrapperAsyncTest2",
        "body": "{| var myMockCondition = new MyMockCondition(false);| var myTarget = new MyAsyncTarget();| var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.Null(lastException);| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(1, myMockCondition.CallCount);| continuationHit.Reset();| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.Null(lastException);| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(2, myMockCondition.CallCount);| }"
      },
      {
        "name": "FilteringTargetWrapperAsyncWithExceptionTest2",
        "body": "{| var myMockCondition = new MyMockCondition(false);| var myTarget = new MyAsyncTarget| {| ThrowExceptions = true,| };| var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);| myTarget.Initialize(null);| wrapper.Initialize(null);| var logEvent = new LogEventInfo();| Exception lastException = null;| var continuationHit = new ManualResetEvent(false);| AsyncContinuation continuation =| ex =>| {| lastException = ex;| continuationHit.Set();| };| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.Null(lastException);| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(1, myMockCondition.CallCount);| continuationHit.Reset();| lastException = null;| wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));| continuationHit.WaitOne();| Assert.Null(lastException);| Assert.Equal(0, myTarget.WriteCount);| Assert.Equal(2, myMockCondition.CallCount);| }"
      },
      {
        "name": "FilteringTargetWrapperWhenRepeatedFilter",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <variable name='test' value='${message}' />| <targets>| <target name='debug' type='BufferingWrapper'>| <target name='filter' type='FilteringWrapper'>| <filter type='whenRepeated' layout='${var:test:whenempty=${guid}}' timeoutSeconds='30' action='Ignore' />| <target name='memory' type='Memory' />| </target>| </target>| </targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug'/>| </rules>| </nlog>\").LogFactory;| var myTarget = logFactory.Configuration.FindTargetByName<MemoryTarget>(\"memory\");| var logger = logFactory.GetLogger(nameof(FilteringTargetWrapperWhenRepeatedFilter));| logger.Info(\"Hello World\");| logger.Info(\"Hello World\"); // Will be ignored| logger.Info(\"Goodbye World\");| logger.Warn(\"Goodbye World\");| logFactory.Flush();| Assert.Equal(3, myTarget.Logs.Count);| logger.Info(\"Hello World\"); // Will be ignored| logger.Error(\"Goodbye World\");| logger.Fatal(\"Goodbye World\");| logFactory.Flush();| Assert.Equal(5, myTarget.Logs.Count);| }"
      },
      {
        "name": "FilteringTargetWrapperWithConditionAttribute_correctBehavior",
        "body": "{| // Arrange| var logFactory = CreateConfigWithCondition();| var myTarget = logFactory.Configuration.FindTargetByName<MemoryTarget>(\"memory\");| // Act| var logger = logFactory.GetLogger(nameof(FilteringTargetWrapperWhenRepeatedFilter));| logger.Info(\"Hello World\");| logger.Info(\"2\"); // Will be ignored| logger.Info(\"3\"); // Will be ignored| logFactory.Flush();| // Assert| Assert.Single(myTarget.Logs);| }"
      },
      {
        "name": "FilteringTargetWrapperWithConditionAttribute_validCondition",
        "body": "{| // Arrange| var expectedCondition = \"(length(message) > 2)\";| // Act| var logFactory = CreateConfigWithCondition();| // Assert| var myTarget = logFactory.Configuration.FindTargetByName<FilteringTargetWrapper>(\"target1\");| Assert.Equal(expectedCondition, myTarget.Condition?.ToString());| var conditionBasedFilter = Assert.IsType<ConditionBasedFilter>(myTarget.Filter);| Assert.Equal(expectedCondition, conditionBasedFilter.Condition?.ToString());| }"
      }
    ]
  },
  {
    "file": "GroupByTargetWrapperTests.cs",
    "methods": [
      {
        "name": "SimpleGroupByTest",
        "body": "{| // Arrange| var memoryTarget = new MemoryTarget(\"memory\") { Layout = \"${level}\" };| var groupByTarget = new GroupByTargetWrapper(\"groupby\", memoryTarget, \"${logger}\");| var bufferTarget = new BufferingTargetWrapper(\"buffer\", groupByTarget);| var logFactory = new LogFactory();| var logConfig = new NLog.Config.LoggingConfiguration(logFactory);| logConfig.AddRule(LogLevel.Info, LogLevel.Fatal, bufferTarget);| logFactory.Configuration = logConfig;| var logger1 = logFactory.GetLogger(\"Logger1\");| var logger2 = logFactory.GetLogger(\"Logger2\");| var logger3 = logFactory.GetLogger(\"Logger3\");| // Act| logger1.Trace(\"Ignore Me\");| logger2.Warn(\"Special Warning\");| logger1.Debug(\"Hello world\");| logger1.Fatal(\"Catastropic Goodbye\");| logger2.Error(\"General Error\");| logFactory.Flush();| groupByTarget.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Info, logger1.Name, \"Special Hello\").WithContinuation((ex) => { }));| // Assert| Assert.Equal(4, memoryTarget.Logs.Count);| Assert.Equal(\"Warn\", memoryTarget.Logs[0]);| Assert.Equal(\"Error\", memoryTarget.Logs[1]);| Assert.Equal(\"Fatal\", memoryTarget.Logs[2]);| Assert.Equal(\"Info\", memoryTarget.Logs[3]);| }"
      }
    ]
  },
  {
    "file": "LimitingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "WriteMoreMessagesThanLimitOnlyWritesLimitMessages",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <wrapper-target name='limiting' type='LimitingWrapper' messagelimit='5'>| <target name='debug' type='Debug' layout='${message}' />| </wrapper-target>| </targets>| <rules>| <logger name='*' level='Debug' writeTo='limiting' />| </rules>| </nlog>\").LogFactory;| const int messagelimit = 5;| var logger = logFactory.GetLogger(\"A\");| for (int i = 1; i <= 10; i++)| {| logger.Debug(\"message {0}\", i);| //Should have only written 5 messages, since limit is 5.| if (i <= messagelimit)| logFactory.AssertDebugLastMessage($\"message {i}\");| }| logFactory.AssertDebugLastMessage(\"debug\", $\"message {messagelimit}\");| }"
      },
      {
        "name": "WriteMessagesAfterLimitExpiredWritesMessages",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <wrapper-target name='limiting' type='LimitingWrapper' messagelimit='5' interval='0:0:0:0.100'>| <target name='debug' type='Debug' layout='${message}' />| </wrapper-target>| </targets>| <rules>| <logger name='*' level='Debug' writeTo='limiting' />| </rules>| </nlog>\").LogFactory;| const int messagelimit = 5;| var logger = logFactory.GetLogger(\"A\");| for (int i = 1; i <= 10; i++)| {| logger.Debug(\"message {0}\", i);| if (i <= messagelimit)| logFactory.AssertDebugLastMessage($\"message {i}\");| }| //Wait for the interval to expire.| Thread.Sleep(100);| for (int i = 1; i <= 10; i++)| {| logger.Debug(\"message {0}\", i + 10);| if (i <= messagelimit)| logFactory.AssertDebugLastMessage($\"message {i + 10}\");| }| //Should have written 10 messages.| //5 from the first interval and 5 from the second.| logFactory.AssertDebugLastMessage(\"debug\", \"message 15\");| }"
      },
      {
        "name": "WriteMessagesLessThanMessageLimitWritesToWrappedTarget",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromMilliseconds(100));| InitializeTargets(wrappedTarget, wrapper);| // Write limit number of messages should just write them to the wrappedTarget.| WriteNumberAsyncLogEventsStartingAt(0, 5, wrapper);| Assert.Equal(5, wrappedTarget.WriteCount);| //Let the interval expire to start a new one.| Thread.Sleep(100);| // Write limit number of messages should just write them to the wrappedTarget.| var lastException = WriteNumberAsyncLogEventsStartingAt(5, 5, wrapper);| // We should have 10 messages (5 from first interval, 5 from second interval).| Assert.Equal(10, wrappedTarget.WriteCount);| Assert.Null(lastException);| }"
      },
      {
        "name": "WriteMoreMessagesThanMessageLimitDiscardsExcessMessages",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromHours(1));| InitializeTargets(wrappedTarget, wrapper);| // Write limit number of messages should just write them to the wrappedTarget.| var lastException = WriteNumberAsyncLogEventsStartingAt(0, 5, wrapper);| Assert.Equal(5, wrappedTarget.WriteCount);| //Additional messages will be discarded, but InternalLogger will write to trace.| string internalLog = RunAndCaptureInternalLog(() =>| {| wrapper.WriteAsyncLogEvent(| new LogEventInfo(LogLevel.Debug, \"test\", $\"Hello {5}\").WithContinuation(ex => lastException = ex));| }, LogLevel.Trace);| Assert.Equal(5, wrappedTarget.WriteCount);| Assert.Contains(\"MessageLimit\", internalLog);| Assert.Null(lastException);| }"
      },
      {
        "name": "WriteMessageAfterIntervalHasExpiredStartsNewInterval",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromMilliseconds(100));| InitializeTargets(wrappedTarget, wrapper);| Exception lastException = null;| wrapper.WriteAsyncLogEvent(| new LogEventInfo(LogLevel.Debug, \"test\", \"first interval\").WithContinuation(ex => lastException = ex));| //Let the interval expire.| Thread.Sleep(100);| //Writing a logEvent should start a new Interval. This should be written to InternalLogger.Debug.| string internalLog = RunAndCaptureInternalLog(() =>| {| // We can write 5 messages again since a new interval started.| lastException = WriteNumberAsyncLogEventsStartingAt(0, 5, wrapper);| }, LogLevel.Trace);| //We should have written 6 messages (1 in first interval and 5 in second interval).| Assert.Equal(6, wrappedTarget.WriteCount);| Assert.Contains(\"New interval\", internalLog);| Assert.Null(lastException);| }"
      },
      {
        "name": "TestWritingMessagesOverMultipleIntervals",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromMilliseconds(100));| InitializeTargets(wrappedTarget, wrapper);| Exception lastException = null;| lastException = WriteNumberAsyncLogEventsStartingAt(0, 10, wrapper);| //Let the interval expire.| Thread.Sleep(100);| Assert.Equal(5, wrappedTarget.WriteCount);| Assert.Equal(\"Hello 4\", wrappedTarget.LastWrittenMessage);| Assert.Null(lastException);| lastException = WriteNumberAsyncLogEventsStartingAt(10, 10, wrapper);| //We should have 10 messages (5 from first, 5 from second interval).| Assert.Equal(10, wrappedTarget.WriteCount);| Assert.Equal(\"Hello 14\", wrappedTarget.LastWrittenMessage);| Assert.Null(lastException);| //Let the interval expire.| Thread.Sleep(230);| lastException = WriteNumberAsyncLogEventsStartingAt(20, 10, wrapper);| //We should have 15 messages (5 from first, 5 from second, 5 from third interval).| Assert.Equal(15, wrappedTarget.WriteCount);| Assert.Equal(\"Hello 24\", wrappedTarget.LastWrittenMessage);| Assert.Null(lastException);| //Let the interval expire.| Thread.Sleep(20);| lastException = WriteNumberAsyncLogEventsStartingAt(30, 10, wrapper);| //No more messages should be been written, since we are still in the third interval.| Assert.Equal(15, wrappedTarget.WriteCount);| Assert.Equal(\"Hello 24\", wrappedTarget.LastWrittenMessage);| Assert.Null(lastException);| }"
      },
      {
        "name": "ConstructorWithNoParametersInitialisesDefaultsCorrectly",
        "body": "{| LimitingTargetWrapper wrapper = new LimitingTargetWrapper();| Assert.Equal(1000, wrapper.MessageLimit);| Assert.Equal(TimeSpan.FromHours(1), wrapper.Interval);| }"
      },
      {
        "name": "ConstructorWithTargetInitialisesDefaultsCorrectly",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget);| Assert.Equal(1000, wrapper.MessageLimit);| Assert.Equal(TimeSpan.FromHours(1), wrapper.Interval);| }"
      },
      {
        "name": "ConstructorWithNameInitialisesDefaultsCorrectly",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(\"Wrapper\", wrappedTarget);| Assert.Equal(1000, wrapper.MessageLimit);| Assert.Equal(TimeSpan.FromHours(1), wrapper.Interval);| }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfMessageLimitIsSetToZero",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { MessageLimit = 0 };| wrappedTarget.Initialize(null);| LogManager.ThrowConfigExceptions = true;| Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));| LogManager.ThrowConfigExceptions = false;| }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfMessageLimitIsSmallerZero",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { MessageLimit = -1 };| wrappedTarget.Initialize(null);| LogManager.ThrowConfigExceptions = true;| Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));| LogManager.ThrowConfigExceptions = false;| }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfIntervalIsSmallerZero",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { Interval = TimeSpan.MinValue };| wrappedTarget.Initialize(null);| LogManager.ThrowConfigExceptions = true;| Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));| LogManager.ThrowConfigExceptions = false;| }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfIntervalIsZero",
        "body": "{| MyTarget wrappedTarget = new MyTarget();| LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { Interval = TimeSpan.Zero };| wrappedTarget.Initialize(null);| LogManager.ThrowConfigExceptions = true;| Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));| LogManager.ThrowConfigExceptions = false;| }"
      },
      {
        "name": "CreatingFromConfigSetsMessageLimitCorrectly",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <wrapper-target name='limiting' type='LimitingWrapper' messagelimit='50'>| <target name='debug' type='Debug' layout='${message}' />| </wrapper-target>| </targets>| <rules>| <logger name='*' level='Debug' writeTo='limiting' />| </rules>| </nlog>\").LogFactory;| LimitingTargetWrapper limitingWrapper = logFactory.Configuration.FindTargetByName<LimitingTargetWrapper>(\"limiting\");| DebugTarget debugTarget = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\");| Assert.NotNull(limitingWrapper);| Assert.NotNull(debugTarget);| Assert.Equal(50, limitingWrapper.MessageLimit);| Assert.Equal(TimeSpan.FromHours(1), limitingWrapper.Interval);| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| }"
      },
      {
        "name": "CreatingFromConfigSetsIntervalCorrectly",
        "body": "{| var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"| <nlog>| <targets>| <wrapper-target name='limiting' type='LimitingWrapper' interval='1:2:5:00'>| <target name='debug' type='Debug' layout='${message}' />| </wrapper-target>| </targets>| <rules>| <logger name='*' level='Debug' writeTo='limiting' />| </rules>| </nlog>\").LogFactory;| LimitingTargetWrapper limitingWrapper = logFactory.Configuration.FindTargetByName<LimitingTargetWrapper>(\"limiting\");| DebugTarget debugTarget = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\");| Assert.NotNull(limitingWrapper);| Assert.NotNull(debugTarget);| Assert.Equal(1000, limitingWrapper.MessageLimit);| Assert.Equal(TimeSpan.FromDays(1) + TimeSpan.FromHours(2) + TimeSpan.FromMinutes(5), limitingWrapper.Interval);| var logger = logFactory.GetLogger(\"A\");| logger.Debug(\"a\");| logFactory.AssertDebugLastMessage(\"a\");| }"
      }
    ]
  },
  {
    "file": "PostFilteringTargetWrapperTests.cs",
    "methods": [
      {
        "name": "PostFilteringTargetWrapperUsingDefaultFilterTest",
        "body": "{| var target = new MyTarget();| var wrapper = new PostFilteringTargetWrapper()| {| WrappedTarget = target,| Rules =| {| // if we had any warnings, log debug too| new FilteringRule(\"level >= LogLevel.Warn\", \"level >= LogLevel.Debug\"),| // when there is an error, emit everything| new FilteringRule| {| Exists = \"level >= LogLevel.Error\",| Filter = \"true\",| },| },| // by default log info and above| DefaultFilter = \"level >= LogLevel.Info\",| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),| };| wrapper.WriteAsyncLogEvents(events);| // make sure all Info events went through| Assert.Equal(3, target.Events.Count);| Assert.Same(events[1].LogEvent, target.Events[0]);| Assert.Same(events[2].LogEvent, target.Events[1]);| Assert.Same(events[5].LogEvent, target.Events[2]);| Assert.Equal(events.Length, exceptions.Count);| }"
      },
      {
        "name": "PostFilteringTargetWrapperUsingDefaultNonFilterTest",
        "body": "{| var target = new MyTarget();| var wrapper = new PostFilteringTargetWrapper()| {| WrappedTarget = target,| Rules =| {| // if we had any warnings, log debug too| new FilteringRule(\"level >= LogLevel.Warn\", \"level >= LogLevel.Debug\"),| // when there is an error, emit everything| new FilteringRule(\"level >= LogLevel.Error\", \"true\"),| },| // by default log info and above| DefaultFilter = \"level >= LogLevel.Info\",| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Warn, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| };| string result = RunAndCaptureInternalLog(() => wrapper.WriteAsyncLogEvents(events), LogLevel.Trace);| Assert.Contains(\"Running on 7 events\", result);| Assert.Contains(\"Rule matched: (level >= Warn)\", result);| Assert.Contains(\"Filter to apply: (level >= Debug)\", result);| Assert.Contains(\"After filtering: 6 events.\", result);| Assert.Contains(\"Sending to MyTarget\", result);| // make sure all Debug,Info,Warn events went through| Assert.Equal(6, target.Events.Count);| Assert.Same(events[0].LogEvent, target.Events[0]);| Assert.Same(events[1].LogEvent, target.Events[1]);| Assert.Same(events[2].LogEvent, target.Events[2]);| Assert.Same(events[3].LogEvent, target.Events[3]);| Assert.Same(events[5].LogEvent, target.Events[4]);| Assert.Same(events[6].LogEvent, target.Events[5]);| Assert.Equal(events.Length, exceptions.Count);| }"
      },
      {
        "name": "PostFilteringTargetWrapperUsingDefaultNonFilterTest2",
        "body": "{| // in this case both rules would match, but first one is picked| var target = new MyTarget();| var wrapper = new PostFilteringTargetWrapper()| {| WrappedTarget = target,| Rules =| {| // when there is an error, emit everything| new FilteringRule(\"level >= LogLevel.Error\", \"true\"),| // if we had any warnings, log debug too| new FilteringRule(\"level >= LogLevel.Warn\", \"level >= LogLevel.Debug\"),| },| // by default log info and above| DefaultFilter = \"level >= LogLevel.Info\",| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Error, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| };| var result = RunAndCaptureInternalLog(() => wrapper.WriteAsyncLogEvents(events), LogLevel.Trace);| Assert.Contains(\"Running on 7 events\", result);| Assert.Contains(\"Rule matched: (level >= Error)\", result);| Assert.Contains(\"Filter to apply: True\", result);| Assert.Contains(\"After filtering: 7 events.\", result);| Assert.Contains(\"Sending to MyTarget\", result);| // make sure all events went through| Assert.Equal(7, target.Events.Count);| Assert.Same(events[0].LogEvent, target.Events[0]);| Assert.Same(events[1].LogEvent, target.Events[1]);| Assert.Same(events[2].LogEvent, target.Events[2]);| Assert.Same(events[3].LogEvent, target.Events[3]);| Assert.Same(events[4].LogEvent, target.Events[4]);| Assert.Same(events[5].LogEvent, target.Events[5]);| Assert.Same(events[6].LogEvent, target.Events[6]);| Assert.Equal(events.Length, exceptions.Count);| }"
      },
      {
        "name": "PostFilteringTargetWrapperOnlyDefaultFilter",
        "body": "{| var target = new MyTarget();| var wrapper = new PostFilteringTargetWrapper()| {| WrappedTarget = target,| DefaultFilter = \"level >= LogLevel.Info\", // by default log info and above| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| wrapper.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add));| Assert.Single(target.Events);| wrapper.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add));| Assert.Single(target.Events);| }"
      },
      {
        "name": "PostFilteringTargetWrapperNoFiltersDefined",
        "body": "{| var target = new MyTarget();| var wrapper = new PostFilteringTargetWrapper()| {| WrappedTarget = target,| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Error, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| };| wrapper.WriteAsyncLogEvents(events);| // make sure all events went through| Assert.Equal(7, target.Events.Count);| Assert.Same(events[0].LogEvent, target.Events[0]);| Assert.Same(events[1].LogEvent, target.Events[1]);| Assert.Same(events[2].LogEvent, target.Events[2]);| Assert.Same(events[3].LogEvent, target.Events[3]);| Assert.Same(events[4].LogEvent, target.Events[4]);| Assert.Same(events[5].LogEvent, target.Events[5]);| Assert.Same(events[6].LogEvent, target.Events[6]);| Assert.Equal(events.Length, exceptions.Count);| }"
      }
    ]
  },
  {
    "file": "RandomizeGroupTargetTests.cs",
    "methods": [
      {
        "name": "RandomizeGroupSyncTest1",
        "body": "{| var myTarget1 = new MyTarget();| var myTarget2 = new MyTarget();| var myTarget3 = new MyTarget();| var wrapper = new RandomizeGroupTarget()| {| Targets = { myTarget1, myTarget2, myTarget3 },| };| myTarget1.Initialize(null);| myTarget2.Initialize(null);| myTarget3.Initialize(null);| wrapper.Initialize(null);| List<Exception> exceptions = new List<Exception>();| // no exceptions| for (int i = 0; i < 10; ++i)| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| Assert.Equal(10, exceptions.Count);| foreach (var e in exceptions)| {| Assert.Null(e);| }| Assert.Equal(10, myTarget1.WriteCount + myTarget2.WriteCount + myTarget3.WriteCount);| Exception flushException = null;| var flushHit = new ManualResetEvent(false);| wrapper.Flush(ex => { flushException = ex; flushHit.Set(); });| flushHit.WaitOne();| Assert.True(flushException is null, flushException?.ToString());| Assert.Equal(1, myTarget1.FlushCount);| Assert.Equal(1, myTarget2.FlushCount);| Assert.Equal(1, myTarget3.FlushCount);| }"
      },
      {
        "name": "RandomizeGroupSyncTest2",
        "body": "{| var wrapper = new RandomizeGroupTarget()| {| // no targets| };| wrapper.Initialize(null);| List<Exception> exceptions = new List<Exception>();| // no exceptions| for (int i = 0; i < 10; ++i)| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| Assert.Equal(10, exceptions.Count);| foreach (var e in exceptions)| {| Assert.Null(e);| }| Exception flushException = new Exception(\"Flush not hit synchronously.\");| wrapper.Flush(ex => flushException = ex);| Assert.True(flushException is null, flushException?.ToString());| }"
      }
    ]
  },
  {
    "file": "RepeatingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "RepeatingTargetWrapperTest1",
        "body": "{| var target = new MyTarget();| var wrapper = new RepeatingTargetWrapper()| {| WrappedTarget = target,| RepeatCount = 3,| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| };| wrapper.WriteAsyncLogEvents(events);| // make sure all events went through and were replicated 3 times| Assert.Equal(9, target.Events.Count);| Assert.Same(events[0].LogEvent, target.Events[0]);| Assert.Same(events[0].LogEvent, target.Events[1]);| Assert.Same(events[0].LogEvent, target.Events[2]);| Assert.Same(events[1].LogEvent, target.Events[3]);| Assert.Same(events[1].LogEvent, target.Events[4]);| Assert.Same(events[1].LogEvent, target.Events[5]);| Assert.Same(events[2].LogEvent, target.Events[6]);| Assert.Same(events[2].LogEvent, target.Events[7]);| Assert.Same(events[2].LogEvent, target.Events[8]);| Assert.Equal(events.Length, exceptions.Count);| }"
      },
      {
        "name": "RepeatingTargetWrapperTest2",
        "body": "{| using (new NoThrowNLogExceptions())| {| var target = new MyTarget();| target.ThrowExceptions = true;| var wrapper = new RepeatingTargetWrapper()| {| WrappedTarget = target,| RepeatCount = 3,| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| };| wrapper.WriteAsyncLogEvents(events);| // make sure all events went through but were registered only once| // since repeating target wrapper will not repeat in case of exception.| Assert.Equal(3, target.Events.Count);| Assert.Same(events[0].LogEvent, target.Events[0]);| Assert.Same(events[1].LogEvent, target.Events[1]);| Assert.Same(events[2].LogEvent, target.Events[2]);| Assert.Equal(events.Length, exceptions.Count);| foreach (var exception in exceptions)| {| Assert.NotNull(exception);| Assert.Equal(\"Some exception has occurred.\", exception.Message);| }| }| }"
      }
    ]
  },
  {
    "file": "RetryingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "RetryingTargetWrapperTest1",
        "body": "{| var target = new MyTarget();| var wrapper = new RetryingTargetWrapper()| {| WrappedTarget = target,| RetryCount = 10,| RetryDelayMilliseconds = 1,| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| };| wrapper.WriteAsyncLogEvents(events);| // make sure all events went through| Assert.Equal(3, target.Events.Count);| Assert.Same(events[0].LogEvent, target.Events[0]);| Assert.Same(events[1].LogEvent, target.Events[1]);| Assert.Same(events[2].LogEvent, target.Events[2]);| Assert.Equal(events.Length, exceptions.Count);| // make sure there were no exception| foreach (var ex in exceptions)| {| Assert.Null(ex);| }| }"
      },
      {
        "name": "RetryingTargetWrapperTest2",
        "body": "{| var target = new MyTarget()| {| ThrowExceptions = 6,| };| var wrapper = new RetryingTargetWrapper()| {| WrappedTarget = target,| RetryCount = 4,| RetryDelayMilliseconds = 1,| };| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| };| var result = RunAndCaptureInternalLog(() => wrapper.WriteAsyncLogEvents(events), LogLevel.Trace);| Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 1/4\", result);| Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 2/4\", result);| Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 3/4\", result);| Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 4/4\", result);| Assert.Contains(\"Too many retries. Aborting.\", result);| Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 1/4\", result);| Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 2/4\", result);| // first event does not get to wrapped target because of too many attempts.| // second event gets there in 3rd retry| // and third event gets there immediately| Assert.Equal(2, target.Events.Count);| Assert.Same(events[1].LogEvent, target.Events[0]);| Assert.Same(events[2].LogEvent, target.Events[1]);| Assert.Equal(events.Length, exceptions.Count);| Assert.NotNull(exceptions[0]);| Assert.Equal(\"Some exception has occurred.\", exceptions[0].Message);| Assert.Null(exceptions[1]);| Assert.Null(exceptions[2]);| }"
      },
      {
        "name": "RetryingTargetWrapperBlockingCloseTest",
        "body": "{| RetryingIntegrationTest(3, () =>| {| var target = new MyTarget()| {| ThrowExceptions = 5,| };| var wrapper = new RetryingTargetWrapper()| {| WrappedTarget = target,| RetryCount = 10,| RetryDelayMilliseconds = 5000,| };| var asyncWrapper = new AsyncTargetWrapper(wrapper) { TimeToSleepBetweenBatches = 1 };| asyncWrapper.Initialize(null);| wrapper.Initialize(null);| target.Initialize(null);| var exceptions = new List<Exception>();| var events = new[]| {| new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),| new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),| };| // Attempt to write LogEvents that will take forever to retry| asyncWrapper.WriteAsyncLogEvents(events);| // Wait a little for the AsyncWrapper to start writing| System.Threading.Thread.Sleep(50);| // Close down the AsyncWrapper while busy writing| asyncWrapper.Close();| // Close down the RetryingWrapper while busy retrying| wrapper.Close();| // Close down the actual target while busy writing| target.Close();| // Wait a little for the RetryingWrapper to detect that it has been closed down| System.Threading.Thread.Sleep(200);| // The premature abort, causes the exception to be logged| Assert.NotNull(exceptions[0]);| });| }"
      },
      {
        "name": "RetryingTargetWrapperBatchingTest",
        "body": "{| var target = new MyTarget()| {| ThrowExceptions = 3,| };| var retryWrapper = new RetryingTargetWrapper()| {| WrappedTarget = target,| RetryCount = 2,| RetryDelayMilliseconds = 10,| EnableBatchWrite = true,| };| var asyncWrapper = new AsyncTargetWrapper(retryWrapper) { TimeToSleepBetweenBatches = 5000 };| var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>| {| builder.ForLogger().WriteTo(asyncWrapper);| }).LogFactory;| // Verify that RetryingTargetWrapper is not sleeping for every LogEvent in single batch| var stopWatch = new System.Diagnostics.Stopwatch();| stopWatch.Start();| var logger = logFactory.GetCurrentClassLogger();| for (int i = 1; i <= 500; ++i)| logger.Info(\"Test {0}\", i);| logFactory.Flush();| Assert.Equal(1, target.WriteBatchCount);| for (int i = 0; i < 5000; ++i)| {| if (target.Events.Count >= 495)| break;| System.Threading.Thread.Sleep(1);| }| Assert.Equal(1, target.WriteBatchCount);| Assert.InRange(target.Events.Count, 495, 500);| Assert.InRange(stopWatch.ElapsedMilliseconds, 0, 3000);| }"
      }
    ]
  },
  {
    "file": "RoundRobinGroupTargetTests.cs",
    "methods": [
      {
        "name": "RoundRobinGroupTargetSyncTest1",
        "body": "{| var myTarget1 = new MyTarget();| var myTarget2 = new MyTarget();| var myTarget3 = new MyTarget();| var wrapper = new RoundRobinGroupTarget()| {| Targets = { myTarget1, myTarget2, myTarget3 },| };| myTarget1.Initialize(null);| myTarget2.Initialize(null);| myTarget3.Initialize(null);| wrapper.Initialize(null);| List<Exception> exceptions = new List<Exception>();| // no exceptions| for (int i = 0; i < 10; ++i)| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| Assert.Equal(10, exceptions.Count);| foreach (var e in exceptions)| {| Assert.Null(e);| }| Assert.Equal(4, myTarget1.WriteCount);| Assert.Equal(3, myTarget2.WriteCount);| Assert.Equal(3, myTarget3.WriteCount);| Exception flushException = null;| var flushHit = new ManualResetEvent(false);| wrapper.Flush(ex => { flushException = ex; flushHit.Set(); });| flushHit.WaitOne();| Assert.True(flushException is null, flushException?.ToString());| Assert.Equal(1, myTarget1.FlushCount);| Assert.Equal(1, myTarget2.FlushCount);| Assert.Equal(1, myTarget3.FlushCount);| }"
      },
      {
        "name": "RoundRobinGroupTargetSyncTest2",
        "body": "{| var wrapper = new RoundRobinGroupTarget()| {| // empty target list| };| wrapper.Initialize(null);| List<Exception> exceptions = new List<Exception>();| // no exceptions| for (int i = 0; i < 10; ++i)| {| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));| }| Assert.Equal(10, exceptions.Count);| foreach (var e in exceptions)| {| Assert.Null(e);| }| Exception flushException = null;| var flushHit = new ManualResetEvent(false);| wrapper.Flush(ex => { flushException = ex; flushHit.Set(); });| flushHit.WaitOne();| Assert.True(flushException is null, flushException?.ToString());| }"
      }
    ]
  },
  {
    "file": "SplitGroupTargetTests.cs",
    "methods": [
      {
        "name": "NoTargets_SplitGroupTarget_IsWorking",
        "body": "{| SplitGroupTarget_Exercise(ArrayHelper.Empty<MyTarget>());| }"
      },
      {
        "name": "SingleTarget_SplitGroupTarget_IsWorking",
        "body": "{| SplitGroupTarget_Exercise(new[] { new MyTarget() });| }"
      },
      {
        "name": "MultipleTargets_SplitGroupTarget_IsWorking",
        "body": "{| SplitGroupTarget_Exercise(new[] { new MyTarget(), new MyTarget(), new MyTarget() });| }"
      },
      {
        "name": "FirstTargetFails_SplitGroupTarget_WritesToAll",
        "body": "{| using (new NoThrowNLogExceptions())| {| int logEventFailCount = 2;| var failingTarget = new MyTarget() { FailCounter = logEventFailCount };| SplitGroupTarget_Exercise(new[] { failingTarget, new MyTarget(), new MyTarget() }, logEventFailCount);| }| }"
      },
      {
        "name": "AsyncOutOfOrder_SplitGroupTarget_IsWorking",
        "body": "{| var targets = Enumerable.Range(0, 3).Select(i => new AsyncTargetWrapper(i.ToString(), new MyTarget()) { TimeToSleepBetweenBatches = i * 10 }).ToArray();| targets.ToList().ForEach(t => t.WrappedTarget.Initialize(null));| Func<Target, MyTarget> lookupTarget = t => (MyTarget)((AsyncTargetWrapper)t).WrappedTarget;| SplitGroupTarget_Exercise(targets, 0, lookupTarget);| }"
      },
      {
        "name": "SplitGroupToStringTest",
        "body": "{| var myTarget1 = new MyTarget();| var myTarget2 = new FileTarget(\"file1\");| var myTarget3 = new ConsoleTarget(\"Console2\");| var wrapper = new SplitGroupTarget()| {| Targets = { myTarget1, myTarget2, myTarget3 },| };| Assert.Equal(\"SplitGroup[MyTarget([unnamed]), FileTarget(Name=file1), ConsoleTarget(Name=Console2)]\", wrapper.ToString());| }"
      }
    ]
  },
  {
    "file": "WrapperTargetBaseTests.cs",
    "methods": [
      {
        "name": "WrapperTargetNestedToStringTest",
        "body": "{| var wrapper = new MyWrapper| {| WrappedTarget = new DebugTarget() { Name = \"foo\" },| };| var wrapper2 = new MyWrapper()| {| WrappedTarget = wrapper,| };| Assert.Equal(\"MyWrapper_MyWrapper_DebugTarget(Name=foo)\", wrapper2.ToString());| }"
      },
      {
        "name": "WrapperTargetToStringTest",
        "body": "{| var wrapper = new MyWrapper| {| Name = \"foo\",| WrappedTarget = new DebugTarget() { Name = \"foo_wrapped\" },| };| Assert.Equal(\"MyWrapper_DebugTarget(Name=foo)\", wrapper.ToString());| }"
      },
      {
        "name": "WrapperTargetFlushTest",
        "body": "{| var wrapped = new MyWrappedTarget();| var wrapper = new MyWrapper| {| WrappedTarget = wrapped,| };| wrapper.Initialize(null);| wrapped.Initialize(null);| wrapper.Flush(ex => { });| Assert.Equal(1, wrapped.FlushCount);| }"
      },
      {
        "name": "WrapperTargetDefaultWriteTest",
        "body": "{| using (new NoThrowNLogExceptions())| {| Exception lastException = null;| var wrapper = new MyWrapper();| wrapper.WrappedTarget = new MyWrappedTarget();| wrapper.Initialize(null);| wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => lastException = ex));| Assert.NotNull(lastException);| Assert.IsType<NotSupportedException>(lastException);| }| }"
      }
    ]
  },
  {
    "file": "TimeSourceTests.cs",
    "methods": [
      {
        "name": "AccurateLocalTest",
        "body": "{| TestTimeSource(new AccurateLocalTimeSource(), DateTime.Now, DateTimeKind.Local);| }"
      },
      {
        "name": "AccurateUtcTest",
        "body": "{| TestTimeSource(new AccurateUtcTimeSource(), DateTime.UtcNow, DateTimeKind.Utc);| }"
      },
      {
        "name": "FastLocalTest",
        "body": "{| TestTimeSource(new FastLocalTimeSource(), DateTime.Now, DateTimeKind.Local);| }"
      },
      {
        "name": "FastUtcTest",
        "body": "{| TestTimeSource(new FastUtcTimeSource(), DateTime.UtcNow, DateTimeKind.Utc);| }"
      },
      {
        "name": "CustomTimeSourceTest",
        "body": "{| TestTimeSource(new CustomTimeSource(), DateTime.UtcNow.AddHours(1), DateTimeKind.Unspecified);| }"
      }
    ]
  },
  {
    "file": "RegistryTests.cs",
    "methods": [
      {
        "name": "RegistryNamedValueTest",
        "body": "{| AssertLayoutRendererResult(\"FooValue\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=Foo}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryNamedValueTest_hive32",
        "body": "{| AssertLayoutRendererResult(\"reg32\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=view32:view=Registry32}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryNamedValueTest_hive64",
        "body": "{| AssertLayoutRendererResult(\"reg64\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=view64:view=Registry64}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryNamedValueTest_forward_slash",
        "body": "{| AssertLayoutRendererResult(\"FooValue\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU/Software/NLogTest:value=Foo}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryUnnamedValueTest",
        "body": "{| AssertLayoutRendererResult(\"UnnamedValue\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryUnnamedValueTest_forward_slash",
        "body": "{| AssertLayoutRendererResult(\"UnnamedValue\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU/Software/NLogTest}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryKeyNotFoundTest",
        "body": "{| AssertLayoutRendererResult(\"xyz\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NoSuchKey:defaultValue=xyz}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryKeyNotFoundTest_forward_slash",
        "body": "{| AssertLayoutRendererResult(\"xyz\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU/Software/NoSuchKey:defaultValue=xyz}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryValueNotFoundTest",
        "body": "{| AssertLayoutRendererResult(\"xyz\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=NoSuchValue:defaultValue=xyz}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryDefaultValueTest",
        "body": "{| AssertLayoutRendererResult(\"logdefaultvalue\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=logdefaultvalue}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryDefaultValueTest_with_colon",
        "body": "{| AssertLayoutRendererResult(\"C:temp\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C\\:temp}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryDefaultValueTest_with_slash",
        "body": "{| AssertLayoutRendererResult(\"C/temp\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C/temp}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryDefaultValueTest_with_foward_slash",
        "body": "{| AssertLayoutRendererResult(\"C\\\\temp\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C\\\\temp}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryDefaultValueTest_with_foward_slash2",
        "body": "{| AssertLayoutRendererResult(\"C\\\\temp\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C\\temp:requireEscapingSlashesInDefaultValue=false}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "Registry_nosubky",
        "body": "{| AssertLayoutRendererResult(\"\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:key=HKEY_CURRENT_CONFIG}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryDefaultValueNull",
        "body": "{| AssertLayoutRendererResult(\"\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }"
      },
      {
        "name": "RegistryTestWrongKey_no_ex",
        "body": "{| try| {| LogManager.ThrowExceptions = false;| AssertLayoutRendererResult(\"\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=garabageHKLM/NOT_EXISTENT:defaultValue=empty}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }| finally| {| LogManager.ThrowExceptions = true;| }| }"
      },
      {
        "name": "RegistryTestWrongKey_ex",
        "body": "{| try| {| LogManager.ThrowExceptions = false;| AssertLayoutRendererResult(\"\",| @\"<nlog>| <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=garabageHKLM/NOT_EXISTENT:defaultValue=empty}' /></targets>| <rules>| <logger name='*' minlevel='Debug' writeTo='debug' />| </rules>| </nlog>\");| }| finally| {| LogManager.ThrowExceptions = true;| }| }"
      }
    ]
  }
]