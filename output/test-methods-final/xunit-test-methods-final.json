[
  {
    "file": "AssumeIdentityAttributeAcceptanceTests.cs",
    "methods": [
      {
        "name": "AttributeChangesRoleInTestMethod",
        "body": "{|Assert.True(Thread.CurrentPrincipal.IsInRole(\"casper\"));|}"
      },
      {
        "name": "CallingSecuredMethodWillThrow",
        "body": "{|// Mono does not appear to properly support PrincipalPermission|if (!EnvironmentHelper.IsMono)|Assert.Throws<SecurityException>(() => DefeatVillian());|}"
      },
      {
        "name": "CallingSecuredMethodWithWrongIdentityWillThrow",
        "body": "{|// Mono does not appear to properly support PrincipalPermission|if (!EnvironmentHelper.IsMono)|Assert.Throws<SecurityException>(() => DefeatVillian());|}"
      },
      {
        "name": "CallingSecuredMethodWithAssumedIdentityPasses",
        "body": "{|// Mono does not appear to properly support PrincipalPermission|if (!EnvironmentHelper.IsMono)|Assert.DoesNotThrow(() => DefeatVillian());|}"
      }
    ]
  },
  {
    "file": "ClassDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "ClassDataTest",
        "body": "{|MethodResult result = RunClass(typeof(ClassDataTestClass)).Single();|Assert.IsType<PassedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.ClassDataAcceptanceTests+ClassDataTestClass.PassingTestData(foo: 1, bar: \"\"hello world\"\", baz: 2.3)\", result.DisplayName);|}"
      }
    ]
  },
  {
    "file": "InlineDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "MultipleDataSets",
        "body": "{|MethodResult[] results = RunClass(typeof(MultipleDataSetsClass)).ToArray();|Assert.Equal(2, results.Length);|PassedResult passedResult = results.OfType<PassedResult>().Single();|Assert.Equal(@\"Xunit1.Extensions.InlineDataAcceptanceTests+MultipleDataSetsClass.PassingTestData(foo: 1, bar: \"\"hello\"\", baz: 2.3)\", passedResult.DisplayName);|FailedResult failedResult = results.OfType<FailedResult>().Single();|Assert.Equal(@\"Xunit1.Extensions.InlineDataAcceptanceTests+MultipleDataSetsClass.PassingTestData(foo: 42, bar: \"\"world\"\", baz: 21.12)\", failedResult.DisplayName);|}"
      },
      {
        "name": "NullValue",
        "body": "{|MethodResult result = RunClass(typeof(NullValueClass)).Single();|Assert.IsType<PassedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.InlineDataAcceptanceTests+NullValueClass.PassingTestData(foo: null)\", result.DisplayName);|}"
      }
    ]
  },
  {
    "file": "PropertyDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "PropertyDataTest",
        "body": "{|MethodResult result = RunClass(typeof(PropertyDataTestClass)).Single();|Assert.IsType<PassedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.PropertyDataAcceptanceTests+PropertyDataTestClass.PassingTestData(foo: 1, bar: \"\"hello world\"\", baz: 2.3)\", result.DisplayName);|}"
      }
    ]
  },
  {
    "file": "TheoryAcceptanceTests.cs",
    "methods": [
      {
        "name": "IncorrectParameterCount",
        "body": "{|MethodResult[] results = RunClass(typeof(IncorrectParameterCountClass)).ToArray();|Assert.Equal(2, results.Length);|PassedResult passedResult = results.OfType<PassedResult>().Single();|Assert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+IncorrectParameterCountClass.PassingTestData(x: 1)\", passedResult.DisplayName);|FailedResult failedResult = results.OfType<FailedResult>().Single();|Assert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+IncorrectParameterCountClass.PassingTestData(x: 2, ???: 3)\", failedResult.DisplayName);|}"
      },
      {
        "name": "NoDataAttributes",
        "body": "{|MethodResult result = RunClass(typeof(NoDataAttributesClass)).Single();|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+NoDataAttributesClass.TheoryMethod\", failedResult.DisplayName);|Assert.Equal(\"System.InvalidOperationException : No data found for Xunit1.Extensions.TheoryAcceptanceTests+NoDataAttributesClass.TheoryMethod\", failedResult.Message);|}"
      },
      {
        "name": "EmptyTheoryData",
        "body": "{|MethodResult result = RunClass(typeof(EmptyTheoryDataClass)).Single();|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+EmptyTheoryDataClass.TheoryMethod\", failedResult.DisplayName);|Assert.Equal(\"System.InvalidOperationException : No data found for Xunit1.Extensions.TheoryAcceptanceTests+EmptyTheoryDataClass.TheoryMethod\", failedResult.Message);|}"
      },
      {
        "name": "ThrowingData",
        "body": "{|MethodResult result = RunClass(typeof(ThrowingDataClass)).Single();|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+ThrowingDataClass.TheoryWithMisbehavingData\", failedResult.DisplayName);|Assert.Contains(\"System.InvalidOperationException : An exception was thrown while getting data for theory Xunit1.Extensions.TheoryAcceptanceTests+ThrowingDataClass.TheoryWithMisbehavingData\", failedResult.Message);|}"
      }
    ]
  },
  {
    "file": "DataAdapterDataAttributeTests.cs",
    "methods": [
      {
        "name": "WillConvertDBNullToNull",
        "body": "{|DataAdapterDataAttribute attr = new TestableDataAdapterDataAttribute(DBNull.Value);|List<object[]> results = new List<object[]>(attr.GetData(null, new Type[] { typeof(object) }));|object[] result = Assert.Single(results);|object singleResult = Assert.Single(result);|Assert.Null(singleResult);|}"
      },
      {
        "name": "WillNotThrowWhenGivenInsufficientParameterTypeLength",
        "body": "{|DataAdapterDataAttribute attr = new TestableDataAdapterDataAttribute(DBNull.Value);|Assert.DoesNotThrow(() => new List<object[]>(attr.GetData(null, new Type[0])));|}"
      }
    ]
  },
  {
    "file": "TheoryAttributeTests.cs",
    "methods": [
      {
        "name": "TestDataFromProperty",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestViaProperty\");|TheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];|List<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));|ITestCommand command = Assert.Single(commands);|TheoryCommand theoryCommand = Assert.IsType<TheoryCommand>(command);|object parameter = Assert.Single(theoryCommand.Parameters);|Assert.Equal(2, parameter);|}"
      },
      {
        "name": "TestDataFromPropertyOnBaseClass",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestViaPropertyOnBaseClass\");|TheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];|List<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));|ITestCommand command = Assert.Single(commands);|TheoryCommand theoryCommand = Assert.IsType<TheoryCommand>(command);|object parameter = Assert.Single(theoryCommand.Parameters);|Assert.Equal(4, parameter);|}"
      },
      {
        "name": "TestDataFromOtherTypeProperty",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestViaOtherTypeProperty\");|TheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];|List<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));|ITestCommand command = Assert.Single(commands);|TheoryCommand theoryCommand = Assert.IsType<TheoryCommand>(command);|object parameter = Assert.Single(theoryCommand.Parameters);|Assert.Equal(3, parameter);|}"
      },
      {
        "name": "ResolvedGenericTypeIsIncludedInDisplayName",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"GenericTest\");|TheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];|List<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));|Assert.Equal(4, commands.Count);|TheoryCommand command1 = Assert.IsType<TheoryCommand>(commands[0]);|Assert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<Int32>(value: 42)\", command1.DisplayName);|TheoryCommand command2 = Assert.IsType<TheoryCommand>(commands[1]);|Assert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<String>(value: \"\"Hello, world!\"\")\", command2.DisplayName);|TheoryCommand command3 = Assert.IsType<TheoryCommand>(commands[2]);|Assert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<Int32[]>(value: System.Int32[])\", command3.DisplayName);|// TODO: Would like to see @\"TheoryAttributeTests+TestMethodCommandClass.GenericTest<Int32[]>(value: Int32[] { 1, 2, 3 })\"|TheoryCommand command4 = Assert.IsType<TheoryCommand>(commands[3]);|Assert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<List<String>>(value: System.Collections.Generic.List`1[System.String])\", command4.DisplayName);|// TODO: Would like to see @\"TheoryAttributeTests+TestMethodCommandClass.GenericTest<List<String>>(value: List<String> { \"\"a\"\", \"\"b\"\", \"\"c\"\" })\"|}"
      }
    ]
  },
  {
    "file": "TheoryCommandTests.cs",
    "methods": [
      {
        "name": "ExecuteCreatesClassAndRunsTest",
        "body": "{|MethodInfo methodInfo = typeof(InstrumentedSpy).GetMethod(\"PassedTest\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);|InstrumentedSpy.ctorCounter = 0;|InstrumentedSpy.passedTestCounter = 0;|command.Execute(new InstrumentedSpy());|Assert.Equal(1, InstrumentedSpy.ctorCounter);|Assert.Equal(1, InstrumentedSpy.passedTestCounter);|}"
      },
      {
        "name": "ExecuteStubTestFixtureVerifyBeforeAfterTestCalledOnce",
        "body": "{|MethodInfo methodInfo = typeof(DisposableSpy).GetMethod(\"PassedTest\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);|DisposableSpy.ctorCalled = 0;|DisposableSpy.disposeCalled = 0;|ITestResult result = command.Execute(new DisposableSpy());|Assert.IsType<PassedResult>(result);|}"
      },
      {
        "name": "NotEnoughData",
        "body": "{|TheoryCommand command = new TheoryCommand(|Reflector.Wrap(typeof(ParameterSpy).GetMethod(\"Method\")),|new object[] { 2 });|Assert.Throws<InvalidOperationException>(() => command.Execute(new ParameterSpy()));|}"
      },
      {
        "name": "UsesDisplayName",
        "body": "{|MethodInfo methodInfo = typeof(DummyWithAttributes).GetMethod(\"TheoryMethod\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42, 24.5 });|Assert.Equal(\"My display name(x: 42, y: 24.5)\", command.DisplayName);|}"
      },
      {
        "name": "DisplayNameWithTooManyValues",
        "body": "{|MethodInfo methodInfo = typeof(DummyWithAttributes).GetMethod(\"TheoryMethod\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42, 24.5, \"Hello!\", 'c' });|Assert.Equal(\"My display name(x: 42, y: 24.5, ???: \\\"Hello!\\\", ???: 'c')\", command.DisplayName);|}"
      },
      {
        "name": "DisplayNameWithTooFewValues",
        "body": "{|MethodInfo methodInfo = typeof(DummyWithAttributes).GetMethod(\"TheoryMethod\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42 });|Assert.Equal(\"My display name(x: 42, y: ???)\", command.DisplayName);|}"
      },
      {
        "name": "PassesParametersToTest",
        "body": "{|MethodInfo methodInfo = typeof(SpyWithDataPassed).GetMethod(\"Test\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42, 24.5, \"foo\" });|SpyWithDataPassed.X = 0;|SpyWithDataPassed.Y = 0.0;|SpyWithDataPassed.Z = null;|command.Execute(new SpyWithDataPassed());|Assert.Equal(42, SpyWithDataPassed.X);|Assert.Equal(24.5, SpyWithDataPassed.Y);|Assert.Equal(\"foo\", SpyWithDataPassed.Z);|}"
      },
      {
        "name": "TestMethodReturnPassedResult",
        "body": "{|MethodInfo methodInfo = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);|MethodResult result = command.Execute(new TestMethodCommandClass());|Assert.IsType<PassedResult>(result);|}"
      },
      {
        "name": "ThrowsExceptionReturnFailedResult",
        "body": "{|MethodInfo methodInfo = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");|TheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);|Assert.Throws<InvalidOperationException>(() => command.Execute(new TestMethodCommandClass()));|}"
      },
      {
        "name": "TooMuchData",
        "body": "{|TheoryCommand command = new TheoryCommand(|Reflector.Wrap(typeof(ParameterSpy).GetMethod(\"Method\")),|new object[] { 2, \"foo\", 3.14 });|Assert.Throws<InvalidOperationException>(() => command.Execute(new ParameterSpy()));|}"
      },
      {
        "name": "TruncatesVeryLongStrings",
        "body": "{|StringBuilder sb = new StringBuilder(500);|for (int idx = 0; idx < 50; idx++)|sb.Append(\"----=----|\");|TheoryCommand command = new TheoryCommand(|Reflector.Wrap(typeof(ParameterSpy).GetMethod(\"Method\")),|new object[] { 2, sb.ToString() });|MethodResult result = command.Execute(new ParameterSpy());|Assert.IsType<PassedResult>(result);|Assert.Equal(@\"Xunit1.Extensions.TheoryCommandTests+ParameterSpy.Method(x: 2, y: \"\"----=----|----=----|----=----|----=----|----=----|\"\"...)\", result.DisplayName);|}"
      },
      {
        "name": "SettingTheoryTimeoutSetsTimeout",
        "body": "{|TheoryCommand command = new TheoryCommand(Reflector.Wrap(typeof(DummyWithAttributes).GetMethod(\"TimeoutMethod\")), null);|Assert.Equal(153, command.Timeout);|}"
      },
      {
        "name": "StringDataWithEmbeddedNullCreatesValidXml",
        "body": "{|string expectedXml = @\"<start name=\"\"Xunit1.Extensions.TheoryCommandTests+DummyWithAttributes.StringMethod(s: &quot;\\x0\\xFFFF&quot;)\"\" type=\"\"Xunit1.Extensions.TheoryCommandTests+DummyWithAttributes\"\" method=\"\"StringMethod\"\" />\";|TheoryCommand command = new TheoryCommand(Reflector.Wrap(typeof(DummyWithAttributes).GetMethod(\"StringMethod\")), new object[] { \"\\0\\xffff\" });|Assert.Equal(expectedXml, command.ToStartXml().OuterXml);|}"
      }
    ]
  },
  {
    "file": "FreezeClockAttributeAcceptanceTests.cs",
    "methods": [
      {
        "name": "FrozenWithCurrentTime",
        "body": "{|DateTime reference = DateTime.Now;|DateTime result1 = Clock.Now;|Thread.Sleep(100);|DateTime result2 = Clock.Now;|Assert.Equal(result1, result2);|Assert.True((reference - result1).TotalMilliseconds < 1000);|}"
      },
      {
        "name": "FrozenWithSpecificDate",
        "body": "{|DateTime result = Clock.Now;|Assert.Equal(new DateTime(2006, 12, 31), result);|}"
      },
      {
        "name": "FrozenWithSpecificLocalDateTime",
        "body": "{|DateTime result = Clock.Now;|Assert.Equal(new DateTime(2006, 12, 31, 4, 5, 6), result);|}"
      },
      {
        "name": "FrozenWithSpecificUTCDateTime",
        "body": "{|DateTime result = Clock.Now;|Assert.Equal(new DateTime(2006, 12, 31, 4, 5, 6, DateTimeKind.Utc).ToLocalTime(), result);|}"
      },
      {
        "name": "NotFrozen",
        "body": "{|DateTime result1 = Clock.Now;|Thread.Sleep(100);|DateTime result2 = Clock.Now;|Assert.NotEqual(result1, result2);|}"
      }
    ]
  },
  {
    "file": "ApartmentAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestsRunsInTheSingleThreadedApartment",
        "body": "{|Assert.Equal(ApartmentState.STA, Thread.CurrentThread.GetApartmentState());|}"
      }
    ]
  },
  {
    "file": "AsyncAcceptanceTests.cs",
    "methods": [
      {
        "name": "Async40AcceptanceTest",
        "body": "{|IEnumerable<MethodResult> results = RunClass(typeof(Async40AcceptanceTestClass));|MethodResult result = Assert.Single(results);|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(typeof(TrueException).FullName, failedResult.ExceptionType);|}"
      },
      {
        "name": "Task",
        "body": "{|return Task.Factory.StartNew(() =>|{|Thread.Sleep(1);|})|.ContinueWith(_ =>|{|Assert.True(false);|});|}"
      }
    ]
  },
  {
    "file": "FactMethodWithArgumentsTests.cs",
    "methods": [
      {
        "name": "FactMethodsCannotHaveArguments",
        "body": "{|MethodResult result = RunClass(typeof(ClassUnderTest)).Single();|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(typeof(InvalidOperationException).FullName, failedResult.ExceptionType);|Assert.Equal(\"System.InvalidOperationException : Fact method Xunit1.FactMethodWithArgumentsTests+ClassUnderTest.FactWithParameters cannot have parameters\", failedResult.Message);|}"
      },
      {
        "name": "FactWithParameters",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "FailureTimingAcceptanceTests.cs",
    "methods": [
      {
        "name": "TimingForFailedTestShouldReflectActualRunTime",
        "body": "{|MethodResult result = RunClass(typeof(ClassUnderTest)).Single();|Assert.IsType<FailedResult>(result);|Assert.NotEqual(0.0, result.ExecutionTime);|}"
      },
      {
        "name": "TwoNumbersAreNotEqual",
        "body": "{|Thread.Sleep(100);|Assert.Equal(2, 3);|}"
      }
    ]
  },
  {
    "file": "FixtureDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "ClassWithFixtureAndSkippedFactDoesNotSetFixtureData",
        "body": "{|MethodResult result = RunClass(typeof(FixtureWithAllSkips)).Single();|// If it ran the fixture, then we would get a class failure|Assert.IsType<SkipResult>(result);|}"
      },
      {
        "name": "SkippedTest",
        "body": "{ }"
      },
      {
        "name": "ClassWithFixtureAndStaticFactDoesNotSetFixtureData",
        "body": "{|MethodResult result = RunClass(typeof(FixtureWithAllStatics)).Single();|// If it ran the fixture, then we would get a class failure|Assert.IsType<PassedResult>(result);|}"
      },
      {
        "name": "StaticPassingTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "SkipAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestClassIsNotInstantiatedForSkippedTests",
        "body": "{|MethodResult result = RunClass(typeof(ClassUnderTest)).Single();|// If we ran the constructor, we would get a failure instead of a skip.|Assert.IsType<SkipResult>(result);|}"
      },
      {
        "name": "TestThatShouldBeSkipped",
        "body": "{|}"
      }
    ]
  },
  {
    "file": "TestTimeoutTests.cs",
    "methods": [
      {
        "name": "TestHasTimeoutAndExceeds",
        "body": "{|MethodResult result = RunClass(typeof(ClassUnderTest)).Single();|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.InRange(failedResult.ExecutionTime, 0.049, 0.051);|Assert.Equal(\"Test execution time exceeded: 50ms\", failedResult.Message);|}"
      },
      {
        "name": "TestShouldTimeout",
        "body": "{|Thread.Sleep(120);|Assert.Equal(2, 2);|}"
      }
    ]
  },
  {
    "file": "ContainsTests.cs",
    "methods": [
      {
        "name": "CanFindNullInContainer",
        "body": "{|List<object> list = new List<object> { 16, null, \"Hi there\" };|Assert.Contains(null, list);|}"
      },
      {
        "name": "CanUseComparer",
        "body": "{|List<int> list = new List<int> { 42 };|Assert.Contains(43, list, new MyComparer());|}"
      },
      {
        "name": "ItemInContainer",
        "body": "{|List<int> list = new List<int> { 42 };|Assert.Contains(42, list);|}"
      },
      {
        "name": "ItemNotInContainer",
        "body": "{|List<int> list = new List<int>();|ContainsException ex = Assert.Throws<ContainsException>(() => Assert.Contains(42, list));|Assert.Equal(\"Assert.Contains() failure: Not found: 42\", ex.Message);|}"
      },
      {
        "name": "NullsAllowedInContainer",
        "body": "{|List<object> list = new List<object> { null, 16, \"Hi there\" };|Assert.Contains(\"Hi there\", list);|}"
      },
      {
        "name": "NullContainerThrows",
        "body": "{|Assert.Throws<ContainsException>(() => Assert.Contains(14, (List<int>)null));|}"
      },
      {
        "name": "CanSearchForSubstrings",
        "body": "{|Assert.Contains(\"wor\", \"Hello, world!\");|}"
      },
      {
        "name": "CanSearchForSubstringsCaseInsensitive",
        "body": "{|Assert.Contains(\"WORLD\", \"Hello, world!\", StringComparison.InvariantCultureIgnoreCase);|}"
      },
      {
        "name": "SubstringContainsIsCaseSensitiveByDefault",
        "body": "{|var ex = Record.Exception(() => Assert.Contains(\"WORLD\", \"Hello, world!\"));|Assert.IsType<ContainsException>(ex);|Assert.Equal(|\"Assert.Contains() failure:\" + Environment.NewLine +|\"Not found: WORLD\" + Environment.NewLine +|\"In value: Hello, world!\", ex.Message);|}"
      },
      {
        "name": "SubstringNotFound",
        "body": "{|Assert.Throws<ContainsException>(() => Assert.Contains(\"hey\", \"Hello, world!\"));|}"
      },
      {
        "name": "NullActualStringThrows",
        "body": "{|Assert.Throws<ContainsException>(() => Assert.Contains(\"foo\", (string)null));|}"
      }
    ]
  },
  {
    "file": "DoesNotContainTests.cs",
    "methods": [
      {
        "name": "CanSearchForNullInContainer",
        "body": "{|List<object> list = new List<object> { 16, \"Hi there\" };|Assert.DoesNotContain(null, list);|}"
      },
      {
        "name": "CanUseComparer",
        "body": "{|List<int> list = new List<int>();|list.Add(42);|Assert.DoesNotContain(42, list, new MyComparer());|}"
      },
      {
        "name": "ItemInContainer",
        "body": "{|List<int> list = new List<int> { 42 };|DoesNotContainException ex =|Assert.Throws<DoesNotContainException>(() => Assert.DoesNotContain(42, list));|Assert.Equal(\"Assert.DoesNotContain() failure: Found: 42\", ex.Message);|}"
      },
      {
        "name": "ItemNotInContainer",
        "body": "{|List<int> list = new List<int>();|Assert.DoesNotContain(42, list);|}"
      },
      {
        "name": "NullsAllowedInContainer",
        "body": "{|List<object> list = new List<object> { null, 16, \"Hi there\" };|Assert.DoesNotContain(42, list);|}"
      },
      {
        "name": "NullContainerDoesNotThrow",
        "body": "{|Assert.DoesNotThrow(() => Assert.DoesNotContain(14, (List<int>)null));|}"
      },
      {
        "name": "CanSearchForSubstrings",
        "body": "{|Assert.DoesNotContain(\"hey\", \"Hello, world!\");|}"
      },
      {
        "name": "CanSearchForSubstringsCaseInsensitive",
        "body": "{|Assert.Throws<DoesNotContainException>(|() => Assert.DoesNotContain(\"WORLD\", \"Hello, world!\", StringComparison.InvariantCultureIgnoreCase));|}"
      },
      {
        "name": "SubstringDoesNotContainIsCaseSensitiveByDefault",
        "body": "{|Assert.DoesNotContain(\"WORLD\", \"Hello, world!\");|}"
      },
      {
        "name": "SubstringFound",
        "body": "{|Assert.Throws<DoesNotContainException>(() => Assert.DoesNotContain(\"world\", \"Hello, world!\"));|}"
      },
      {
        "name": "NullActualStringDoesNotThrow",
        "body": "{|Assert.DoesNotThrow(() => Assert.DoesNotContain(\"foo\", (string)null));|}"
      }
    ]
  },
  {
    "file": "DoesNotThrowTests.cs",
    "methods": [
      {
        "name": "CorrectExceptionType",
        "body": "{|DoesNotThrowException ex =|Assert.Throws<DoesNotThrowException>(|() => Assert.DoesNotThrow(|() => { throw new NotImplementedException(\"Exception Message\"); }));|Assert.Equal(\"Assert.DoesNotThrow() failure\", ex.UserMessage);|Assert.Equal(\"(No exception)\", ex.Expected);|Assert.Equal(\"System.NotImplementedException: Exception Message\", ex.Actual);|}"
      },
      {
        "name": "PassingTest",
        "body": "{|Assert.DoesNotThrow(() => { });|}"
      }
    ]
  },
  {
    "file": "EmptyTests.cs",
    "methods": [
      {
        "name": "IsEmpty",
        "body": "{|List<int> list = new List<int>();|Assert.Empty(list);|}"
      },
      {
        "name": "IsNotEmpty",
        "body": "{|List<int> list = new List<int>();|list.Add(42);|EmptyException ex = Assert.Throws<EmptyException>(() => Assert.Empty(list));|Assert.Equal(\"Assert.Empty() failure\", ex.Message);|}"
      },
      {
        "name": "NullIsNotEmpty",
        "body": "{|Assert.Throws<ArgumentNullException>(() => Assert.Empty(null));|}"
      },
      {
        "name": "IsEmpty",
        "body": "{|Assert.Empty(\"\");|}"
      },
      {
        "name": "IsNotEmpty",
        "body": "{|EmptyException ex = Assert.Throws<EmptyException>(() => Assert.Empty(\"Foo\"));|Assert.Equal(\"Assert.Empty() failure\", ex.Message);|}"
      }
    ]
  },
  {
    "file": "EqualTests.cs",
    "methods": [
      {
        "name": "Array",
        "body": "{|string[] expected = { \"@\", \"a\", \"ab\", \"b\" };|string[] actual = { \"@\", \"a\", \"ab\", \"b\" };|Assert.Equal(expected, actual);|Assert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual));|}"
      },
      {
        "name": "ArrayInsideArray",
        "body": "{|string[][] expected = { new[] { \"@\", \"a\" }, new[] { \"ab\", \"b\" } };|string[][] actual = { new[] { \"@\", \"a\" }, new[] { \"ab\", \"b\" } };|Assert.Equal(expected, actual);|Assert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual));|}"
      },
      {
        "name": "ArraysOfDifferentLengthsAreNotEqual",
        "body": "{|string[] expected = { \"@\", \"a\", \"ab\", \"b\", \"c\" };|string[] actual = { \"@\", \"a\", \"ab\", \"b\" };|Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));|Assert.NotEqual(expected, actual);|}"
      },
      {
        "name": "ArrayValuesAreDifferentNotEqual",
        "body": "{|string[] expected = { \"@\", \"d\", \"v\", \"d\" };|string[] actual = { \"@\", \"a\", \"ab\", \"b\" };|Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));|Assert.NotEqual(expected, actual);|}"
      },
      {
        "name": "EnumerableEquivalence",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(expected);|Assert.Equal(expected, actual);|}"
      },
      {
        "name": "EnumerableInequivalence",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(new[] { 1, 2, 3, 4, 6 });|EqualException ex = Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));|Assert.Contains(\"First difference is at position 4\" + Environment.NewLine, ex.Message);|}"
      },
      {
        "name": "EnumerableEquivalenceWithSuccessfulComparer",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(new int[] { 0, 0, 0, 0, 0 });|Assert.Equal(expected, actual, new IntComparer(true));|}"
      },
      {
        "name": "EnumerableEquivalenceWithFailedComparer",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(new int[] { 1, 2, 3, 4, 5 });|EqualException ex = Assert.Throws<EqualException>(() => Assert.Equal(expected, actual, new IntComparer(false)));|// TODO: When we fix up the assert exception messages, we should allow the enumerator who|// did the comparisons to tell us exactly where the error was, rather than determining the|// inequivalence after the fact.|// Assert.Contains(\"First difference is at position 0\\r\\n\", ex.Message);|}"
      },
      {
        "name": "DepthExample",
        "body": "{|var x = new List<object> { new List<object> { new List<object> { new List<object>() } } };|var y = new List<object> { new List<object> { new List<object> { new List<object>() } } };|Assert.Equal(x, y);|}"
      },
      {
        "name": "ObjectWithComparable",
        "body": "{|ComparableObject obj1 = new ComparableObject();|ComparableObject obj2 = new ComparableObject();|Assert.Equal(obj1, obj2);|Assert.True(obj1.CompareCalled);|}"
      },
      {
        "name": "ObjectWithGenericComparable",
        "body": "{|GenericComparableObject obj1 = new GenericComparableObject();|GenericComparableObject obj2 = new GenericComparableObject();|Assert.Equal(obj1, obj2);|Assert.True(obj1.CompareCalled);|}"
      },
      {
        "name": "ObjectWithoutIComparable",
        "body": "{|NonComparableObject nco1 = new NonComparableObject();|NonComparableObject nco2 = new NonComparableObject();|Assert.Equal(nco1, nco2);|}"
      },
      {
        "name": "DoubleNegativeInfinityEqualsNegativeInfinity",
        "body": "{|Assert.Equal(double.NegativeInfinity, double.NegativeInfinity);|}"
      },
      {
        "name": "DoubleNegativeInfinityNotEquals",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(1.23, double.NegativeInfinity));|}"
      },
      {
        "name": "DoublePositiveInfinityEqualsPositiveInfinity",
        "body": "{|Assert.Equal(double.PositiveInfinity, double.PositiveInfinity);|}"
      },
      {
        "name": "DoublePositiveInfinityNotEquals",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(1.23, double.PositiveInfinity));|}"
      },
      {
        "name": "DoublePositiveInfinityNotEqualsNegativeInfinity",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(double.NegativeInfinity, double.PositiveInfinity));|}"
      },
      {
        "name": "Select_should_equal_Select",
        "body": "{|IEnumerable<int> items = IntGenerator.Range(1, 12);|IEnumerable<int> others = IntGenerator.Range(1, 12);|Assert.Equal(items, others);|}"
      },
      {
        "name": "CallsIEquatable",
        "body": "{|EquatableObject obj1 = new EquatableObject();|EquatableObject obj2 = new EquatableObject();|Assert.Equal(obj1, obj2);|Assert.True(obj1.Equals__Called);|Assert.Same(obj2, obj1.Equals_Other);|}"
      },
      {
        "name": "EqualsNaNFails",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(double.NaN, 1.234));|}"
      },
      {
        "name": "NanEqualsFails",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(1.234, double.NaN));|}"
      },
      {
        "name": "NanEqualsNaNSucceeds",
        "body": "{|Assert.Equal(double.NaN, double.NaN);|}"
      },
      {
        "name": "EqualsNull",
        "body": "{|Assert.Equal<object>(null, null);|}"
      },
      {
        "name": "FailsWhenActualIsNullExpectedIsNot",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(new object(), null));|}"
      },
      {
        "name": "FailsWhenExpectedIsNullActualIsNot",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(null, new object()));|}"
      },
      {
        "name": "DecimalEqualsFails",
        "body": "{|decimal expected = 25;|decimal actual = 42;|Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));|}"
      },
      {
        "name": "DoubleEqualsFails",
        "body": "{|double expected = 25.3;|double actual = 42.0;|Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));|}"
      },
      {
        "name": "EqualsByte",
        "body": "{|byte valueType = 35;|Byte referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<byte>(valueType, 35);|Assert.Equal<byte>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsDecimal",
        "body": "{|decimal valueType = 35;|Decimal referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<decimal>(valueType, 35);|Assert.Equal(valueType, 35M);|Assert.Equal<decimal>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsInt16",
        "body": "{|short valueType = 35;|Int16 referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<short>(valueType, 35);|Assert.Equal<short>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsInt32",
        "body": "{|int valueType = 35;|Int32 referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal(valueType, 35);|Assert.Equal(referenceValue, 35);|}"
      },
      {
        "name": "EqualsInt64",
        "body": "{|long valueType = 35;|Int64 referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<long>(valueType, 35);|Assert.Equal<long>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsSByte",
        "body": "{|sbyte valueType = 35;|SByte referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<sbyte>(valueType, 35);|Assert.Equal<sbyte>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsUInt16",
        "body": "{|ushort valueType = 35;|UInt16 referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<ushort>(valueType, 35);|Assert.Equal<ushort>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsUInt32",
        "body": "{|uint valueType = 35;|UInt32 referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<uint>(valueType, 35);|Assert.Equal<uint>(referenceValue, 35);|}"
      },
      {
        "name": "EqualsUInt64",
        "body": "{|ulong valueType = 35;|UInt64 referenceValue = 35;|Assert.True(valueType == referenceValue);|Assert.Equal(referenceValue, valueType);|Assert.Equal<ulong>(valueType, 35);|Assert.Equal<ulong>(referenceValue, 35);|}"
      },
      {
        "name": "Int32Int64Comparison",
        "body": "{|long l64 = 0;|int i32 = 0;|Assert.Equal<long>(l64, i32);|}"
      },
      {
        "name": "IntegerLongComparison",
        "body": "{|Assert.Equal<long>(1L, 1);|Assert.Equal<long>(1, 1L);|}"
      },
      {
        "name": "LongEquals",
        "body": "{|Assert.Equal(2L, 2L);|}"
      },
      {
        "name": "LongEqualsFails",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(3L, 2L));|}"
      },
      {
        "name": "UInt64EqualsFails",
        "body": "{|UInt64 expected = 25;|UInt64 actual = 42;|Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));|}"
      },
      {
        "name": "SingleNegativeInfinityEqualsNegativeInfinity",
        "body": "{|Assert.Equal(float.NegativeInfinity, float.NegativeInfinity);|}"
      },
      {
        "name": "SingleNumberNotEqualNegativeInfinity",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(1.23f, float.NegativeInfinity));|}"
      },
      {
        "name": "SingleNumberNotEqualPositiiveInfinity",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(1.23f, float.PositiveInfinity));|}"
      },
      {
        "name": "SinglePositiveInfinityEqualsPositiveInfinity",
        "body": "{|Assert.Equal(float.PositiveInfinity, float.PositiveInfinity);|}"
      },
      {
        "name": "SinglePositiveInfinityNotEqualNegativeInfinity",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(float.NegativeInfinity, float.PositiveInfinity));|}"
      },
      {
        "name": "EqualsFail",
        "body": "{|Assert.Throws<EqualException>(() => Assert.Equal(\"expected\", \"actual\"));|}"
      },
      {
        "name": "EqualsString",
        "body": "{|string testString = \"Test String\";|string expected = testString;|string actual = testString;|Assert.True(actual == expected);|Assert.Equal(expected, actual);|}"
      },
      {
        "name": "EqualStringWithTrailingNull",
        "body": "{|Exception ex = Record.Exception(() => Assert.Equal(\"foo\", \"foo\\0\"));|Assert.IsType<EqualException>(ex);|}"
      },
      {
        "name": "EqualsStringIgnoreCase",
        "body": "{|string expected = \"TestString\";|string actual = \"testString\";|Assert.False(actual == expected);|Assert.NotEqual(expected, actual);|Assert.Equal(expected, actual, StringComparer.CurrentCultureIgnoreCase);|}"
      },
      {
        "name": "String",
        "body": "{|string s1 = \"test\";|string s2 = new StringBuilder(s1).ToString();|Assert.True(s1.Equals(s2));|Assert.Equal(s2, s1);|}"
      },
      {
        "name": "NullableValueTypesCanBeNull",
        "body": "{|DateTime? dt1 = null;|DateTime? dt2 = null;|Assert.Equal(dt1, dt2);|}"
      },
      {
        "name": "AssertEqualWithDoubleWithPrecision",
        "body": "{|Assert.Equal(0.11111, 0.11444, 2);|}"
      },
      {
        "name": "AssertEqualWithDoubleWithPrecisionFailure",
        "body": "{|var ex = Assert.Throws<EqualException>(() => Assert.Equal(0.11111, 0.11444, 3));|Assert.Equal(string.Format(\"{0} (rounded from {1})\", 0.111, 0.11111), ex.Expected);|Assert.Equal(string.Format(\"{0} (rounded from {1})\", 0.114, 0.11444), ex.Actual);|}"
      },
      {
        "name": "AssertEqualWithDecimalWithPrecision",
        "body": "{|Assert.Equal(0.11111M, 0.11444M, 2);|}"
      },
      {
        "name": "AssertEqualWithDecimalWithPrecisionFailure",
        "body": "{|var ex = Assert.Throws<EqualException>(() => Assert.Equal(0.11111M, 0.11444M, 3));|Assert.Equal(string.Format(\"{0} (rounded from {1})\", 0.111M, 0.11111M), ex.Expected);|Assert.Equal(string.Format(\"{0} (rounded from {1})\", 0.114M, 0.11444M), ex.Actual);|}"
      }
    ]
  },
  {
    "file": "FactAttributeTests.cs",
    "methods": [
      {
        "name": "FactAttributeGeneratesFactCommand",
        "body": "{|MethodInfo method = typeof(FactAttributeTests).GetMethod(\"DummyFactMethod\");|FactAttribute attribute = new FactAttribute();|List<ITestCommand> results = new List<ITestCommand>(attribute.CreateTestCommands(Reflector.Wrap(method)));|ITestCommand result = Assert.Single(results);|Assert.IsType<FactCommand>(result);|}"
      },
      {
        "name": "DefaultFactAttributeValues",
        "body": "{|FactAttribute attrib = new FactAttribute();|MethodInfo method = typeof(FactAttributeTests).GetMethod(\"DummyFactMethod\");|var commands = new List<ITestCommand>(attrib.CreateTestCommands(Reflector.Wrap(method)));|ITestCommand command = Assert.Single(commands);|FactCommand factCommand = Assert.IsType<FactCommand>(command);|Assert.Equal(\"Xunit1.FactAttributeTests\", factCommand.TypeName);|Assert.Equal(\"DummyFactMethod\", factCommand.MethodName);|Assert.Equal(\"Xunit1.FactAttributeTests.DummyFactMethod\", factCommand.DisplayName);|}"
      },
      {
        "name": "NameOnFactAttributeOverridesDisplayName",
        "body": "{|MethodInfo method = typeof(FactAttributeTests).GetMethod(\"CustomNamedFactMethod\");|FactAttribute attrib = method.GetCustomAttributes(true).OfType<FactAttribute>().Single();|var commands = new List<ITestCommand>(attrib.CreateTestCommands(Reflector.Wrap(method)));|ITestCommand command = Assert.Single(commands);|FactCommand factCommand = Assert.IsType<FactCommand>(command);|Assert.Equal(\"Custom display name\", factCommand.DisplayName);|}"
      },
      {
        "name": "SkipCanBeOverridenInDerivedAttribute",
        "body": "{|MyFactAttribute attrib = new MyFactAttribute(7);|string result = attrib.Skip;|Assert.Equal(\"35\", result);|}"
      },
      {
        "name": "CustomNamedFactMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "FalseTests.cs",
    "methods": [
      {
        "name": "AssertFalse",
        "body": "{|Assert.False(false);|}"
      },
      {
        "name": "AssertFalseThrowsExceptionWhenTrue",
        "body": "{|try|{|Assert.False(true);|}|catch (AssertException exception)|{|Assert.Equal(\"Assert.False() Failure\", exception.UserMessage);|}|}"
      }
    ]
  },
  {
    "file": "InRangeTests.cs",
    "methods": [
      {
        "name": "DoubleNotWithinRange",
        "body": "{|Assert.Throws<InRangeException>(() => Assert.InRange(1.50, .75, 1.25));|}"
      },
      {
        "name": "DoubleValueWithinRange",
        "body": "{|Assert.InRange(1.0, .75, 1.25);|}"
      },
      {
        "name": "IntNotWithinRangeWithZeroActual",
        "body": "{|Assert.Throws<InRangeException>(() => Assert.InRange(0, 1, 2));|}"
      },
      {
        "name": "IntNotWithinRangeWithZeroMinimum",
        "body": "{|Assert.Throws<InRangeException>(() => Assert.InRange(2, 0, 1));|}"
      },
      {
        "name": "IntValueWithinRange",
        "body": "{|Assert.InRange(2, 1, 3);|}"
      },
      {
        "name": "StringNotWithinRange",
        "body": "{|Assert.Throws<InRangeException>(() => Assert.InRange(\"adam\", \"bob\", \"scott\"));|}"
      },
      {
        "name": "StringValueWithinRange",
        "body": "{|Assert.InRange(\"bob\", \"adam\", \"scott\");|}"
      }
    ]
  },
  {
    "file": "IsAssignableFromTests.cs",
    "methods": [
      {
        "name": "IsAssignableFrom_SameType",
        "body": "{|var expected = new InvalidCastException();|Assert.IsAssignableFrom(typeof(InvalidCastException), expected);|Assert.IsAssignableFrom<InvalidCastException>(expected);|}"
      },
      {
        "name": "IsAssignableFrom_BaseType",
        "body": "{|var expected = new InvalidCastException();|Assert.IsAssignableFrom(typeof(Exception), expected);|Assert.IsAssignableFrom<Exception>(expected);|}"
      },
      {
        "name": "IsAssignableFrom_Interface",
        "body": "{|var expected = new DisposableClass();|Assert.IsAssignableFrom(typeof(IDisposable), expected);|Assert.IsAssignableFrom<IDisposable>(expected);|}"
      },
      {
        "name": "IsAssignableFromReturnsCastObject",
        "body": "{|InvalidCastException expected = new InvalidCastException();|InvalidCastException actual = Assert.IsAssignableFrom<InvalidCastException>(expected);|Assert.Same(expected, actual);|}"
      },
      {
        "name": "IsAssignableFromThrowsExceptionWhenWrongType",
        "body": "{|var exception =|Assert.Throws<IsAssignableFromException>(|() => Assert.IsAssignableFrom<InvalidCastException>(new InvalidOperationException())|);|Assert.Equal(\"Assert.IsAssignableFrom() Failure\", exception.UserMessage);|}"
      },
      {
        "name": "IsAssignableFromThrowsExceptionWhenPassedNull",
        "body": "{|Assert.Throws<IsAssignableFromException>(() => Assert.IsAssignableFrom<object>(null));|}"
      }
    ]
  },
  {
    "file": "IsNotTypeTests.cs",
    "methods": [
      {
        "name": "IsNotType",
        "body": "{|InvalidCastException expected = new InvalidCastException();|Assert.IsNotType(typeof(Exception), expected);|Assert.IsNotType<Exception>(expected);|}"
      },
      {
        "name": "IsNotTypeThrowsExceptionWhenWrongType",
        "body": "{|AssertException exception =|Assert.Throws<IsNotTypeException>(() => Assert.IsNotType<InvalidCastException>(new InvalidCastException()));|Assert.Equal(\"Assert.IsNotType() Failure\", exception.UserMessage);|}"
      },
      {
        "name": "NullObjectDoesNotThrow",
        "body": "{|Assert.DoesNotThrow(() => Assert.IsNotType<object>(null));|}"
      }
    ]
  },
  {
    "file": "IsTypeTests.cs",
    "methods": [
      {
        "name": "IsType",
        "body": "{|InvalidCastException expected = new InvalidCastException();|Assert.IsType(typeof(InvalidCastException), expected);|Assert.IsType<InvalidCastException>(expected);|}"
      },
      {
        "name": "IsTypeReturnsCastObject",
        "body": "{|InvalidCastException expected = new InvalidCastException();|InvalidCastException actual = Assert.IsType<InvalidCastException>(expected);|Assert.Same(expected, actual);|}"
      },
      {
        "name": "IsTypeThrowsExceptionWhenWrongType",
        "body": "{|AssertException exception =|Assert.Throws<IsTypeException>(() => Assert.IsType<InvalidCastException>(new InvalidOperationException()));|Assert.Equal(\"Assert.IsType() Failure\", exception.UserMessage);|}"
      },
      {
        "name": "IsTypeThrowsExceptionWhenPassedNull",
        "body": "{|Assert.Throws<IsTypeException>(() => Assert.IsType<object>(null));|}"
      }
    ]
  },
  {
    "file": "NotEmptyTests.cs",
    "methods": [
      {
        "name": "ContainerIsEmpty",
        "body": "{|List<int> list = new List<int>();|NotEmptyException ex =|Assert.Throws<NotEmptyException>(() => Assert.NotEmpty(list));|Assert.Equal(\"Assert.NotEmpty() failure\", ex.Message);|}"
      },
      {
        "name": "ContainerIsNotEmpty",
        "body": "{|List<int> list = new List<int>();|list.Add(42);|Assert.NotEmpty(list);|}"
      }
    ]
  },
  {
    "file": "NotEqualTests.cs",
    "methods": [
      {
        "name": "NotEqualFailsString",
        "body": "{|try|{|Assert.NotEqual(\"actual\", \"actual\");|}|catch (NotEqualException exception)|{|Assert.Equal(\"Assert.NotEqual() Failure\", exception.UserMessage);|}|}"
      },
      {
        "name": "NotEqualWithCustomComparer",
        "body": "{|string expected = \"TestString\";|string actual = \"testString\";|Assert.False(actual == expected);|Assert.Equal(expected, actual, StringComparer.CurrentCultureIgnoreCase);|Assert.NotEqual(expected, actual, StringComparer.CurrentCulture);|}"
      },
      {
        "name": "ValuesNotEqual",
        "body": "{|Assert.NotEqual(\"bob\", \"jim\");|}"
      },
      {
        "name": "EnumerableInequivalence",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(new[] { 1, 2, 3, 4, 6 });|Assert.NotEqual(expected, actual);|}"
      },
      {
        "name": "EnumerableEquivalence",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(expected);|Assert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual));|}"
      },
      {
        "name": "EnumerableInequivalenceWithFailedComparer",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(new int[] { 1, 2, 3, 4, 5 });|Assert.NotEqual(expected, actual, new IntComparer(false));|}"
      },
      {
        "name": "EnumerableEquivalenceWithSuccessfulComparer",
        "body": "{|int[] expected = new[] { 1, 2, 3, 4, 5 };|List<int> actual = new List<int>(new int[] { 0, 0, 0, 0, 0 });|Assert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual, new IntComparer(true)));|}"
      }
    ]
  },
  {
    "file": "NotInRangeTests.cs",
    "methods": [
      {
        "name": "DoubleNotWithinRange",
        "body": "{|Assert.NotInRange(1.50, .75, 1.25);|}"
      },
      {
        "name": "DoubleWithinRange",
        "body": "{|Assert.Throws<NotInRangeException>(() => Assert.NotInRange(1.0, .75, 1.25));|}"
      },
      {
        "name": "IntNotWithinRange",
        "body": "{|Assert.NotInRange(1, 2, 3);|}"
      },
      {
        "name": "IntWithinRange",
        "body": "{|Assert.Throws<NotInRangeException>(() => Assert.NotInRange(2, 1, 3));|}"
      },
      {
        "name": "StringNotWithNotInRange",
        "body": "{|Assert.NotInRange(\"adam\", \"bob\", \"scott\");|}"
      },
      {
        "name": "StringWithNotInRange",
        "body": "{|Assert.Throws<NotInRangeException>(() => Assert.NotInRange(\"bob\", \"adam\", \"scott\"));|}"
      }
    ]
  },
  {
    "file": "NotNullTests.cs",
    "methods": [
      {
        "name": "NotNull",
        "body": "{|Assert.NotNull(new object());|}"
      },
      {
        "name": "NotNullThrowsException",
        "body": "{|Assert.Throws<NotNullException>(() => Assert.NotNull(null));|}"
      }
    ]
  },
  {
    "file": "NotSameTests.cs",
    "methods": [
      {
        "name": "NotSameFailsWith",
        "body": "{|object actual = new object();|try|{|Assert.NotSame(actual, actual);|}|catch (NotSameException exception)|{|Assert.Equal(\"Assert.NotSame() Failure\", exception.UserMessage);|}|}"
      },
      {
        "name": "ValuesAreNotTheSame",
        "body": "{|Assert.NotSame(\"bob\", \"jim\");|}"
      },
      {
        "name": "ValuesAreTheSame",
        "body": "{|string jim = \"jim\";|Assert.Throws<NotSameException>(() => Assert.NotSame(jim, jim));|}"
      },
      {
        "name": "ValueTypesGetBoxedTwice",
        "body": "{|int index = 0;|Assert.NotSame(index, index);|}"
      }
    ]
  },
  {
    "file": "NullTests.cs",
    "methods": [
      {
        "name": "Null",
        "body": "{|Assert.Null(null);|}"
      },
      {
        "name": "NullThrowsExceptionWhenNotNull",
        "body": "{|try|{|Assert.Null(new object());|}|catch (AssertException exception)|{|Assert.Equal(\"Assert.Null() Failure\", exception.UserMessage);|}|}"
      }
    ]
  },
  {
    "file": "PropertyChangedTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|var ex1 = Assert.Throws<ArgumentNullException>(() => Assert.PropertyChanged(null, \"propertyName\", delegate { }));|Assert.Equal(\"object\", ex1.ParamName);|var ex2 = Assert.Throws<ArgumentNullException>(() => Assert.PropertyChanged(new Mock<INotifyPropertyChanged>().Object, \"propertyName\", null));|Assert.Equal(\"testCode\", ex2.ParamName);|}"
      },
      {
        "name": "ExceptionThrownWhenPropertyNotChanged",
        "body": "{|NotifiedClass obj = new NotifiedClass();|Exception ex = Record.Exception(|() => Assert.PropertyChanged(obj, \"Property1\", () => { })|);|Assert.IsType<PropertyChangedException>(ex);|Assert.Equal(\"Assert.PropertyChanged failure: Property Property1 was not set\", ex.Message);|}"
      },
      {
        "name": "ExceptionThrownWhenWrongPropertyChanged",
        "body": "{|NotifiedClass obj = new NotifiedClass();|Exception ex = Record.Exception(|() => Assert.PropertyChanged(obj, \"Property1\", () => obj.Property2 = 42)|);|Assert.IsType<PropertyChangedException>(ex);|Assert.Equal(\"Assert.PropertyChanged failure: Property Property1 was not set\", ex.Message);|}"
      },
      {
        "name": "NoExceptionThrownWhenPropertyChanged",
        "body": "{|NotifiedClass obj = new NotifiedClass();|Exception ex = Record.Exception(|() => Assert.PropertyChanged(obj, \"Property1\", () => obj.Property1 = \"NewValue\")|);|Assert.Null(ex);|}"
      },
      {
        "name": "NoExceptionThrownWhenMultiplePropertyChangesIncludesCorrectProperty",
        "body": "{|NotifiedClass obj = new NotifiedClass();|Exception ex = Record.Exception(|() =>|{|Assert.PropertyChanged(obj, \"Property1\", () =>|{|obj.Property2 = 12;|obj.Property1 = \"New Value\";|obj.Property2 = 42;|});|}|);|Assert.Null(ex);|}"
      }
    ]
  },
  {
    "file": "RecordTests.cs",
    "methods": [
      {
        "name": "Exception",
        "body": "{|Exception ex = Record.Exception(delegate { throw new InvalidOperationException(); });|Assert.NotNull(ex);|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "NoException",
        "body": "{|Exception ex = Record.Exception(delegate { });|Assert.Null(ex);|}"
      },
      {
        "name": "Exception",
        "body": "{|StubAccessor accessor = new StubAccessor();|Exception ex = Record.Exception(() => accessor.FailingProperty);|Assert.NotNull(ex);|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "NoException",
        "body": "{|StubAccessor accessor = new StubAccessor();|Exception ex = Record.Exception(() => accessor.SuccessfulProperty);|Assert.Null(ex);|}"
      }
    ]
  },
  {
    "file": "SameTests.cs",
    "methods": [
      {
        "name": "BoxedTypesDontWork",
        "body": "{|int index = 0;|Assert.Throws<SameException>(() => Assert.Same(index, index));|}"
      },
      {
        "name": "SameFailsWith",
        "body": "{|string actual = \"Abc\";|string expected = \"a\".ToUpperInvariant() + \"bc\";|try|{|Assert.Same(expected, actual);|}|catch (Exception ex)|{|AssertException aex = Assert.IsAssignableFrom<AssertException>(ex);|Assert.Equal(\"Assert.Same() Failure\", aex.UserMessage);|Assert.DoesNotContain(\"Position:\", aex.Message);|}|}"
      },
      {
        "name": "ValuesAreNotTheSame",
        "body": "{|Assert.Throws<SameException>(() => Assert.Same(\"bob\", \"jim\"));|}"
      },
      {
        "name": "ValuesAreTheSame",
        "body": "{|string jim = \"jim\";|Assert.Same(jim, jim);|}"
      }
    ]
  },
  {
    "file": "AfterTestExceptionTests.cs",
    "methods": [
      {
        "name": "SingleException",
        "body": "{|Exception ex = Record.Exception(delegate { throw new Exception(\"Exception Message\"); });|Exception result = Record.Exception(delegate { throw new AfterTestException(ex); });|Assert.Equal(\"One or more exceptions were thrown from After methods during test cleanup\", result.Message);|Assert.Contains(\"System.Exception thrown: Exception Message\", result.StackTrace);|Assert.Contains(\"AfterTestExceptionTests\", result.StackTrace);|Assert.Contains(\"Xunit.Record.Exception\", result.StackTrace);|}"
      },
      {
        "name": "MultipleExceptions",
        "body": "{|Exception ex1 = Record.Exception(delegate { throw new Exception(\"Exception Message\"); });|Exception ex2 = Record.Exception(delegate { throw new InvalidOperationException(\"Invalid Operation Message\"); });|Exception result = Record.Exception(delegate { throw new AfterTestException(ex1, ex2); });|Assert.Equal(\"One or more exceptions were thrown from After methods during test cleanup\", result.Message);|Assert.Contains(\"System.Exception thrown: Exception Message\", result.StackTrace);|Assert.Contains(\"System.InvalidOperationException thrown: Invalid Operation Message\", result.StackTrace);|}"
      },
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalInnerException = new AssertException(\"User Message\");|var originalException = new AfterTestException(originalInnerException);|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|var deserializedInnerException = Assert.Single(deserializedException.AfterExceptions);|Assert.Equal(originalInnerException.Message, deserializedInnerException.Message);|var deserializedAssertException = Assert.IsType<AssertException>(deserializedInnerException);|Assert.Equal(originalInnerException.UserMessage, deserializedAssertException.UserMessage);|}"
      }
    ]
  },
  {
    "file": "TestClassCommandFactoryTests.cs",
    "methods": [
      {
        "name": "AbstractTestClassReturnsNull",
        "body": "{|ITestClassCommand command = TestClassCommandFactory.Make(typeof(AbstractTestClass));|Assert.Null(command);|}"
      },
      {
        "name": "NoTestMethodsShouldReturnNull",
        "body": "{|Type type = typeof(StubClass);|ITestClassCommand command = TestClassCommandFactory.Make(type);|Assert.Null(command);|}"
      },
      {
        "name": "RunWithClassReturnsTypeToRunWith",
        "body": "{|ITestClassCommand command = TestClassCommandFactory.Make(typeof(MyRunWithTestClass));|Assert.IsType<MyRunWith>(command);|Assert.Equal(typeof(MyRunWithTestClass), command.TypeUnderTest.Type);|}"
      },
      {
        "name": "RunWithForInvalidTestClassCommandReturnsNull",
        "body": "{|ITestClassCommand command = TestClassCommandFactory.Make(typeof(MyInvalidRunWithTestClass));|Assert.Null(command);|}"
      },
      {
        "name": "StubTestClassMakesTestClassCommand",
        "body": "{|Type testClassType = typeof(StubTestClass);|ITestClassCommand command = TestClassCommandFactory.Make(testClassType);|Assert.IsType<TestClassCommand>(command);|Assert.Equal(typeof(StubTestClass), command.TypeUnderTest.Type);|}"
      },
      {
        "name": "AllStagesOfTestLifetimeExistOnSameThread",
        "body": "{|Type testClassType = typeof(ThreadLifetimeSpy);|ITestClassCommand command = TestClassCommandFactory.Make(testClassType);|ThreadFixtureSpy.Reset();|ThreadLifetimeSpy.Reset();|TestClassCommandRunner.Execute(command, null, null, null);|// The fixture data may take place on a different thread from the test, but that's|// an acceptable limitation, as the fixture should have no knowledge of the test|// class that it's attached to. This means that fixtures cannot use thread local|// storage, but there's no reason for them to need that anyway, as their own data|// remains the same throughout all the tests for a given class.|Assert.NotEqual(-1, ThreadFixtureSpy.CtorThreadId);|Assert.Equal(ThreadFixtureSpy.CtorThreadId, ThreadFixtureSpy.DisposeThreadId);|Assert.NotEqual(-1, ThreadLifetimeSpy.CtorThreadId);|Assert.Equal(ThreadLifetimeSpy.CtorThreadId, ThreadLifetimeSpy.DisposeThreadId);|Assert.Equal(ThreadLifetimeSpy.CtorThreadId, ThreadLifetimeSpy.TestThreadId);|}"
      },
      {
        "name": "TestMethod",
        "body": "{|TestThreadId = Thread.CurrentThread.ManagedThreadId;|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestClassCommandRunnerTests.cs",
    "methods": [
      {
        "name": "StartCallbackIsCalled",
        "body": "{|int count = 0;|string passName = typeof(VarietyTestClass).FullName + \".PassedTest\";|string failName = typeof(VarietyTestClass).FullName + \".FailedTest\";|string skipName = typeof(VarietyTestClass).FullName + \".SkippedTest\";|bool foundPass = false;|bool foundFail = false;|bool foundSkip = false;|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|TestClassCommandRunner.Execute(|command,|null,|cmd =>|{|++count;|if (cmd.DisplayName == passName)|foundPass = true;|if (cmd.DisplayName == failName)|foundFail = true;|if (cmd.DisplayName == skipName)|foundSkip = true;|return true;|},|null|);|Assert.Equal(3, count);|Assert.True(foundPass);|Assert.True(foundFail);|Assert.True(foundSkip);|}"
      },
      {
        "name": "ResultCallbackIsCalledWithCorrectResults",
        "body": "{|int classCounter = 0;|int errorCounter = 0;|int failedCounter = 0;|int passedCounter = 0;|int skippedCounter = 0;|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|TestClassCommandRunner.Execute(|command,|null,|null,|result =>|{|if (result is PassedResult)|passedCounter++;|else if (result is FailedResult)|failedCounter++;|else if (result is SkipResult)|skippedCounter++;|else if (result is ClassResult)|classCounter++;|else|errorCounter++;|return true;|}|);|Assert.Equal(1, passedCounter);|Assert.Equal(1, failedCounter);|Assert.Equal(1, skippedCounter);|Assert.Equal(1, classCounter);|Assert.Equal(0, errorCounter);|}"
      },
      {
        "name": "ClassFinishException",
        "body": "{|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|command.ClassFinish__Result = new Exception();|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(typeof(Exception) + \" : \" + command.ClassFinish__Result.Message, result.Message);|Assert.Equal(command.ClassFinish__Result.StackTrace, result.StackTrace);|}"
      },
      {
        "name": "ClassFinishExceptionSupercedesClassStartException",
        "body": "{|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|command.ClassStart__Result = new NotImplementedException();|command.ClassFinish__Result = new Exception();|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(typeof(Exception) + \" : \" + command.ClassFinish__Result.Message, result.Message);|Assert.Equal(command.ClassFinish__Result.StackTrace, result.StackTrace);|}"
      },
      {
        "name": "ClassStartExceptionDoesNotRunTestsButDoesCallClassFinish",
        "body": "{|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|command.ClassStart__Result = new Exception();|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.True(command.ClassStart__Called);|Assert.True(command.ClassFinish__Called);|Assert.Equal(typeof(Exception) + \" : \" + command.ClassStart__Result.Message, result.Message);|Assert.Equal(command.ClassStart__Result.StackTrace, result.StackTrace);|Assert.Equal(0, result.Results.Count);|}"
      },
      {
        "name": "ExecuteWillNotRunRequestedNonTestMethod",
        "body": "{|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|List<IMethodInfo> methods = new List<IMethodInfo> {|Reflector.Wrap(typeof(VarietyTestClass).GetMethod(\"NonTestMethod\"))|};|ClassResult result = TestClassCommandRunner.Execute(command, methods, null, null);|Assert.Equal(0, result.Results.Count);|}"
      },
      {
        "name": "ExecuteWithNullMethodsRunAllTestMethods",
        "body": "{|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(VarietyTestClass.TestMethodCount, result.Results.Count);|}"
      },
      {
        "name": "ExecuteWithSpecificMethodOnlyRunsThatMethod",
        "body": "{|StubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));|List<IMethodInfo> methods = new List<IMethodInfo> {|Reflector.Wrap(typeof(VarietyTestClass).GetMethod(\"PassedTest\"))|};|ClassResult result = TestClassCommandRunner.Execute(command, methods, null, null);|Assert.Single(result.Results);|}"
      },
      {
        "name": "UsesProvidedObjectInstanceForAllTests",
        "body": "{|InstanceSpy originalObject = new InstanceSpy();|StubTestClassCommand command = new StubTestClassCommand(typeof(InstanceSpy));|command.ObjectUnderTest__Result = originalObject;|InstanceSpy.Reset();|TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(3, InstanceSpy.instances.Count);|foreach (object obj in InstanceSpy.instances)|Assert.Same(originalObject, obj);|}"
      },
      {
        "name": "FailedTest",
        "body": "{|Assert.Equal(3, 2);|}"
      },
      {
        "name": "PassedTest",
        "body": "{ }"
      },
      {
        "name": "SkippedTest",
        "body": "{ }"
      },
      {
        "name": "Test1",
        "body": "{|instances.Add(this);|}"
      },
      {
        "name": "Test2",
        "body": "{|instances.Add(this);|}"
      },
      {
        "name": "Test3",
        "body": "{|instances.Add(this);|}"
      }
    ]
  },
  {
    "file": "TestClassCommandTests.cs",
    "methods": [
      {
        "name": "FixtureDataDisposeFailure_InvocationException",
        "body": "{|TestClassCommand command = new TestClassCommand(typeof(DataDisposeFailureSpy));|DataDisposeThrow.Exception = new TargetInvocationException(new Exception());|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(\"System.Reflection.TargetInvocationException\", result.ExceptionType);|}"
      },
      {
        "name": "FixtureDataConstructorFailure_InvocationException",
        "body": "{|TestClassCommand command = new TestClassCommand();|command.TypeUnderTest = Reflector.Wrap(typeof(DataCtorFailureSpy));|DataCtorThrow.Exception = new TargetInvocationException(new Exception());|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(\"System.Reflection.TargetInvocationException\", result.ExceptionType);|}"
      },
      {
        "name": "CannotUseTestClassAsItsOwnFixture",
        "body": "{|TestClassCommand command = new TestClassCommand(typeof(InvalidTestClassWithSelfFixture));|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(typeof(InvalidOperationException).FullName, result.ExceptionType);|Assert.Equal(0, result.Results.Count);|}"
      },
      {
        "name": "DummyTest",
        "body": "{|dummyTestCalled++;|}"
      },
      {
        "name": "DummyTest",
        "body": "{|dummyTestCalled++;|}"
      },
      {
        "name": "DummyTest",
        "body": "{|Assert.Equal(1, 1);|}"
      },
      {
        "name": "Test1",
        "body": "{|}"
      },
      {
        "name": "Test2",
        "body": "{|}"
      },
      {
        "name": "ClassResultContainsOneResultForEachTestMethod",
        "body": "{|TestClassCommand command = new TestClassCommand();|command.TypeUnderTest = Reflector.Wrap(typeof(Spy));|ClassResult result = TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(3, result.Results.Count);|}"
      },
      {
        "name": "CtorFailure",
        "body": "{|TestClassCommand command = new TestClassCommand();|command.TypeUnderTest = Reflector.Wrap(typeof(CtorFailureSpy));|CtorFailureSpy.Reset();|CtorFailureSpy.dummyTestCalled = 0;|TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(1, CtorFailureSpy.dataCtorCalled);|Assert.Equal(1, CtorFailureSpy.ctorCalled);|Assert.Equal(0, CtorFailureSpy.dummyTestCalled);|Assert.Equal(0, CtorFailureSpy.disposeCalled);|Assert.Equal(1, CtorFailureSpy.dataDisposeCalled);|}"
      },
      {
        "name": "DisposeFailure",
        "body": "{|TestClassCommand command = new TestClassCommand();|command.TypeUnderTest = Reflector.Wrap(typeof(DisposeFailureSpy));|DisposeFailureSpy.Reset();|DisposeFailureSpy.dummyTestCalled = 0;|TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(1, DisposeFailureSpy.dataCtorCalled);|Assert.Equal(1, DisposeFailureSpy.ctorCalled);|Assert.Equal(1, DisposeFailureSpy.dummyTestCalled);|Assert.Equal(1, DisposeFailureSpy.disposeCalled);|Assert.Equal(1, DisposeFailureSpy.dataDisposeCalled);|Assert.Equal(\"ctorData ctor setFixture dispose disposeData \", DisposeFailureSpy.callOrder);|}"
      },
      {
        "name": "RandomizerUsedToDetermineTestOrder",
        "body": "{|RandomSpy randomizer = new RandomSpy();|TestClassCommand command = new TestClassCommand(typeof(OrderingSpy));|command.Randomizer = randomizer;|TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(OrderingSpy.TestMethodCount, randomizer.Next__Count);|}"
      },
      {
        "name": "DummyTest",
        "body": "{|dummyTestCalled++;|}"
      },
      {
        "name": "DummyTest",
        "body": "{|dummyTestCalled++;|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test4",
        "body": "{ }"
      },
      {
        "name": "Test5",
        "body": "{ }"
      },
      {
        "name": "Test6",
        "body": "{ }"
      },
      {
        "name": "Test7",
        "body": "{ }"
      },
      {
        "name": "Test8",
        "body": "{ }"
      },
      {
        "name": "Test9",
        "body": "{ }"
      },
      {
        "name": "FailedTest",
        "body": "{|throw new InvalidOperationException();|}"
      },
      {
        "name": "PassedTest",
        "body": "{ }"
      },
      {
        "name": "Skip",
        "body": "{ }"
      },
      {
        "name": "TestMethodCounters",
        "body": "{|TestClassCommand command = new TestClassCommand();|command.TypeUnderTest = Reflector.Wrap(typeof(InstrumentedTestClass));|InstrumentedTestClass.Reset();|InstrumentedTestClass.passedTestCalled = 0;|InstrumentedTestClass.failedTestCalled = 0;|InstrumentedTestClass.skipTestCalled = 0;|InstrumentedTestClass.nonTestCalled = 0;|TestClassCommandRunner.Execute(command, null, null, null);|Assert.Equal(1, InstrumentedTestClass.dataCtorCalled);|Assert.Equal(2, InstrumentedTestClass.ctorCalled); // Two non-skipped tests, the skipped test does not create an instance|Assert.Equal(1, InstrumentedTestClass.passedTestCalled);|Assert.Equal(1, InstrumentedTestClass.failedTestCalled);|Assert.Equal(0, InstrumentedTestClass.skipTestCalled);|Assert.Equal(0, InstrumentedTestClass.nonTestCalled);|Assert.Equal(2, InstrumentedTestClass.disposeCalled);|Assert.Equal(1, InstrumentedTestClass.dataDisposeCalled);|Assert.Equal(\"ctorData ctor setFixture dispose ctor setFixture dispose disposeData \", InstrumentedTestClass.callOrder);|}"
      },
      {
        "name": "TestsCanBePrivateMethods",
        "body": "{|TestClassCommand command = new TestClassCommand();|command.TypeUnderTest = Reflector.Wrap(typeof(PrivateSpy));|PrivateSpy.Reset();|TestClassCommandRunner.Execute(command, null, null, null);|Assert.True(PrivateSpy.WasRun);|}"
      },
      {
        "name": "SettingSkipReasonGeneratesSkipCommand",
        "body": "{|MethodInfo method = typeof(ClassWithSkippedTest).GetMethod(\"SkippedTest\");|TestClassCommand classCommand = new TestClassCommand(typeof(ClassWithSkippedTest));|var commands = new List<ITestCommand>(classCommand.EnumerateTestCommands(Reflector.Wrap(method)));|ITestCommand command = Assert.Single(commands);|SkipCommand skipCommand = Assert.IsType<SkipCommand>(command);|Assert.Equal(\"My Skip Reason\", skipCommand.Reason);|}"
      },
      {
        "name": "FailedTest",
        "body": "{|failedTestCalled++;|}"
      },
      {
        "name": "PassedTest",
        "body": "{|passedTestCalled++;|}"
      },
      {
        "name": "SkippedTest",
        "body": "{|skipTestCalled++;|}"
      },
      {
        "name": "PrivateTest",
        "body": "{|WasRun = true;|}"
      },
      {
        "name": "SkippedTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "BeforeAfterCommandTests.cs",
    "methods": [
      {
        "name": "VerifyBeforeAfterTestAttributeCalledOnce",
        "body": "{|MethodInfo method = typeof(SimpleTestFixtureSpy).GetMethod(\"PassedTest\");|BeforeAfterCommand command = new BeforeAfterCommand(new FactCommand(Reflector.Wrap(method)), method);|SimpleTestFixtureSpy.Reset();|ITestResult result = command.Execute(new SimpleTestFixtureSpy());|Assert.Equal(1, BeforeAfterSpyAttribute.beforeTestCount);|Assert.Equal(1, BeforeAfterSpyAttribute.afterTestCount);|Assert.Equal(\"ctor beforetest test aftertest \", SimpleTestFixtureSpy.callOrder);|Assert.IsType<PassedResult>(result);|}"
      },
      {
        "name": "MethodUnderTestProvidedToBeforeAfter",
        "body": "{|MethodInfo methodInfo = typeof(InstrumentedTestClass).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|InstrumentedTestClass.Reset();|command.Execute(new InstrumentedTestClass());|Assert.Same(methodInfo, BeforeAfterSpyAttribute.beforeMethod);|Assert.Same(methodInfo, BeforeAfterSpyAttribute.afterMethod);|}"
      },
      {
        "name": "BeforeTestThrows",
        "body": "{|MethodInfo methodInfo = typeof(InstrumentedTestClass).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|InstrumentedTestClass.Reset();|BeforeAfterSpyAttribute.beforeTestThrowCount = 1;|Assert.Throws<Exception>(() => command.Execute(new InstrumentedTestClass()));|Assert.Equal(1, BeforeAfterSpyAttribute.beforeTestCount);|Assert.Equal(0, stub.ExecuteCount);|Assert.Equal(0, BeforeAfterSpyAttribute.afterTestCount);|}"
      },
      {
        "name": "AfterTestThrows",
        "body": "{|MethodInfo methodInfo = typeof(InstrumentedTestClass).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|InstrumentedTestClass.Reset();|BeforeAfterSpyAttribute.afterTestThrowCount = 1;|Assert.Throws<AfterTestException>(() => command.Execute(new InstrumentedTestClass()));|Assert.Equal(1, BeforeAfterSpyAttribute.beforeTestCount);|Assert.Equal(1, stub.ExecuteCount);|Assert.Equal(1, BeforeAfterSpyAttribute.afterTestCount);|}"
      },
      {
        "name": "MultipleBeforeAfterTestAttributesAllCalled",
        "body": "{|MethodInfo methodInfo = typeof(BeforeAfterDoubleSpy).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|BeforeAfterDoubleSpy.Reset();|command.Execute(new BeforeAfterDoubleSpy());|Assert.Equal(2, BeforeAfterSpyAttribute.beforeTestCount);|Assert.Equal(1, stub.ExecuteCount);|Assert.Equal(2, BeforeAfterSpyAttribute.afterTestCount);|}"
      },
      {
        "name": "MultipleBeforeTestsSecondThrows",
        "body": "{|MethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|BeforeAfterSpyAttribute.Reset();|BeforeAfterSpyAttribute.beforeTestThrowCount = 2;|Assert.Throws<Exception>(() => command.Execute(new MultipleAttributeSpy()));|Assert.Equal(2, BeforeAfterSpyAttribute.beforeTestCount);|Assert.Equal(0, stub.ExecuteCount);|Assert.Equal(1, BeforeAfterSpyAttribute.afterTestCount);|}"
      },
      {
        "name": "MultipleAfterTestsSecondThrows",
        "body": "{|MethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|BeforeAfterSpyAttribute.Reset();|BeforeAfterSpyAttribute.afterTestThrowCount = 2;|AfterTestException ex = Assert.Throws<AfterTestException>(() => command.Execute(new MultipleAttributeSpy()));|Assert.Equal(3, BeforeAfterSpyAttribute.beforeTestCount);|Assert.Equal(1, stub.ExecuteCount);|Assert.Equal(3, BeforeAfterSpyAttribute.afterTestCount);|Assert.Equal(2, ex.AfterExceptions.Count);|}"
      },
      {
        "name": "BeforeThrowsAfterThrowsShouldResultInBeforeException",
        "body": "{|MethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand();|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|BeforeAfterSpyAttribute.Reset();|BeforeAfterSpyAttribute.beforeTestThrowCount = 2;|BeforeAfterSpyAttribute.afterTestThrowCount = 1;|Assert.Throws<Exception>(() => command.Execute(new MultipleAttributeSpy()));|}"
      },
      {
        "name": "TestThrowsAfterThrowsShouldResultInTestException",
        "body": "{|MethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");|StubTestCommand stub = new StubTestCommand { ThrowsOnExecute = true };|BeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);|BeforeAfterSpyAttribute.Reset();|BeforeAfterSpyAttribute.afterTestThrowCount = 1;|Assert.Throws<Exception>(() => command.Execute(new InstrumentedTestClass()));|}"
      }
    ]
  },
  {
    "file": "ExceptionAndOutputCaptureCommandTests.cs",
    "methods": [
      {
        "name": "ShouldWrapExceptionDetailsWhenExceptionIsThrown",
        "body": "{|ExceptionThrowingCommand innerCmd = new ExceptionThrowingCommand();|MethodInfo method = typeof(ExceptionThrowingCommand).GetMethod(\"Execute\");|var command = new ExceptionAndOutputCaptureCommand(innerCmd, Reflector.Wrap(method));|MethodResult result = command.Execute(null);|FailedResult failed = Assert.IsType<FailedResult>(result);|Assert.Equal(method.Name, failed.MethodName);|Assert.Equal(method.DeclaringType.FullName, failed.TypeName);|Assert.Equal(typeof(TargetInvocationException).FullName, failed.ExceptionType);|Assert.Contains(\"ExceptionThrowingCommand.Execute\", failed.StackTrace);|}"
      },
      {
        "name": "ConsoleOutAndErrorAreReplacedDuringTestExecution",
        "body": "{|TextWriter originalOut = Console.Out;|TextWriter originalError = Console.Error;|try|{|TextWriter newOut = new StringWriter();|TextWriter newError = new StringWriter();|Console.SetOut(newOut);|Console.SetError(newError);|StubCommand cmd = new StubCommand();|var outputCmd = new ExceptionAndOutputCaptureCommand(cmd, null);|outputCmd.Execute(null);|Assert.Empty(newOut.ToString());|Assert.Empty(newError.ToString());|}|finally|{|Console.SetOut(originalOut);|Console.SetError(originalError);|}|}"
      },
      {
        "name": "ConsoleOutAndErrorAndTraceIsCapturedAndPlacedInMethodResult",
        "body": "{|string expected = \"Standard Output\" + Environment.NewLine +| \"Standard Error\" + Environment.NewLine +| \"Trace\" + Environment.NewLine;|StubCommand cmd = new StubCommand();|var outputCmd = new ExceptionAndOutputCaptureCommand(cmd, null);|MethodResult result = outputCmd.Execute(null);|Assert.Equal(expected, result.Output);|}"
      }
    ]
  },
  {
    "file": "FactCommandTests.cs",
    "methods": [
      {
        "name": "ExecuteRunsTest",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");|TestCommand command = new FactCommand(Reflector.Wrap(method));|TestMethodCommandClass.testCounter = 0;|command.Execute(new TestMethodCommandClass());|Assert.Equal(1, TestMethodCommandClass.testCounter);|}"
      },
      {
        "name": "TestMethodReturnPassedResult",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");|TestCommand command = new FactCommand(Reflector.Wrap(method));|MethodResult result = command.Execute(new TestMethodCommandClass());|Assert.IsType<PassedResult>(result);|}"
      }
    ]
  },
  {
    "file": "LifetimeCommandTests.cs",
    "methods": [
      {
        "name": "CreatesNewInstanceWhenPassedNull",
        "body": "{|StubCommand innerCommand = new StubCommand();|MethodInfo method = typeof(StubCommand).GetMethod(\"Execute\");|LifetimeCommand command = new LifetimeCommand(innerCommand, Reflector.Wrap(method));|command.Execute(null);|Assert.NotNull(innerCommand.TestClass);|}"
      },
      {
        "name": "ConstructorThrowsTestNotCalledDisposeNotCalled",
        "body": "{|MethodInfo method = typeof(SpyWithConstructorThrow).GetMethod(\"PassedTest\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestCommand testCommand = new FactCommand(wrappedMethod);|LifetimeCommand command = new LifetimeCommand(testCommand, wrappedMethod);|SpyWithConstructorThrow.Reset();|Record.Exception(() => command.Execute(null));|Assert.Equal(1, SpyWithConstructorThrow.ctorCalled);|Assert.Equal(0, SpyWithConstructorThrow.testCalled);|Assert.Equal(0, SpyWithConstructorThrow.disposeCalled);|}"
      },
      {
        "name": "ConstructorThrowsTargetInvocationExceptionIsUnwrappedAndRethrown",
        "body": "{|MethodInfo method = typeof(SpyWithConstructorThrow).GetMethod(\"PassedTest\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|FactCommand factCommand = new FactCommand(wrappedMethod);|LifetimeCommand command = new LifetimeCommand(factCommand, wrappedMethod);|SpyWithConstructorThrow.Reset();|Exception ex = Record.Exception(() => command.Execute(null));|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "DoesNotCreateNewInstanceWhenPassedExistingInstance",
        "body": "{|StubCommand innerCommand = new StubCommand();|MethodInfo method = typeof(StubCommand).GetMethod(\"Execute\");|LifetimeCommand command = new LifetimeCommand(innerCommand, Reflector.Wrap(method));|object instance = new object();|command.Execute(instance);|Assert.Same(instance, innerCommand.TestClass);|}"
      },
      {
        "name": "DisposeThrowsTestCalled",
        "body": "{|MethodInfo method = typeof(SpyWithDisposeThrow).GetMethod(\"PassedTest\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestCommand testCommand = new FactCommand(wrappedMethod);|LifetimeCommand command = new LifetimeCommand(testCommand, wrappedMethod);|SpyWithDisposeThrow.Reset();|Record.Exception(() => command.Execute(new SpyWithDisposeThrow()));|Assert.Equal(1, SpyWithDisposeThrow.ctorCalled);|Assert.Equal(1, SpyWithDisposeThrow.testCalled);|Assert.Equal(1, SpyWithDisposeThrow.disposeCalled);|}"
      },
      {
        "name": "DuringTestThrowsDisposeCalled",
        "body": "{|MethodInfo method = typeof(SpyWithTestThrow).GetMethod(\"FailedTest\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestCommand testCommand = new FactCommand(wrappedMethod);|LifetimeCommand command = new LifetimeCommand(testCommand, wrappedMethod);|SpyWithTestThrow.Reset();|Record.Exception(() => command.Execute(new SpyWithTestThrow()));|Assert.Equal(1, SpyWithTestThrow.ctorCalled);|Assert.Equal(1, SpyWithTestThrow.testCalled);|Assert.Equal(1, SpyWithTestThrow.disposeCalled);|}"
      }
    ]
  },
  {
    "file": "SkipCommandTests.cs",
    "methods": [
      {
        "name": "SkipReturnSkipResult",
        "body": "{|MethodInfo method = typeof(SpyStub).GetMethod(\"Skip\");|SkipCommand command = new SkipCommand(Reflector.Wrap(method), null, \"reason\");|MethodResult result = command.Execute(new SpyStub());|SkipResult skipResult = Assert.IsType<SkipResult>(result);|Assert.Equal(\"reason\", skipResult.Reason);|}"
      }
    ]
  },
  {
    "file": "TestCommandFactoryTests.cs",
    "methods": [
      {
        "name": "CallsTestClassCommandToGetTestCommandsAndWrapsTheminTimedCommands",
        "body": "{|MethodInfo method = typeof(TestCommandFactoryTests).GetMethod(\"PublicTestMethod\");|List<ITestCommand> testCommands = new List<ITestCommand>();|StubTestClassCommand classCommand = new StubTestClassCommand();|testCommands.Add(new StubTestCommand());|classCommand.EnumerateTestCommands__Result = testCommands;|List<ITestCommand> result = new List<ITestCommand>(TestCommandFactory.Make(classCommand, Reflector.Wrap(method)));|Assert.Same(method, classCommand.EnumerateTestCommands_TestMethod.MethodInfo);|Assert.Equal(testCommands.Count, result.Count);|var timedCommand = Assert.IsType<TimedCommand>(result[0]);|var captureCommand = Assert.IsType<ExceptionAndOutputCaptureCommand>(timedCommand.InnerCommand);|var lifetimeCommand = Assert.IsType<LifetimeCommand>(captureCommand.InnerCommand);|var beforeAfterCommand = Assert.IsType<BeforeAfterCommand>(lifetimeCommand.InnerCommand);|Assert.Same(testCommands[0], beforeAfterCommand.InnerCommand);|}"
      },
      {
        "name": "DoesNotIncludeCreationCommandWhenTestCommandSaysNotToCreateInstance",
        "body": "{|MethodInfo method = typeof(TestCommandFactoryTests).GetMethod(\"PublicTestMethod\");|List<ITestCommand> testCommands = new List<ITestCommand>();|StubTestClassCommand classCommand = new StubTestClassCommand();|StubTestCommand testCommand = new StubTestCommand();|testCommand.ShouldCreateInstance__Result = false;|testCommands.Add(testCommand);|classCommand.EnumerateTestCommands__Result = testCommands;|List<ITestCommand> result = new List<ITestCommand>(TestCommandFactory.Make(classCommand, Reflector.Wrap(method)));|Assert.Same(method, classCommand.EnumerateTestCommands_TestMethod.MethodInfo);|Assert.Equal(testCommands.Count, result.Count);|var timedCommand = Assert.IsType<TimedCommand>(result[0]);|var captureCommand = Assert.IsType<ExceptionAndOutputCaptureCommand>(timedCommand.InnerCommand);|var beforeAfterCommand = Assert.IsType<BeforeAfterCommand>(captureCommand.InnerCommand);|Assert.Same(testCommands[0], beforeAfterCommand.InnerCommand);|}"
      },
      {
        "name": "IncludesTimeoutCommandWhenTestCommandSaysTheresATimeout",
        "body": "{|MethodInfo method = typeof(TestCommandFactoryTests).GetMethod(\"PublicTestMethod\");|List<ITestCommand> testCommands = new List<ITestCommand>();|StubTestClassCommand classCommand = new StubTestClassCommand();|testCommands.Add(new StubTestCommand { Timeout__Result = 153 });|classCommand.EnumerateTestCommands__Result = testCommands;|List<ITestCommand> result = new List<ITestCommand>(TestCommandFactory.Make(classCommand, Reflector.Wrap(method)));|Assert.Same(method, classCommand.EnumerateTestCommands_TestMethod.MethodInfo);|Assert.Equal(testCommands.Count, result.Count);|Assert.IsType<TimeoutCommand>(result[0]);|}"
      }
    ]
  },
  {
    "file": "TestCommandTests.cs",
    "methods": [
      {
        "name": "TestCommandReturnsStartXml_WithoutDisplayName",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");|Mock<TestCommand> command = new Mock<TestCommand>(Reflector.Wrap(method), null, 0);|command.CallBase = true;|XmlNode result = command.Object.ToStartXml();|Assert.Equal(\"start\", result.Name);|ResultXmlUtility.AssertAttribute(result, \"name\", typeof(TestMethodCommandClass).FullName + \".TestMethod\");|ResultXmlUtility.AssertAttribute(result, \"type\", typeof(TestMethodCommandClass).FullName);|ResultXmlUtility.AssertAttribute(result, \"method\", \"TestMethod\");|}"
      },
      {
        "name": "TestCommandReturnsStartXml_WithDisplayName",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");|Mock<TestCommand> command = new Mock<TestCommand>(Reflector.Wrap(method), \"Display Name!\", 0);|command.CallBase = true;|XmlNode result = command.Object.ToStartXml();|Assert.Equal(\"start\", result.Name);|ResultXmlUtility.AssertAttribute(result, \"name\", \"Display Name!\");|ResultXmlUtility.AssertAttribute(result, \"type\", typeof(TestMethodCommandClass).FullName);|ResultXmlUtility.AssertAttribute(result, \"method\", \"TestMethod\");|}"
      }
    ]
  },
  {
    "file": "TimedCommandTests.cs",
    "methods": [
      {
        "name": "MeasuresTime",
        "body": "{|TimedCommand command = new TimedCommand(new DummyCommand());|MethodResult result = command.Execute(null);|Assert.InRange(result.ExecutionTime, 0.01, 100.0);|}"
      }
    ]
  },
  {
    "file": "TimeoutCommandTests.cs",
    "methods": [
      {
        "name": "TestFinshedOnTimePassedResult",
        "body": "{|Mock<ITestCommand> testCommand = new Mock<ITestCommand>();|testCommand|.Setup(tc => tc.Execute(null))|.Returns(new PassedResult(GetMethodInfo(), null));|TimeoutCommand command = new TimeoutCommand(testCommand.Object, 10000, GetMethodInfo());|MethodResult result = command.Execute(null);|Assert.IsType<PassedResult>(result);|}"
      },
      {
        "name": "TestTookTooLongFailedResult",
        "body": "{|Mock<ITestCommand> testCommand = new Mock<ITestCommand>();|testCommand|.Setup(tc => tc.Execute(null))|.Callback<object>(_ => Thread.Sleep(500));|TimeoutCommand command = new TimeoutCommand(testCommand.Object, 20, GetMethodInfo());|MethodResult result = command.Execute(null);|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(\"Test execution time exceeded: 20ms\", failedResult.Message);|}"
      }
    ]
  },
  {
    "file": "AssertActualExpectedExceptionTests.cs",
    "methods": [
      {
        "name": "ActualValueWrapsForMultiline",
        "body": "{|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 0\" + Environment.NewLine +|\"Expected: expected\" + Environment.NewLine +|\"Actual: line 1\" + Environment.NewLine +|\" line 2\";|AssertActualExpectedException ex =|new AssertActualExpectedException(|\"expected\",|\"line 1\" + Environment.NewLine + \"line 2\",|\"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "ArraysShowDifferencePoint",
        "body": "{|int[] actualValue = new int[] { 1, 2, 3, 4, 5 };|int[] expectedValue = new int[] { 1, 2, 5, 7, 9 };|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 2\" + Environment.NewLine +|\"Expected: Int32[] { 1, 2, 5, 7, 9 }\" + Environment.NewLine +|\"Actual: Int32[] { 1, 2, 3, 4, 5 }\";|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "ListsShowDifferencePoint",
        "body": "{|var actualValue = new List<int> { 1, 2, 3, 4, 5 };|var expectedValue = new List<int> { 1, 2, 5, 7, 9 };|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 2\" + Environment.NewLine +|\"Expected: List<Int32> { 1, 2, 5, 7, 9 }\" + Environment.NewLine +|\"Actual: List<Int32> { 1, 2, 3, 4, 5 }\";|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "MixedEnumerationShowDifferencePoint",
        "body": "{|var expectedValue = MakeEnumeration(1, 42, \"Hello\").ToList();|var actualValue = MakeEnumeration(1, 2.3, \"Goodbye\").ToList();|string expectedMessage =|string.Format(\"Message{0}Position: First difference is at position 1{0}Expected: List<Object> {{ 1, 42, \\\"Hello\\\" }}{0}Actual: List<Object> {{ 1, {1}, \\\"Goodbye\\\" }}\", Environment.NewLine, 2.3);|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "NullValuesInArraysCreateCorrectExceptionMessage",
        "body": "{|string[] expectedValue = new string[] { null, \"hello\" };|string[] actualValue = new string[] { null, \"world\" };|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 1\" + Environment.NewLine +|\"Expected: String[] { (null), \\\"hello\\\" }\" + Environment.NewLine +|\"Actual: String[] { (null), \\\"world\\\" }\";|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "ExpectedAndActualAreUsedInMessage",
        "body": "{|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Expected: 2\" + Environment.NewLine +|\"Actual: 1\";|AssertActualExpectedException ex =|new AssertActualExpectedException(2, 1, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "ExpectedValueWrapsForMultiline",
        "body": "{|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 0\" + Environment.NewLine +|\"Expected: line 1\" + Environment.NewLine +|\" line 2\" + Environment.NewLine +|\"Actual: actual\";|AssertActualExpectedException ex =|new AssertActualExpectedException(|\"line 1\" + Environment.NewLine + \"line 2\",|\"actual\",|\"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "OneStringAddsValueToEndOfTheOtherString",
        "body": "{|string actualValue = \"first test\";|string expectedValue = \"first test 1\";|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 10\" + Environment.NewLine +|\"Expected: first test 1\" + Environment.NewLine +|\"Actual: first test\";|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "OneStringOneNullDoesNotShowDifferencePoint",
        "body": "{|string actualValue = null;|string expectedValue = \"first test 1\";|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Expected: first test 1\" + Environment.NewLine +|\"Actual: (null)\";|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "PreservesExpectedAndActual",
        "body": "{|AssertActualExpectedException ex =|new AssertActualExpectedException(2, 1, null);|Assert.Equal(\"1\", ex.Actual);|Assert.Equal(\"2\", ex.Expected);|Assert.Null(ex.UserMessage);|}"
      },
      {
        "name": "StringsDifferInTheMiddle",
        "body": "{|string actualValue = \"first test\";|string expectedValue = \"first failure\";|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Position: First difference is at position 6\" + Environment.NewLine +|\"Expected: first failure\" + Environment.NewLine +|\"Actual: first test\";|AssertActualExpectedException ex =|new AssertActualExpectedException(expectedValue, actualValue, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "SameVisibleValueDifferentTypes",
        "body": "{|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Expected: 1 (System.String)\" + Environment.NewLine +|\"Actual: 1 (System.Int32)\";|AssertActualExpectedException ex =|new AssertActualExpectedException(\"1\", 1, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      },
      {
        "name": "DifferentVisibleValueDifferentTypes",
        "body": "{|string expectedMessage =|\"Message\" + Environment.NewLine +|\"Expected: 2\" + Environment.NewLine +|\"Actual: 1\";|AssertActualExpectedException ex =|new AssertActualExpectedException(\"2\", 1, \"Message\");|Assert.Equal(expectedMessage, ex.Message);|}"
      }
    ]
  },
  {
    "file": "AssertExceptionTests.cs",
    "methods": [
      {
        "name": "PreservesUserMessage",
        "body": "{|AssertException ex = new AssertException(\"UserMessage\");|Assert.Equal(\"UserMessage\", ex.UserMessage);|}"
      },
      {
        "name": "UserMessageIsTheMessage",
        "body": "{|AssertException ex = new AssertException(\"UserMessage\");|Assert.Equal(ex.UserMessage, ex.Message);|}"
      },
      {
        "name": "DeveloperCanChooseWhichStackFrameItemsToExclude",
        "body": "{|CustomException ex = Assert.Throws<CustomException>(() => { throw new CustomException(); });|string stackTrace = ex.StackTrace;|Assert.Empty(stackTrace); // Everything was filtered out in our exception|Assert.Equal(2, ex.StackFrames.Count);|Assert.Contains(\"Xunit1.AssertExceptionTests\", ex.StackFrames[0]);|Assert.Contains(\"Xunit.Record.Exception\", ex.StackFrames[1]);|}"
      },
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalException = new TestableAssertException(\"User Message\", \"Stack Trace\");|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|Assert.Equal(originalException.StackTrace, deserializedException.StackTrace);|Assert.Equal(originalException.UserMessage, deserializedException.UserMessage);|}"
      }
    ]
  },
  {
    "file": "DoesNotThrowExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalException = new TestableDoesNotThrowException(\"Stack Trace\");|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|Assert.Equal(originalException.StackTrace, deserializedException.StackTrace);|}"
      }
    ]
  },
  {
    "file": "InRangeExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalException = new InRangeException(\"Actual\", \"Low\", \"High\");|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|Assert.Equal(originalException.Actual, deserializedException.Actual);|Assert.Equal(originalException.Low, deserializedException.Low);|Assert.Equal(originalException.High, deserializedException.High);|}"
      }
    ]
  },
  {
    "file": "NotInRangeExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalException = new NotInRangeException(\"Actual\", \"Low\", \"High\");|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|Assert.Equal(originalException.Actual, deserializedException.Actual);|Assert.Equal(originalException.Low, deserializedException.Low);|Assert.Equal(originalException.High, deserializedException.High);|}"
      }
    ]
  },
  {
    "file": "ThrowsExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalException = new TestableThrowsException(\"Stack Trace\");|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|Assert.Equal(originalException.StackTrace, deserializedException.StackTrace);|}"
      }
    ]
  },
  {
    "file": "TraceAssertExceptionTests.cs",
    "methods": [
      {
        "name": "TraceAssertFailureWithFullDetails",
        "body": "{|TraceAssertException ex = Assert.Throws<TraceAssertException>(() => Trace.Assert(false, \"message\", \"detailed message\"));|Assert.Equal(\"message\", ex.AssertMessage);|Assert.Equal(\"detailed message\", ex.AssertDetailedMessage);|Assert.Equal(\"Debug.Assert() Failure : message\" + Environment.NewLine + \"Detailed Message:\" + Environment.NewLine + \"detailed message\", ex.Message);|}"
      },
      {
        "name": "TraceAssertFailureWithNoDetailedMessage",
        "body": "{|TraceAssertException ex = Assert.Throws<TraceAssertException>(() => Trace.Assert(false, \"message\"));|Assert.Equal(\"message\", ex.AssertMessage);|Assert.Equal(\"\", ex.AssertDetailedMessage);|Assert.Equal(\"Debug.Assert() Failure : message\", ex.Message);|}"
      },
      {
        "name": "TraceAssertFailureWithNoMessage",
        "body": "{|// Mono does \"non-standard\" things with the message when it's empty|if (!EnvironmentHelper.IsMono)|{|TraceAssertException ex = Assert.Throws<TraceAssertException>(() => Trace.Assert(false));|Assert.Equal(\"\", ex.AssertMessage);|Assert.Equal(\"\", ex.AssertDetailedMessage);|Assert.Equal(\"Debug.Assert() Failure\", ex.Message);|}|}"
      },
      {
        "name": "SerializesCustomProperties",
        "body": "{|var originalException = new TraceAssertException(\"Assert Message\", \"Detailed Message\");|var deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);|Assert.Equal(originalException.AssertMessage, deserializedException.AssertMessage);|Assert.Equal(originalException.AssertDetailedMessage, deserializedException.AssertDetailedMessage);|}"
      }
    ]
  },
  {
    "file": "ExecutorCallbackTests.cs",
    "methods": [
      {
        "name": "IMessageSink",
        "body": "{|IMessage msg = null;|var handler = new Mock<IMessageSink>();|handler|.Setup(h => h.SyncProcessMessage(It.IsAny<IMessage>()))|.Callback<IMessage>(_msg => msg = _msg)|.Returns((IMessage)null);|var callback = ExecutorCallback.Wrap(handler.Object);|callback.Notify(\"This is the callback value\");|Assert.Equal(\"This is the callback value\", msg.Properties[\"data\"]);|}"
      },
      {
        "name": "ICallbackEventHandler",
        "body": "{|var handler = new Mock<ICallbackEventHandler>();|var callback = ExecutorCallback.Wrap(handler.Object);|callback.Notify(\"This is the callback value\");|handler.Verify(h => h.RaiseCallbackEvent(\"This is the callback value\"), Times.Once());|}"
      },
      {
        "name": "NullCallbackDoesNotThrow",
        "body": "{|var callback = ExecutorCallback.Wrap(null);|Assert.DoesNotThrow(() => callback.Notify(\"This is the callback value\"));|}"
      },
      {
        "name": "IMessageSinkReturnsTrueByDefault",
        "body": "{|var handler = new Mock<IMessageSink>();|var callback = ExecutorCallback.Wrap(handler.Object);|// Don't call Notify here|var result = callback.ShouldContinue();|Assert.True(result);|}"
      },
      {
        "name": "IMessageSinkReturningTrue",
        "body": "{|var values = new Hashtable { { \"data\", \"true\" } };|var message = new Mock<IMessage>();|message.Setup(m => m.Properties).Returns(values);|var handler = new Mock<IMessageSink>();|handler|.Setup(h => h.SyncProcessMessage(It.IsAny<IMessage>()))|.Returns(message.Object);|var callback = ExecutorCallback.Wrap(handler.Object);|// Have to call Notify() because that's how we discover the intended ShouldContinue value|callback.Notify(null);|var result = callback.ShouldContinue();|Assert.True(result);|}"
      },
      {
        "name": "IMessageSinkReturningFalse",
        "body": "{|var values = new Hashtable { { \"data\", \"false\" } };|var message = new Mock<IMessage>();|message.Setup(m => m.Properties).Returns(values);|var handler = new Mock<IMessageSink>();|handler|.Setup(h => h.SyncProcessMessage(It.IsAny<IMessage>()))|.Returns(message.Object);|var callback = ExecutorCallback.Wrap(handler.Object);|// Have to call Notify() because that's how we discover the intended ShouldContinue value|callback.Notify(null);|var result = callback.ShouldContinue();|Assert.False(result);|}"
      },
      {
        "name": "ICallbackEventHandlerReturningTrue",
        "body": "{|var handler = new Mock<ICallbackEventHandler>();|handler.Setup(h => h.GetCallbackResult()).Returns(\"true\");|var callback = ExecutorCallback.Wrap(handler.Object);|var result = callback.ShouldContinue();|Assert.True(result);|}"
      },
      {
        "name": "ICallbackEventHandlerReturningFalse",
        "body": "{|var handler = new Mock<ICallbackEventHandler>();|handler.Setup(h => h.GetCallbackResult()).Returns(\"false\");|var callback = ExecutorCallback.Wrap(handler.Object);|var result = callback.ShouldContinue();|Assert.False(result);|}"
      },
      {
        "name": "ICallbackEventHandlerReturningNull",
        "body": "{|var handler = new Mock<ICallbackEventHandler>();|var callback = ExecutorCallback.Wrap(handler.Object);|var result = callback.ShouldContinue();|Assert.True(result);|}"
      },
      {
        "name": "NullCallbackAlwaysReturnsTrue",
        "body": "{|var callback = ExecutorCallback.Wrap(null);|var result = callback.ShouldContinue();|Assert.True(result);|}"
      },
      {
        "name": "UnsupportedCallbackTypeThrows",
        "body": "{|ExecutorCallback wrapper = ExecutorCallback.Wrap(42);|var ex = Record.Exception(() => wrapper.Notify(\"Notification\"));|Assert.IsType<TargetException>(ex);|}"
      }
    ]
  },
  {
    "file": "AssemblyResultTests.cs",
    "methods": [
      {
        "name": "AssemblyResultCodeBase",
        "body": "{|AssemblyResult assemblyResult = new AssemblyResult(filename);|Assert.Equal(Path.GetDirectoryName(Path.GetFullPath(filename)), assemblyResult.Directory);|}"
      },
      {
        "name": "AssemblyResultName",
        "body": "{|AssemblyResult assemblyResult = new AssemblyResult(filename);|Assert.Equal(Path.GetFullPath(filename), assemblyResult.Filename);|}"
      },
      {
        "name": "AssemblyResultConfigFilename",
        "body": "{|AssemblyResult assemblyResult = new AssemblyResult(filename, fullPathName);|Assert.Equal(fullPathName, assemblyResult.ConfigFilename);|}"
      },
      {
        "name": "ToXml",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|AssemblyResult assemblyResult = new AssemblyResult(filename, fullPathName);|XmlNode resultNode = assemblyResult.ToXml(parentNode);|Assert.Equal(\"assembly\", resultNode.Name);|Assert.Equal(Path.GetFullPath(filename), resultNode.Attributes[\"name\"].Value);|Assert.Equal(fullPathName, resultNode.Attributes[\"configFile\"].Value);|Assert.NotNull(resultNode.Attributes[\"run-date\"]);|Assert.NotNull(resultNode.Attributes[\"run-time\"]);|Assert.Equal(\"0.000\", resultNode.Attributes[\"time\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"total\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"passed\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"failed\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"skipped\"].Value);|Assert.Contains(\"xUnit.net\", resultNode.Attributes[\"test-framework\"].Value);|string expectedEnvironment = string.Format(\"{0}-bit .NET {1}\", IntPtr.Size * 8, Environment.Version);|Assert.Equal(expectedEnvironment, resultNode.Attributes[\"environment\"].Value);|}"
      },
      {
        "name": "ToXml_WithChildren",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|PassedResult passedResult = new PassedResult(\"foo\", \"bar\", null, null);|passedResult.ExecutionTime = 1.1;|FailedResult failedResult = new FailedResult(\"foo\", \"bar\", null, null, \"extype\", \"message\", \"stack\");|failedResult.ExecutionTime = 2.2;|SkipResult skipResult = new SkipResult(\"foo\", \"bar\", null, null, \"reason\");|ClassResult classResult = new ClassResult(typeof(object));|classResult.Add(passedResult);|classResult.Add(failedResult);|classResult.Add(skipResult);|AssemblyResult assemblyResult = new AssemblyResult(filename);|assemblyResult.Add(classResult);|XmlNode resultNode = assemblyResult.ToXml(parentNode);|Assert.Equal(\"3.300\", resultNode.Attributes[\"time\"].Value);|Assert.Equal(\"3\", resultNode.Attributes[\"total\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"passed\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"failed\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"skipped\"].Value);|Assert.Single(resultNode.SelectNodes(\"class\"));|}"
      }
    ]
  },
  {
    "file": "ClassResultTests.cs",
    "methods": [
      {
        "name": "ConstructorGuardClauses",
        "body": "{|Assert.Throws<ArgumentNullException>(() => new ClassResult(null));|}"
      },
      {
        "name": "ConstructWithStrings",
        "body": "{|ClassResult result = new ClassResult(\"name\", \"fullname\", \"namespace\");|Assert.Equal(\"fullname\", result.FullyQualifiedName);|Assert.Equal(\"name\", result.Name);|Assert.Equal(\"namespace\", result.Namespace);|}"
      },
      {
        "name": "ConstructWithType",
        "body": "{|ClassResult result = new ClassResult(typeof(object));|Assert.Equal(typeof(object).FullName, result.FullyQualifiedName);|Assert.Equal(typeof(object).Name, result.Name);|Assert.Equal(typeof(object).Namespace, result.Namespace);|}"
      },
      {
        "name": "SetAssertException",
        "body": "{|ClassResult result = new ClassResult(typeof(object));|Exception thrownException;|try|{|throw new EqualException(2, 3);|}|catch (Exception ex)|{|thrownException = ex;|result.SetException(ex);|}|Assert.Equal(thrownException.GetType().FullName, result.ExceptionType);|Assert.Equal(thrownException.Message, result.Message);|Assert.Equal(thrownException.StackTrace, result.StackTrace);|}"
      },
      {
        "name": "SetExceptionNull",
        "body": "{|ClassResult result = new ClassResult(typeof(object));|result.SetException(null);|Assert.Null(result.ExceptionType);|Assert.Null(result.Message);|Assert.Null(result.StackTrace);|}"
      },
      {
        "name": "SetNonAssertException",
        "body": "{|ClassResult result = new ClassResult(typeof(object));|Exception thrownException;|try|{|throw new Exception(\"message\");|}|catch (Exception ex)|{|thrownException = ex;|result.SetException(ex);|}|Assert.Equal(thrownException.GetType().FullName, result.ExceptionType);|Assert.Equal(result.ExceptionType + \" : \" + thrownException.Message, result.Message);|Assert.Equal(thrownException.StackTrace, result.StackTrace);|}"
      },
      {
        "name": "SetNonAssertExceptionWithInnerException",
        "body": "{|ClassResult result = new ClassResult(typeof(object));|Exception thrownException = null;|Exception innerException = null;|try|{|try|{|throw new InvalidOperationException();|}|catch (Exception ex)|{|innerException = ex;|throw new Exception(\"message\", ex);|}|}|catch (Exception ex)|{|thrownException = ex;|result.SetException(ex);|}|string expectedMessage = string.Format(|\"{0} : {1}{2}---- {3} : {4}\",|thrownException.GetType().FullName,|thrownException.Message,|Environment.NewLine,|innerException.GetType().FullName,|innerException.Message);|Assert.Equal(expectedMessage, result.Message);|string expectedStackTrace =|string.Format(|\"{0}{1}----- Inner Stack Trace -----{1}{2}\",|thrownException.StackTrace,|Environment.NewLine,|innerException.StackTrace);|Assert.Equal(expectedStackTrace, result.StackTrace);|}"
      },
      {
        "name": "ToXml",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|ClassResult classResult = new ClassResult(typeof(object));|XmlNode resultNode = classResult.ToXml(parentNode);|Assert.Equal(\"class\", resultNode.Name);|Assert.Equal(classResult.FullyQualifiedName, resultNode.Attributes[\"name\"].Value);|Assert.Equal(\"0.000\", resultNode.Attributes[\"time\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"total\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"passed\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"failed\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"skipped\"].Value);|}"
      },
      {
        "name": "ToXml_WithChildren",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|ClassResult classResult = new ClassResult(typeof(object));|PassedResult passedResult = new PassedResult(\"foo\", \"bar\", null, null);|passedResult.ExecutionTime = 1.1;|FailedResult failedResult = new FailedResult(\"foo\", \"bar\", null, null, \"extype\", \"message\", \"stack\");|failedResult.ExecutionTime = 2.2;|SkipResult skipResult = new SkipResult(\"foo\", \"bar\", null, null, \"reason\");|classResult.Add(passedResult);|classResult.Add(failedResult);|classResult.Add(skipResult);|XmlNode resultNode = classResult.ToXml(parentNode);|Assert.Equal(\"3.300\", resultNode.Attributes[\"time\"].Value);|Assert.Equal(\"3\", resultNode.Attributes[\"total\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"passed\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"failed\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"skipped\"].Value);|Assert.Equal(3, resultNode.SelectNodes(\"test\").Count);|}"
      },
      {
        "name": "ToXml_WithClassFailure",
        "body": "{|Exception ex;|try|{|throw new InvalidOperationException(\"message\");|}|catch (Exception e)|{|ex = e;|}|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|ClassResult classResult = new ClassResult(typeof(object));|classResult.SetException(ex);|XmlNode resultNode = classResult.ToXml(parentNode);|Assert.Equal(\"class\", resultNode.Name);|Assert.Equal(classResult.FullyQualifiedName, resultNode.Attributes[\"name\"].Value);|Assert.Equal(\"0.000\", resultNode.Attributes[\"time\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"total\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"passed\"].Value);|Assert.Equal(\"1\", resultNode.Attributes[\"failed\"].Value);|Assert.Equal(\"0\", resultNode.Attributes[\"skipped\"].Value);|XmlNode failureNode = resultNode.SelectSingleNode(\"failure\");|Assert.Equal(ex.GetType().FullName, failureNode.Attributes[\"exception-type\"].Value);|Assert.Equal(ExceptionUtility.GetMessage(ex), failureNode.SelectSingleNode(\"message\").InnerText);|Assert.Equal(ExceptionUtility.GetStackTrace(ex), failureNode.SelectSingleNode(\"stack-trace\").InnerText);|}"
      },
      {
        "name": "ToXmlTwiceDoesNotDoubleCounts",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|ClassResult classResult = new ClassResult(typeof(object));|PassedResult passedResult = new PassedResult(\"foo\", \"bar\", null, null);|passedResult.ExecutionTime = 1.1;|FailedResult failedResult = new FailedResult(\"foo\", \"bar\", null, null, \"extype\", \"message\", \"stack\");|failedResult.ExecutionTime = 2.2;|SkipResult skipResult = new SkipResult(\"foo\", \"bar\", null, null, \"reason\");|classResult.Add(passedResult);|classResult.Add(failedResult);|classResult.Add(skipResult);|XmlNode resultNode1 = classResult.ToXml(parentNode);|XmlNode resultNode2 = classResult.ToXml(parentNode);|Assert.Equal(resultNode1.Attributes[\"time\"].Value, resultNode2.Attributes[\"time\"].Value);|Assert.Equal(resultNode1.Attributes[\"total\"].Value, resultNode2.Attributes[\"total\"].Value);|Assert.Equal(resultNode1.Attributes[\"passed\"].Value, resultNode2.Attributes[\"passed\"].Value);|Assert.Equal(resultNode1.Attributes[\"failed\"].Value, resultNode2.Attributes[\"failed\"].Value);|Assert.Equal(resultNode1.Attributes[\"skipped\"].Value, resultNode2.Attributes[\"skipped\"].Value);|Assert.Equal(resultNode1.SelectNodes(\"test\").Count, resultNode2.SelectNodes(\"test\").Count);|}"
      }
    ]
  },
  {
    "file": "CompositeResultsTests.cs",
    "methods": [
      {
        "name": "AddResult",
        "body": "{|StubResult stubResult = new StubResult();|StubCompositeResult compositeResult = new StubCompositeResult();|compositeResult.Add(stubResult);|Assert.Single(compositeResult.Results);|Assert.True(compositeResult.Results.Contains(stubResult));|}"
      },
      {
        "name": "AddResultsMultiple",
        "body": "{|StubResult stubResult1 = new StubResult();|StubResult stubResult2 = new StubResult();|StubResult stubResult3 = new StubResult();|StubCompositeResult compositeResult = new StubCompositeResult();|compositeResult.Add(stubResult1);|compositeResult.Add(stubResult2);|compositeResult.Add(stubResult3);|Assert.Equal(3, compositeResult.Results.Count);|Assert.True(compositeResult.Results.Contains(stubResult1));|Assert.True(compositeResult.Results.Contains(stubResult2));|Assert.True(compositeResult.Results.Contains(stubResult3));|}"
      },
      {
        "name": "ResultsShouldBeReadOnly",
        "body": "{|StubCompositeResult result = new StubCompositeResult();|Assert.True(result.Results.IsReadOnly);|}"
      }
    ]
  },
  {
    "file": "FailedResultTests.cs",
    "methods": [
      {
        "name": "InitializeFailedResult",
        "body": "{|Type stubType = typeof(StubClass);|MethodInfo method = stubType.GetMethod(\"StubMethod\");|StubException stubException = new StubException(\"Message\", \"StackTrace\");|FailedResult result = new FailedResult(Reflector.Wrap(method), stubException, null);|result.ExecutionTime = 1.2;|Assert.Equal(\"StubMethod\", result.MethodName);|Assert.Equal(stubType.FullName, result.TypeName);|Assert.Equal(typeof(StubException).FullName + \" : Message\", result.Message);|Assert.Equal(1.2, result.ExecutionTime);|Assert.Equal(\"StackTrace\", result.StackTrace);|}"
      },
      {
        "name": "InitializeFailedResultWithMultipleInnerExceptions",
        "body": "{|Type stubType = typeof(StubClass);|MethodInfo method = stubType.GetMethod(\"StubMethod\");|Exception thrownException = null;|Exception innerException = null;|try|{|try|{|throw new InvalidOperationException();|}|catch (Exception ex)|{|innerException = ex;|throw new Exception(\"message\", ex);|}|}|catch (Exception ex)|{|thrownException = ex;|}|FailedResult result = new FailedResult(Reflector.Wrap(method), thrownException, null);|result.ExecutionTime = 1.2;|string expectedMessage = string.Format(|\"{0} : {1}{2}---- {3} : {4}\",|thrownException.GetType().FullName,|thrownException.Message,|Environment.NewLine,|innerException.GetType().FullName,|innerException.Message);|Assert.Equal(expectedMessage, result.Message);|string expectedStackTrace =|string.Format(|\"{0}{1}----- Inner Stack Trace -----{1}{2}\",|thrownException.StackTrace,|Environment.NewLine,|innerException.StackTrace);|Assert.Equal(expectedStackTrace, result.StackTrace);|}"
      },
      {
        "name": "ToXml",
        "body": "{|Exception ex = new Exception();|try|{|ThrowAnException();|}|catch (Exception e)|{|ex = e;|}|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"StubMethod\");|FailedResult failedResult = new FailedResult(Reflector.Wrap(method), ex, null);|failedResult.ExecutionTime = 1.2;|XmlNode resultNode = failedResult.ToXml(parentNode);|Assert.Equal(\"Fail\", resultNode.Attributes[\"result\"].Value);|Assert.Equal(\"1.200\", resultNode.Attributes[\"time\"].Value);|XmlNode failureXmlNode = resultNode.SelectSingleNode(\"failure\");|Assert.NotNull(failureXmlNode);|Assert.Equal(ex.GetType().FullName, failureXmlNode.Attributes[\"exception-type\"].Value);|Assert.Equal(ex.GetType().FullName + \" : \" + ex.Message, failureXmlNode.SelectSingleNode(\"message\").InnerText);|Assert.Equal(ex.StackTrace, failureXmlNode.SelectSingleNode(\"stack-trace\").InnerText);|Assert.Null(resultNode.SelectSingleNode(\"reason\"));|}"
      }
    ]
  },
  {
    "file": "MethodResultTests.cs",
    "methods": [
      {
        "name": "ConstructWithMethodInfo",
        "body": "{|Type stubType = typeof(StubClass);|MethodInfo method = stubType.GetMethod(\"Method\");|MethodResult result = new TestableMethodResult(Reflector.Wrap(method));|Assert.Equal(\"Method\", result.MethodName);|Assert.Equal(typeof(StubClass).FullName, result.TypeName);|Assert.Equal(0.0, result.ExecutionTime);|Assert.Equal(0, result.Traits.Count);|}"
      },
      {
        "name": "ConstructWithMethodInfoWithProperties",
        "body": "{|Type stubType = typeof(StubClass);|MethodInfo method = stubType.GetMethod(\"MethodWithTraits\");|MethodResult result = new TestableMethodResult(Reflector.Wrap(method));|Assert.Equal(2, result.Traits.Count);|}"
      },
      {
        "name": "ToXml",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"Method\");|TestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method));|XmlNode resultNode = methodResult.ToXml(parentNode);|Assert.Equal(\"test\", resultNode.Name);|Assert.Equal(methodResult.TypeName, resultNode.Attributes[\"type\"].Value);|Assert.Equal(methodResult.MethodName, resultNode.Attributes[\"method\"].Value);|Assert.Equal(methodResult.TypeName + \".\" + methodResult.MethodName, resultNode.Attributes[\"name\"].Value);|Assert.Null(resultNode.SelectSingleNode(\"traits\"));|Assert.Null(resultNode.SelectSingleNode(\"output\"));|}"
      },
      {
        "name": "ToXmlWithDisplayName",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"Method\");|TestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method), \"Display Name\");|XmlNode resultNode = methodResult.ToXml(parentNode);|Assert.Equal(\"Display Name\", resultNode.Attributes[\"name\"].Value);|}"
      },
      {
        "name": "ToXmlWithTraits",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"MethodWithTraits\");|TestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method));|XmlNode resultNode = methodResult.ToXml(parentNode);|XmlNode traitsNode = resultNode.SelectSingleNode(\"traits\");|Assert.NotNull(traitsNode);|XmlNodeList traitNodes = traitsNode.SelectNodes(\"trait\");|Assert.Equal(\"larry\", FindTrait(traitNodes, \"author\").Attributes[\"value\"].Value);|Assert.Equal(\"PassedResults\", FindTrait(traitNodes, \"Class\").Attributes[\"value\"].Value);|}"
      },
      {
        "name": "ToXmlWithOutput",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"Method\");|TestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method), \"Display Name\");|methodResult.Output = \"This is my output!\";|XmlNode resultNode = methodResult.ToXml(parentNode);|Assert.Equal(\"This is my output!\", resultNode.SelectSingleNode(\"output\").InnerText);|}"
      },
      {
        "name": "Method",
        "body": "{ }"
      },
      {
        "name": "MethodWithParams",
        "body": "{ }"
      },
      {
        "name": "MethodWithTraits",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "PassedResultTests.cs",
    "methods": [
      {
        "name": "ToXml",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"StubMethod\");|PassedResult passedResult = new PassedResult(Reflector.Wrap(method), null);|passedResult.ExecutionTime = 1.2;|XmlNode resultNode = passedResult.ToXml(parentNode);|Assert.Equal(\"Pass\", resultNode.Attributes[\"result\"].Value);|Assert.Equal(\"1.200\", resultNode.Attributes[\"time\"].Value);|Assert.Null(resultNode.SelectSingleNode(\"failure\"));|Assert.Null(resultNode.SelectSingleNode(\"reason\"));|}"
      }
    ]
  },
  {
    "file": "SkipResultTests.cs",
    "methods": [
      {
        "name": "ToXml",
        "body": "{|XmlDocument doc = new XmlDocument();|doc.LoadXml(\"<foo/>\");|XmlNode parentNode = doc.ChildNodes[0];|MethodInfo method = typeof(StubClass).GetMethod(\"StubMethod\");|SkipResult skipResult = new SkipResult(Reflector.Wrap(method), null, \"the reason\");|XmlNode resultNode = skipResult.ToXml(parentNode);|Assert.Equal(\"Skip\", resultNode.Attributes[\"result\"].Value);|Assert.Null(resultNode.Attributes[\"success\"]);|Assert.Null(resultNode.Attributes[\"time\"]);|Assert.Null(resultNode.SelectSingleNode(\"failure\"));|Assert.Equal(\"the reason\", resultNode.SelectSingleNode(\"reason/message\").InnerText);|}"
      }
    ]
  },
  {
    "file": "MethodUtilityTests.cs",
    "methods": [
      {
        "name": "ReturnsNullWithNoDisplayName",
        "body": "{|string methodName = \"WithoutDisplayName\";|Type testClassType = typeof(ClassWithDisplayName);|MethodInfo methodInfo = testClassType.GetMethod(methodName);|var result = MethodUtility.GetDisplayName(Reflector.Wrap(methodInfo));|Assert.Null(result);|}"
      },
      {
        "name": "ReturnsDisplayNameFromFact",
        "body": "{|string methodName = \"WithDisplayName\";|Type testClassType = typeof(ClassWithDisplayName);|MethodInfo methodInfo = testClassType.GetMethod(methodName);|var result = MethodUtility.GetDisplayName(Reflector.Wrap(methodInfo));|Assert.Equal(\"My Display Name\", result);|}"
      },
      {
        "name": "WithDisplayName",
        "body": "{ }"
      },
      {
        "name": "WithoutDisplayName",
        "body": "{ }"
      },
      {
        "name": "MultipleTraitsOnATestMethod",
        "body": "{|Type testClassType = typeof(ClassWithTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"MultipleTestTraitsOnAMethod\");|var traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));|Assert.Equal(2, traits.Count);|string description = Assert.Single(traits[\"Description\"]);|Assert.Equal(\"more than just the test method name\", description);|string author = Assert.Single(traits[\"Author\"]);|Assert.Equal(\"James Newkirk\", author);|}"
      },
      {
        "name": "NoTraits",
        "body": "{|Type testClassType = typeof(ClassWithTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"MethodDoesNotHaveTestTraits\");|var traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));|Assert.Equal(0, traits.Count);|}"
      },
      {
        "name": "SingleTraitOnATestMethod",
        "body": "{|Type testClassType = typeof(ClassWithTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"SingleTraitOnAMethod\");|var traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));|Assert.Single(traits);|string description = Assert.Single(traits[\"Description\"]);|Assert.Equal(\"more than just the test method name\", description);|}"
      },
      {
        "name": "TraitsOnClass",
        "body": "{|Type testClassType = typeof(ClassWithClassTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"TestMethod\");|var traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));|Assert.Equal(2, traits.Count);|string description = Assert.Single(traits[\"Description\"]);|Assert.Equal(\"more than just the test method name\", description);|string author = Assert.Single(traits[\"Author\"]);|Assert.Equal(\"James Newkirk\", author);|}"
      },
      {
        "name": "DuplicatedTraitsOnClassAndMethodAreNotDuplicated",
        "body": "{|Type testClassType = typeof(ClassWithClassTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"TestMethodWithTraits\");|var traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));|Assert.Equal(2, traits.Count);|string description = Assert.Single(traits[\"Description\"]);|Assert.Equal(\"more than just the test method name\", description);|string author = Assert.Single(traits[\"Author\"]);|Assert.Equal(\"James Newkirk\", author);|}"
      },
      {
        "name": "CanDecorateTestMethodWithMultipleFactDerivedAttributes",
        "body": "{|MethodInfo method = typeof(Spy).GetMethod(\"TestMethod\");|List<ITestCommand> commands = new List<ITestCommand>(MethodUtility.GetTestCommands(Reflector.Wrap(method)));|Assert.Equal(2, commands.Count);|}"
      },
      {
        "name": "MethodDoesNotHaveTraits",
        "body": "{|Type testClassType = typeof(ClassWithTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"MethodDoesNotHaveTestTraits\");|Assert.False(MethodUtility.HasTraits(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "MethodHasATrait",
        "body": "{|Type testClassType = typeof(ClassWithTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"SingleTraitOnAMethod\");|Assert.True(MethodUtility.HasTraits(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "ClassHasTrait",
        "body": "{|Type testClassType = typeof(ClassWithClassTraits);|MethodInfo methodInfo = testClassType.GetMethod(\"TestMethod\");|Assert.True(MethodUtility.HasTraits(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestMethodWithNoTimeoutParameter",
        "body": "{|Type testClassType = typeof(TimeoutTestClass);|MethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithNoTimeoutParameter\");|Assert.False(MethodUtility.HasTimeout(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestMethodWithTimeoutParameter",
        "body": "{|Type testClassType = typeof(TimeoutTestClass);|MethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithTimeoutParameter\");|Assert.True(MethodUtility.HasTimeout(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TimeoutParameter",
        "body": "{|Type testClassType = typeof(TimeoutTestClass);|MethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithTimeoutParameter\");|long timeout = MethodUtility.GetTimeoutParameter(Reflector.Wrap(methodInfo));|Assert.Equal<long>(1000, timeout);|}"
      },
      {
        "name": "TestAttributeWithNoTimeoutParameter",
        "body": "{ }"
      },
      {
        "name": "TestAttributeWithTimeoutParameter",
        "body": "{ }"
      },
      {
        "name": "SkipReasonParameter",
        "body": "{|Type testClassType = typeof(SkipTestClass);|MethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithSkipReason\");|string skipReason = MethodUtility.GetSkipReason(Reflector.Wrap(methodInfo));|Assert.Equal(\"reason\", skipReason);|}"
      },
      {
        "name": "TestMethodDoesNotHaveSkipReasonParameter",
        "body": "{|Type testClassType = typeof(SkipTestClass);|MethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithNoSkipReason\");|Assert.False(MethodUtility.IsSkip(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestMethodHasSkipReasonParameter",
        "body": "{|Type testClassType = typeof(SkipTestClass);|MethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithSkipReason\");|Assert.True(MethodUtility.IsSkip(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestAttributeWithNoSkipReason",
        "body": "{ }"
      },
      {
        "name": "TestAttributeWithSkipReason",
        "body": "{ }"
      },
      {
        "name": "IsATest",
        "body": "{|Type testClassType = typeof(TestMethodClass);|MethodInfo methodInfo = testClassType.GetMethod(\"IsATestMethod\");|Assert.True(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "MethodDoesNotHaveTestAttribute",
        "body": "{|Type testClassType = typeof(NoTestAttributeClass);|MethodInfo methodInfo = testClassType.GetMethod(\"NoTestAttribute\");|Assert.False(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestMethodIsAbstract",
        "body": "{|Type testClassType = typeof(AbstractMethodClass);|MethodInfo methodInfo = testClassType.GetMethod(\"AbstractMethod\");|Assert.False(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestMethodIsStatic",
        "body": "{|Type testClassType = typeof(StaticTestMethodClass);|MethodInfo methodInfo = testClassType.GetMethod(\"StaticTestMethod\");|Assert.True(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "TestMethodsCanHaveNonVoidReturnType",
        "body": "{|Type testClassType = typeof(NonVoidReturnClass);|MethodInfo methodInfo = testClassType.GetMethod(\"NonVoidTest\");|Assert.True(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));|}"
      },
      {
        "name": "AbstractMethod",
        "body": "No body available"
      },
      {
        "name": "NonVoidTest",
        "body": "{|return null;|}"
      },
      {
        "name": "StaticTestMethod",
        "body": "{ }"
      },
      {
        "name": "IsATestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "MultiValueDictionaryTests.cs",
    "methods": [
      {
        "name": "EmptyDictionary",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|Assert.Equal(0, dictionary.Keys.Count());|}"
      },
      {
        "name": "RetrievingUnknownKeyThrows",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|Assert.Throws<KeyNotFoundException>(() => dictionary[\"foo\"]);|}"
      },
      {
        "name": "AddSingleValue",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value\");|Assert.Contains(\"Key\", dictionary.Keys);|Assert.Contains(\"Value\", dictionary[\"Key\"]);|}"
      },
      {
        "name": "AddTwoValuesForSameKey",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value1\");|dictionary.AddValue(\"Key\", \"Value2\");|Assert.Contains(\"Key\", dictionary.Keys);|IEnumerable<string> values = dictionary[\"Key\"];|Assert.Contains(\"Value1\", values);|Assert.Contains(\"Value2\", values);|}"
      },
      {
        "name": "AddSameValueForSameKeyDoesNotDuplicateValue",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value1\");|dictionary.AddValue(\"Key\", \"Value1\");|Assert.Contains(\"Key\", dictionary.Keys);|IEnumerable<string> values = dictionary[\"Key\"];|Assert.Single(values);|Assert.Contains(\"Value1\", values);|}"
      },
      {
        "name": "RemoveKey",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value\");|dictionary.Remove(\"Key\");|Assert.DoesNotContain(\"Key\", dictionary.Keys);|}"
      },
      {
        "name": "RemoveKeyForUnknownKeyDoesNotThrow",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|Assert.DoesNotThrow(() => dictionary.Remove(\"Key\"));|}"
      },
      {
        "name": "RemoveValue",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value1\");|dictionary.AddValue(\"Key\", \"Value2\");|dictionary.RemoveValue(\"Key\", \"Value1\");|Assert.Contains(\"Key\", dictionary.Keys);|IEnumerable<string> values = dictionary[\"Key\"];|Assert.DoesNotContain(\"Value1\", values);|Assert.Contains(\"Value2\", values);|}"
      },
      {
        "name": "RemoveValueForUnknownKeyDoesNotThrow",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|Assert.DoesNotThrow(() => dictionary.RemoveValue(\"Key\", \"Value1\"));|}"
      },
      {
        "name": "RemoveValueForUnknownValueDoesNotThrow",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value1\");|Assert.DoesNotThrow(() => dictionary.RemoveValue(\"Key\", \"Value2\"));|}"
      },
      {
        "name": "RemovingLastValueFromKeyRemovesKey",
        "body": "{|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key\", \"Value1\");|dictionary.RemoveValue(\"Key\", \"Value1\");|Assert.DoesNotContain(\"Key\", dictionary.Keys);|}"
      },
      {
        "name": "CanEnumerateKeysAndValuesWithDelegate",
        "body": "{|string result = \"\";|var dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();|dictionary.AddValue(\"Key1\", \"Value1\");|dictionary.AddValue(\"Key2\", \"Value2\");|dictionary.AddValue(\"Key2\", \"Value1\");|dictionary.AddValue(\"Key3\", \"Value7\");|dictionary.ForEach((key, value) => result += key + \": \" + value + \"\\r\\n\");|Assert.Equal(|\"Key1: Value1\\r\\n\" +|\"Key2: Value2\\r\\n\" +|\"Key2: Value1\\r\\n\" +|\"Key3: Value7\\r\\n\", result);|}"
      }
    ]
  },
  {
    "file": "ReflectorTests.cs",
    "methods": [
      {
        "name": "CanFindPublicMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PublicMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "CanFindPublicStaticMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PublicStaticMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "CanFindPrivateMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PrivateMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "CanFindPrivateStaticMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PrivateStaticMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "NonExistantMethodReturnsNull",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"NonExistantMethod\");|Assert.Null(result);|}"
      },
      {
        "name": "ReturnsPublicAndPrivateStaticAndNonStaticMethods",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|List<IMethodInfo> methods = new List<IMethodInfo>(typeInfo.GetMethods());|foreach (string name in new string[] { \"PrivateMethod\", \"PrivateStaticMethod\", \"PublicMethod\", \"PublicStaticMethod\" })|Assert.NotNull(methods.Find(methodInfo => methodInfo.Name == name));|Assert.Null(methods.Find(methodInfo => methodInfo.Name == \"Property\"));|}"
      },
      {
        "name": "ThrowsException",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestMethodCommandClass obj = new TestMethodCommandClass();|Exception ex = Record.Exception(() => wrappedMethod.Invoke(obj));|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "ThrowsTargetInvocationException",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsTargetInvocationException\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestMethodCommandClass obj = new TestMethodCommandClass();|Exception ex = Record.Exception(() => wrappedMethod.Invoke(obj));|Assert.IsType<TargetInvocationException>(ex);|}"
      },
      {
        "name": "TurnsTargetParameterCountExceptionIntoParameterCountMismatchException",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestMethodCommandClass obj = new TestMethodCommandClass();|Exception ex = Record.Exception(() => wrappedMethod.Invoke(obj, \"Hello world\"));|Assert.IsType<ParameterCountMismatchException>(ex);|}"
      },
      {
        "name": "PrivateMethod",
        "body": "{ }"
      },
      {
        "name": "PrivateStaticMethod",
        "body": "{ }"
      },
      {
        "name": "PublicMethod",
        "body": "{ }"
      },
      {
        "name": "PublicStaticMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TypeUtilityTests.cs",
    "methods": [
      {
        "name": "ClassContains2MethodsWithTestAttribute",
        "body": "{|List<IMethodInfo> testMethods =|new List<IMethodInfo>(TypeUtility.GetTestMethods(Reflector.Wrap(typeof(ClassWith2TestMethods))));|Assert.Equal(2, testMethods.Count);|}"
      },
      {
        "name": "ClassContainsNoMethodsWithTestAttribute",
        "body": "{|List<IMethodInfo> testMethods =|new List<IMethodInfo>(TypeUtility.GetTestMethods(Reflector.Wrap(typeof(ClassWithNoTestMethods))));|Assert.Equal(0, testMethods.Count);|}"
      },
      {
        "name": "ClassContainsTestMethods",
        "body": "{|Assert.True(TypeUtility.ContainsTestMethods(Reflector.Wrap(typeof(ClassWith2TestMethods))));|}"
      },
      {
        "name": "ClassDoesNotContainTestMethods",
        "body": "{|Assert.False(TypeUtility.ContainsTestMethods(Reflector.Wrap(typeof(ClassWithNoTestMethods))));|}"
      },
      {
        "name": "ClassHasRunWithAttributeReturnsTypeThatDoesNotImplementsITestClassCommand",
        "body": "{|Type testClassType = typeof(CustomRunWithInvalidClass);|Assert.Null(TypeUtility.GetRunWith(Reflector.Wrap(testClassType)));|}"
      },
      {
        "name": "ClassHasRunWithAttributeReturnsTypeThatImplementsITestClassCommand",
        "body": "{|Type testClassType = typeof(CustomRunWithClass);|Type commandType = TypeUtility.GetRunWith(Reflector.Wrap(testClassType)).Type;|Assert.True(TypeUtility.ImplementsITestClassCommand(Reflector.Wrap(commandType)));|}"
      },
      {
        "name": "ClassHasRunWithAttributeWithITestClassCommand",
        "body": "{|Type testClassType = typeof(CustomRunWithClass);|Assert.True(TypeUtility.HasRunWith(Reflector.Wrap(testClassType)));|}"
      },
      {
        "name": "BaseClassCanHaveRunWithAttribute",
        "body": "{|Type testClassType = typeof(RunWithDerivedClass);|Type commandType = TypeUtility.GetRunWith(Reflector.Wrap(testClassType)).Type;|Assert.NotNull(commandType);|}"
      },
      {
        "name": "CanDetermineIfClassIsStatic",
        "body": "{|Assert.False(TypeUtility.IsStatic(Reflector.Wrap(typeof(NonStaticClass))));|Assert.True(TypeUtility.IsStatic(Reflector.Wrap(typeof(StaticClass))));|}"
      },
      {
        "name": "Method1",
        "body": "{ }"
      },
      {
        "name": "Method2",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "SerializationTests.cs",
    "methods": [
      {
        "name": "CanSerializeAndDeserializeObjectsInATest",
        "body": "{|BinaryFormatter bf = new BinaryFormatter();|using (Stream ms = new MemoryStream())|{|bf.Serialize(ms, new SerializableObject());|ms.Position = 0;|object o = bf.Deserialize(ms);|Assert.IsType(typeof(SerializableObject), o);|Assert.DoesNotThrow(delegate { SerializableObject o2 = (SerializableObject)o; });|}|}"
      }
    ]
  },
  {
    "file": "SingleTests.cs",
    "methods": [
      {
        "name": "NullCollectionThrows",
        "body": "{|Assert.Throws<ArgumentNullException>(() => Assert.Single(null));|}"
      },
      {
        "name": "EmptyCollectionThrows",
        "body": "{|ArrayList collection = new ArrayList();|Exception ex = Record.Exception(() => Assert.Single(collection));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 0 elements instead of 1.\", ex.Message);|}"
      },
      {
        "name": "MultiItemCollectionThrows",
        "body": "{|ArrayList collection = new ArrayList { \"Hello\", \"World\" };|Exception ex = Record.Exception(() => Assert.Single(collection));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 2 elements instead of 1.\", ex.Message);|}"
      },
      {
        "name": "SingleItemCollectionDoesNotThrow",
        "body": "{|ArrayList collection = new ArrayList { \"Hello\" };|Exception ex = Record.Exception(() => Assert.Single(collection));|Assert.Null(ex);|}"
      },
      {
        "name": "SingleItemCollectionReturnsTheItem",
        "body": "{|ArrayList collection = new ArrayList { \"Hello\" };|object result = Assert.Single(collection);|Assert.Equal(\"Hello\", result);|}"
      },
      {
        "name": "NullCollectionThrows",
        "body": "{|Assert.Throws<ArgumentNullException>(() => Assert.Single(null, null));|}"
      },
      {
        "name": "ObjectSingleMatch",
        "body": "{|IEnumerable collection = new[] { \"Hello\", \"World!\" };|Assert.Single(collection, \"Hello\");|}"
      },
      {
        "name": "NullSingleMatch",
        "body": "{|IEnumerable collection = new[] { \"Hello\", \"World!\", null };|Assert.Single(collection, null);|}"
      },
      {
        "name": "ObjectNoMatch",
        "body": "{|IEnumerable collection = new[] { \"Hello\", \"World!\" };|Exception ex = Record.Exception(() => Assert.Single(collection, \"foo\"));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 0 instances of 'foo' instead of 1.\", ex.Message);|}"
      },
      {
        "name": "PredicateTooManyMatches",
        "body": "{|string[] collection = new[] { \"Hello\", \"World!\", \"Hello\" };|Exception ex = Record.Exception(() => Assert.Single(collection, \"Hello\"));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 2 instances of 'Hello' instead of 1.\", ex.Message);|}"
      },
      {
        "name": "NullCollectionThrows",
        "body": "{|Assert.Throws<ArgumentNullException>(() => Assert.Single<object>(null));|}"
      },
      {
        "name": "EmptyCollectionThrows",
        "body": "{|object[] collection = new object[0];|Exception ex = Record.Exception(() => Assert.Single(collection));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 0 elements instead of 1.\", ex.Message);|}"
      },
      {
        "name": "MultiItemCollectionThrows",
        "body": "{|string[] collection = new[] { \"Hello\", \"World!\" };|Exception ex = Record.Exception(() => Assert.Single(collection));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 2 elements instead of 1.\", ex.Message);|}"
      },
      {
        "name": "SingleItemCollectionDoesNotThrow",
        "body": "{|string[] collection = new[] { \"Hello\" };|Exception ex = Record.Exception(() => Assert.Single(collection));|Assert.Null(ex);|}"
      },
      {
        "name": "SingleItemCollectionReturnsTheItem",
        "body": "{|string[] collection = new[] { \"Hello\" };|string result = Assert.Single(collection);|Assert.Equal(\"Hello\", result);|}"
      },
      {
        "name": "NullCollectionThrows",
        "body": "{|Assert.Throws<ArgumentNullException>(() => Assert.Single<object>(null, _ => true));|}"
      },
      {
        "name": "NullPredicateThrows",
        "body": "{|Assert.Throws<ArgumentNullException>(() => Assert.Single<object>(new object[0], null));|}"
      },
      {
        "name": "PredicateSingleMatch",
        "body": "{|string[] collection = new[] { \"Hello\", \"World!\" };|string result = Assert.Single(collection, item => item.StartsWith(\"H\"));|Assert.Equal(\"Hello\", result);|}"
      },
      {
        "name": "PredicateNoMatch",
        "body": "{|string[] collection = new[] { \"Hello\", \"World!\" };|Exception ex = Record.Exception(() => Assert.Single(collection, item => false));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 0 elements instead of 1.\", ex.Message);|}"
      },
      {
        "name": "PredicateTooManyMatches",
        "body": "{|string[] collection = new[] { \"Hello\", \"World!\" };|Exception ex = Record.Exception(() => Assert.Single(collection, item => true));|Assert.IsType<SingleException>(ex);|Assert.Equal(\"The collection contained 2 elements instead of 1.\", ex.Message);|}"
      }
    ]
  },
  {
    "file": "ThrowsTests.cs",
    "methods": [
      {
        "name": "DoesNotThrowException",
        "body": "{|bool methodCalled = false;|Assert.DoesNotThrow(() => methodCalled = true);|Assert.True(methodCalled);|}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{|try|{|Assert.Throws<ArgumentException>(delegate { });|}|catch (AssertActualExpectedException exception)|{|Assert.Equal(\"(No exception was thrown)\", exception.Actual);|}|}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{|try|{|Assert.Throws<Exception>(delegate { throw new InvalidOperationException(); });|}|catch (AssertException exception)|{|Assert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);|}|}"
      },
      {
        "name": "GotExpectedException",
        "body": "{|ArgumentException ex =|Assert.Throws<ArgumentException>(delegate { throw new ArgumentException(); });|Assert.NotNull(ex);|}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{|StubAccessor accessor = new StubAccessor();|try|{|Assert.Throws<ArgumentException>(() => accessor.SuccessfulProperty);|}|catch (AssertActualExpectedException exception)|{|Assert.Equal(\"(No exception was thrown)\", exception.Actual);|}|}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{|StubAccessor accessor = new StubAccessor();|try|{|Assert.Throws<Exception>(() => accessor.FailingProperty);|}|catch (AssertException exception)|{|Assert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);|}|}"
      },
      {
        "name": "GotExpectedException",
        "body": "{|StubAccessor accessor = new StubAccessor();|InvalidOperationException ex =|Assert.Throws<InvalidOperationException>(() => accessor.FailingProperty);|Assert.NotNull(ex);|}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{|try|{|Assert.Throws(typeof(ArgumentException), delegate { });|}|catch (AssertActualExpectedException exception)|{|Assert.Equal(\"(No exception was thrown)\", exception.Actual);|}|}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{|try|{|Assert.Throws(typeof(Exception), delegate { throw new InvalidOperationException(); });|}|catch (AssertException exception)|{|Assert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);|}|}"
      },
      {
        "name": "GotExpectedException",
        "body": "{|Exception ex =|Assert.Throws(typeof(ArgumentException), delegate { throw new ArgumentException(); });|Assert.NotNull(ex);|Assert.IsType<ArgumentException>(ex);|}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{|StubAccessor accessor = new StubAccessor();|try|{|Assert.Throws(typeof(ArgumentException), () => accessor.SuccessfulProperty);|}|catch (AssertActualExpectedException exception)|{|Assert.Equal(\"(No exception was thrown)\", exception.Actual);|}|}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{|StubAccessor accessor = new StubAccessor();|try|{|Assert.Throws(typeof(Exception), () => accessor.FailingProperty);|}|catch (AssertException exception)|{|Assert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);|}|}"
      },
      {
        "name": "GotExpectedException",
        "body": "{|StubAccessor accessor = new StubAccessor();|Exception ex =|Assert.Throws(typeof(InvalidOperationException), () => accessor.FailingProperty);|Assert.NotNull(ex);|Assert.IsType<InvalidOperationException>(ex);|}"
      }
    ]
  },
  {
    "file": "TrueTests.cs",
    "methods": [
      {
        "name": "AssertTrue",
        "body": "{|Assert.True(true);|}"
      },
      {
        "name": "AssertTrueThrowsExceptionWhenFalse",
        "body": "{|TrueException exception = Assert.Throws<TrueException>(() => Assert.True(false));|Assert.Equal(\"Assert.True() Failure\", exception.UserMessage);|}"
      }
    ]
  },
  {
    "file": "AsyncAcceptanceTests.cs",
    "methods": [
      {
        "name": "Async40AcceptanceTest",
        "body": "{|IEnumerable<MethodResult> results = RunClass(typeof(Async40AcceptanceTestClass));|MethodResult result = Assert.Single(results);|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(typeof(TrueException).FullName, failedResult.ExceptionType);|}"
      },
      {
        "name": "Task",
        "body": "{|return Task.Factory.StartNew(() =>|{|Thread.Sleep(1);|})|.ContinueWith(_ =>|{|Assert.True(false);|});|}"
      }
    ]
  },
  {
    "file": "CollectionAcceptanceTests.cs",
    "methods": [
      {
        "name": "TwoClasses_OneInExplicitCollection_OneInDefaultCollection",
        "body": "{|var results = Run(new[] { typeof(ClassInExplicitCollection), typeof(ClassInDefaultCollection) });|var defaultResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName.StartsWith(\"Test collection for \"));|AssertMessageSequence(defaultResults, \"CollectionAcceptanceTests+ClassInDefaultCollection.Passing\");|var explicitResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName == \"Explicit Collection\");|AssertMessageSequence(explicitResults, \"CollectionAcceptanceTests+ClassInExplicitCollection.Passing\");|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "FixtureAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestClassMustHaveSinglePublicConstructor",
        "body": "{|var messages = Run(typeof(ClassWithTooManyConstructors));|Assert.Collection(messages,|message => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),|message => Assert.IsAssignableFrom<ITestCollectionStarting>(message),|message => Assert.IsAssignableFrom<ITestClassStarting>(message),|// TestMethod1|message => Assert.IsAssignableFrom<ITestMethodStarting>(message),|message => Assert.IsAssignableFrom<ITestCaseStarting>(message),|message => Assert.IsAssignableFrom<ITestStarting>(message),|message =>|{|var failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);|Assert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());|Assert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());|},|message => Assert.IsAssignableFrom<ITestFinished>(message),|message => Assert.IsAssignableFrom<ITestCaseFinished>(message),|message => Assert.IsAssignableFrom<ITestMethodFinished>(message),|// TestMethod2|message => Assert.IsAssignableFrom<ITestMethodStarting>(message),|message => Assert.IsAssignableFrom<ITestCaseStarting>(message),|message => Assert.IsAssignableFrom<ITestStarting>(message),|message =>|{|var failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);|Assert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());|Assert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());|},|message => Assert.IsAssignableFrom<ITestFinished>(message),|message => Assert.IsAssignableFrom<ITestCaseFinished>(message),|message => Assert.IsAssignableFrom<ITestMethodFinished>(message),|message => Assert.IsAssignableFrom<ITestClassFinished>(message),|message => Assert.IsAssignableFrom<ITestCollectionFinished>(message),|message => Assert.IsAssignableFrom<ITestAssemblyFinished>(message)|);|}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());|Assert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));|var msg = Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));|var msg = Assert.Single(messages);|Assert.Collection(|msg.ExceptionTypes,|type => Assert.Equal(typeof(TestClassException).FullName, type),|type => Assert.Equal(typeof(DivideByZeroException).FullName, type)|);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureDisposeResultsInFailedTest",
        "body": "{|var messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithDefaultParameter",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithDefaultCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithDefaultCtorArg.TheTest\", msg.Test.DisplayName);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithOptionalParameter",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithOptionalCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithOptionalCtorArg.TheTest\", msg.Test.DisplayName);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithParamsParameter",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithParamsArg));|var msg = Assert.Single(messages);|Assert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithParamsArg.TheTest\", msg.Test.DisplayName);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataShouldHaveBeenSetup",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ThrowingAsyncSetupShouldResultInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetup));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureAsyncDisposeResultsInFailedTest",
        "body": "{|var messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotBeDecoratedWithICollectionFixture",
        "body": "{|var messages = Run<ITestFailed>(typeof(TestClassWithCollectionFixture));|var msg = Assert.Single(messages);|Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());|Assert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", msg.Messages.Single());|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());|Assert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));|var msg = Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeResultsInFailedTest",
        "body": "{|var messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsSameInstanceAcrossClasses",
        "body": "{|Run<ITestPassed>(new[] { typeof(FixtureSaver1), typeof(FixtureSaver2) });|Assert.Same(FixtureSaver1.Fixture, FixtureSaver2.Fixture);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnCollectionDecorationWorks",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy_ClassFixture));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnTestClassTakesPrecedenceOverClassFixtureOnCollection",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithCountedFixture));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureSetupAsyncResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetupAsync));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest",
        "body": "{|var messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureAsyncDispose));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "CollectionFixtureAsyncSetupShouldOnlyRunOnce",
        "body": "{|var results = Run<ITestPassed>(new[] { typeof(Fixture1), typeof(Fixture2) });|Assert.Equal(2, results.Count);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "Xunit2AcceptanceTests.cs",
    "methods": [
      {
        "name": "NoTests",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(NoTestsClass));|Assert.Collection(results,|message => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),|message =>|{|var finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);|Assert.Equal(0, finished.TestsRun);|Assert.Equal(0, finished.TestsFailed);|Assert.Equal(0, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "SinglePassingTest",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(SinglePassingTestClass));|Assert.Collection(results,|message => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),|message =>|{|var collectionStarting = Assert.IsAssignableFrom<ITestCollectionStarting>(message);|Assert.NotNull(collectionStarting.TestCollection);|// TODO: There will need to be more tests here eventually...|},|message =>|{|var classStarting = Assert.IsAssignableFrom<ITestClassStarting>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", classStarting.TestClass.Class.Name);|},|message =>|{|var testMethodStarting = Assert.IsAssignableFrom<ITestMethodStarting>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodStarting.TestClass.Class.Name);|Assert.Equal(\"TestMethod\", testMethodStarting.TestMethod.Method.Name);|},|message =>|{|var testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass.TestMethod\", testCaseStarting.TestCase.DisplayName);|},|message =>|{|var starting = Assert.IsAssignableFrom<ITestStarting>(message);|Assert.Equal(starting.TestCase.DisplayName, starting.Test.DisplayName);|},|message =>|{|var classConstructionStarting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(message);|Assert.Equal(classConstructionStarting.TestCase.DisplayName, classConstructionStarting.Test.DisplayName);|},|message =>|{|var classConstructionFinished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(message);|Assert.Equal(classConstructionFinished.TestCase.DisplayName, classConstructionFinished.Test.DisplayName);|},|message =>|{|var testPassed = Assert.IsAssignableFrom<ITestPassed>(message);|Assert.Equal(testPassed.TestCase.DisplayName, testPassed.Test.DisplayName);|Assert.NotEqual(0M, testPassed.ExecutionTime);|},|message =>|{|var testFinished = Assert.IsAssignableFrom<ITestFinished>(message);|Assert.Equal(testFinished.TestCase.DisplayName, testFinished.Test.DisplayName);|},|message =>|{|var testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(message);|Assert.Equal(1, testCaseFinished.TestsRun);|Assert.Equal(0, testCaseFinished.TestsFailed);|Assert.Equal(0, testCaseFinished.TestsSkipped);|Assert.NotEqual(0M, testCaseFinished.ExecutionTime);|},|message =>|{|var testMethodFinished = Assert.IsAssignableFrom<ITestMethodFinished>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodFinished.TestClass.Class.Name);|Assert.Equal(\"TestMethod\", testMethodFinished.TestMethod.Method.Name);|},|message =>|{|var classFinished = Assert.IsAssignableFrom<ITestClassFinished>(message);|Assert.Equal(1, classFinished.TestsRun);|Assert.Equal(0, classFinished.TestsFailed);|Assert.Equal(0, classFinished.TestsSkipped);|Assert.NotEqual(0M, classFinished.ExecutionTime);|},|message =>|{|var collectionFinished = Assert.IsAssignableFrom<ITestCollectionFinished>(message);|Assert.NotNull(collectionFinished.TestCollection);|Assert.Equal(1, collectionFinished.TestsRun);|Assert.Equal(0, collectionFinished.TestsFailed);|Assert.Equal(0, collectionFinished.TestsSkipped);|Assert.NotEqual(0M, collectionFinished.ExecutionTime);|// TODO: There will need to be more tests here eventually...|},|message =>|{|var assemblyFinished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);|Assert.Equal(1, assemblyFinished.TestsRun);|Assert.Equal(0, assemblyFinished.TestsFailed);|Assert.Equal(0, assemblyFinished.TestsSkipped);|Assert.NotEqual(0M, assemblyFinished.ExecutionTime);|}|);|}"
      },
      {
        "name": "SingleSkippedTest",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(SingleSkippedTestClass));|var skippedMessage = Assert.Single(results.OfType<ITestSkipped>());|Assert.Equal(\"Xunit2AcceptanceTests+SingleSkippedTestClass.TestMethod\", skippedMessage.Test.DisplayName);|Assert.Equal(\"This is a skipped test\", skippedMessage.Reason);|var classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());|Assert.Equal(1, classFinishedMessage.TestsSkipped);|var collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());|Assert.Equal(1, collectionFinishedMessage.TestsSkipped);|}"
      },
      {
        "name": "TimedOutTest",
        "body": "{|var stopwatch = Stopwatch.StartNew();|var results = Run(typeof(ClassUnderTest));|stopwatch.Stop();|var passedMessage = Assert.Single(results.OfType<ITestPassed>());|Assert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.ShortRunningTest\", passedMessage.Test.DisplayName);|var failedMessage = Assert.Single(results.OfType<ITestFailed>());|Assert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.LongRunningTest\", failedMessage.Test.DisplayName);|Assert.Equal(\"Test execution timed out after 10 milliseconds\", failedMessage.Messages.Single());|Assert.True(stopwatch.ElapsedMilliseconds < 10000, \"Elapsed time should be less than 10 seconds\");|}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "TestWithUnstartedTaskThrows",
        "body": "{|var stopwatch = Stopwatch.StartNew();|var results = Run(typeof(ClassUnderTest));|stopwatch.Stop();|var failedMessage = Assert.Single(results.OfType<ITestFailed>());|Assert.Equal(\"Xunit2AcceptanceTests+NonStartedTasks+ClassUnderTest.NonStartedTask\", failedMessage.Test.DisplayName);|Assert.Equal(\"Test method returned a non-started Task (tasks must be started before being returned)\", failedMessage.Messages.Single());|}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "SingleFailingTest",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(SingleFailingTestClass));|var failedMessage = Assert.Single(results.OfType<ITestFailed>());|Assert.Equal(typeof(TrueException).FullName, failedMessage.ExceptionTypes.Single());|var classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());|Assert.Equal(1, classFinishedMessage.TestsFailed);|var collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());|Assert.Equal(1, collectionFinishedMessage.TestsFailed);|}"
      },
      {
        "name": "TestFailureResultsFromThrowingCtorInTestClass",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassUnderTest_CtorFailure));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TestFailureResultsFromThrowingDisposeInTestClass",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassUnderTest_DisposeFailure));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "CompositeTestFailureResultsFromFailingTestsPlusThrowingDisposeInTestClass",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassUnderTest_FailingTestAndDisposeFailure));|var msg = Assert.Single(messages);|var combinedMessage = Xunit.ExceptionUtility.CombineMessages(msg);|Assert.StartsWith(\"System.AggregateException : \", combinedMessage);|Assert.Contains(|\"---- Assert.Equal() Failure: Values differ\" + Environment.NewLine +|\"Expected: 2\" + Environment.NewLine +|\"Actual: 3\" + Environment.NewLine +|\"---- System.DivideByZeroException : \",|combinedMessage);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{|Assert.Equal(2, 3);|}"
      },
      {
        "name": "TestsCanBeInStaticClasses",
        "body": "{|var testMessages = Run<ITestResultMessage>(typeof(StaticClassUnderTest));|var testMessage = Assert.Single(testMessages);|Assert.Equal(\"Xunit2AcceptanceTests+StaticClassSupport+StaticClassUnderTest.Passing\", testMessage.Test.DisplayName);|Assert.IsAssignableFrom<ITestPassed>(testMessage);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "EachTestMethodHasIndividualExceptionMessage",
        "body": "{|var testMessages = Run<ITestFailed>(typeof(ClassUnderTest));|var equalFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.EqualFailure\");|Assert.Contains(\"Assert.Equal() Failure\", equalFailure.Messages.Single());|var notNullFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.NotNullFailure\");|Assert.Contains(\"Assert.NotNull() Failure\", notNullFailure.Messages.Single());|}"
      },
      {
        "name": "EqualFailure",
        "body": "{|Assert.Equal(42, 40);|}"
      },
      {
        "name": "NotNullFailure",
        "body": "{|Assert.NotNull(null);|}"
      },
      {
        "name": "OverrideOfOrderingAtCollectionLevel",
        "body": "{|var testMessages = Run<ITestPassed>(typeof(TestClassUsingCollection));|Assert.Collection(testMessages,|message => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)|);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "OverrideOfOrderingAtClassLevel",
        "body": "{|var testMessages = Run<ITestPassed>(typeof(TestClassWithoutCollection));|Assert.Collection(testMessages,|message => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)|);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "NonParallelCollectionsRunLast",
        "body": "{|var testMessages = Run<ITestPassed>(new[] {|typeof(TestClassNonParallelCollection),|typeof(TestClassParallelCollection)|});|Assert.Collection(testMessages,|message => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"IShouldBeLast1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"IShouldBeLast2\", message.TestCase.TestMethod.Method.Name)|);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast1",
        "body": "{ }"
      },
      {
        "name": "CanUseCustomFactAttribute",
        "body": "{|var msgs = Run<ITestPassed>(typeof(ClassWithCustomFact));|var msg = Assert.Single(msgs);|Assert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomFact.Passing\", msg.Test.DisplayName);|}"
      },
      {
        "name": "CanUseCustomFactWithArrayParameters",
        "body": "{|var msgs = Run<ITestPassed>(typeof(ClassWithCustomArrayFact));|var msg = Assert.Single(msgs);|Assert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomArrayFact.Passing\", msg.Test.DisplayName);|}"
      },
      {
        "name": "CannotMixMultipleFactDerivedAttributes",
        "body": "{|var msgs = Run<ITestFailed>(typeof(ClassWithMultipleFacts)).ToList();|Assert.Collection(msgs,|msg =>|{|Assert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing\", msg.Test.DisplayName);|Assert.Equal(\"System.InvalidOperationException\", msg.ExceptionTypes.Single());|Assert.Equal(\"Test method 'Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing' has multiple [Fact]-derived attributes\", msg.Messages.Single());|}|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "SendOutputMessages",
        "body": "{|var msgs = Run(typeof(ClassUnderTest));|var idxOfTestPassed = msgs.FindIndex(msg => msg is ITestPassed);|Assert.True(idxOfTestPassed >= 0, \"Test should have passed\");|var idxOfFirstTestOutput = msgs.FindIndex(msg => msg is ITestOutput);|Assert.True(idxOfFirstTestOutput >= 0, \"Test should have output\");|Assert.True(idxOfFirstTestOutput < idxOfTestPassed, \"Test output messages should precede test result\");|Assert.Collection(msgs.OfType<ITestOutput>(),|msg =>|{|var outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);|Assert.Equal(\"This is output in the constructor\" + Environment.NewLine, outputMessage.Output);|},|msg =>|{|var outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);|Assert.Equal(\"This is test output\" + Environment.NewLine, outputMessage.Output);|},|msg =>|{|var outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);|Assert.Equal(\"This is output in Dispose\" + Environment.NewLine, outputMessage.Output);|}|);|}"
      },
      {
        "name": "TestMethod",
        "body": "{|output.WriteLine(\"This is test output\");|}"
      },
      {
        "name": "AsyncLifetimeAcceptanceTest",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithAsyncLifetime));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");|}"
      },
      {
        "name": "TheTest",
        "body": "{|output.WriteLine(\"Run Test\");|}"
      },
      {
        "name": "ThrowingConstructor",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingCtor));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\");|}"
      },
      {
        "name": "ThrowingInitializeAsync",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingInitializeAsync));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Dispose\");|}"
      },
      {
        "name": "ThrowingDisposeAsync",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingDisposeAsync));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");|}"
      },
      {
        "name": "FailingTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_FailingTest));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{|Assert.True(false);|}"
      },
      {
        "name": "TestMethod",
        "body": "{|Assert.True(false);|}"
      }
    ]
  },
  {
    "file": "TraitHelperTests.cs",
    "methods": [
      {
        "name": "MethodWithNoTraits_ReturnsEmptyList",
        "body": "{|var method = typeof(ClassUnderTest).GetMethod(\"NoTraits\");|var traits = TraitHelper.GetTraits(method);|Assert.Empty(traits);|}"
      },
      {
        "name": "MethodWithTraitAttribute_ReturnsTrait",
        "body": "{|var method = typeof(ClassUnderTest).GetMethod(\"Trait\");|var traits = TraitHelper.GetTraits(method);|var value = Assert.Single(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase));|Assert.Equal(\"foo = bar\", value);|}"
      },
      {
        "name": "MethodWithCustomTraitAttribute_ReturnsTraitValues",
        "body": "{|var method = typeof(ClassUnderTest).GetMethod(\"CustomTrait\");|var traits = TraitHelper.GetTraits(method);|Assert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),|value => Assert.Equal(\"Baz = 2112\", value),|value => Assert.Equal(\"Foo = Biff\", value)|);|}"
      },
      {
        "name": "CombinesMultipleTraitSources",
        "body": "{|var method = typeof(ClassUnderTest).GetMethod(\"MultipleTraits\");|var traits = TraitHelper.GetTraits(method);|Assert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),|value => Assert.Equal(\"Baz = 2112\", value),|value => Assert.Equal(\"foo = bar\", value),|value => Assert.Equal(\"Foo = Biff\", value),|value => Assert.Equal(\"Hello = World\", value)|);|}"
      },
      {
        "name": "MethodWithInheritedCustomTraitAttribute_ReturnsTraitValues",
        "body": "{|var method = typeof(ClassUnderTest).GetMethod(\"InheritedTrait\");|var traits = TraitHelper.GetTraits(method);|Assert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),|value => Assert.Equal(\"Baz = 2112\", value),|value => Assert.Equal(\"Foo = Biff\", value)|);|}"
      },
      {
        "name": "CombinesInheritedMultipleTraitSources",
        "body": "{|var method = typeof(ClassUnderTest).GetMethod(\"InheritedMultipleTraits\");|var traits = TraitHelper.GetTraits(method);|Assert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),|value => Assert.Equal(\"Baz = 2112\", value),|value => Assert.Equal(\"foo = bar\", value),|value => Assert.Equal(\"Foo = Biff\", value),|value => Assert.Equal(\"Hello = World\", value)|);|}"
      }
    ]
  },
  {
    "file": "ReflectionAbstractionExtensionsTests.cs",
    "methods": [
      {
        "name": "WhenUsingReflectionMethodInfo_ReturnsExistingMethodInfo",
        "body": "{|var methodInfo = Mocks.ReflectionMethodInfo<ToRuntimeMethod>(\"WhenUsingReflectionMethodInfo_ReturnsExistingMethodInfo\");|var result = methodInfo.ToRuntimeMethod();|Assert.NotNull(result);|Assert.Same(methodInfo.MethodInfo, result);|}"
      },
      {
        "name": "WhenUsingNonReflectionMethodInfo_MethodExists_ReturnsMethodInfo",
        "body": "{|var typeInfo = Mocks.TypeInfo(\"ReflectionAbstractionExtensionsTests+ToRuntimeMethod\", assemblyFileName: \"xunit.v2.tests.dll\");|var methodInfo = Mocks.MethodInfo(\"WhenUsingNonReflectionMethodInfo_MethodExists_ReturnsMethodInfo\", isStatic: true, type: typeInfo);|var result = methodInfo.ToRuntimeMethod();|Assert.NotNull(result);|Assert.Same(typeof(ToRuntimeMethod).GetMethod(\"WhenUsingNonReflectionMethodInfo_MethodExists_ReturnsMethodInfo\"), result);|}"
      },
      {
        "name": "WhenUsingNonReflectionMethodInfo_MethodDoesNotExist_ReturnsNull",
        "body": "{|var typeInfo = Mocks.TypeInfo(\"ReflectionAbstractionExtensionsTests+ToRuntimeMethod\", assemblyFileName: \"xunit.v2.tests.dll\");|var methodInfo = Mocks.MethodInfo(\"UnknownMethod\", isStatic: true, type: typeInfo);|var result = methodInfo.ToRuntimeMethod();|Assert.Null(result);|}"
      },
      {
        "name": "WhenUsingReflectionTypeInfo_ReturnsExistingType",
        "body": "{|var typeInfo = Mocks.ReflectionTypeInfo<ToRuntimeType>();|var result = typeInfo.ToRuntimeType();|Assert.NotNull(result);|Assert.Same(typeInfo.Type, result);|}"
      },
      {
        "name": "WhenUsingNonReflectionTypeInfo_TypeExists_ReturnsType",
        "body": "{|var typeInfo = Mocks.TypeInfo(\"ReflectionAbstractionExtensionsTests+ToRuntimeType\", assemblyFileName: \"xunit.v2.tests.dll\");|var result = typeInfo.ToRuntimeType();|Assert.NotNull(result);|Assert.Same(typeof(ToRuntimeType), result);|}"
      },
      {
        "name": "WhenUsingNonReflectionTypeInfo_TypeDoesNotExist_ReturnsNull",
        "body": "{|var typeInfo = Mocks.TypeInfo(\"UnknownType\", assemblyFileName: \"xunit.v2.tests.dll\");|var result = typeInfo.ToRuntimeType();|Assert.Null(result);|}"
      }
    ]
  },
  {
    "file": "DefaultTestCaseOrdererTests.cs",
    "methods": [
      {
        "name": "OrderIsStable",
        "body": "{|var orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());|var result1 = orderer.OrderTestCases(TestCases);|var result2 = orderer.OrderTestCases(TestCases);|var result3 = orderer.OrderTestCases(TestCases);|Assert.Equal(result1, result2);|Assert.Equal(result2, result3);|}"
      },
      {
        "name": "OrderIsUnpredictable",
        "body": "{|var orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());|var result = orderer.OrderTestCases(TestCases);|Assert.NotEqual(TestCases, result);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test4",
        "body": "{ }"
      },
      {
        "name": "Test5",
        "body": "{ }"
      },
      {
        "name": "Test6",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ExtensibilityPointFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultTestCollectionFactoryIsCollectionPerClass",
        "body": "{|var assembly = Mocks.TestAssembly();|var result = ExtensibilityPointFactory.GetXunitTestCollectionFactory(spy, (IAttributeInfo)null, assembly);|Assert.IsType<CollectionPerClassTestCollectionFactory>(result);|}"
      },
      {
        "name": "UserCanChooseCustomCollectionFactory",
        "body": "{|var factoryType = typeof(MyTestCollectionFactory);|var attr = Mocks.CollectionBehaviorAttribute(factoryType.FullName, factoryType.Assembly.FullName);|var assembly = Mocks.TestAssembly();|var result = ExtensibilityPointFactory.GetXunitTestCollectionFactory(spy, attr, assembly);|var myFactory = Assert.IsType<MyTestCollectionFactory>(result);|Assert.Same(assembly, myFactory.Assembly);|}"
      }
    ]
  },
  {
    "file": "CollectionPerAssemblyTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "ReturnsDefaultTestCollectionForUndecoratedTestClass",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\");|var type2 = Mocks.TypeInfo(\"type2\");|var assemblyFileName = Path.DirectorySeparatorChar == '/' ? \"/foo/bar.dll\" : @\"C:\\Foo\\bar.dll\";|var assembly = Mocks.TestAssembly(assemblyFileName);|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"Test collection for bar.dll\", result1.DisplayName);|}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{|var attr = Mocks.CollectionAttribute(\"My Collection\");|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"My Collection\", result1.DisplayName);|}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.NotSame(result1, result2);|Assert.Equal(\"Collection 1\", result1.DisplayName);|Assert.Equal(\"Collection 2\", result2.DisplayName);|}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result = factory.Get(testType);|Assert.Same(collectionDefinitionType, result.CollectionDefinition);|}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var spy = SpyMessageSink.Create(messages: messages);|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, spy);|factory.Get(testType);|var msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));|Assert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);|}"
      }
    ]
  },
  {
    "file": "CollectionPerClassTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultCollectionBehaviorIsCollectionPerClass",
        "body": "{|var type1 = Mocks.TypeInfo(\"FullyQualified.Type.Number1\");|var type2 = Mocks.TypeInfo(\"FullyQualified.Type.Number2\");|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.NotSame(result1, result2);|Assert.Equal(\"Test collection for FullyQualified.Type.Number1\", result1.DisplayName);|Assert.Equal(\"Test collection for FullyQualified.Type.Number2\", result2.DisplayName);|Assert.Null(result1.CollectionDefinition);|Assert.Null(result2.CollectionDefinition);|}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{|var attr = Mocks.CollectionAttribute(\"My Collection\");|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"My Collection\", result1.DisplayName);|}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.NotSame(result1, result2);|Assert.Equal(\"Collection 1\", result1.DisplayName);|Assert.Equal(\"Collection 2\", result2.DisplayName);|}"
      },
      {
        "name": "ExplicitlySpecifyingACollectionWithTheSameNameAsAnImplicitWorks",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\");|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Test collection for type1\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"Test collection for type1\", result1.DisplayName);|}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result = factory.Get(testType);|Assert.Same(collectionDefinitionType, result.CollectionDefinition);|}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var spy = SpyMessageSink.Create(messages: messages);|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });|var factory = new CollectionPerClassTestCollectionFactory(assembly, spy);|factory.Get(testType);|var msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));|Assert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);|}"
      }
    ]
  },
  {
    "file": "FactDiscovererTests.cs",
    "methods": [
      {
        "name": "FactWithoutParameters_ReturnsTestCaseThatRunsFact",
        "body": "{|var discoverer = TestableFactDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithNoParameters\");|var testCases = discoverer.Discover(options, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|await testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);|Assert.Single(messageBus.Messages.OfType<ITestPassed>());|}"
      },
      {
        "name": "FactWithParameters_ReturnsTestCaseWhichThrows",
        "body": "{|var discoverer = TestableFactDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithParameters\");|var testCases = discoverer.Discover(options, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|await testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());|Assert.Equal(\"[Fact] methods are not allowed to have parameters. Did you mean to use [Theory]?\", failed.Messages.Single());|}"
      },
      {
        "name": "GenericFact_ReturnsTestCaseWhichThrows",
        "body": "{|var discoverer = TestableFactDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"GenericFact\");|var testCases = discoverer.Discover(options, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|await testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());|Assert.Equal(\"[Fact] methods are not allowed to be generic.\", failed.Messages.Single());|}"
      },
      {
        "name": "FactWithNoParameters",
        "body": "{ }"
      },
      {
        "name": "FactWithParameters",
        "body": "{ }"
      },
      {
        "name": "GenericFact",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ExecutionErrorTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var testCase = Mocks.ExecutionErrorTestCase(\"This is my error message\");|var runner = new ExecutionErrorTestCaseRunner(testCase, messageBus, aggregator, tokenSource);|var result = await runner.RunAsync();|Assert.Equal(1, result.Total);|Assert.Equal(0m, result.Time);|Assert.Collection(messageBus.Messages,|msg =>|{|var testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);|Assert.Same(testCase, testCaseStarting.TestCase);|},|msg =>|{|var testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);|Assert.Same(testCase, testStarting.TestCase);|},|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, failed.TestCollection);|Assert.Same(testCase, failed.TestCase);|Assert.Equal(0m, failed.ExecutionTime);|Assert.Empty(failed.Output);|var exceptionType = Assert.Single(failed.ExceptionTypes);|Assert.Equal(\"System.InvalidOperationException\", exceptionType);|var type = Assert.Single(failed.Messages);|Assert.Equal(\"This is my error message\", type);|},|msg =>|{|var testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);|Assert.Same(testCase, testFinished.TestCase);|Assert.Equal(0m, testFinished.ExecutionTime);|Assert.Empty(testFinished.Output);|},|msg =>|{|var testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);|Assert.Same(testCase, testCaseFinished.TestCase);|Assert.Equal(0m, testCaseFinished.ExecutionTime);|Assert.Equal(1, testCaseFinished.TestsRun);|Assert.Equal(1, testCaseFinished.TestsFailed);|Assert.Equal(0, testCaseFinished.TestsSkipped);|}|);|}"
      }
    ]
  },
  {
    "file": "TestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "DefaultMessageBus",
        "body": "{|var runner = TestableTestAssemblyRunner.Create();|var messageBus = runner.CreateMessageBus_Public();|Assert.IsType<MessageBus>(messageBus);|}"
      },
      {
        "name": "SyncMessageBusOption",
        "body": "{|var executionOptions = TestFrameworkOptions.ForExecution();|executionOptions.SetSynchronousMessageReporting(true);|var runner = TestableTestAssemblyRunner.Create(executionOptions: executionOptions);|var messageBus = runner.CreateMessageBus_Public();|Assert.IsType<SynchronousMessageBus>(messageBus);|}"
      },
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messages = new List<IMessageSinkMessage>();|var messageSink = SpyMessageSink.Create(messages: messages);|var runner = TestableTestAssemblyRunner.Create(messageSink, summary);|var thisAssembly = Assembly.GetExecutingAssembly();|var thisAppDomain = AppDomain.CurrentDomain;|var result = await runner.RunAsync();|Assert.Equal(4, result.Total);|Assert.Equal(2, result.Failed);|Assert.Equal(1, result.Skipped);|Assert.NotEqual(21.12m, result.Time); // Uses clock time, not result time|Assert.Collection(messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestAssemblyStarting>(msg);|#if NETFRAMEWORK|Assert.Equal(thisAssembly.GetLocalCodeBase(), starting.TestAssembly.Assembly.AssemblyPath);|Assert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, starting.TestAssembly.ConfigFileName);|#endif|Assert.InRange(starting.StartTime, DateTime.Now.AddMinutes(-15), DateTime.Now);|Assert.Equal(\"The test framework environment\", starting.TestEnvironment);|Assert.Equal(\"The test framework display name\", starting.TestFrameworkDisplayName);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(msg);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|Assert.Equal(result.Time, finished.ExecutionTime);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestAssemblyStarting_DoesNotQueueTestAssemblyFinished_DoesNotRunTestCollections",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageSink = Substitute.For<IMessageSink>();|messageSink.OnMessage(null)| .ReturnsForAnyArgs(callInfo =>| {| var msg = callInfo.Arg<IMessageSinkMessage>();| messages.Add(msg);| if (msg is ITestAssemblyStarting)| throw new InvalidOperationException();| return true;| });|var runner = TestableTestAssemblyRunner.Create(messageSink);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestAssemblyStarting>(starting);|Assert.Empty(runner.CollectionsRun);|}"
      },
      {
        "name": "FailureInAfterTestAssemblyStarting_GivesErroredAggregatorToTestCollectionRunner_NoCleanupFailureMessage",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageSink = SpyMessageSink.Create(messages: messages);|var runner = TestableTestAssemblyRunner.Create(messageSink);|var ex = new DivideByZeroException();|runner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestCollectionAsync_AggregatorResult);|Assert.Empty(messages.OfType<ITestAssemblyCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestAssemblyFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestAssemblyStarting",
        "body": "{|var thisAssembly = Assembly.GetExecutingAssembly();|var thisAppDomain = AppDomain.CurrentDomain;|var messages = new List<IMessageSinkMessage>();|var messageSink = SpyMessageSink.Create(messages: messages);|var testCases = new[] { Mocks.TestCase() };|var runner = TestableTestAssemblyRunner.Create(messageSink, testCases: testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestAssemblyFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messages.OfType<ITestAssemblyCleanupFailure>());|#if NETFRAMEWORK|Assert.Equal(thisAssembly.GetLocalCodeBase(), cleanupFailure.TestAssembly.Assembly.AssemblyPath);|Assert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, cleanupFailure.TestAssembly.ConfigFileName);|#endif|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestAssemblyStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{|var messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyStarting));|var runner = TestableTestAssemblyRunner.Create(messageSink);|await runner.RunAsync();|Assert.False(runner.AfterTestAssemblyStarting_Called);|Assert.False(runner.BeforeTestAssemblyFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestAssemblyFinished_CallsCallExtensibilityCallbacks",
        "body": "{|var messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyFinished));|var runner = TestableTestAssemblyRunner.Create(messageSink);|await runner.RunAsync();|Assert.True(runner.AfterTestAssemblyStarting_Called);|Assert.True(runner.BeforeTestAssemblyFinished_Called);|}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{|var collection1 = Mocks.TestCollection(displayName: \"1\");|var testCase1a = Mocks.TestCase(collection1);|var testCase1b = Mocks.TestCase(collection1);|var collection2 = Mocks.TestCollection(displayName: \"2\");|var testCase2a = Mocks.TestCase(collection2);|var testCase2b = Mocks.TestCase(collection2);|var runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1a, testCase2a, testCase2b, testCase1b });|await runner.RunAsync();|Assert.Collection(runner.CollectionsRun.OrderBy(c => c.Item1.DisplayName),|tuple =>|{|Assert.Same(collection1, tuple.Item1);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(testCase1a, testCase),|testCase => Assert.Same(testCase1b, testCase)|);|},|tuple =>|{|Assert.Same(collection2, tuple.Item1);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(testCase2a, testCase),|testCase => Assert.Same(testCase2b, testCase)|);|}|);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningCollections",
        "body": "{|var collection1 = Mocks.TestCollection();|var testCase1 = Mocks.TestCase(collection1);|var collection2 = Mocks.TestCollection();|var testCase2 = Mocks.TestCase(collection2);|var runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1, testCase2 }, cancelInRunTestCollectionAsync: true);|await runner.RunAsync();|Assert.Single(runner.CollectionsRun);|}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{|var runner = TestableTestAssemblyRunner.Create();|Assert.IsType<DefaultTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{|var runner = TestableTestAssemblyRunner.Create();|Assert.IsType<DefaultTestCollectionOrderer>(runner.TestCollectionOrderer);|}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var collection1 = Mocks.TestCollection(displayName: \"AAA\");|var testCase1 = Mocks.TestCase(collection1);|var collection2 = Mocks.TestCollection(displayName: \"ZZZZ\");|var testCase2 = Mocks.TestCase(collection2);|var collection3 = Mocks.TestCollection(displayName: \"MM\");|var testCase3 = Mocks.TestCase(collection3);|var testCases = new[] { testCase1, testCase2, testCase3 };|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableTestAssemblyRunner.Create(testCases: testCases, executionMessageSink: executionSink);|runner.TestCollectionOrderer = new ThrowingOrderer();|await runner.RunAsync();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Test collection orderer 'TestAssemblyRunnerTests+TestCollectionOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);|Assert.Empty(runner.CollectionsRun);|}"
      }
    ]
  },
  {
    "file": "TestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var runner = TestableTestCaseRunner.Create(messageBus, result: summary);|var result = await runner.RunAsync();|Assert.Same(result, summary);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);|Assert.Same(runner.TestCase, testCaseStarting.TestCase);|},|msg =>|{|var testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);|Assert.Same(runner.TestCase, testCaseFinished.TestCase);|Assert.Equal(21.12m, testCaseFinished.ExecutionTime);|Assert.Equal(4, testCaseFinished.TestsRun);|Assert.Equal(2, testCaseFinished.TestsFailed);|Assert.Equal(1, testCaseFinished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestCaseStarting_DoesNotQueueTestCaseFinished_DoesNotRunTests",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestCaseStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestCaseRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestCaseStarting>(starting);|Assert.False(runner.RunTestAsync_Called);|}"
      },
      {
        "name": "RunTestAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestCaseRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestCaseStarting_GivesErroredAggregatorToTestRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestCaseRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestCaseFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCaseStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");|var runner = TestableTestCaseRunner.Create(messageBus, testCase);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCaseCleanupFailure>());|Assert.Same(testCase, cleanupFailure.TestCase);|Assert.Equal(new[] { testCase }, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestCaseStarting_DoesNotCallExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCaseStarting));|var runner = TestableTestCaseRunner.Create(messageBus);|await runner.RunAsync();|Assert.False(runner.AfterTestCaseStarting_Called);|Assert.False(runner.BeforeTestCaseFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCaseFinished_CallsExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCaseFinished));|var runner = TestableTestCaseRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.AfterTestCaseStarting_Called);|Assert.True(runner.BeforeTestCaseFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCaseCleanupFailure));|var runner = TestableTestCaseRunner.Create(messageBus);|runner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      }
    ]
  },
  {
    "file": "TestClassRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var runner = TestableTestClassRunner.Create(messageBus, new[] { testCase }, result: summary);|var result = await runner.RunAsync();|Assert.Equal(result.Total, summary.Total);|Assert.Equal(result.Failed, summary.Failed);|Assert.Equal(result.Skipped, summary.Skipped);|Assert.Equal(result.Time, summary.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestClassStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Equal(\"TestClassRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestClassFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Equal(\"TestClassRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);|Assert.Equal(21.12m, finished.ExecutionTime);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestClassStarting_DoesNotQueueTestClassFinished_DoesNotRunTestMethods",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus.QueueMessage(null)| .ReturnsForAnyArgs(callInfo =>| {| var msg = callInfo.Arg<IMessageSinkMessage>();| messages.Add(msg);| if (msg is ITestClassStarting)| throw new InvalidOperationException();| return true;| });|var runner = TestableTestClassRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestClassStarting>(starting);|Assert.Empty(runner.MethodsRun);|}"
      },
      {
        "name": "RunTestMethodAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestClassRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestClassStarting_GivesErroredAggregatorToTestMethodRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestClassRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestClassFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestClassStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };|var runner = TestableTestClassRunner.Create(messageBus, testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestClassCleanupFailure>());|Assert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestClassStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestClassStarting));|var runner = TestableTestClassRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestClassStarting_Called);|Assert.False(runner.BeforeTestClassFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestClassFinished_CallsExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestClassFinished));|var runner = TestableTestClassRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.True(runner.AfterTestClassStarting_Called);|Assert.True(runner.BeforeTestClassFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestClassCleanupFailure));|var runner = TestableTestClassRunner.Create(messageBus);|runner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      },
      {
        "name": "TestsAreGroupedByMethod",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, other2, passing2 });|await runner.RunAsync();|Assert.Collection(runner.MethodsRun,|tuple =>|{|Assert.Equal(\"Passing\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing1, testCase),|testCase => Assert.Same(passing2, testCase)|);|},|tuple =>|{|Assert.Equal(\"Other\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(other1, testCase),|testCase => Assert.Same(other2, testCase)|);|}|);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{|var passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestClassRunner.Create(testCases: new[] { passing, other }, cancelInRunTestMethodAsync: true);|await runner.RunAsync();|var tuple = Assert.Single(runner.MethodsRun);|Assert.Equal(\"Passing\", tuple.Item1.Name);|}"
      },
      {
        "name": "TestsOrdererIsUsedToDetermineRunOrder",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, passing2, other2 }, orderer: new MockTestCaseOrderer(reverse: true));|await runner.RunAsync();|Assert.Collection(runner.MethodsRun,|tuple =>|{|Assert.Equal(\"Other\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(other2, testCase),|testCase => Assert.Same(other1, testCase)|);|},|tuple =>|{|Assert.Equal(\"Passing\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing2, testCase),|testCase => Assert.Same(passing1, testCase)|);|}|);|}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var messageBus = new SpyMessageBus();|var runner = TestableTestClassRunner.Create(messageBus, [passing1, other1, passing2, other2], new ThrowingOrderer());|await runner.RunAsync();|var errorMessage = Assert.Single(messageBus.Messages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Test case orderer 'TestClassRunnerTests+TestCaseOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);|Assert.Empty(runner.MethodsRun);|}"
      },
      {
        "name": "TestClassMustHaveParameterlessConstructor",
        "body": "{|var test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");|var runner = TestableTestClassRunner.Create(testCases: new[] { test });|await runner.RunAsync();|var tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"A test class must have a parameterless constructor.\", tcex.Message);|}"
      },
      {
        "name": "ConstructorWithMissingArguments",
        "body": "{|var test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");|var constructor = typeof(ClassWithConstructor).GetConstructors().Single();|var args = new object[] { \"Hello, world!\" };|var runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);|await runner.RunAsync();|var tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"The following constructor parameters did not have matching arguments: Int32 x, Decimal z\", tcex.Message);|}"
      },
      {
        "name": "ConstructorWithMatchingArguments",
        "body": "{|var test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");|var constructor = typeof(ClassWithConstructor).GetConstructors().Single();|var args = new object[] { \"Hello, world!\", 21.12m, 42, DateTime.Now };|var runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);|await runner.RunAsync();|var tuple = Assert.Single(runner.MethodsRun);|Assert.Collection(tuple.Item3,|arg => Assert.Equal(42, arg),|arg => Assert.Equal(\"Hello, world!\", arg),|arg => Assert.Equal(21.12m, arg)|);|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var runner = TestableTestCollectionRunner.Create(messageBus, new[] { testCase }, summary);|var result = await runner.RunAsync();|Assert.Equal(result.Total, summary.Total);|Assert.Equal(result.Failed, summary.Failed);|Assert.Equal(result.Skipped, summary.Skipped);|Assert.Equal(result.Time, summary.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestCollectionStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestCollectionFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Equal(21.12m, finished.ExecutionTime);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestCollectionStarting_DoesNotQueueTestCollectionFinished_DoesNotRunTestClasses",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestCollectionStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestCollectionRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestCollectionStarting>(starting);|Assert.Empty(runner.ClassesRun);|}"
      },
      {
        "name": "RunTestClassAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestCollectionRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestClassAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestCollectionStarting_GivesErroredAggregatorToTestClassRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestCollectionRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestClassAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestCollectionFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCollectionStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };|var runner = TestableTestCollectionRunner.Create(messageBus, testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());|Assert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestCollectionStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionStarting));|var runner = TestableTestCollectionRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestCollectionStarting_Called);|Assert.False(runner.BeforeTestCollectionFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCollectionFinished_CallsExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionFinished));|var runner = TestableTestCollectionRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.True(runner.AfterTestCollectionStarting_Called);|Assert.True(runner.BeforeTestCollectionFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCollectionCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionCleanupFailure));|var runner = TestableTestCollectionRunner.Create(messageBus);|runner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");|var other2 = Mocks.TestCase<ClassUnderTest2>(\"Other\");|var runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2, other2, other1 });|await runner.RunAsync();|Assert.Collection(runner.ClassesRun,|tuple =>|{|Assert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing1, testCase),|testCase => Assert.Same(other1, testCase)|);|},|tuple =>|{|Assert.Equal(\"TestCollectionRunnerTests+ClassUnderTest2\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing2, testCase),|testCase => Assert.Same(other2, testCase)|);|}|);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningClasses",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");|var runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2 }, cancelInRunTestClassAsync: true);|await runner.RunAsync();|var tuple = Assert.Single(runner.ClassesRun);|Assert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestInvokerTests.cs",
    "methods": [
      {
        "name": "Messages_StaticTestMethod",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"StaticPassing\", messageBus);|await invoker.RunAsync();|Assert.Empty(messageBus.Messages);|Assert.True(invoker.BeforeTestMethodInvoked_Called);|Assert.True(invoker.AfterTestMethodInvoked_Called);|}"
      },
      {
        "name": "Messages_NonStaticTestMethod_NoDispose",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, \"Display Name\");|await invoker.RunAsync();|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Same(invoker.TestCase, starting.TestCase);|Assert.Equal(\"Display Name\", starting.Test.DisplayName);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Same(invoker.TestCase, finished.TestCase);|Assert.Equal(\"Display Name\", finished.Test.DisplayName);|}|);|}"
      },
      {
        "name": "Messages_NonStaticTestMethod_WithDispose",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<DisposableClass>(\"Passing\", messageBus, \"Display Name\");|await invoker.RunAsync();|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg =>|{|var starting = Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Same(invoker.TestCase, starting.TestCase);|Assert.Equal(\"Display Name\", starting.Test.DisplayName);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Same(invoker.TestCase, finished.TestCase);|Assert.Equal(\"Display Name\", finished.Test.DisplayName);|}|);|}"
      },
      {
        "name": "Passing",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus);|var result = await invoker.RunAsync();|Assert.NotEqual(0m, result);|Assert.Null(invoker.Aggregator.ToException());|}"
      },
      {
        "name": "Failing",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);|var result = await invoker.RunAsync();|Assert.NotEqual(0m, result);|Assert.IsType<TrueException>(invoker.Aggregator.ToException());|}"
      },
      {
        "name": "TooManyParameterValues",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, testMethodArguments: new object[] { 42 });|await invoker.RunAsync();|var ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());|Assert.Equal(\"The test method expected 0 parameter values, but 1 parameter value was provided.\", ex.Message);|}"
      },
      {
        "name": "NotEnoughParameterValues",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"FactWithParameter\", messageBus);|await invoker.RunAsync();|var ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());|Assert.Equal(\"The test method expected 1 parameter value, but 0 parameter values were provided.\", ex.Message);|}"
      },
      {
        "name": "CancellationRequested_DoesNotInvokeTestMethod",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);|invoker.TokenSource.Cancel();|var result = await invoker.RunAsync();|Assert.Equal(0m, result);|Assert.Null(invoker.Aggregator.ToException());|Assert.False(invoker.BeforeTestMethodInvoked_Called);|Assert.False(invoker.AfterTestMethodInvoked_Called);|}"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "{|Assert.True(false);|}"
      },
      {
        "name": "FactWithParameter",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestMethodRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var runner = TestableTestMethodRunner.Create(messageBus, new[] { testCase }, result: summary);|var result = await runner.RunAsync();|Assert.Equal(result.Total, summary.Total);|Assert.Equal(result.Failed, summary.Failed);|Assert.Equal(result.Skipped, summary.Skipped);|Assert.Equal(result.Time, summary.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestMethodStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);|Assert.Equal(\"Passing\", starting.TestMethod.Method.Name);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestMethodFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);|Assert.Equal(\"Passing\", finished.TestMethod.Method.Name);|Assert.Equal(21.12m, finished.ExecutionTime);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestMethodStarting_DoesNotQueueTestMethodFinished_DoesNotRunTestCases",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestMethodStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestMethodRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestMethodStarting>(starting);|Assert.Empty(runner.TestCasesRun);|}"
      },
      {
        "name": "RunTestCaseAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestMethodRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestMethodStarting_GivesErroredAggregatorToTestCaseRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestMethodRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestMethodFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestMethodStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };|var runner = TestableTestMethodRunner.Create(messageBus, testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestMethodCleanupFailure>());|Assert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestMethodStarting_DoesNotCallExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestMethodStarting));|var runner = TestableTestMethodRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestMethodStarting_Called);|Assert.False(runner.BeforeTestMethodFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestMethodFinished_CallsExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestMethodFinished));|var runner = TestableTestMethodRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.True(runner.AfterTestMethodStarting_Called);|Assert.True(runner.BeforeTestMethodFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestMethodCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestMethodCleanupFailure));|var runner = TestableTestMethodRunner.Create(messageBus);|runner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{|var passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestMethodRunner.Create(testCases: new[] { passing, other }, cancelInRunTestCaseAsync: true);|await runner.RunAsync();|var testCase = Assert.Single(runner.TestCasesRun);|Assert.Same(passing, testCase);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);|var result = await runner.RunAsync();|Assert.Equal(21.12m, result.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);|Assert.Same(runner.TestCase, testStarting.TestCase);|Assert.Equal(\"Display Name\", testStarting.Test.DisplayName);|},|msg => { }, // Pass/fail/skip, will be tested elsewhere|msg =>|{|var testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);|Assert.Same(runner.TestCase, testFinished.TestCase);|Assert.Equal(\"Display Name\", testFinished.Test.DisplayName);|Assert.Equal(21.12m, testFinished.ExecutionTime);|Assert.Empty(testFinished.Output);|}|);|}"
      },
      {
        "name": "Passing",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);|var result = await runner.RunAsync();|// Direct run summary|Assert.Equal(1, result.Total);|Assert.Equal(0, result.Failed);|Assert.Equal(0, result.Skipped);|Assert.Equal(21.12m, result.Time);|// Pass message|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, passed.TestCollection);|Assert.Same(runner.TestCase, passed.TestCase);|Assert.Equal(\"Display Name\", passed.Test.DisplayName);|Assert.Equal(21.12m, passed.ExecutionTime);|Assert.Empty(passed.Output);|}"
      },
      {
        "name": "Failing",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m, lambda: () => Assert.True(false));|var result = await runner.RunAsync();|// Direct run summary|Assert.Equal(1, result.Total);|Assert.Equal(1, result.Failed);|Assert.Equal(0, result.Skipped);|Assert.Equal(21.12m, result.Time);|// Fail message|var failed = messageBus.Messages.OfType<ITestFailed>().Single();|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);|Assert.Same(runner.TestCase, failed.TestCase);|Assert.Equal(\"Display Name\", failed.Test.DisplayName);|Assert.Equal(21.12m, failed.ExecutionTime);|Assert.Empty(failed.Output);|Assert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());|}"
      },
      {
        "name": "Skipping",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", skipReason: \"Please don't run me\", runTime: 21.12m, lambda: () => Assert.True(false));|var result = await runner.RunAsync();|// Direct run summary|Assert.Equal(1, result.Total);|Assert.Equal(0, result.Failed);|Assert.Equal(1, result.Skipped);|Assert.Equal(0m, result.Time);|// Skip message|var failed = messageBus.Messages.OfType<ITestSkipped>().Single();|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);|Assert.Same(runner.TestCase, failed.TestCase);|Assert.Equal(\"Display Name\", failed.Test.DisplayName);|Assert.Equal(0m, failed.ExecutionTime);|Assert.Empty(failed.Output);|Assert.Equal(\"Please don't run me\", failed.Reason);|}"
      },
      {
        "name": "Output",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, output: \"This is my text output\");|await runner.RunAsync();|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Equal(\"This is my text output\", passed.Output);|}"
      },
      {
        "name": "FailureInQueueOfTestStarting_DoesNotQueueTestFinished_DoesNotInvokeTest",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestStarting>(starting);|Assert.False(runner.InvokeTestAsync_Called);|}"
      },
      {
        "name": "WithPreSeededException_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());|Assert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestStarting_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());|Assert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");|var runner = TestableTestRunner.Create(messageBus, testCase);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCleanupFailure>());|Assert.Same(testCase, cleanupFailure.TestCase);|Assert.Equal(new[] { testCase }, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestStarting_DoesNotCallExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestStarting));|var runner = TestableTestRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestStarting_Called);|Assert.False(runner.BeforeTestFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCleanupFailure));|var runner = TestableTestRunner.Create(messageBus);|runner.BeforeTestFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      }
    ]
  },
  {
    "file": "XunitTestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "IsXunit",
        "body": "{|var runner = TestableXunitTestAssemblyRunner.Create();|var result = runner.GetTestFrameworkDisplayName();|Assert.StartsWith(\"xUnit.net \", result);|}"
      },
      {
        "name": "Default",
        "body": "{|var runner = TestableXunitTestAssemblyRunner.Create();|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith($\"[collection-per-class, parallel ({Environment.ProcessorCount} threads)]\", result);|}"
      },
      {
        "name": "Attribute_NonParallel",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, non-parallel]\", result);|}"
      },
      {
        "name": "Attribute_MaxThreads",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: 3);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);|}"
      },
      {
        "name": "Attribute_Unlimited",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: -1);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (unlimited threads)]\", result);|}"
      },
      {
        "name": "Attribute_CustomCollectionFactory",
        "body": "{|var factoryType = typeof(MyTestCollectionFactory);|var attr = Mocks.CollectionBehaviorAttribute(factoryType.FullName, factoryType.Assembly.FullName, disableTestParallelization: true);|var assembly = Mocks.TestAssembly(new[] { attr });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[My Factory, non-parallel]\", result);|}"
      },
      {
        "name": "TestOptions_NonParallel",
        "body": "{|var options = TestFrameworkOptions.ForExecution();|options.SetDisableParallelization(true);|var runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, non-parallel]\", result);|}"
      },
      {
        "name": "TestOptions_MaxThreads",
        "body": "{|var options = TestFrameworkOptions.ForExecution();|options.SetMaxParallelThreads(3);|var runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);|}"
      },
      {
        "name": "TestOptions_MaxThreads_Aggressive",
        "body": "{|var options = TestFrameworkOptions.ForExecution();|options.SetMaxParallelThreads(3);|options.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);|var runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads/aggressive)]\", result);|}"
      },
      {
        "name": "TestOptionsOverrideAttribute",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true, maxParallelThreads: 127);|var options = TestFrameworkOptions.ForExecution();|options.SetDisableParallelization(false);|options.SetMaxParallelThreads(3);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);|}"
      },
      {
        "name": "Parallel_SingleThread_Aggressive",
        "body": "{|var passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");|var options = TestFrameworkOptions.ForExecution();|options.SetMaxParallelThreads(1);|options.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);|var runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);|await runner.RunAsync();|var threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();|Assert.Equal(threadIDs[0], threadIDs[1]);|}"
      },
      {
        "name": "NonParallel",
        "body": "{|var passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");|var options = TestFrameworkOptions.ForExecution();|options.SetDisableParallelization(true);|var runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);|await runner.RunAsync();|var threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();|Assert.Equal(threadIDs[0], threadIDs[1]);|}"
      },
      {
        "name": "CanSetTestCaseOrdererInAssemblyAttribute",
        "body": "{|var ordererAttribute = Mocks.TestCaseOrdererAttribute<MyTestCaseOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|runner.Initialize();|Assert.IsType<MyTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{|var ordererAttribute = Mocks.TestCaseOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test case orderer\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var ordererAttribute = Mocks.TestCaseOrdererAttribute<MyCtorThrowingTestCaseOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Assembly-level test case orderer 'XunitTestAssemblyRunnerTests+TestCaseOrderer+MyCtorThrowingTestCaseOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "CanSetTestCollectionOrdererInAssemblyAttribute",
        "body": "{|var ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyTestCollectionOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|runner.Initialize();|Assert.IsType<MyTestCollectionOrderer>(runner.TestCollectionOrderer);|}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{|var ordererAttribute = Mocks.TestCollectionOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test collection orderer\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyCtorThrowingTestCollectionOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Assembly-level test collection orderer 'XunitTestAssemblyRunnerTests+TestCollectionOrderer+MyCtorThrowingTestCollectionOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "Passing",
        "body": "{ Thread.Sleep(0); }"
      },
      {
        "name": "Other",
        "body": "{ Thread.Sleep(0); }"
      }
    ]
  },
  {
    "file": "XunitTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "BeforeAfterTestAttributesComeFromTestCollectionAndTestClassAndTestMethod",
        "body": "{|var collection = Mocks.TestCollection(definition: Reflector.Wrap(typeof(BeforeAfterCollection)));|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\", collection);|var messageBus = Substitute.For<IMessageBus>();|var aggregator = new ExceptionAggregator();|var tokenSource = new CancellationTokenSource();|var runner = new XunitTestCaseRunner(testCase, \"Display Name\", \"Skip Reason\", new object[0], new object[0], messageBus, aggregator, tokenSource);|Assert.Collection(runner.BeforeAfterAttributes,|attr => Assert.IsType<BeforeAfterOnCollection>(attr),|attr => Assert.IsType<BeforeAfterOnClass>(attr),|attr => Assert.IsType<BeforeAfterOnMethod>(attr)|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestClassRunnerTests.cs",
    "methods": [
      {
        "name": "ClassCannotBeDecoratedWithICollectionFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithCollectionFixture>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", runner.RunTestMethodAsync_AggregatorResult.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotHaveMoreThanOneConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithTwoConstructors>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"A test class may only define a single public constructor.\", runner.RunTestMethodAsync_AggregatorResult.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHavePublicAndPrivateConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithMixedConstructors>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHaveStaticConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithStaticConstructor>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CreatesFixturesFromClassAndCollection",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\", collection);|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Collection(runner.ClassFixtureMappings.OrderBy(mapping => mapping.Key.Name),|mapping => Assert.IsType<FixtureUnderTest>(mapping.Value),|mapping => Assert.IsType<object>(mapping.Value)|);|}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureUnderTest>().Single();|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassForFixtureAsyncLifetimeAndDisposableUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|var runnerSessionTask = runner.RunAsync();|await Task.Delay(500);|var fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();|Assert.True(fixtureUnderTest.DisposeAsyncCalled);|Assert.False(fixtureUnderTest.Disposed);|fixtureUnderTest.DisposeAsyncSignaler.SetResult(true);|await runnerSessionTask;|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "MultiplePublicConstructorsOnClassFixture_ReturnsError",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithMultiCtorClassFixture>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UnresolvedConstructorParameterOnClassFixture_ReturnsError",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);|}"
      },
      {
        "name": "CanInjectCollectionFixtureIntoClassFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");|var collectionFixture = new DependentCollectionFixture();|var runner = TestableXunitTestClassRunner.Create(testCase, collectionFixture);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|var classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithCollectionFixtureDependency>().Single();|Assert.Same(collectionFixture, classFixture.CollectionFixture);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CanInjectMessageSinkIntoClassFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|var classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithMessageSinkDependency>().Single();|Assert.NotNull(classFixture.MessageSink);|Assert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);|}"
      },
      {
        "name": "CanLogSinkMessageFromClassFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"ClassFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithUnknownTestCaseOrderer>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for class-level test case orderer on test class 'XunitTestClassRunnerTests+TestCaseOrderer+TestClassWithUnknownTestCaseOrderer'\", diagnosticMessage.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "PassesFixtureValuesToConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase, 42, \"Hello, world!\", 21.12m);|await runner.RunAsync();|var args = Assert.Single(runner.ConstructorArguments);|Assert.Collection(args,|arg => Assert.IsType<FixtureUnderTest>(arg),|arg => Assert.Equal(\"Hello, world!\", arg),|arg => Assert.Equal(21.12m, arg)|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "CreatesFixtures",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.Collection(runner.CollectionFixtureMappings.OrderBy(mapping => mapping.Key.Name),|mapping => Assert.IsType<FixtureUnderTest>(mapping.Value),|mapping => Assert.IsType<object>(mapping.Value)|);|}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureUnderTest>().Single();|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionForFixtureAsyncLifetimeAndDisposableUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|var runnerSessionTask = runner.RunAsync();|await Task.Delay(500);|var fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();|Assert.True(fixtureUnderTest.DisposeAsyncCalled);|Assert.False(fixtureUnderTest.Disposed);|fixtureUnderTest.DisposeAsyncSignaler.SetResult(true);|await runnerSessionTask;|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "MultiplePublicConstructorsOnCollectionFixture_ReturnsError",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionsWithMultiCtorCollectionFixture)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);|Assert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);|}"
      },
      {
        "name": "UnresolvedConstructorParameterOnCollectionFixture_ReturnsError",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithDependency)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);|Assert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);|}"
      },
      {
        "name": "CanInjectMessageSinkIntoCollectionFixture",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestClassAsync_AggregatorResult);|var classFixture = runner.CollectionFixtureMappings.Values.OfType<CollectionFixtureWithMessageSinkDependency>().Single();|Assert.NotNull(classFixture.MessageSink);|Assert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);|}"
      },
      {
        "name": "CanLogSinkMessageFromCollectionFixture",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"CollectionFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);|}"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithUnknownTestCaseOrderer)), \"TestCollectionDisplayName\");|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for collection-level test case orderer on test collection 'TestCollectionDisplayName'\", diagnosticMessage.Message);|}"
      }
    ]
  },
  {
    "file": "XunitTestInvokerTests.cs",
    "methods": [
      {
        "name": "Success",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest();|var invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute });|await invoker.RunAsync();|Assert.Null(invoker.Aggregator.ToException());|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg), // From TestInvoker|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg), // From TestInvoker|msg =>|{|var beforeStarting = Assert.IsAssignableFrom<IBeforeTestStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeStarting.TestCollection);|Assert.Same(invoker.TestCase, beforeStarting.TestCase);|Assert.Equal(\"Display Name\", beforeStarting.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", beforeStarting.AttributeName);|},|msg =>|{|var beforeFinished = Assert.IsAssignableFrom<IBeforeTestFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeFinished.TestCollection);|Assert.Same(invoker.TestCase, beforeFinished.TestCase);|Assert.Equal(\"Display Name\", beforeFinished.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", beforeFinished.AttributeName);|},|// Test method is invoked here; no directly observable message (tested below)|msg =>|{|var afterStarting = Assert.IsAssignableFrom<IAfterTestStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterStarting.TestCollection);|Assert.Same(invoker.TestCase, afterStarting.TestCase);|Assert.Equal(\"Display Name\", afterStarting.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", afterStarting.AttributeName);|},|msg =>|{|var afterFinished = Assert.IsAssignableFrom<IAfterTestFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterFinished.TestCollection);|Assert.Same(invoker.TestCase, afterFinished.TestCase);|Assert.Equal(\"Display Name\", afterFinished.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", afterFinished.AttributeName);|}|);|}"
      },
      {
        "name": "FailedBefore",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest { ThrowInBefore = true };|var invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));|await invoker.RunAsync();|Assert.IsType<SpyBeforeAfterTest.BeforeException>(invoker.Aggregator.ToException());|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg)|);|}"
      },
      {
        "name": "FailedAfter",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest { ThrowInAfter = true };|var invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));|await invoker.RunAsync();|var aggEx = Assert.IsType<AggregateException>(invoker.Aggregator.ToException());|Assert.Collection(aggEx.InnerExceptions,|ex => Assert.IsType<TrueException>(ex),|ex => Assert.IsType<SpyBeforeAfterTest.AfterException>(ex)|);|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),|msg => Assert.IsAssignableFrom<IAfterTestStarting>(msg),|msg => Assert.IsAssignableFrom<IAfterTestFinished>(msg)|);|}"
      },
      {
        "name": "Successful",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingBefore_First",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInBefore = true };|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|var msg = Assert.Single(messages);|Assert.Equal(\"Before #1\", msg);|}"
      },
      {
        "name": "FailingBefore_Second",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInBefore = true };|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|// No cleanup for #2, since it threw|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingAfter_First",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInAfter = true };|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingAfter_Second",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInAfter = true };|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingTest",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => { messages.Add(\"Test method invocation\"); Assert.True(false); }|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTheoryTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "EnumeratesDataAtRuntimeAndExecutesOneTestForEachDataRow",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableXunitTheoryTestCaseRunner.Create<ClassUnderTest>(\"TestWithData\", messageBus, \"Display Name\");|var summary = await runner.RunAsync();|Assert.NotEqual(0m, summary.Time);|Assert.Equal(2, summary.Total);|Assert.Equal(1, summary.Failed);|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Equal(\"Display Name(x: 42, y: 'a', z: \\\"Hello\\\")\", passed.Test.DisplayName);|var failed = messageBus.Messages.OfType<ITestFailed>().Single();|Assert.Equal(\"Display Name(x: 0, y: null, z: \\\"World!\\\")\", failed.Test.DisplayName);|}"
      },
      {
        "name": "DisposesArguments",
        "body": "{|ClassUnderTest.DataWasDisposed = false;|var messageBus = new SpyMessageBus();|var runner = TestableXunitTheoryTestCaseRunner.Create<ClassUnderTest>(\"TestWithDisposableData\", messageBus);|await runner.RunAsync();|Assert.True(ClassUnderTest.DataWasDisposed);|}"
      },
      {
        "name": "OnlySkipsDataRowsWithSkipReason",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableXunitTheoryTestCaseRunner.Create<ClassUnderTest>(\"TestWithSomeDataSkipped\", messageBus, \"Display Name\");|var summary = await runner.RunAsync();|Assert.NotEqual(0m, summary.Time);|Assert.Equal(4, summary.Total);|Assert.Equal(2, summary.Skipped);|Assert.Equal(1, summary.Failed);|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Equal($\"Display Name(x: 1, y: 'b', z: \\\"not skipped\\\")\", passed.Test.DisplayName);|var failed = messageBus.Messages.OfType<ITestFailed>().Single();|Assert.Equal(\"Display Name(x: 0, y: 'c', z: \\\"also not skipped\\\")\", failed.Test.DisplayName);|Assert.Contains(messageBus.Messages.OfType<ITestSkipped>(), skipped => skipped.Test.DisplayName == $\"Display Name(x: 42, y: 'a', z: \\\"Hello\\\")\");|Assert.Contains(messageBus.Messages.OfType<ITestSkipped>(), skipped => skipped.Test.DisplayName == \"Display Name(x: 0, y: null, z: \\\"World!\\\")\");|}"
      },
      {
        "name": "ThrowingToString",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableXunitTheoryTestCaseRunner.Create<ClassWithThrowingToString>(\"Test\", messageBus, \"Display Name\");|var summary = await runner.RunAsync();|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Equal(\"Display Name(c: TargetInvocationException was thrown formatting an object of type \\\"XunitTheoryTestCaseRunnerTests+ClassWithThrowingToString\\\")\", passed.Test.DisplayName);|}"
      },
      {
        "name": "ThrowingEnumerator",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableXunitTheoryTestCaseRunner.Create<ClassWithThrowingEnumerator>(\"Test\", messageBus, \"Display Name\");|var summary = await runner.RunAsync();|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Equal(\"Display Name(c: [ClassWithThrowingEnumerator { }])\", passed.Test.DisplayName);|}"
      }
    ]
  },
  {
    "file": "TestMethodTestCaseTests.cs",
    "methods": [
      {
        "name": "DefaultBehavior",
        "body": "{|var testMethod = Mocks.TestMethod(\"MockType\", \"MockMethod\");|var testCase = new TestableTestMethodTestCase(testMethod);|Assert.Equal(\"MockType.MockMethod\", testCase.DisplayName);|Assert.Null(testCase.SkipReason);|Assert.Empty(testCase.Traits);|}"
      },
      {
        "name": "DisposesArguments",
        "body": "{|var disposable1 = Substitute.For<IDisposable>();|var disposable2 = Substitute.For<IDisposable>();|var testMethod = Mocks.TestMethod();|var testCase = new TestableTestMethodTestCase(testMethod, new[] { disposable1, disposable2 });|testCase.Dispose();|disposable1.Received(1).Dispose();|disposable2.Received(1).Dispose();|}"
      },
      {
        "name": "CorrectNumberOfTestArguments",
        "body": "{|var param1 = Mocks.ParameterInfo(\"p1\");|var param2 = Mocks.ParameterInfo(\"p2\");|var param3 = Mocks.ParameterInfo(\"p3\");|var testMethod = Mocks.TestMethod(parameters: new[] { param1, param2, param3 });|var arguments = new object[] { 42, \"Hello, world!\", 'A' };|var testCase = new TestableTestMethodTestCase(testMethod, arguments);|Assert.Equal($\"{testMethod.TestClass.Class.Name}.{testMethod.Method.Name}(p1: 42, p2: \\\"Hello, world!\\\", p3: 'A')\", testCase.DisplayName);|}"
      },
      {
        "name": "NotEnoughTestArguments",
        "body": "{|var param = Mocks.ParameterInfo(\"p1\");|var testMethod = Mocks.TestMethod(parameters: new[] { param });|var testCase = new TestableTestMethodTestCase(testMethod, new object[0]);|Assert.Equal($\"{testMethod.TestClass.Class.Name}.{testMethod.Method.Name}(p1: ???)\", testCase.DisplayName);|}"
      },
      {
        "name": "UniqueID_NoArguments",
        "body": "{|var value = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\").UniqueID;|Assert.NotEmpty(value);|}"
      },
      {
        "name": "UniqueID_Arguments",
        "body": "{|var value42 = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\", new object[] { 42 }).UniqueID;|var valueHelloWorld = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\", new object[] { \"Hello, world!\" }).UniqueID;|var valueNull = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\", new object[] { (string)null }).UniqueID;|Assert.NotEmpty(value42);|Assert.NotEqual(value42, valueHelloWorld);|Assert.NotEqual(value42, valueNull);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TheoryDiscovererTests.cs",
    "methods": [
      {
        "name": "NoDataAttributes",
        "body": "{|var failures = Run<ITestFailed>(typeof(NoDataAttributesClass));|var failure = Assert.Single(failures);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"No data found for TheoryDiscovererTests+NoDataAttributesClass.TheoryMethod\", failure.Messages.Single());|}"
      },
      {
        "name": "NullMemberData_ThrowsInvalidOperationException",
        "body": "{|var results = Run<ITestFailed>(typeof(NullDataClass));|var failure = Assert.Single(results);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"Test data returned null for TheoryDiscovererTests+NullDataClass.NullMemberData. Make sure it is statically initialized before this test method is called.\", failure.Messages.Single());|}"
      },
      {
        "name": "EmptyTheoryData",
        "body": "{|var failures = Run<ITestFailed>(typeof(EmptyTheoryDataClass));|var failure = Assert.Single(failures);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"No data found for TheoryDiscovererTests+EmptyTheoryDataClass.TheoryMethod\", failure.Messages.Single());|}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToTrue_YieldsTestCasePerDataRow",
        "body": "{|discoveryOptions.SetPreEnumerateTheories(true);|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();|Assert.Equal(2, testCases.Count);|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 42)\");|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 2112)\");|}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToFalse_YieldsSingleTheoryTestCase",
        "body": "{|discoveryOptions.SetPreEnumerateTheories(false);|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+MultipleDataClass.TheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "DiscoverOptions_PreEnumerateTheoriesSetToTrueWithSkipOnData_YieldsSkippedTestCasePerDataRow",
        "body": "{|discoveryOptions.SetPreEnumerateTheories(true);|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MultipleDataClassSkipped), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();|Assert.Equal(2, testCases.Count);|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 42)\" && testCase.SkipReason == \"Skip this attribute\");|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 2112)\" && testCase.SkipReason == \"Skip this attribute\");|}"
      },
      {
        "name": "ThrowingData",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ThrowingDataClass), \"TheoryWithMisbehavingData\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData\", theoryTestCase.DisplayName);|var message = Assert.Single(discoverer.DiagnosticMessages);|var diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);|Assert.StartsWith($\"Exception thrown during theory discovery on 'TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData'; falling back to single test case.{Environment.NewLine}System.DivideByZeroException:\", diagnostic.Message);|}"
      },
      {
        "name": "DataDiscovererReturningNullYieldsSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var theoryAttribute = Mocks.TheoryAttribute();|var dataAttribute = Mocks.DataAttribute();|var testMethod = Mocks.TestMethod(\"MockTheoryType\", \"MockTheoryMethod\", methodAttributes: new[] { theoryAttribute, dataAttribute });|var testCases = discoverer.Discover(discoveryOptions, testMethod, theoryAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"MockTheoryType.MockTheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "NonSerializableDataYieldsSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(NonSerializableDataClass), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod\", theoryTestCase.DisplayName);|var message = Assert.Single(discoverer.DiagnosticMessages);|var diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);|Assert.Equal(\"Non-serializable data ('System.Object[]') found for 'TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod'; falling back to single test case.\", diagnostic.Message);|}"
      },
      {
        "name": "NoSuchDataDiscoverer_ThrowsInvalidOperationException",
        "body": "{|var results = Run<ITestFailed>(typeof(NoSuchDataDiscovererClass));|var failure = Assert.Single(results);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NoSuchDataDiscovererAttribute on TheoryDiscovererTests+NoSuchDataDiscovererClass.Test does not exist.\", failure.Messages.Single());|}"
      },
      {
        "name": "NotADataDiscoverer_ThrowsInvalidOperationException",
        "body": "{|var results = Run<ITestFailed>(typeof(NotADataDiscovererClass));|var failure = Assert.Single(results);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NotADataDiscovererAttribute on TheoryDiscovererTests+NotADataDiscovererClass.Test does not implement IDataDiscoverer.\", failure.Messages.Single());|}"
      },
      {
        "name": "NonDiscoveryEnumeratedDataYieldsSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(NonDiscoveryEnumeratedData), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+NonDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "MixedDiscoveryEnumerationDataYieldSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MixedDiscoveryEnumeratedData), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+MixedDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "SkippedTheoryWithNoData",
        "body": "{|var skips = Run<ITestSkipped>(typeof(SkippedWithNoData));|var skip = Assert.Single(skips);|Assert.Equal(\"TheoryDiscovererTests+SkippedWithNoData.TestMethod\", skip.Test.DisplayName);|Assert.Equal(\"I have no data\", skip.Reason);|}"
      },
      {
        "name": "SkippedTheoryWithData",
        "body": "{|var skips = Run<ITestSkipped>(typeof(SkippedWithData));|var skip = Assert.Single(skips);|Assert.Equal(\"TheoryDiscovererTests+SkippedWithData.TestMethod\", skip.Test.DisplayName);|Assert.Equal(\"I have data\", skip.Reason);|}"
      }
    ]
  },
  {
    "file": "XunitTestCaseTests.cs",
    "methods": [
      {
        "name": "DefaultBehavior",
        "body": "{|var testMethod = Mocks.TestMethod(\"MockType\", \"MockMethod\");|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"MockType.MockMethod\", testCase.DisplayName);|Assert.Null(testCase.SkipReason);|Assert.Empty(testCase.Traits);|}"
      },
      {
        "name": "SkipReason",
        "body": "{|var testMethod = Mocks.TestMethod(skip: \"Skip Reason\");|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Skip Reason\", testCase.SkipReason);|}"
      },
      {
        "name": "Timeout",
        "body": "{|var testMethod = Mocks.TestMethod(timeout: 42);|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(42, testCase.Timeout);|}"
      },
      {
        "name": "TraitsOnTestMethod",
        "body": "{|var trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");|var trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");|var testMethod = Mocks.TestMethod(methodAttributes: new[] { trait1, trait2 });|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));|Assert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));|}"
      },
      {
        "name": "TraitsOnTestClass",
        "body": "{|var trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");|var trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");|var testMethod = Mocks.TestMethod(classAttributes: new[] { trait1, trait2 });|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));|Assert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));|}"
      },
      {
        "name": "CustomTrait",
        "body": "{|var passingTests = Run<ITestPassed>(typeof(ClassWithCustomTraitTest));|var passingTest = Assert.Single(passingTests);|if (passingTest != null)|Assert.Collection(|passingTest.TestCase.Traits.OrderBy(x => x.Key),|namedTrait =>|{|Assert.Equal(\"Assembly\", namedTrait.Key);|var value = Assert.Single(namedTrait.Value);|Assert.Equal(\"Trait\", value);|},|namedTrait =>|{|Assert.Equal(\"Author\", namedTrait.Key);|var value = Assert.Single(namedTrait.Value);|Assert.Equal(\"Some Schmoe\", value);|},|namedTrait =>|{|Assert.Equal(\"Bug\", namedTrait.Key);|var value = Assert.Single(namedTrait.Value);|Assert.Equal(\"2112\", value);|});|}"
      },
      {
        "name": "CustomTraitWithoutDiscoverer",
        "body": "{|var trait = Mocks.TraitAttribute<BadTraitAttribute>();|var testMethod = Mocks.TestMethod(classAttributes: new[] { trait });|var messages = new List<IMessageSinkMessage>();|var spy = SpyMessageSink.Create(messages: messages);|var testCase = new XunitTestCase(spy, TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Empty(testCase.Traits);|var diagnosticMessages = messages.OfType<IDiagnosticMessage>();|var diagnosticMessage = Assert.Single(diagnosticMessages);|Assert.Equal($\"Trait attribute on '{testCase.DisplayName}' did not have [TraitDiscoverer]\", diagnosticMessage.Message);|}"
      },
      {
        "name": "BugFix",
        "body": "{ }"
      },
      {
        "name": "CustomDisplayName",
        "body": "{|var testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\");|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Custom Display Name\", testCase.DisplayName);|}"
      },
      {
        "name": "CustomDisplayNameWithArguments",
        "body": "{|var param1 = Mocks.ParameterInfo(\"p1\");|var param2 = Mocks.ParameterInfo(\"p2\");|var param3 = Mocks.ParameterInfo(\"p3\");|var testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\", parameters: new[] { param1, param2, param3 });|var arguments = new object[] { 42, \"Hello, world!\", 'A' };|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod, arguments);|Assert.Equal(\"Custom Display Name(p1: 42, p2: \\\"Hello, world!\\\", p3: 'A')\", testCase.DisplayName);|}"
      }
    ]
  },
  {
    "file": "XunitTestFrameworkDiscovererTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|var assembly = Substitute.For<IAssemblyInfo>();|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var diagnosticMessageSink = SpyMessageSink.Create();|Assert.Throws<ArgumentNullException>(\"assemblyInfo\", () => new XunitTestFrameworkDiscoverer(null, sourceProvider, diagnosticMessageSink));|Assert.Throws<ArgumentNullException>(\"sourceProvider\", () => new XunitTestFrameworkDiscoverer(assembly, null, diagnosticMessageSink));|Assert.Throws<ArgumentNullException>(\"diagnosticMessageSink\", () => new XunitTestFrameworkDiscoverer(assembly, sourceProvider, null));|}"
      },
      {
        "name": "GuardClauses",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|Assert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: TestFrameworkOptions.ForDiscovery()));|Assert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: Substitute.For<IMessageSink>(), discoveryOptions: null));|}"
      },
      {
        "name": "AssemblyWithNoTypes_ReturnsNoTestCases",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|framework.Find();|Assert.Empty(framework.TestCases);|}"
      },
      {
        "name": "RequestsOnlyPublicTypesFromAssembly",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create(collectionFactory: Substitute.For<IXunitTestCollectionFactory>());|framework.Find();|framework.Assembly.Received(1).GetTypes(includePrivateTypes: false);|}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{|var abstractClassTypeInfo = Reflector.Wrap(typeof(AbstractClass));|var assembly = Mocks.AssemblyInfo(types: new[] { abstractClassTypeInfo });|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);|framework.FindTestsForClass(null).ReturnsForAnyArgs(true);|framework.Find();|framework.Sink.Finished.WaitOne();|framework.Received(0).FindTestsForClass(Arg.Any<ITestClass>(), Arg.Any<bool>());|}"
      },
      {
        "name": "CallsFindImplWhenTypesAreFoundInAssembly",
        "body": "{|var objectTypeInfo = Reflector.Wrap(typeof(object));|var intTypeInfo = Reflector.Wrap(typeof(int));|var assembly = Mocks.AssemblyInfo(types: new[] { objectTypeInfo, intTypeInfo });|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);|framework.FindTestsForClass(null).ReturnsForAnyArgs(true);|framework.Find();|framework.Sink.Finished.WaitOne();|framework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == objectTypeInfo), false);|framework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == intTypeInfo), false);|}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));|var mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });|var framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);|framework.Find();|framework.Sink.Finished.WaitOne();|sourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());|}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|sourceProvider|.GetSourceInformation(null)|.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });|var typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));|var mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });|var framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);|framework.Find(includeSourceInformation: true);|Assert.Collection(framework.TestCases,|testCase =>|{|Assert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);|Assert.Equal(\"Source File\", testCase.SourceInformation.FileName);|Assert.Equal(42, testCase.SourceInformation.LineNumber);|}|);|}"
      },
      {
        "name": "GuardClauses",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var typeName = typeof(object).FullName;|var sink = Substitute.For<IMessageSink>();|var options = TestFrameworkOptions.ForDiscovery();|Assert.Throws<ArgumentNullException>(\"typeName\", () => framework.Find(typeName: null, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));|Assert.Throws<ArgumentException>(\"typeName\", () => framework.Find(typeName: \"\", includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));|Assert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: options));|Assert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: null));|}"
      },
      {
        "name": "RequestsPublicAndPrivateMethodsFromType",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var type = Substitute.For<ITypeInfo>();|framework.Assembly.GetType(\"abc\").Returns(type);|framework.Find(\"abc\");|framework.Sink.Finished.WaitOne();|type.Received(1).GetMethods(includePrivateMethods: true);|}"
      },
      {
        "name": "CallsFindImplWhenMethodsAreFoundOnType",
        "body": "{|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();|var type = Substitute.For<ITypeInfo>();|framework.Assembly.GetType(\"abc\").Returns(type);|framework.Find(\"abc\");|framework.Sink.Finished.WaitOne();|framework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), false);|}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();|var type = Substitute.For<ITypeInfo>();|type.IsAbstract.Returns(true);|framework.Assembly.GetType(\"abc\").Returns(type);|framework.Find(\"abc\");|framework.Sink.Finished.WaitOne();|framework.Received(0).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), Arg.Any<bool>());|}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);|framework.Find(\"abc\");|sourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());|}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|sourceProvider|.GetSourceInformation(null)|.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });|var framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);|var typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));|framework.Assembly.GetType(\"abc\").Returns(typeInfo);|framework.Find(\"abc\", includeSourceInformation: true);|Assert.Collection(framework.TestCases,|testCase =>|{|Assert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);|Assert.Equal(\"Source File\", testCase.SourceInformation.FileName);|Assert.Equal(42, testCase.SourceInformation.LineNumber);|}|);|}"
      },
      {
        "name": "ClassWithNoTests_ReturnsNoTestCases",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithNoTests)));|framework.FindTestsForClass(testClass);|Assert.False(framework.Sink.Finished.WaitOne(0));|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithFact_ReturnsOneTestCaseOfTypeXunitTestCase",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithOneFact)));|framework.FindTestsForClass(testClass);|var testCase = Assert.Single(framework.Sink.TestCases);|Assert.IsType<XunitTestCase>(testCase);|}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithMixOfFactsAndNonTests_ReturnsTestCasesOnlyForFacts",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithMixOfFactsAndNonFacts)));|framework.FindTestsForClass(testClass);|Assert.Equal(2, framework.Sink.TestCases.Count);|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod1\");|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod2\");|}"
      },
      {
        "name": "AssemblyWithTheoryWithInlineData_ReturnsOneTestCasePerDataRecord",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = Mocks.TestClass(typeof(TheoryWithInlineData));|framework.FindTestsForClass(testClass);|Assert.Equal(2, framework.Sink.TestCases.Count);|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: \\\"Hello world\\\")\");|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: 42)\");|}"
      },
      {
        "name": "AssemblyWithTheoryWithPropertyData_ReturnsOneTestCasePerDataRecord",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = Mocks.TestClass(typeof(TheoryWithPropertyData));|framework.FindTestsForClass(testClass);|Assert.Equal(2, framework.Sink.TestCases.Count);|Assert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 42)\");|Assert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 2112)\");|}"
      },
      {
        "name": "AssemblyWithMultiLevelHierarchyWithFactOverridenInNonImmediateDerivedClass_ReturnsOneTestCase",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = Mocks.TestClass(typeof(Child));|framework.FindTestsForClass(testClass);|Assert.Equal(1, framework.Sink.TestCases.Count);|Assert.Equal(\"XunitTestFrameworkDiscovererTests+FindImpl+Child.FactOverridenInNonImmediateDerivedClass\", framework.Sink.TestCases[0].DisplayName);|}"
      },
      {
        "name": "FactOverridenInNonImmediateDerivedClass",
        "body": "{|Assert.True(true);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefaultTestCollection",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var type = Reflector.Wrap(typeof(ClassWithNoCollection));|var testClass = framework.CreateTestClass(type);|Assert.NotNull(testClass.TestCollection);|Assert.Equal(\"Test collection for XunitTestFrameworkDiscovererTests+CreateTestClass+ClassWithNoCollection\", testClass.TestCollection.DisplayName);|Assert.Null(testClass.TestCollection.CollectionDefinition);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "UndeclaredTestCollection",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var type = Reflector.Wrap(typeof(ClassWithUndeclaredCollection));|var testClass = framework.CreateTestClass(type);|Assert.NotNull(testClass.TestCollection);|Assert.Equal(\"This a collection without declaration\", testClass.TestCollection.DisplayName);|Assert.Null(testClass.TestCollection.CollectionDefinition);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefinedTestCollection",
        "body": "{|var type = Reflector.Wrap(typeof(ClassWithDefinedCollection));|var framework = TestableXunitTestFrameworkDiscoverer.Create(type.Assembly);|var testClass = framework.CreateTestClass(type);|Assert.NotNull(testClass.TestCollection);|Assert.Equal(\"This a defined collection\", testClass.TestCollection.DisplayName);|Assert.NotNull(testClass.TestCollection.CollectionDefinition);|Assert.Equal(\"XunitTestFrameworkDiscovererTests+CreateTestClass+DeclaredCollection\", testClass.TestCollection.CollectionDefinition.Name);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "ATestNotToBeRun",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "MessageBusTests.cs",
    "methods": [
      {
        "name": "QueuedMessageShowUpInMessageSink",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var sink = SpyMessageSink.Create(messages: messages);|var msg1 = Substitute.For<IMessageSinkMessage>();|var msg2 = Substitute.For<IMessageSinkMessage>();|var msg3 = Substitute.For<IMessageSinkMessage>();|using (var bus = new MessageBus(sink))|{|bus.QueueMessage(msg1);|bus.QueueMessage(msg2);|bus.QueueMessage(msg3);|}|Assert.Collection(messages,|message => Assert.Same(msg1, message),|message => Assert.Same(msg2, message),|message => Assert.Same(msg3, message)|);|}"
      },
      {
        "name": "TryingToQueueMessageAfterDisposingThrows",
        "body": "{|var bus = new MessageBus(SpyMessageSink.Create());|bus.Dispose();|var exception = Record.Exception(|() => bus.QueueMessage(Substitute.For<IMessageSinkMessage>())|);|Assert.IsType<ObjectDisposedException>(exception);|}"
      },
      {
        "name": "WhenSinkThrowsMessagesContinueToBeDelivered",
        "body": "{|var sink = Substitute.For<IMessageSink>();|var msg1 = Substitute.For<IMessageSinkMessage>();|var msg2 = Substitute.For<IMessageSinkMessage>();|var msg3 = Substitute.For<IMessageSinkMessage>();|var messages = new List<IMessageSinkMessage>();|sink.OnMessage(Arg.Any<IMessageSinkMessage>())|.Returns(callInfo =>|{|var msg = (IMessageSinkMessage)callInfo[0];|if (msg == msg2)|throw new DivideByZeroException(\"whee!\");|else|messages.Add(msg);|return false;|});|using (var bus = new MessageBus(sink))|{|bus.QueueMessage(msg1);|bus.QueueMessage(msg2);|bus.QueueMessage(msg3);|}|Assert.Collection(messages,|message => Assert.Same(message, msg1),|message =>|{|var errorMessage = Assert.IsAssignableFrom<IErrorMessage>(message);|Assert.Equal(\"System.DivideByZeroException\", errorMessage.ExceptionTypes.Single());|Assert.Equal(\"whee!\", errorMessage.Messages.Single());|},|message => Assert.Same(message, msg3)|);|}"
      },
      {
        "name": "QueueReturnsTrueForFailIfStopOnFailFalse",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var sink = SpyMessageSink.Create(messages: messages);|var msg1 = Substitute.For<IMessageSinkMessage>();|var msg2 = Substitute.For<ITestFailed>();|var msg3 = Substitute.For<IMessageSinkMessage>();|using (var bus = new MessageBus(sink))|{|Assert.True(bus.QueueMessage(msg1));|Assert.True(bus.QueueMessage(msg2));|Assert.True(bus.QueueMessage(msg3));|}|Assert.Collection(messages,|message => Assert.Same(msg1, message),|message => Assert.Same(msg2, message),|message => Assert.Same(msg3, message)|);|}"
      }
    ]
  },
  {
    "file": "ReflectionAttributeInfoTests.cs",
    "methods": [
      {
        "name": "Throws",
        "body": "{|var attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithAttribute)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));|var attributeInfo = new ReflectionAttributeInfo(attributeData);|var ex = Record.Exception(() => attributeInfo.GetNamedArgument<int>(\"IntValue\"));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.StartsWith(\"Could not find property or field named 'IntValue' on instance of 'ReflectionAttributeInfoTests+GetNamedArgument+NamedValueDoesNotExist+AttributeUnderTest'\", argEx.Message);|Assert.Equal(\"argumentName\", argEx.ParamName);|}"
      },
      {
        "name": "ReturnsValue",
        "body": "{|var attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));|var attributeInfo = new ReflectionAttributeInfo(attributeData);|var result = attributeInfo.GetNamedArgument<int>(\"IntValue\");|Assert.Equal(42, result);|}"
      },
      {
        "name": "ReturnsDefaultValueWhenValueIsNotSet",
        "body": "{|var attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithoutAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));|var attributeInfo = new ReflectionAttributeInfo(attributeData);|var result = attributeInfo.GetNamedArgument<int>(\"IntValue\");|Assert.Equal(0, result);|}"
      },
      {
        "name": "ReturnsValue",
        "body": "{|var attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));|var attributeInfo = new ReflectionAttributeInfo(attributeData);|var result = attributeInfo.GetNamedArgument<int>(\"IntValue\");|Assert.Equal(42, result);|}"
      },
      {
        "name": "ReturnsDefaultValueWhenValueIsNotSet",
        "body": "{|var attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithoutAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));|var attributeInfo = new ReflectionAttributeInfo(attributeData);|var result = attributeInfo.GetNamedArgument<int>(\"IntValue\");|Assert.Equal(0, result);|}"
      }
    ]
  },
  {
    "file": "ReflectorTests.cs",
    "methods": [
      {
        "name": "CanFindPublicMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PublicMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "CanFindPublicStaticMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PublicStaticMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "CanFindPrivateMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PrivateMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "CanFindPrivateStaticMethod",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"PrivateStaticMethod\");|Assert.NotNull(result);|}"
      },
      {
        "name": "NonExistantMethodReturnsNull",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|IMethodInfo result = typeInfo.GetMethod(\"NonExistantMethod\");|Assert.Null(result);|}"
      },
      {
        "name": "ReturnsPublicAndPrivateStaticAndNonStaticMethods",
        "body": "{|ITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));|List<IMethodInfo> methods = new List<IMethodInfo>(typeInfo.GetMethods());|foreach (string name in new string[] { \"PrivateMethod\", \"PrivateStaticMethod\", \"PublicMethod\", \"PublicStaticMethod\" })|Assert.NotNull(methods.Find(methodInfo => methodInfo.Name == name));|Assert.Null(methods.Find(methodInfo => methodInfo.Name == \"Property\"));|}"
      },
      {
        "name": "ThrowsException",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestMethodCommandClass obj = new TestMethodCommandClass();|Exception ex = Record.Exception(() => wrappedMethod.Invoke(obj));|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "ThrowsTargetInvocationException",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsTargetInvocationException\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestMethodCommandClass obj = new TestMethodCommandClass();|Exception ex = Record.Exception(() => wrappedMethod.Invoke(obj));|Assert.IsType<TargetInvocationException>(ex);|}"
      },
      {
        "name": "TurnsTargetParameterCountExceptionIntoParameterCountMismatchException",
        "body": "{|MethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");|IMethodInfo wrappedMethod = Reflector.Wrap(method);|TestMethodCommandClass obj = new TestMethodCommandClass();|Exception ex = Record.Exception(() => wrappedMethod.Invoke(obj, \"Hello world\"));|Assert.IsType<ParameterCountMismatchException>(ex);|}"
      },
      {
        "name": "PrivateMethod",
        "body": "{ }"
      },
      {
        "name": "PrivateStaticMethod",
        "body": "{ }"
      },
      {
        "name": "PublicMethod",
        "body": "{ }"
      },
      {
        "name": "PublicStaticMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "SynchronousMessageBusTests.cs",
    "methods": [
      {
        "name": "MessagesAreDispatchedImmediatelyFromBus",
        "body": "{|var msg1 = Substitute.For<IMessageSinkMessage>();|var dispatchedMessages = new List<IMessageSinkMessage>();|using (var bus = new SynchronousMessageBus(SpyMessageSink.Create(messages: dispatchedMessages), stopOnFail: false))|{|Assert.True(bus.QueueMessage(msg1));|}|var message = Assert.Single(dispatchedMessages);|Assert.Same(msg1, message);|}"
      },
      {
        "name": "BusShouldReportShutdownWhenMessageSinkReturnsFalse",
        "body": "{|using (var bus = new SynchronousMessageBus(SpyMessageSink.Create(returnResult: false), stopOnFail: false))|{|Assert.False(bus.QueueMessage(Substitute.For<IMessageSinkMessage>()));|}|}"
      }
    ]
  },
  {
    "file": "TestCaseBulkDeserializerTests.cs",
    "methods": [
      {
        "name": "XunitFactWithColonsGetsEscaped",
        "body": "{|var testMethod = Mocks.TestMethod(\"TESTS:TESTS\", \"a:b\");|var testCase = new XunitTestCase(null, Xunit.Sdk.TestMethodDisplay.ClassAndMethod, Xunit.Sdk.TestMethodDisplayOptions.None, testMethod);|var serializedTestCase = discoverer.Serialize(testCase);|Assert.StartsWith(\":F:TESTS::TESTS:a::b:1:0:\", serializedTestCase);|}"
      },
      {
        "name": "CanDeserializeGeneralizedSerialization",
        "body": "{|var discoverySink = new SpyMessageSink<IDiscoveryCompleteMessage>();|discoverer.Find(\"TestCaseBulkDeserializerTests+TestClass\", false, discoverySink, TestFrameworkOptions.ForDiscovery());|discoverySink.Finished.WaitOne();|var serializedTestCases =|discoverySink|.Messages|.OfType<ITestCaseDiscoveryMessage>()|.Where(m => m.TestCase.TestMethod.Method.Name == \"TheoryMethod\")|.Select(m => discoverer.Serialize(m.TestCase))|.ToList();|var results = default(List<KeyValuePair<string, ITestCase>>);|Action<List<KeyValuePair<string, ITestCase>>> callback = r => results = r;|new TestCaseBulkDeserializer(discoverer, executor, serializedTestCases, callback);|var kvp = Assert.Single(results);|Assert.Equal(kvp.Value.UniqueID, kvp.Key);|Assert.Equal(\"TestCaseBulkDeserializerTests+TestClass\", kvp.Value.TestMethod.TestClass.Class.Name);|Assert.Equal(\"TheoryMethod\", kvp.Value.TestMethod.Method.Name);|Assert.Equal(\"TestCaseBulkDeserializerTests+TestClass.TheoryMethod(x: 42)\", kvp.Value.DisplayName);|}"
      },
      {
        "name": "FactMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestCaseDescriptorFactoryTests.cs",
    "methods": [
      {
        "name": "EmptyTestCase",
        "body": "{|var testCase = Substitute.For<ITestCase>();|new TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);|var result = Assert.Single(callbackResults);|Assert.Equal(\"C \\nM \\nU \\nD \\nS Serialization of test case ID ''\\n\", result);|}"
      },
      {
        "name": "NoDiscovererMeansNoSerialization",
        "body": "{|var testCase = Substitute.For<ITestCase>();|new TestCaseDescriptorFactory(null, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);|var result = Assert.Single(callbackResults);|Assert.Equal(\"C \\nM \\nU \\nD \\n\", result);|}"
      },
      {
        "name": "PopulatedTestCase",
        "body": "{|var sourceInfo = Substitute.For<ISourceInformation>();|sourceInfo.FileName.Returns(@\"C:\\Foo\\Bar.dll\");|sourceInfo.LineNumber.Returns(123456);|var traits = new Dictionary<string, List<string>>|{|{ \"Name \\n 1\", new List<string> { \"Value 1a\", \"Value \\n 1b\" } },|{ \"Name 2\", new List<string> { \"Value 2\" } }|};|var testCase = Mocks.TestCase<MockDiscovery>(\"PopulatedTestCase\", \"Display \\n Name\", \"Skip \\n Reason\", \"ABCDEF0123456789\");|testCase.SourceInformation.Returns(sourceInfo);|testCase.Traits.Returns(traits);|new TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);|var result = Assert.Single(callbackResults);|Assert.Equal(|\"C TestCaseDescriptorFactoryTests+MockDiscovery\\n\" +|\"M PopulatedTestCase\\n\" +|\"U ABCDEF0123456789\\n\" +|\"D Display \\\\n Name\\n\" +|\"S Serialization of test case ID 'ABCDEF0123456789'\\n\" +|\"R Skip \\\\n Reason\\n\" +|\"F C:\\\\Foo\\\\Bar.dll\\n\" +|\"L 123456\\n\" +|\"T Name \\\\n 1\\nValue 1a\\n\" +|\"T Name \\\\n 1\\nValue \\\\n 1b\\n\" +|\"T Name 2\\nValue 2\\n\",|result);|}"
      },
      {
        "name": "XunitFactHasSpecialSerialization",
        "body": "{|var testCase = testCases.Single(tc => tc.TestMethod.Method.Name == \"FactMethod\");|new TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);|var result = Assert.Single(callbackResults);|var serialization = Assert.Single(result.Split('\\n').Where(line => line.StartsWith(\"S \")));|Assert.Equal($\"S :F:TestCaseDescriptorFactoryTests+TestClass:FactMethod:1:0:{testCase.TestMethod.TestClass.TestCollection.UniqueID.ToString(\"N\")}\", serialization);|}"
      },
      {
        "name": "XunitTheoryDoesNotHaveSpecialSerialization",
        "body": "{|var testCase = testCases.Single(tc => tc.TestMethod.Method.Name == \"TheoryMethod\");|new TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);|var result = Assert.Single(callbackResults);|var serialization = Assert.Single(result.Split('\\n').Where(line => line.StartsWith(\"S \")));|Assert.False(serialization.StartsWith(\"S :FACT\"));|}"
      },
      {
        "name": "FactMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestFrameworkProxyTests.cs",
    "methods": [
      {
        "name": "NoAttribute",
        "body": "{|var assembly = Mocks.AssemblyInfo();|var proxy = new TestFrameworkProxy(assembly, null, diagnosticSpy);|Assert.IsType<XunitTestFramework>(proxy.InnerTestFramework);|Assert.Empty(diagnosticMessages);|}"
      },
      {
        "name": "Attribute_NoDiscoverer",
        "body": "{|var attribute = Mocks.TestFrameworkAttribute(typeof(AttributeWithoutDiscoverer));|var assembly = Mocks.AssemblyInfo(attributes: new[] { attribute });|var proxy = new TestFrameworkProxy(assembly, null, diagnosticSpy);|Assert.IsType<XunitTestFramework>(proxy.InnerTestFramework);|AssertSingleDiagnosticMessage(\"Assembly-level test framework attribute was not decorated with [TestFrameworkDiscoverer]\");|}"
      },
      {
        "name": "Attribute_WithDiscoverer_NoMessageSink",
        "body": "{|var attribute = Mocks.TestFrameworkAttribute(typeof(AttributeWithDiscoverer));|var assembly = Mocks.AssemblyInfo(attributes: new[] { attribute });|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var proxy = new TestFrameworkProxy(assembly, sourceProvider, diagnosticSpy);|var testFramework = Assert.IsType<MyTestFramework>(proxy.InnerTestFramework);|Assert.Same(sourceProvider, testFramework.SourceInformationProvider);|Assert.Empty(diagnosticMessages);|}"
      },
      {
        "name": "Attribute_WithDiscoverer_WithMessageSink",
        "body": "{|var attribute = Mocks.TestFrameworkAttribute(typeof(AttributeWithDiscovererWithMessageSink));|var assembly = Mocks.AssemblyInfo(attributes: new[] { attribute });|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var proxy = new TestFrameworkProxy(assembly, sourceProvider, diagnosticSpy);|var testFramework = Assert.IsType<MyTestFrameworkWithMessageSink>(proxy.InnerTestFramework);|var wrapper = Assert.IsType<TestFrameworkProxy.MessageSinkWrapper>(testFramework.MessageSink);|Assert.Same(diagnosticSpy, wrapper.InnerSink);|Assert.Same(sourceProvider, testFramework.SourceInformationProvider);|Assert.Empty(diagnosticMessages);|}"
      }
    ]
  },
  {
    "file": "XmlTestExecutionVisitorTests.cs",
    "methods": [
      {
        "name": "ReturnsFalseWhenCancellationThunkIsTrue",
        "body": "{|var visitor = new XmlTestExecutionVisitor(null, () => true);|var result = visitor.OnMessage(testMessage);|Assert.False(result);|}"
      },
      {
        "name": "ReturnsTrueWhenCancellationThunkIsFalse",
        "body": "{|var visitor = new XmlTestExecutionVisitor(null, () => false);|var result = visitor.OnMessage(testMessage);|Assert.True(result);|}"
      },
      {
        "name": "AddsStatisticsToRunningTotal",
        "body": "{|var assemblyFinished = Substitute.For<ITestAssemblyFinished>();|assemblyFinished.TestsRun.Returns(2112);|assemblyFinished.TestsFailed.Returns(42);|assemblyFinished.TestsSkipped.Returns(6);|assemblyFinished.ExecutionTime.Returns(123.4567M);|var visitor = new XmlTestExecutionVisitor(null, () => false) { Total = 10, Failed = 10, Skipped = 10, Time = 10M };|visitor.OnMessage(assemblyFinished);|Assert.Equal(2122, visitor.Total);|Assert.Equal(52, visitor.Failed);|Assert.Equal(16, visitor.Skipped);|Assert.Equal(133.4567M, visitor.Time);|}"
      },
      {
        "name": "AddsAssemblyStartingInformationToXml",
        "body": "{|var assemblyStarting = Substitute.For<ITestAssemblyStarting>();|assemblyStarting.TestAssembly.Assembly.AssemblyPath.Returns(\"assembly\");|assemblyStarting.TestAssembly.ConfigFileName.Returns(\"config\");|assemblyStarting.StartTime.Returns(new DateTime(2013, 7, 6, 16, 24, 32));|assemblyStarting.TestEnvironment.Returns(\"256-bit MentalFloss\");|assemblyStarting.TestFrameworkDisplayName.Returns(\"xUnit.net v14.42\");|var assemblyElement = new XElement(\"assembly\");|var visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);|visitor.OnMessage(assemblyStarting);|Assert.Equal(\"assembly\", assemblyElement.Attribute(\"name\").Value);|Assert.Equal(\"256-bit MentalFloss\", assemblyElement.Attribute(\"environment\").Value);|Assert.Equal(\"xUnit.net v14.42\", assemblyElement.Attribute(\"test-framework\").Value);|Assert.Equal(\"config\", assemblyElement.Attribute(\"config-file\").Value);|Assert.Equal(\"2013-07-06\", assemblyElement.Attribute(\"run-date\").Value);|Assert.Equal(\"16:24:32\", assemblyElement.Attribute(\"run-time\").Value);|}"
      },
      {
        "name": "AssemblyStartingDoesNotIncludeNullConfigFile",
        "body": "{|var assemblyStarting = Substitute.For<ITestAssemblyStarting>();|assemblyStarting.TestAssembly.ConfigFileName.Returns((string)null);|var assemblyElement = new XElement(\"assembly\");|var visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);|visitor.OnMessage(assemblyStarting);|Assert.Null(assemblyElement.Attribute(\"config-file\"));|}"
      },
      {
        "name": "NullStackTraceInFailedTestResultsInEmptyStackTraceXmlElement",
        "body": "{|var assemblyFinished = Substitute.For<ITestAssemblyFinished>();|var testCase = Mocks.TestCase<ClassUnderTest>(\"TestMethod\");|var testFailed = Substitute.For<ITestFailed>();|testFailed.TestCase.Returns(testCase);|testFailed.ExceptionTypes.Returns(new[] { \"ExceptionType\" });|testFailed.Messages.Returns(new[] { \"Exception Message\" });|testFailed.StackTraces.Returns(new[] { (string)null });|testFailed.ExceptionParentIndices.Returns(new[] { -1 });|var assemblyElement = new XElement(\"assembly\");|var visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);|visitor.OnMessage(testFailed);|visitor.OnMessage(assemblyFinished);|var testElement = Assert.Single(assemblyElement.Elements(\"collection\").Single().Elements(\"test\"));|var failureElement = Assert.Single(testElement.Elements(\"failure\"));|Assert.Empty(failureElement.Elements(\"stack-trace\").Single().Value);|}"
      },
      {
        "name": "TestElementSourceInfoIsPlacedInXmlWhenPresent",
        "body": "{|var assemblyFinished = Substitute.For<ITestAssemblyFinished>();|var testCase = Mocks.TestCase<ClassUnderTest>(\"TestMethod\");|testCase.SourceInformation.Returns(new SourceInformation { FileName = \"source file\", LineNumber = 42 });|var testPassed = Substitute.For<ITestPassed>();|testPassed.TestCase.Returns(testCase);|var assemblyElement = new XElement(\"assembly\");|var visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);|visitor.OnMessage(testPassed);|visitor.OnMessage(assemblyFinished);|var testElement = Assert.Single(assemblyElement.Elements(\"collection\").Single().Elements(\"test\"));|Assert.Equal(\"source file\", testElement.Attribute(\"source-file\").Value);|Assert.Equal(\"42\", testElement.Attribute(\"source-line\").Value);|}"
      },
      {
        "name": "TestElementTraisArePlacedInXmlWhenPresent",
        "body": "{|var traits = new Dictionary<string, List<string>>|{|{ \"name1\", new List<string> { \"value1\" }},|{ \"name2\", new List<string> { \"value2\" }}|};|var assemblyFinished = Substitute.For<ITestAssemblyFinished>();|var passingTestCase = Mocks.TestCase<ClassUnderTest>(\"TestMethod\");|passingTestCase.Traits.Returns(traits);|var testPassed = Substitute.For<ITestPassed>();|testPassed.TestCase.Returns(passingTestCase);|var assemblyElement = new XElement(\"assembly\");|var visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);|visitor.OnMessage(testPassed);|visitor.OnMessage(assemblyFinished);|var traitsElements = assemblyElement.Elements(\"collection\").Single().Elements(\"test\").Single().Elements(\"traits\").Single().Elements(\"trait\");|var name1Element = Assert.Single(traitsElements, e => e.Attribute(\"name\").Value == \"name1\");|Assert.Equal(\"value1\", name1Element.Attribute(\"value\").Value);|var name2Element = Assert.Single(traitsElements, e => e.Attribute(\"name\").Value == \"name2\");|Assert.Equal(\"value2\", name2Element.Attribute(\"value\").Value);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "BooleanAssertsTests.cs",
    "methods": [
      {
        "name": "AssertFalse",
        "body": "{|Assert.False(false);|}"
      },
      {
        "name": "ThrowsExceptionWhenTrue",
        "body": "{|var ex = Record.Exception(() => Assert.False(true));|Assert.IsType<FalseException>(ex);|Assert.Equal(|\"Assert.False() Failure\" + Environment.NewLine +|\"Expected: False\" + Environment.NewLine +|\"Actual: True\",|ex.Message|);|}"
      },
      {
        "name": "ThrowsExceptionWhenNull",
        "body": "{|var ex = Record.Exception(() => Assert.False(null));|Assert.IsType<FalseException>(ex);|Assert.Equal(|\"Assert.False() Failure\" + Environment.NewLine +|\"Expected: False\" + Environment.NewLine +|\"Actual: null\",|ex.Message|);|}"
      },
      {
        "name": "UserSuppliedMessage",
        "body": "{|#pragma warning disable xUnit2020 // Do not use always-failing boolean assertions|var ex = Record.Exception(() => Assert.False(true, \"Custom User Message\"));|#pragma warning restore xUnit2020 // Do not use always-failing boolean assertions|Assert.NotNull(ex);|Assert.Equal(\"Custom User Message\", ex.Message);|}"
      },
      {
        "name": "AssertTrue",
        "body": "{|Assert.True(true);|}"
      },
      {
        "name": "ThrowsExceptionWhenFalse",
        "body": "{|var ex = Record.Exception(() => Assert.True(false));|Assert.IsType<TrueException>(ex);|Assert.Equal(|\"Assert.True() Failure\" + Environment.NewLine +|\"Expected: True\" + Environment.NewLine +|\"Actual: False\",|ex.Message|);|}"
      },
      {
        "name": "ThrowsExceptionWhenNull",
        "body": "{|var ex = Record.Exception(() => Assert.True(null));|Assert.IsType<TrueException>(ex);|Assert.Equal(|\"Assert.True() Failure\" + Environment.NewLine +|\"Expected: True\" + Environment.NewLine +|\"Actual: null\",|ex.Message|);|}"
      },
      {
        "name": "UserSuppliedMessage",
        "body": "{|#pragma warning disable xUnit2020 // Do not use always-failing boolean assertions|var ex = Record.Exception(() => Assert.True(false, \"Custom User Message\"));|#pragma warning restore xUnit2020 // Do not use always-failing boolean assertions|Assert.NotNull(ex);|Assert.Equal(\"Custom User Message\", ex.Message);|}"
      }
    ]
  },
  {
    "file": "DictionaryAssertsTests.cs",
    "methods": [
      {
        "name": "KeyInDictionary",
        "body": "{|var dictionary = new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase)|{|[\"forty-two\"] = 42|};|Assert.Equal(42, Assert.Contains(\"FORTY-two\", dictionary));|Assert.Equal(42, Assert.Contains(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary)));|Assert.Equal(42, Assert.Contains(\"FORTY-two\", (IDictionary<string, int>)dictionary));|Assert.Equal(42, Assert.Contains(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary));|#if XUNIT_IMMUTABLE_COLLECTIONS|Assert.Equal(42, Assert.Contains(\"FORTY-two\", dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));|Assert.Equal(42, Assert.Contains(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));|#endif|}"
      },
      {
        "name": "KeyNotInDictionary",
        "body": "{|var dictionary = new Dictionary<string, int>()|{|[\"eleventeen\"] = 110|};|void assertFailure(Action action)|{|var ex = Record.Exception(action);|Assert.IsType<ContainsException>(ex);|Assert.Equal(|\"Assert.Contains() Failure: Key not found in dictionary\" + Environment.NewLine +|\"Keys: [\\\"eleventeen\\\"]\" + Environment.NewLine +|\"Not found: \\\"FORTY-two\\\"\",|ex.Message|);|}|assertFailure(() => Assert.Contains(\"FORTY-two\", dictionary));|assertFailure(() => Assert.Contains(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary)));|assertFailure(() => Assert.Contains(\"FORTY-two\", (IDictionary<string, int>)dictionary));|assertFailure(() => Assert.Contains(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary));|#if XUNIT_IMMUTABLE_COLLECTIONS|assertFailure(() => Assert.Contains(\"FORTY-two\", dictionary.ToImmutableDictionary()));|assertFailure(() => Assert.Contains(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary()));|#endif|}"
      },
      {
        "name": "KeyNotInDictionary",
        "body": "{|var dictionary = new Dictionary<string, int>()|{|[\"eleventeen\"] = 110|};|Assert.DoesNotContain(\"FORTY-two\", dictionary);|Assert.DoesNotContain(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary));|Assert.DoesNotContain(\"FORTY-two\", (IDictionary<string, int>)dictionary);|Assert.DoesNotContain(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary);|#if XUNIT_IMMUTABLE_COLLECTIONS|Assert.DoesNotContain(\"FORTY-two\", dictionary.ToImmutableDictionary());|Assert.DoesNotContain(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary());|#endif|}"
      },
      {
        "name": "KeyInDictionary",
        "body": "{|var dictionary = new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase)|{|[\"forty-two\"] = 42|};|void assertFailure(Action action)|{|var ex = Record.Exception(action);|Assert.IsType<DoesNotContainException>(ex);|Assert.Equal(|\"Assert.DoesNotContain() Failure: Key found in dictionary\" + Environment.NewLine +|\"Keys: [\\\"forty-two\\\"]\" + Environment.NewLine +|\"Found: \\\"FORTY-two\\\"\",|ex.Message|);|}|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", dictionary));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary)));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IDictionary<string, int>)dictionary));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary));|#if XUNIT_IMMUTABLE_COLLECTIONS|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));|#endif|}"
      }
    ]
  },
  {
    "file": "EventAssertsTests.cs",
    "methods": [
      {
        "name": "NoEventRaised",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var ex = Record.Exception(|() => Assert.Raises<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => { }|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "NoEventRaised_NoData",
        "body": "{|var obj = new RaisingClass_Action();|var ex = Record.Exception(|() => Assert.Raises(|h => obj.Completed += h,|h => obj.Completed -= h,|() => { }|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(\"Assert.Raises() Failure: No event was raised\", ex.Message);|}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new object();|var evt = Assert.Raises<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Null(evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "RaisingClass_ActionOfT",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new DerivedObject();|var ex = Record.Exception(|() => Assert.Raises<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|$\"Actual: typeof({typeof(DerivedObject).FullName})\",|ex.Message|);|}"
      },
      {
        "name": "NoEventRaised",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var ex = Record.Exception(|() => Assert.Raises<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => { }|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new object();|var evt = Assert.Raises<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "DerivedTypeRaised",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new DerivedObject();|var ex = Record.Exception(|() => Assert.Raises<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|$\"Actual: typeof({typeof(DerivedObject).FullName})\",|ex.Message|);|}"
      },
      {
        "name": "CustomRaised",
        "body": "{|var obj = new RaisingClass_CustomEventHandler();|var eventObj = new object();|Assert.RaisedEvent<object>? raisedEvent = null;|void handler(object? s, object args) => raisedEvent = new Assert.RaisedEvent<object>(s, args);|var evt = Assert.Raises(|() => raisedEvent,|() => obj.Completed += handler,|() => obj.Completed -= handler,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "NoEventRaised",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var ex = Record.Exception(|() => Assert.RaisesAny<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => { }|)|);|Assert.IsType<RaisesAnyException>(ex);|Assert.Equal(|\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new object();|var evt = Assert.RaisesAny<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Null(evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "DerivedTypeRaised",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new DerivedObject();|var evt = Assert.RaisesAny<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Null(evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "NoEventRaised",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var ex = Record.Exception(|() => Assert.RaisesAny<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => { }|)|);|Assert.IsType<RaisesAnyException>(ex);|Assert.Equal(|\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "NoEventRaised_NonGeneric",
        "body": "{|var obj = new RaisingClass_EventHandler();|var ex = Record.Exception(|() => Assert.RaisesAny(|h => obj.Completed += h,|h => obj.Completed -= h,|() => { }|)|);|Assert.IsType<RaisesAnyException>(ex);|Assert.Equal(|\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(System.EventArgs)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new object();|var evt = Assert.RaisesAny<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "ExactTypeRaised_NonGeneric",
        "body": "{|var obj = new RaisingClass_EventHandler();|var eventObj = new EventArgs();|var evt = Assert.RaisesAny(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "DerivedTypeRaised",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new DerivedObject();|var evt = Assert.RaisesAny<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "DerivedTypeRaised_NonGeneric",
        "body": "{|var obj = new RaisingClass_EventHandler();|var eventObj = new DerivedEventArgs();|var evt = Assert.RaisesAny(|h => obj.Completed += h,|h => obj.Completed -= h,|() => obj.RaiseWithArgs(eventObj)|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAnyAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => Task.FromResult(0)|)|);|Assert.IsType<RaisesAnyException>(ex);|Assert.Equal(|\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new object();|var evt = await Assert.RaisesAnyAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Null(evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new DerivedObject();|var evt = await Assert.RaisesAnyAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Null(evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAnyAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => Task.FromResult(0)|)|);|Assert.IsType<RaisesAnyException>(ex);|Assert.Equal(|\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandler();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAnyAsync(|h => obj.Completed += h,|h => obj.Completed -= h,|() => Task.FromResult(0)|)|);|Assert.IsType<RaisesAnyException>(ex);|Assert.Equal(|\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(System.EventArgs)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new object();|var evt = await Assert.RaisesAnyAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandler();|var eventObj = new EventArgs();|var evt = await Assert.RaisesAnyAsync(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new DerivedObject();|var evt = await Assert.RaisesAnyAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandler();|var eventObj = new DerivedEventArgs();|var evt = await Assert.RaisesAnyAsync(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => Task.FromResult(0)|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_Action();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAsync(|h => obj.Completed += h,|h => obj.Completed -= h,|() => Task.CompletedTask|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(\"Assert.Raises() Failure: No event was raised\", ex.Message);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new object();|var evt = await Assert.RaisesAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Null(evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_ActionOfT();|var eventObj = new DerivedObject();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|$\"Actual: typeof({typeof(DerivedObject).FullName})\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|() => Task.FromResult(0)|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: No event was raised\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new object();|var evt = await Assert.RaisesAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|);|Assert.NotNull(evt);|Assert.Equal(obj, evt.Sender);|Assert.Equal(eventObj, evt.Arguments);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new RaisingClass_EventHandlerOfT();|var eventObj = new DerivedObject();|var ex = await Record.ExceptionAsync(|() => Assert.RaisesAsync<object>(|h => obj.Completed += h,|h => obj.Completed -= h,|#if XUNIT_V2|() => Task.Run(() => obj.RaiseWithArgs(eventObj))|#else|() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)|#endif|)|);|Assert.IsType<RaisesException>(ex);|Assert.Equal(|\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|$\"Actual: typeof({typeof(DerivedObject).FullName})\",|ex.Message|);|}"
      }
    ]
  },
  {
    "file": "ExceptionAssertsTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|void testCode() { }|Assert.Throws<ArgumentNullException>(\"exceptionType\", () => Assert.Throws(null!, testCode));|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws(typeof(Exception), default(Action)!));|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|void testCode() { }|var ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|void testCode() => throw new ArgumentException();|Assert.Throws(typeof(ArgumentException), testCode);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|var thrown = new ArgumentNullException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "GuardClauses",
        "body": "{|object testCode() => 42;|Assert.Throws<ArgumentNullException>(\"exceptionType\", () => Assert.Throws(null!, testCode));|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws(typeof(Exception), default(Func<object>)!));|}"
      },
      {
        "name": "ProtectsAgainstAccidentalTask",
        "body": "{|static object testCode() => Task.FromResult(42);|var ex = Record.Exception(() => Assert.Throws(typeof(Exception), testCode));|Assert.IsType<InvalidOperationException>(ex);|Assert.Equal(\"You must call Assert.ThrowsAsync when testing async code\", ex.Message);|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|object testCode() => 42;|var ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|object testCode() => throw new ArgumentException();|Assert.Throws(typeof(ArgumentException), testCode);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|var thrown = new ArgumentNullException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Action)!));|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|void testCode() { }|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|void testCode() => throw new ArgumentException();|Assert.Throws<ArgumentException>(testCode);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|var thrown = new ArgumentNullException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Func<object>)!));|}"
      },
      {
        "name": "ProtectsAgainstAccidentalTask",
        "body": "{|static object testCode() => Task.FromResult(42);|var ex = Record.Exception(() => Assert.Throws<Exception>(testCode));|Assert.IsType<InvalidOperationException>(ex);|Assert.Equal(\"You must call Assert.ThrowsAsync when testing async code\", ex.Message);|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|object testCode() => 42;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|object testCode() => throw new ArgumentException();|Assert.Throws<ArgumentException>(testCode);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|var thrown = new ArgumentNullException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Action)!));|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|void testCode() { }|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|void testCode() => throw new ArgumentException(\"Hello world\", \"paramName\");|Assert.Throws<ArgumentException>(\"paramName\", testCode);|}"
      },
      {
        "name": "IncorrectParameterName",
        "body": "{|void testCode() => throw new ArgumentException(\"Hello world\", \"paramName1\");|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName2\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Incorrect parameter name\" + Environment.NewLine +|\"Exception: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Expected: \\\"paramName2\\\"\" + Environment.NewLine +|\"Actual: \\\"paramName1\\\"\",|ex.Message|);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|var thrown = new ArgumentNullException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Func<object>)!));|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|object testCode() => 42;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|object testCode() => throw new ArgumentException(\"Hello world\", \"paramName\");|Assert.Throws<ArgumentException>(\"paramName\", testCode);|}"
      },
      {
        "name": "IncorrectParameterName",
        "body": "{|object testCode() => throw new ArgumentException(\"Hello world\", \"paramName1\");|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName2\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Incorrect parameter name\" + Environment.NewLine +|\"Exception: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Expected: \\\"paramName2\\\"\" + Environment.NewLine +|\"Actual: \\\"paramName1\\\"\",|ex.Message|);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|var thrown = new ArgumentNullException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAny<ArgumentException>(default(Action)!));|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|void testCode() { }|var ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));|Assert.IsType<ThrowsAnyException>(ex);|Assert.Equal(|\"Assert.ThrowsAny() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|void testCode() => throw new ArgumentException();|Assert.ThrowsAny<ArgumentException>(testCode);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|void testCode() => throw thrown;|var ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));|Assert.IsType<ThrowsAnyException>(ex);|Assert.Equal(|\"Assert.ThrowsAny() Failure: Exception type was not compatible\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|void testCode() => throw new ArgumentNullException();|Assert.ThrowsAny<ArgumentException>(testCode);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAny<ArgumentException>(default(Func<object>)!));|}"
      },
      {
        "name": "ProtectsAgainstAccidentalTask",
        "body": "{|static object testCode() => Task.FromResult(42);|var ex = Record.Exception(() => Assert.ThrowsAny<Exception>(testCode));|Assert.IsType<InvalidOperationException>(ex);|Assert.Equal(\"You must call Assert.ThrowsAnyAsync when testing async code\", ex.Message);|}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{|object testCode() => 42;|var ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));|Assert.IsType<ThrowsAnyException>(ex);|Assert.Equal(|\"Assert.ThrowsAny() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{|object testCode() => throw new ArgumentException();|Assert.ThrowsAny<ArgumentException>(testCode);|}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{|var thrown = new DivideByZeroException();|object testCode() => throw thrown;|var ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));|Assert.IsType<ThrowsAnyException>(ex);|Assert.Equal(|\"Assert.ThrowsAny() Failure: Exception type was not compatible\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{|object testCode() => throw new ArgumentNullException();|Assert.ThrowsAny<ArgumentException>(testCode);|}"
      },
      {
        "name": "Task",
        "body": "{|await Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAnyAsync<ArgumentException>(default(Func<Task>)!));|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => Task.FromResult(42);|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAnyAsync<ArgumentException>(testCode));|Assert.IsType<ThrowsAnyException>(ex);|Assert.Equal(|\"Assert.ThrowsAny() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => throw new ArgumentException();|await Assert.ThrowsAnyAsync<ArgumentException>(testCode);|}"
      },
      {
        "name": "Task",
        "body": "{|var thrown = new DivideByZeroException();|Task testCode() => throw thrown;|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAnyAsync<ArgumentException>(testCode));|Assert.IsType<ThrowsAnyException>(ex);|Assert.Equal(|\"Assert.ThrowsAny() Failure: Exception type was not compatible\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => throw new ArgumentNullException();|await Assert.ThrowsAnyAsync<ArgumentException>(testCode);|}"
      },
      {
        "name": "Task",
        "body": "{|await Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAsync<ArgumentException>(default(Func<Task>)!));|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => Task.FromResult(42);|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => throw new ArgumentException();|await Assert.ThrowsAsync<ArgumentException>(testCode);|}"
      },
      {
        "name": "Task",
        "body": "{|var thrown = new DivideByZeroException();|Task testCode() => throw thrown;|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|var thrown = new ArgumentNullException();|Task testCode() => throw thrown;|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|await Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAsync<ArgumentException>(\"paramName\", default(Func<Task>)!));|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => Task.FromResult(42);|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\",|ex.Message|);|Assert.Null(ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => throw new ArgumentException(\"Hello world\", \"paramName\");|await Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode);|}"
      },
      {
        "name": "Task",
        "body": "{|Task testCode() => throw new ArgumentException(\"Hello world\", \"paramName1\");|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName2\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Incorrect parameter name\" + Environment.NewLine +|\"Exception: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Expected: \\\"paramName2\\\"\" + Environment.NewLine +|\"Actual: \\\"paramName1\\\"\",|ex.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var thrown = new DivideByZeroException();|Task testCode() => throw thrown;|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.DivideByZeroException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      },
      {
        "name": "Task",
        "body": "{|var thrown = new ArgumentNullException();|Task testCode() => throw thrown;|var ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode));|Assert.IsType<ThrowsException>(ex);|Assert.Equal(|\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +|\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +|\"Actual: typeof(System.ArgumentNullException)\",|ex.Message|);|Assert.Same(thrown, ex.InnerException);|}"
      }
    ]
  },
  {
    "file": "FailAssertsTests.cs",
    "methods": [
      {
        "name": "WithoutMessage",
        "body": "{|var ex = Record.Exception(() => Assert.Fail());|Assert.IsType<FailException>(ex);|Assert.Equal(\"Assert.Fail() Failure\", ex.Message);|}"
      },
      {
        "name": "WithMessage",
        "body": "{|var ex = Record.Exception(() => Assert.Fail(\"This is a user message\"));|Assert.IsType<FailException>(ex);|Assert.Equal(\"This is a user message\", ex.Message);|}"
      }
    ]
  },
  {
    "file": "IdentityAssertsTests.cs",
    "methods": [
      {
        "name": "Identical",
        "body": "{|var actual = new object();|var ex = Record.Exception(() => Assert.NotSame(actual, actual));|Assert.IsType<NotSameException>(ex);|Assert.Equal(\"Assert.NotSame() Failure: Values are the same instance\", ex.Message);|}"
      },
      {
        "name": "NotIdentical",
        "body": "{|Assert.NotSame(\"bob\", \"jim\");|}"
      },
      {
        "name": "Identical",
        "body": "{|var actual = new object();|Assert.Same(actual, actual);|}"
      },
      {
        "name": "NotIdentical",
        "body": "{|var ex = Record.Exception(() => Assert.Same(\"bob\", \"jim\"));|Assert.IsType<SameException>(ex);|Assert.Equal(|\"Assert.Same() Failure: Values are not the same instance\" + Environment.NewLine +|\"Expected: \\\"bob\\\"\" + Environment.NewLine +|\"Actual: \\\"jim\\\"\",|ex.Message|);|}"
      },
      {
        "name": "EqualValueTypeValuesAreNotSameBecauseOfBoxing",
        "body": "{|#pragma warning disable xUnit2005 // Do not use identity check on value type|Assert.Throws<SameException>(() => Assert.Same(0, 0));|#pragma warning restore xUnit2005 // Do not use identity check on value type|}"
      }
    ]
  },
  {
    "file": "MultipleAssertsTests.cs",
    "methods": [
      {
        "name": "NoActions_DoesNotThrow",
        "body": "{|Assert.Multiple();|}"
      },
      {
        "name": "SingleAssert_Success_DoesNotThrow",
        "body": "{|Assert.Multiple(|() => Assert.True(true)|);|}"
      },
      {
        "name": "SingleAssert_Fails_ThrowsFailingAssert",
        "body": "{|var ex = Record.Exception(() =>|Assert.Multiple(|() => Assert.True(false)|)|);|Assert.IsType<TrueException>(ex);|}"
      },
      {
        "name": "MultipleAssert_Success_DoesNotThrow",
        "body": "{|Assert.Multiple(|() => Assert.True(true),|() => Assert.False(false)|);|}"
      },
      {
        "name": "MultipleAssert_SingleFailure_ThrowsFailingAssert",
        "body": "{|var ex = Record.Exception(() =>|Assert.Multiple(|() => Assert.True(true),|() => Assert.False(true)|)|);|Assert.IsType<FalseException>(ex);|}"
      },
      {
        "name": "MultipleAssert_MultipleFailures_ThrowsMultipleException",
        "body": "{|var ex = Record.Exception(() =>|Assert.Multiple(|() => Assert.True(false),|() => Assert.False(true)|)|);|var multiEx = Assert.IsType<MultipleException>(ex);|Assert.Equal(|\"Assert.Multiple() Failure: Multiple failures were encountered\",|ex.Message|);|Assert.Collection(|multiEx.InnerExceptions,|innerEx => Assert.IsType<TrueException>(innerEx),|innerEx => Assert.IsType<FalseException>(innerEx)|);|}"
      }
    ]
  },
  {
    "file": "NullAssertsTests.cs",
    "methods": [
      {
        "name": "Success_Reference",
        "body": "{|Assert.NotNull(new object());|}"
      },
      {
        "name": "Success_NullableStruct",
        "body": "{|int? x = 42;|var result = Assert.NotNull(x);|Assert.IsType<int>(result);|Assert.Equal(42, result);|}"
      },
      {
        "name": "Failure_Reference",
        "body": "{|var ex = Record.Exception(() => Assert.NotNull(null));|Assert.IsType<NotNullException>(ex);|Assert.Equal(\"Assert.NotNull() Failure: Value is null\", ex.Message);|}"
      },
      {
        "name": "Failure_NullableStruct",
        "body": "{|int? value = null;|var ex = Record.Exception(() => Assert.NotNull(value));|Assert.IsType<NotNullException>(ex);|Assert.Equal(\"Assert.NotNull() Failure: Value of type 'Nullable<int>' does not have a value\", ex.Message);|}"
      },
      {
        "name": "Success_Reference",
        "body": "{|Assert.Null(null);|}"
      },
      {
        "name": "Success_NullableStruct",
        "body": "{|int? x = null;|Assert.Null(x);|}"
      },
      {
        "name": "Failure_Reference",
        "body": "{|var ex = Record.Exception(() => Assert.Null(new object()));|Assert.IsType<NullException>(ex);|Assert.Equal(|\"Assert.Null() Failure: Value is not null\" + Environment.NewLine +|\"Expected: null\" + Environment.NewLine +|\"Actual: Object { }\",|ex.Message|);|}"
      },
      {
        "name": "Failure_NullableStruct",
        "body": "{|int? x = 42;|var ex = Record.Exception(() => Assert.Null(x));|Assert.IsType<NullException>(ex);|Assert.Equal(|\"Assert.Null() Failure: Value of type 'Nullable<int>' has a value\" + Environment.NewLine +|\"Expected: null\" + Environment.NewLine +|\"Actual: 42\",|ex.Message|);|}"
      }
    ]
  },
  {
    "file": "PropertyAssertsTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|Assert.Throws<ArgumentNullException>(\"object\", () => Assert.PropertyChanged(null!, \"propertyName\", delegate { }));|Assert.Throws<ArgumentNullException>(\"testCode\", () => Assert.PropertyChanged(Substitute.For<INotifyPropertyChanged>(), \"propertyName\", (Action)null!));|}"
      },
      {
        "name": "ExceptionThrownWhenPropertyNotChanged",
        "body": "{|var obj = new NotifiedClass();|var ex = Record.Exception(() => Assert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () => { }));|Assert.IsType<PropertyChangedException>(ex);|Assert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);|}"
      },
      {
        "name": "ExceptionThrownWhenWrongPropertyChanged",
        "body": "{|var obj = new NotifiedClass();|var ex = Record.Exception(() => Assert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () => obj.Property2 = 42));|Assert.IsType<PropertyChangedException>(ex);|Assert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);|}"
      },
      {
        "name": "NoExceptionThrownWhenPropertyChanged",
        "body": "{|var obj = new NotifiedClass();|Assert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () => obj.Property1 = \"NewValue\");|}"
      },
      {
        "name": "NoExceptionThrownWhenMultiplePropertyChangesIncludesCorrectProperty",
        "body": "{|var obj = new NotifiedClass();|Assert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () =>|{|obj.Property2 = 12;|obj.Property1 = \"New Value\";|obj.Property2 = 42;|});|}"
      },
      {
        "name": "Task",
        "body": "{|await Assert.ThrowsAsync<ArgumentNullException>(\"object\", () => Assert.PropertyChangedAsync(null!, \"propertyName\", () => Task.FromResult(0)));|await Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.PropertyChangedAsync(Substitute.For<INotifyPropertyChanged>(), \"propertyName\", default(Func<Task>)!));|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new NotifiedClass();|var ex = await Record.ExceptionAsync(() => Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), () => Task.FromResult(0)));|Assert.IsType<PropertyChangedException>(ex);|Assert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new NotifiedClass();|async Task setter() => obj!.Property2 = 42;|var ex = await Record.ExceptionAsync(() => Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), setter));|Assert.IsType<PropertyChangedException>(ex);|Assert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new NotifiedClass();|async Task setter() => obj!.Property1 = \"NewValue\";|await Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), setter);|}"
      },
      {
        "name": "Task",
        "body": "{|var obj = new NotifiedClass();|async Task setter()|{|obj.Property2 = 12;|obj.Property1 = \"New Value\";|obj.Property2 = 42;|}|await Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), setter);|}"
      }
    ]
  },
  {
    "file": "RangeAssertsTests.cs",
    "methods": [
      {
        "name": "DoubleValueWithinRange",
        "body": "{|Assert.InRange(1.0, .75, 1.25);|}"
      },
      {
        "name": "IntNotWithinRangeWithZeroActual",
        "body": "{|var ex = Record.Exception(() => Assert.InRange(0, 1, 2));|Assert.IsType<InRangeException>(ex);|Assert.Equal(|\"Assert.InRange() Failure: Value not in range\" + Environment.NewLine +|\"Range: (1 - 2)\" + Environment.NewLine +|\"Actual: 0\",|ex.Message|);|}"
      },
      {
        "name": "IntNotWithinRangeWithZeroMinimum",
        "body": "{|var ex = Record.Exception(() => Assert.InRange(2, 0, 1));|Assert.IsType<InRangeException>(ex);|Assert.Equal(|\"Assert.InRange() Failure: Value not in range\" + Environment.NewLine +|\"Range: (0 - 1)\" + Environment.NewLine +|\"Actual: 2\",|ex.Message|);|}"
      },
      {
        "name": "IntValueWithinRange",
        "body": "{|Assert.InRange(2, 1, 3);|}"
      },
      {
        "name": "StringNotWithinRange",
        "body": "{|var ex = Record.Exception(() => Assert.InRange(\"adam\", \"bob\", \"scott\"));|Assert.IsType<InRangeException>(ex);|Assert.Equal(|\"Assert.InRange() Failure: Value not in range\" + Environment.NewLine +|\"Range: (\\\"bob\\\" - \\\"scott\\\")\" + Environment.NewLine +|\"Actual: \\\"adam\\\"\",|ex.Message|);|}"
      },
      {
        "name": "StringValueWithinRange",
        "body": "{|Assert.InRange(\"bob\", \"adam\", \"scott\");|}"
      },
      {
        "name": "DoubleValueWithinRange",
        "body": "{|Assert.InRange(400.0, .75, 1.25, new DoubleComparer(-1));|}"
      },
      {
        "name": "DoubleNotWithinRange",
        "body": "{|Assert.NotInRange(1.50, .75, 1.25);|}"
      },
      {
        "name": "DoubleWithinRange",
        "body": "{|var ex = Record.Exception(() => Assert.NotInRange(1.0, .75, 1.25));|Assert.IsType<NotInRangeException>(ex);|Assert.Equal(|\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +|\"Range: (0.75 - 1.25)\" + Environment.NewLine +|\"Actual: 1\",|ex.Message|);|}"
      },
      {
        "name": "IntNotWithinRange",
        "body": "{|Assert.NotInRange(1, 2, 3);|}"
      },
      {
        "name": "IntWithinRange",
        "body": "{|var ex = Record.Exception(() => Assert.NotInRange(2, 1, 3));|Assert.IsType<NotInRangeException>(ex);|Assert.Equal(|\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +|\"Range: (1 - 3)\" + Environment.NewLine +|\"Actual: 2\",|ex.Message|);|}"
      },
      {
        "name": "StringNotWithNotInRange",
        "body": "{|Assert.NotInRange(\"adam\", \"bob\", \"scott\");|}"
      },
      {
        "name": "StringWithNotInRange",
        "body": "{|var ex = Record.Exception(() => Assert.NotInRange(\"bob\", \"adam\", \"scott\"));|Assert.IsType<NotInRangeException>(ex);|Assert.Equal(|\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +|\"Range: (\\\"adam\\\" - \\\"scott\\\")\" + Environment.NewLine +|\"Actual: \\\"bob\\\"\",|ex.Message|);|}"
      },
      {
        "name": "DoubleValueWithinRange",
        "body": "{|var ex = Record.Exception(() => Assert.NotInRange(400.0, .75, 1.25, new DoubleComparer(-1)));|Assert.IsType<NotInRangeException>(ex);|Assert.Equal(|\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +|\"Range: (0.75 - 1.25)\" + Environment.NewLine +|\"Actual: 400\",|ex.Message|);|}"
      },
      {
        "name": "DoubleValueNotWithinRange",
        "body": "{|Assert.NotInRange(1.0, .75, 1.25, new DoubleComparer(1));|}"
      }
    ]
  },
  {
    "file": "ArgumentFormatterTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{|#if XUNIT_V2|var task = Task.Run(() => { });|#else|var task = Task.Run(() => { }, TestContext.Current.CancellationToken);|#endif|await task;|Assert.Equal(\"Task { Status = RanToCompletion }\", ArgumentFormatter.Format(task));|}"
      },
      {
        "name": "TaskGenericValue",
        "body": "{|var taskCompletionSource = new TaskCompletionSource<int>();|taskCompletionSource.SetException(new DivideByZeroException());|Assert.Equal(\"Task<int> { Status = Faulted }\", ArgumentFormatter.Format(taskCompletionSource.Task));|}"
      },
      {
        "name": "GroupingIsRenderedAsCollectionsOfKeysLinkedToCollectionsOfValues",
        "body": "{|var grouping = Enumerable.Range(0, 10).GroupBy(i => i % 2 == 0).FirstOrDefault(g => g.Key == true);|Assert.Equal(\"[True] = [0, 2, 4, 6, 8]\", ArgumentFormatter.Format(grouping));|}"
      },
      {
        "name": "GroupingsAreRenderedAsCollectionsOfKeysLinkedToCollectionsOfValues",
        "body": "{|var grouping = Enumerable.Range(0, 10).GroupBy(i => i % 2 == 0);|Assert.Equal(\"[[True] = [0, 2, 4, 6, 8], [False] = [1, 3, 5, 7, 9]]\", ArgumentFormatter.Format(grouping));|}"
      },
      {
        "name": "WhenCustomTypeImplementsToString_UsesToString",
        "body": "{|Assert.Equal(\"This is what you should show\", ArgumentFormatter.Format(new TypeWithToString()));|}"
      },
      {
        "name": "ArgumentFormatterFormatTypeNameGenericTypeParameter",
        "body": "{|var genericTypeParameters = typeof(List<>).GetGenericArguments();|var parameterType = genericTypeParameters.First();|Assert.Equal(\"typeof(T)\", ArgumentFormatter.Format(parameterType));|}"
      },
      {
        "name": "ArgumentFormatterFormatTypeNameGenericTypeParameters",
        "body": "{|var genericTypeParameters = typeof(Dictionary<,>).GetGenericArguments();|var parameterTKey = genericTypeParameters.First();|Assert.Equal(\"typeof(TKey)\", ArgumentFormatter.Format(parameterTKey));|var parameterTValue = genericTypeParameters.Last();|Assert.Equal(\"typeof(TValue)\", ArgumentFormatter.Format(parameterTValue));|}"
      }
    ]
  },
  {
    "file": "CollectionTrackerTests.cs",
    "methods": [
      {
        "name": "ExceededDepth",
        "body": "{|var tracker = new[] { 42, 2112 }.AsTracker();|var result = tracker.FormatIndexedMismatch(2600, out var pointerIndent, ArgumentFormatter.MAX_DEPTH);|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", result);|// - ^|Assert.Equal(1, pointerIndent);|}"
      },
      {
        "name": "SmallCollection_Start",
        "body": "{|var tracker = new[] { 42, 2112 }.AsTracker();|var result = tracker.FormatIndexedMismatch(0, out var pointerIndent);|Assert.Equal(\"[42, 2112]\", result);|// -^|Assert.Equal(1, pointerIndent);|}"
      },
      {
        "name": "LargeCollection_Start",
        "body": "{|var tracker = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsTracker();|var result = tracker.FormatIndexedMismatch(1, out var pointerIndent);|Assert.Equal($\"[1, 2, 3, 4, 5, {ArgumentFormatter.Ellipsis}]\", result);|// ----^|Assert.Equal(4, pointerIndent);|}"
      },
      {
        "name": "LargeCollection_Mid",
        "body": "{|var tracker = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsTracker();|var result = tracker.FormatIndexedMismatch(3, out var pointerIndent);|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}, 2, 3, 4, 5, 6, {ArgumentFormatter.Ellipsis}]\", result);|// - --- |----|--^|Assert.Equal(12, pointerIndent);|}"
      },
      {
        "name": "LargeCollection_End",
        "body": "{|var tracker = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsTracker();|var result = tracker.FormatIndexedMismatch(6, out var pointerIndent);|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}, 3, 4, 5, 6, 7]\", result);|// - --- |----|----|---^|Assert.Equal(18, pointerIndent);|}"
      },
      {
        "name": "ExceededDepth",
        "body": "{|var span = new[] { 42, 2112 }.AsSpan();|var result = CollectionTracker<int>.FormatIndexedMismatch(span, 2600, out var pointerIndent, ArgumentFormatter.MAX_DEPTH);|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", result);|// - ^|Assert.Equal(1, pointerIndent);|}"
      },
      {
        "name": "SmallCollection_Start",
        "body": "{|var span = new[] { 42, 2112 }.AsSpan();|var result = CollectionTracker<int>.FormatIndexedMismatch(span, 0, out var pointerIndent);|Assert.Equal(\"[42, 2112]\", result);|// -^|Assert.Equal(1, pointerIndent);|}"
      },
      {
        "name": "LargeCollection_Start",
        "body": "{|var span = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsSpan();|var result = CollectionTracker<int>.FormatIndexedMismatch(span, 1, out var pointerIndent);|Assert.Equal($\"[1, 2, 3, 4, 5, {ArgumentFormatter.Ellipsis}]\", result);|// ----^|Assert.Equal(4, pointerIndent);|}"
      },
      {
        "name": "LargeCollection_Mid",
        "body": "{|var span = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsSpan();|var result = CollectionTracker<int>.FormatIndexedMismatch(span, 3, out var pointerIndent);|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}, 2, 3, 4, 5, 6, {ArgumentFormatter.Ellipsis}]\", result);|// - --- |----|--^|Assert.Equal(12, pointerIndent);|}"
      },
      {
        "name": "LargeCollection_End",
        "body": "{|var span = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsSpan();|var result = CollectionTracker<int>.FormatIndexedMismatch(span, 6, out var pointerIndent);|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}, 3, 4, 5, 6, 7]\", result);|// - --- |----|----|---^|Assert.Equal(18, pointerIndent);|}"
      },
      {
        "name": "Empty",
        "body": "{|var tracker = new object[0].AsTracker();|Assert.Equal(\"[]\", tracker.FormatStart());|}"
      },
      {
        "name": "ExceededDepth",
        "body": "{|var tracker = new object[0].AsTracker();|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", tracker.FormatStart(ArgumentFormatter.MAX_DEPTH));|}"
      },
      {
        "name": "Empty",
        "body": "{|IEnumerable<object> collection = new object[0];|Assert.Equal(\"[]\", CollectionTracker<object>.FormatStart(collection));|}"
      },
      {
        "name": "ExceededDepth",
        "body": "{|IEnumerable<object> collection = new object[0];|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", CollectionTracker<object>.FormatStart(collection, ArgumentFormatter.MAX_DEPTH));|}"
      },
      {
        "name": "Empty",
        "body": "{|var span = new object[0].AsSpan();|Assert.Equal(\"[]\", CollectionTracker<object>.FormatStart(span));|}"
      },
      {
        "name": "ExceededDepth",
        "body": "{|var span = new object[0].AsSpan();|Assert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", CollectionTracker<object>.FormatStart(span, ArgumentFormatter.MAX_DEPTH));|}"
      }
    ]
  },
  {
    "file": "SetAssertsTests.cs",
    "methods": [
      {
        "name": "ValueInSet",
        "body": "{|var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"forty-two\" };|Assert.Contains(\"FORTY-two\", set);|Assert.Contains(\"FORTY-two\", (ISet<string>)set);|Assert.Contains(\"FORTY-two\", set.ToSortedSet(StringComparer.OrdinalIgnoreCase));|#if NET5_0_OR_GREATER|Assert.Contains(\"FORTY-two\", (IReadOnlySet<string>)set);|#endif|#if XUNIT_IMMUTABLE_COLLECTIONS|Assert.Contains(\"FORTY-two\", set.ToImmutableHashSet(StringComparer.OrdinalIgnoreCase));|Assert.Contains(\"FORTY-two\", set.ToImmutableSortedSet(StringComparer.OrdinalIgnoreCase));|#endif|}"
      },
      {
        "name": "ValueNotInSet",
        "body": "{|var set = new HashSet<string>() { \"eleventeen\" };|void assertFailure(Action action)|{|var ex = Record.Exception(action);|Assert.IsType<ContainsException>(ex);|Assert.Equal(|\"Assert.Contains() Failure: Item not found in set\" + Environment.NewLine +|\"Set: [\\\"eleventeen\\\"]\" + Environment.NewLine +|\"Not found: \\\"FORTY-two\\\"\",|ex.Message|);|}|assertFailure(() => Assert.Contains(\"FORTY-two\", set));|assertFailure(() => Assert.Contains(\"FORTY-two\", (ISet<string>)set));|assertFailure(() => Assert.Contains(\"FORTY-two\", set.ToSortedSet()));|#if NET5_0_OR_GREATER|assertFailure(() => Assert.Contains(\"FORTY-two\", (IReadOnlySet<string>)set));|#endif|#if XUNIT_IMMUTABLE_COLLECTIONS|assertFailure(() => Assert.Contains(\"FORTY-two\", set.ToImmutableHashSet()));|assertFailure(() => Assert.Contains(\"FORTY-two\", set.ToImmutableSortedSet()));|#endif|}"
      },
      {
        "name": "ValueNotInSet",
        "body": "{|var set = new HashSet<string>() { \"eleventeen\" };|Assert.DoesNotContain(\"FORTY-two\", set);|Assert.DoesNotContain(\"FORTY-two\", (ISet<string>)set);|Assert.DoesNotContain(\"FORTY-two\", set.ToSortedSet());|#if NET5_0_OR_GREATER|Assert.DoesNotContain(\"FORTY-two\", (IReadOnlySet<string>)set);|#endif|#if XUNIT_IMMUTABLE_COLLECTIONS|Assert.DoesNotContain(\"FORTY-two\", set.ToImmutableHashSet());|Assert.DoesNotContain(\"FORTY-two\", set.ToImmutableSortedSet());|#endif|}"
      },
      {
        "name": "ValueInSet",
        "body": "{|var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"forty-two\" };|void assertFailure(Action action)|{|var ex = Record.Exception(action);|Assert.IsType<DoesNotContainException>(ex);|Assert.Equal(|\"Assert.DoesNotContain() Failure: Item found in set\" + Environment.NewLine +|\"Set: [\\\"forty-two\\\"]\" + Environment.NewLine +|\"Found: \\\"FORTY-two\\\"\",|ex.Message|);|}|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (ISet<string>)set));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set.ToSortedSet(StringComparer.OrdinalIgnoreCase)));|#if NET5_0_OR_GREATER|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IReadOnlySet<string>)set));|#endif|#if XUNIT_IMMUTABLE_COLLECTIONS|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set.ToImmutableHashSet(StringComparer.OrdinalIgnoreCase)));|assertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set.ToImmutableSortedSet(StringComparer.OrdinalIgnoreCase)));|#endif|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"expectedSubset\", () => Assert.ProperSubset(null!, new HashSet<int>()));|}"
      },
      {
        "name": "IsSubsetButNotProperSubset",
        "body": "{|var expectedSubset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 3 };|var ex = Record.Exception(() => Assert.ProperSubset(expectedSubset, actual));|Assert.IsType<ProperSubsetException>(ex);|Assert.Equal(|\"Assert.ProperSubset() Failure: Value is not a proper subset\" + Environment.NewLine +|\"Expected: [1, 2, 3]\" + Environment.NewLine +|\"Actual: [1, 2, 3]\",|ex.Message|);|}"
      },
      {
        "name": "IsProperSubset",
        "body": "{|var expectedSubset = new HashSet<int> { 1, 2, 3, 4 };|var actual = new HashSet<int> { 1, 2, 3 };|Assert.ProperSubset(expectedSubset, actual);|}"
      },
      {
        "name": "IsNotSubset",
        "body": "{|var expectedSubset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 7 };|var ex = Record.Exception(() => Assert.ProperSubset(expectedSubset, actual));|Assert.IsType<ProperSubsetException>(ex);|Assert.Equal(|\"Assert.ProperSubset() Failure: Value is not a proper subset\" + Environment.NewLine +|\"Expected: [1, 2, 3]\" + Environment.NewLine +|\"Actual: [1, 2, 7]\",|ex.Message|);|}"
      },
      {
        "name": "NullActual",
        "body": "{|var ex = Record.Exception(() => Assert.ProperSubset(new HashSet<int>(), null));|Assert.IsType<ProperSubsetException>(ex);|Assert.Equal(|\"Assert.ProperSubset() Failure: Value is not a proper subset\" + Environment.NewLine +|\"Expected: []\" + Environment.NewLine +|\"Actual: null\",|ex.Message|);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"expectedSuperset\", () => Assert.ProperSuperset(null!, new HashSet<int>()));|}"
      },
      {
        "name": "IsSupersetButNotProperSuperset",
        "body": "{|var expectedSuperset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 3 };|var ex = Record.Exception(() => Assert.ProperSuperset(expectedSuperset, actual));|Assert.IsType<ProperSupersetException>(ex);|Assert.Equal(|\"Assert.ProperSuperset() Failure: Value is not a proper superset\" + Environment.NewLine +|\"Expected: [1, 2, 3]\" + Environment.NewLine +|\"Actual: [1, 2, 3]\",|ex.Message|);|}"
      },
      {
        "name": "IsProperSuperset",
        "body": "{|var expectedSuperset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 3, 4 };|Assert.ProperSuperset(expectedSuperset, actual);|}"
      },
      {
        "name": "IsNotSuperset",
        "body": "{|var expectedSuperset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 7 };|var ex = Record.Exception(() => Assert.ProperSuperset(expectedSuperset, actual));|Assert.IsType<ProperSupersetException>(ex);|Assert.Equal(|\"Assert.ProperSuperset() Failure: Value is not a proper superset\" + Environment.NewLine +|\"Expected: [1, 2, 3]\" + Environment.NewLine +|\"Actual: [1, 2, 7]\",|ex.Message|);|}"
      },
      {
        "name": "NullActual",
        "body": "{|var ex = Record.Exception(() => Assert.ProperSuperset(new HashSet<int>(), null));|Assert.IsType<ProperSupersetException>(ex);|Assert.Equal(|\"Assert.ProperSuperset() Failure: Value is not a proper superset\" + Environment.NewLine +|\"Expected: []\" + Environment.NewLine +|\"Actual: null\",|ex.Message|);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"expectedSubset\", () => Assert.Subset(null!, new HashSet<int>()));|}"
      },
      {
        "name": "IsSubset",
        "body": "{|var expectedSubset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 3 };|Assert.Subset(expectedSubset, actual);|}"
      },
      {
        "name": "IsProperSubset",
        "body": "{|var expectedSubset = new HashSet<int> { 1, 2, 3, 4 };|var actual = new HashSet<int> { 1, 2, 3 };|Assert.Subset(expectedSubset, actual);|}"
      },
      {
        "name": "IsNotSubset",
        "body": "{|var expectedSubset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 7 };|var ex = Record.Exception(() => Assert.Subset(expectedSubset, actual));|Assert.IsType<SubsetException>(ex);|Assert.Equal(|\"Assert.Subset() Failure: Value is not a subset\" + Environment.NewLine +|\"Expected: [1, 2, 3]\" + Environment.NewLine +|\"Actual: [1, 2, 7]\",|ex.Message|);|}"
      },
      {
        "name": "NullActual",
        "body": "{|var ex = Record.Exception(() => Assert.Subset(new HashSet<int>(), null));|Assert.IsType<SubsetException>(ex);|Assert.Equal(|\"Assert.Subset() Failure: Value is not a subset\" + Environment.NewLine +|\"Expected: []\" + Environment.NewLine +|\"Actual: null\",|ex.Message|);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"expectedSuperset\", () => Assert.Superset(null!, new HashSet<int>()));|}"
      },
      {
        "name": "IsSuperset",
        "body": "{|var expectedSuperset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 3 };|Assert.Superset(expectedSuperset, actual);|}"
      },
      {
        "name": "IsProperSuperset",
        "body": "{|var expectedSuperset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 3, 4 };|Assert.Superset(expectedSuperset, actual);|}"
      },
      {
        "name": "IsNotSuperset",
        "body": "{|var expectedSuperset = new HashSet<int> { 1, 2, 3 };|var actual = new HashSet<int> { 1, 2, 7 };|var ex = Assert.Throws<SupersetException>(() => Assert.Superset(expectedSuperset, actual));|Assert.Equal(|\"Assert.Superset() Failure: Value is not a superset\" + Environment.NewLine +|\"Expected: [1, 2, 3]\" + Environment.NewLine +|\"Actual: [1, 2, 7]\",|ex.Message|);|}"
      },
      {
        "name": "NullActual",
        "body": "{|var ex = Record.Exception(() => Assert.Superset(new HashSet<int>(), null));|Assert.IsType<SupersetException>(ex);|Assert.Equal(|\"Assert.Superset() Failure: Value is not a superset\" + Environment.NewLine +|\"Expected: []\" + Environment.NewLine +|\"Actual: null\",|ex.Message|);|}"
      }
    ]
  },
  {
    "file": "TypeAssertsTests.cs",
    "methods": [
      {
        "name": "NullObject",
        "body": "{|var result = Record.Exception(() => Assert.IsAssignableFrom<object>(null));|Assert.IsType<IsAssignableFromException>(result);|Assert.Equal(|\"Assert.IsAssignableFrom() Failure: Value is null\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: null\",|result.Message|);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsAssignableFrom<InvalidCastException>(ex);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsAssignableFrom<Exception>(ex);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|Assert.IsAssignableFrom<IDisposable>(ex);|}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{|var ex = new InvalidCastException();|var result = Assert.IsAssignableFrom<InvalidCastException>(ex);|Assert.Same(ex, result);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|var result =|Record.Exception(|() => Assert.IsAssignableFrom<InvalidCastException>(new InvalidOperationException())|);|Assert.IsType<IsAssignableFromException>(result);|Assert.Equal(|\"Assert.IsAssignableFrom() Failure: Value is an incompatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidOperationException)\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|var result = Record.Exception(() => Assert.IsAssignableFrom(typeof(object), null));|Assert.IsType<IsAssignableFromException>(result);|Assert.Equal(|\"Assert.IsAssignableFrom() Failure: Value is null\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: null\",|result.Message|);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsAssignableFrom(typeof(InvalidCastException), ex);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsAssignableFrom(typeof(Exception), ex);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|Assert.IsAssignableFrom(typeof(IDisposable), ex);|}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{|var ex = new InvalidCastException();|var result = Assert.IsAssignableFrom<InvalidCastException>(ex);|Assert.Same(ex, result);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|var result =|Record.Exception(|() => Assert.IsAssignableFrom(typeof(InvalidCastException), new InvalidOperationException())|);|Assert.IsType<IsAssignableFromException>(result);|Assert.Equal(|\"Assert.IsAssignableFrom() Failure: Value is an incompatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidOperationException)\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|Assert.IsNotAssignableFrom<object>(null);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotAssignableFrom<InvalidCastException>(ex));|Assert.IsType<IsNotAssignableFromException>(result);|Assert.Equal(|\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotAssignableFrom<Exception>(ex));|Assert.IsType<IsNotAssignableFromException>(result);|Assert.Equal(|\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.Exception)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|var result = Record.Exception(() => Assert.IsNotAssignableFrom<IDisposable>(ex));|Assert.IsType<IsNotAssignableFromException>(result);|Assert.Equal(|\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +|\"Actual: typeof(TypeAssertsTests+DisposableClass)\",|result.Message|);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|Assert.IsNotAssignableFrom<InvalidCastException>(new InvalidOperationException());|}"
      },
      {
        "name": "NullObject",
        "body": "{|Assert.IsNotAssignableFrom(typeof(object), null);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotAssignableFrom(typeof(InvalidCastException), ex));|Assert.IsType<IsNotAssignableFromException>(result);|Assert.Equal(|\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotAssignableFrom(typeof(Exception), ex));|Assert.IsType<IsNotAssignableFromException>(result);|Assert.Equal(|\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.Exception)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|var result = Record.Exception(() => Assert.IsNotAssignableFrom(typeof(IDisposable), ex));|Assert.IsType<IsNotAssignableFromException>(result);|Assert.Equal(|\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +|\"Actual: typeof(TypeAssertsTests+DisposableClass)\",|result.Message|);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|Assert.IsNotAssignableFrom(typeof(InvalidCastException), new InvalidOperationException());|}"
      },
      {
        "name": "UnmatchedType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsNotType<Exception>(ex);|}"
      },
      {
        "name": "MatchedType",
        "body": "{|var result = Record.Exception(() => Assert.IsNotType<InvalidCastException>(new InvalidCastException()));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal(|\"Assert.IsNotType() Failure: Value is the exact type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|Assert.IsNotType<object>(null);|}"
      },
      {
        "name": "NullObject",
        "body": "{|Assert.IsNotType<object>(null, exactMatch: false);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotType<InvalidCastException>(ex, exactMatch: false));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal<object>(|\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotType<Exception>(ex, exactMatch: false));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal<object>(|\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.Exception)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|#pragma warning disable xUnit2018 // TODO: Temporary until xUnit2018 is updated for the new signatures|var result = Record.Exception(() => Assert.IsNotType<IDisposable>(ex, exactMatch: false));|#pragma warning restore xUnit2018|Assert.IsType<IsNotTypeException>(result);|Assert.Equal<object>(|\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +|\"Actual: typeof(TypeAssertsTests+DisposableClass)\",|result.Message|);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|Assert.IsNotType<InvalidCastException>(new InvalidOperationException(), exactMatch: false);|}"
      },
      {
        "name": "UnmatchedType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsNotType(typeof(Exception), ex);|}"
      },
      {
        "name": "MatchedType",
        "body": "{|var result = Record.Exception(() => Assert.IsNotType(typeof(InvalidCastException), new InvalidCastException()));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal(|\"Assert.IsNotType() Failure: Value is the exact type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|Assert.IsNotType(typeof(object), null);|}"
      },
      {
        "name": "NullObject",
        "body": "{|Assert.IsNotType(typeof(object), null, exactMatch: false);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotType(typeof(InvalidCastException), ex, exactMatch: false));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal(|\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|var result = Record.Exception(() => Assert.IsNotType(typeof(Exception), ex, exactMatch: false));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal(|\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.Exception)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidCastException)\",|result.Message|);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|var result = Record.Exception(() => Assert.IsNotType(typeof(IDisposable), ex, exactMatch: false));|Assert.IsType<IsNotTypeException>(result);|Assert.Equal(|\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +|\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +|\"Actual: typeof(TypeAssertsTests+DisposableClass)\",|result.Message|);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|Assert.IsNotType(typeof(InvalidCastException), new InvalidOperationException(), exactMatch: false);|}"
      },
      {
        "name": "MatchingType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsType<InvalidCastException>(ex);|}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{|var ex = new InvalidCastException();|var result = Assert.IsType<InvalidCastException>(ex);|Assert.Same(ex, result);|}"
      },
      {
        "name": "UnmatchedType",
        "body": "{|var result = Record.Exception(() => Assert.IsType<InvalidCastException>(new InvalidOperationException()));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidOperationException)\",|result.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var dynamicAssembly = await CSharpDynamicAssembly.Create(\"namespace System.Xml { public class XmlException: Exception { } }\");|var assembly = Assembly.LoadFile(dynamicAssembly.FileName);|var dynamicXmlExceptionType = assembly.GetType(\"System.Xml.XmlException\");|Assert.NotNull(dynamicXmlExceptionType);|var ex = Activator.CreateInstance(dynamicXmlExceptionType);|var result = Record.Exception(() => Assert.IsType<XmlException>(ex));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +|\"Expected: typeof(System.Xml.XmlException) (from \" + typeof(XmlException).Assembly.FullName + \")\" + Environment.NewLine +|\"Actual: typeof(System.Xml.XmlException) (from \" + assembly.FullName + \")\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|var result = Record.Exception(() => Assert.IsType<object>(null));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: null\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|var result = Record.Exception(() => Assert.IsType<object>(null, exactMatch: false));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: null\",|result.Message|);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsType<InvalidCastException>(ex, exactMatch: false);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsType<Exception>(ex, exactMatch: false);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|#pragma warning disable xUnit2018 // TODO: Temporary until xUnit2018 is updated for the new signatures|Assert.IsType<IDisposable>(ex, exactMatch: false);|#pragma warning restore xUnit2018|}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{|var ex = new InvalidCastException();|var result = Assert.IsType<InvalidCastException>(ex, exactMatch: false);|Assert.Same(ex, result);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|var result =|Record.Exception(|() => Assert.IsType<InvalidCastException>(new InvalidOperationException(), exactMatch: false)|);|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is an incompatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidOperationException)\",|result.Message|);|}"
      },
      {
        "name": "MatchingType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsType(typeof(InvalidCastException), ex);|}"
      },
      {
        "name": "UnmatchedTypeThrows",
        "body": "{|var result = Record.Exception(() => Assert.IsType(typeof(InvalidCastException), new InvalidOperationException()));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidOperationException)\",|result.Message|);|}"
      },
      {
        "name": "Task",
        "body": "{|var dynamicAssembly = await CSharpDynamicAssembly.Create(\"namespace System.Xml { public class XmlException: Exception { } }\");|var assembly = Assembly.LoadFile(dynamicAssembly.FileName);|var dynamicXmlExceptionType = assembly.GetType(\"System.Xml.XmlException\");|Assert.NotNull(dynamicXmlExceptionType);|var ex = Activator.CreateInstance(dynamicXmlExceptionType);|var result = Record.Exception(() => Assert.IsType(typeof(XmlException), ex));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +|\"Expected: typeof(System.Xml.XmlException) (from \" + typeof(XmlException).Assembly.FullName + \")\" + Environment.NewLine +|\"Actual: typeof(System.Xml.XmlException) (from \" + assembly.FullName + \")\",|result.Message|);|}"
      },
      {
        "name": "NullObjectThrows",
        "body": "{|var result = Record.Exception(() => Assert.IsType(typeof(object), null));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: null\",|result.Message|);|}"
      },
      {
        "name": "NullObject",
        "body": "{|var result = Record.Exception(() => Assert.IsType(typeof(object), null, exactMatch: false));|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +|\"Expected: typeof(object)\" + Environment.NewLine +|\"Actual: null\",|result.Message|);|}"
      },
      {
        "name": "SameType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsType(typeof(InvalidCastException), ex, exactMatch: false);|}"
      },
      {
        "name": "BaseType",
        "body": "{|var ex = new InvalidCastException();|Assert.IsType(typeof(Exception), ex, exactMatch: false);|}"
      },
      {
        "name": "Interface",
        "body": "{|var ex = new DisposableClass();|Assert.IsType(typeof(IDisposable), ex, exactMatch: false);|}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{|var ex = new InvalidCastException();|var result = Assert.IsType<InvalidCastException>(ex, exactMatch: false);|Assert.Same(ex, result);|}"
      },
      {
        "name": "IncompatibleType",
        "body": "{|var result =|Record.Exception(|() => Assert.IsType(typeof(InvalidCastException), new InvalidOperationException(), exactMatch: false)|);|Assert.IsType<IsTypeException>(result);|Assert.Equal(|\"Assert.IsType() Failure: Value is an incompatible type\" + Environment.NewLine +|\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +|\"Actual: typeof(System.InvalidOperationException)\",|result.Message|);|}"
      }
    ]
  },
  {
    "file": "IAssemblyMetadataExtensionsTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|Assert.Throws<ArgumentNullException>(\"assemblyMetadata\", () => IAssemblyMetadataExtensions.SimpleAssemblyName(null!));|var metadata = Substitute.For<IAssemblyMetadata, InterfaceProxy<IAssemblyMetadata>>();|metadata.AssemblyName.Returns(default(string));|Assert.Throws<ArgumentNullException>(\"assemblyMetadata.AssemblyName\", () => IAssemblyMetadataExtensions.SimpleAssemblyName(metadata));|}"
      },
      {
        "name": "ReturnsSimpleName",
        "body": "{|var metadata = Mocks.AssemblyMetadata(\"mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\");|var result = IAssemblyMetadataExtensions.SimpleAssemblyName(metadata);|Assert.Equal(\"mscorlib\", result);|}"
      }
    ]
  },
  {
    "file": "ReflectionExtensionsTests.cs",
    "methods": [
      {
        "name": "GetDefaultValue",
        "body": "{|Assert.Null(typeof(object).GetDefaultValue());|Assert.Equal(0, typeof(int).GetDefaultValue());|}"
      },
      {
        "name": "ForAssembly",
        "body": "{|var attrs = typeof(ReflectionExtensionsTests).Assembly.GetMatchingCustomAttributes(typeof(IAttributeUnderTest));|Assert.Contains(attrs, attr => attr is AttributeUnderTest);|#if !NETFRAMEWORK|Assert.Contains(attrs, attr => attr is AttributeUnderTest<int>);|#endif|}"
      },
      {
        "name": "ForAttribute",
        "body": "{|var attrs = new AttributeWithAttribute().GetMatchingCustomAttributes(typeof(IAttributeUnderTest));|Assert.Contains(attrs, attr => attr is AttributeUnderTest);|#if !NETFRAMEWORK|Assert.Contains(attrs, attr => attr is AttributeUnderTest<int>);|#endif|}"
      },
      {
        "name": "ForMethod",
        "body": "{|var attrs = typeof(GetMatchingCustomAttributes).GetMethod(nameof(MethodWithAttribute), BindingFlags.NonPublic | BindingFlags.Static)?.GetMatchingCustomAttributes(typeof(IAttributeUnderTest)) ?? [];|Assert.Contains(attrs, attr => attr is AttributeUnderTest);|#if !NETFRAMEWORK|Assert.Contains(attrs, attr => attr is AttributeUnderTest<int>);|#endif|}"
      },
      {
        "name": "ForParameter",
        "body": "{|var method = typeof(GetMatchingCustomAttributes).GetMethod(nameof(MethodWithParameter), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var attrs = method.GetParameters()[0].GetMatchingCustomAttributes(typeof(IAttributeUnderTest));|Assert.Contains(attrs, attr => attr is AttributeUnderTest);|#if !NETFRAMEWORK|Assert.Contains(attrs, attr => attr is AttributeUnderTest<int>);|#endif|}"
      },
      {
        "name": "ForType",
        "body": "{|var attrs = typeof(ClassWithAttribute).GetMatchingCustomAttributes(typeof(IAttributeUnderTest));|Assert.Contains(attrs, attr => attr is AttributeUnderTest);|#if !NETFRAMEWORK|Assert.Contains(attrs, attr => attr is AttributeUnderTest<int>);|#endif|}"
      },
      {
        "name": "Implements",
        "body": "{|Assert.True(typeof(string).Implements(typeof(IEnumerable<char>)));|Assert.True(typeof(IEnumerable<>).Implements(typeof(IEnumerable)));|Assert.True(typeof(IEnumerable<int>).Implements(typeof(IEnumerable)));|Assert.False(typeof(object).Implements(typeof(IEnumerable)));|Assert.False(typeof(IAsyncDisposable).Implements(typeof(IDisposable)));|}"
      },
      {
        "name": "IsFromLocalAssembly",
        "body": "{|Assert.True(typeof(MyEnum).IsFromLocalAssembly());|#if NETFRAMEWORK|if (!EnvironmentHelper.IsMono)|Assert.False(typeof(System.Xml.ConformanceLevel).IsFromLocalAssembly());|#endif|}"
      },
      {
        "name": "IsNullable",
        "body": "{|Assert.True(typeof(object).IsNullable());|Assert.True(typeof(string).IsNullable());|Assert.True(typeof(IXunitSerializable).IsNullable());|Assert.True(typeof(char?).IsNullable());|Assert.False(typeof(char).IsNullable());|}"
      },
      {
        "name": "IsNullableEnum",
        "body": "{|Assert.True(typeof(MyEnum?).IsNullableEnum());|Assert.False(typeof(MyEnum).IsNullableEnum());|Assert.False(typeof(char?).IsNullableEnum());|}"
      },
      {
        "name": "NoArguments",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithNoArgs), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var result = method.ResolveMethodArguments([]);|Assert.Empty(result);|}"
      },
      {
        "name": "TooFewArguments",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithTwoArgs), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var args = new[] { new object() };|var result = method.ResolveMethodArguments(args);|Assert.Same(args, result);|}"
      },
      {
        "name": "MethodWithDefaultValue_UsesDefaultValue",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithDefaultValue), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var results = method.ResolveMethodArguments([]);|var result = Assert.Single(results);|Assert.Equal(42, result);|}"
      },
      {
        "name": "MethodWithParams_NoValuesProvided",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var results = method.ResolveMethodArguments([]);|var result = Assert.Single(results);|var resultArray = Assert.IsType<int[]>(result);|Assert.Empty(resultArray);|}"
      },
      {
        "name": "MethodWithParams_NullProvided",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var results = method.ResolveMethodArguments([null]);|var result = Assert.Single(results);|Assert.Null(result);|}"
      },
      {
        "name": "MethodWithParams_DirectArrayProvided",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var valueArray = new[] { 42, 2112 };|var results = method.ResolveMethodArguments([valueArray]);|var result = Assert.Single(results);|Assert.Same(valueArray, result);|}"
      },
      {
        "name": "MethodWithParams_MultipleValuesProvided",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var results = method.ResolveMethodArguments([42, 2112]);|var result = Assert.Single(results);|var resultArray = Assert.IsType<int[]>(result);|Assert.Equal(new[] { 42, 2112 }, resultArray);|}"
      },
      {
        "name": "MethodWithParams_WrongType",
        "body": "{|var method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(method);|var ex = Record.Exception(() => method.ResolveMethodArguments([42, \"Hello\"]));|Assert.IsType<InvalidOperationException>(ex);|Assert.Equal(\"The arguments for this test method did not match the parameters: [42, \\\"Hello\\\"]\", ex.Message);|}"
      },
      {
        "name": "SafeName",
        "body": "{|Assert.Equal(\"System.Object\", typeof(object).SafeName());|var genericMethod = typeof(ReflectionExtensionsTests).GetMethod(nameof(GenericMethod), BindingFlags.NonPublic | BindingFlags.Static);|Assert.NotNull(genericMethod);|var genericArgumentType = genericMethod.GetGenericArguments()[0];|Assert.Equal(\"T\", genericArgumentType.SafeName());|}"
      },
      {
        "name": "ToCommaSeparatedList",
        "body": "{|Assert.Equal(\"'System.Object', 'System.Int32'\", new[] { typeof(object), typeof(int) }.ToCommaSeparatedList());|}"
      },
      {
        "name": "ToDisplayName",
        "body": "{|Assert.Equal(\"Object\", typeof(object).ToDisplayName());|Assert.Equal(\"Dictionary<String, List<Int32>>\", typeof(Dictionary<string, List<int>>).ToDisplayName());|}"
      },
      {
        "name": "ToSimpleName",
        "body": "{|// Without namespace|Assert.Equal(\"ReflectionExtensionsTests\", typeof(ReflectionExtensionsTests).ToSimpleName());|Assert.Equal(\"ReflectionExtensionsTests+ResolveMethodArguments\", typeof(ResolveMethodArguments).ToSimpleName());|// With namespace|Assert.Equal(\"ParentClass\", typeof(NS1.ParentClass).ToSimpleName());|Assert.Equal(\"ParentClass+ChildClass\", typeof(NS1.ParentClass.ChildClass).ToSimpleName());|}"
      },
      {
        "name": "UnwrapNullable",
        "body": "{|Assert.Equal(typeof(object), typeof(object).UnwrapNullable());|Assert.Equal(typeof(int), typeof(int).UnwrapNullable());|Assert.Equal(typeof(int), typeof(int?).UnwrapNullable());|}"
      }
    ]
  },
  {
    "file": "AssemblyExtensionsTests.cs",
    "methods": [
      {
        "name": "NullAssembly_ReturnsNull",
        "body": "{|var result = AssemblyExtensions.GetLocalCodeBase(null);|Assert.Null(result);|}"
      },
      {
        "name": "NullCodeBase_ReturnsNull",
        "body": "{|var result = AssemblyExtensions.GetLocalCodeBase(null, '/');|Assert.Null(result);|}"
      },
      {
        "name": "UnsupportedCodeBaseFormat_Throws",
        "body": "{|var ex = Record.Exception(() => AssemblyExtensions.GetLocalCodeBase(\"http://host/path\", '/'));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"codeBase\", argEx.ParamName);|Assert.StartsWith(\"Codebase 'http://host/path' is unsupported; must start with 'file://'.\", argEx.Message);|}"
      },
      {
        "name": "UnsupportedDirectorySeparator_Throws",
        "body": "{|var ex = Record.Exception(() => AssemblyExtensions.GetLocalCodeBase(\"file:///path\", 'a'));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"directorySeparator\", argEx.ParamName);|Assert.StartsWith(\"Unknown directory separator 'a'; must be one of '/' or '\\\\'.\", argEx.Message);|}"
      },
      {
        "name": "PosixSystem_LocalPath",
        "body": "{|var result = AssemblyExtensions.GetLocalCodeBase(\"file:///path/to/file.dll\", '/');|Assert.Equal(\"/path/to/file.dll\", result);|}"
      },
      {
        "name": "PosixSystem_UNCPath_Throws",
        "body": "{|var ex = Record.Exception(() => AssemblyExtensions.GetLocalCodeBase(\"file://server/path\", '/'));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"codeBase\", argEx.ParamName);|Assert.StartsWith(\"UNC-style codebase 'file://server/path' is not supported on POSIX-style file systems.\", argEx.Message);|}"
      },
      {
        "name": "WindowsSystem_LocalPath",
        "body": "{|var result = AssemblyExtensions.GetLocalCodeBase(\"file:///C:/path/to/file.dll\", '\\\\');|Assert.Equal(@\"C:\\path\\to\\file.dll\", result);|}"
      },
      {
        "name": "WindowsSystem_UNCPath",
        "body": "{|var result = AssemblyExtensions.GetLocalCodeBase(\"file://server/path/to/file.dll\", '\\\\');|Assert.Equal(@\"\\\\server\\path\\to\\file.dll\", result);|}"
      },
      {
        "name": "GetTargetFramework",
        "body": "{|#if NET472|var expected = \".NETFramework,Version=v4.7.2\";|#elif NET6_0|var expected = \".NETCoreApp,Version=v6.0\";|#else|#error Unknown target framework|#endif|var result = AssemblyExtensions.GetTargetFramework(typeof(AssemblyExtensionsTests).Assembly);|Assert.Equal(expected, result);|}"
      }
    ]
  },
  {
    "file": "ObjectExtensionsTests.cs",
    "methods": [
      {
        "name": "NullValue",
        "body": "{|var result = ObjectExtensions.AsValueTask(null);|Assert.Null(result);|}"
      },
      {
        "name": "NonTaskValue",
        "body": "{|var result = ObjectExtensions.AsValueTask(42);|Assert.Null(result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var task = new ValueTask<int>(42);|var result = ObjectExtensions.AsValueTask(task);|Assert.True(result.HasValue);|Assert.Equal(42, await result.Value);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var task = Task.FromResult(42);|var result = ObjectExtensions.AsValueTask(task);|Assert.True(result.HasValue);|Assert.Equal(42, await result.Value);|}"
      }
    ]
  },
  {
    "file": "JsonDeserializerTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"json\", () => JsonDeserializer.TryDeserialize(null!, out var _));|}"
      }
    ]
  },
  {
    "file": "SerializationHelperTests.cs",
    "methods": [
      {
        "name": "GuardClauseForNullSerializedValue",
        "body": "{|var ex = Record.Exception(() => TestableSerializationHelper.Instance.Deserialize(null!));|var argnEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"serializedValue\", argnEx.ParamName);|}"
      },
      {
        "name": "ArraysCanBeNull",
        "body": "{|var result = TestableSerializationHelper.Instance.Deserialize(\"[]\");|Assert.Null(result);|}"
      },
      {
        "name": "CanSerializeRuntimeType",
        "body": "{|// Type is abstract; RuntimeType is what you get at runtime and since it's|// internal, we can't just call typeof() to get one|var type = 42.GetType().GetType();|Assert.True(TestableSerializationHelper.Instance.IsSerializable(null, type));|}"
      },
      {
        "name": "CannotSerializeGenericArgumentType",
        "body": "{|var value = typeof(ClassWithGenericMethod).GetMethod(nameof(ClassWithGenericMethod.GenericMethod))!.GetGenericArguments()[0];|var type = value.GetType();|Assert.False(TestableSerializationHelper.Instance.IsSerializable(value, type));|}"
      },
      {
        "name": "CannotSerializeGenericArgumentTypeInsideArray",
        "body": "{|Type[] value =|[|// Okay|typeof(Type),|// Not okay|typeof(ClassWithGenericMethod).GetMethod(nameof(ClassWithGenericMethod.GenericMethod))!.GetGenericArguments()[0],|];|var type = value.GetType();|Assert.False(TestableSerializationHelper.Instance.IsSerializable(value, type));|}"
      }
    ]
  },
  {
    "file": "XunitSerializationInfoTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|var ex = Record.Exception(() => new XunitSerializationInfo(SerializationHelper.Instance, default(IXunitSerializable)!));|var argnEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"object\", argnEx.ParamName);|}"
      },
      {
        "name": "InitializedWithSerializedValue",
        "body": "{|var info = new XunitSerializationInfo(SerializationHelper.Instance, $\"ch:1:97\\nst:0:{ToBase64(\"Hello world\")}\\ndec:12:21.12\");|Assert.Equal('a', info.GetValue<char>(\"ch\"));|Assert.Equal(\"Hello world\", info.GetValue<string>(\"st\"));|Assert.Equal(21.12m, info.GetValue<decimal>(\"dec\"));|}"
      },
      {
        "name": "EntryMissingDataThrowsDuringConstructor",
        "body": "{|var serialization = \"ch:1:97\\nst\\ndec:12:21.12\";|var ex = Record.Exception(() => new XunitSerializationInfo(SerializationHelper.Instance, serialization));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"serializedValue\", argEx.ParamName);|Assert.StartsWith($\"Serialized piece 'st' is malformed. Full serialization:{Environment.NewLine}{serialization}\", argEx.Message);|}"
      },
      {
        "name": "GuardClauseForNonSerializableData",
        "body": "{|var info = new XunitSerializationInfo(SerializationHelper.Instance);|var ex = Record.Exception(() => info.AddValue(\"v\", new MyClass()));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"value\", argEx.ParamName);|Assert.StartsWith(\"Cannot serialize a value of type 'XunitSerializationInfoTests+MyClass': unsupported type for serialization\", argEx.Message);|}"
      },
      {
        "name": "EmptyInfo",
        "body": "{|var info = new XunitSerializationInfo(SerializationHelper.Instance);|var result = info.ToSerializedString();|Assert.Empty(result);|}"
      }
    ]
  },
  {
    "file": "DisposalTrackerTests.cs",
    "methods": [
      {
        "name": "AddThrows",
        "body": "{|var ex = Record.Exception(() => classUnderTest.Add(new object()));|Assert.NotNull(ex);|Assert.IsType<ObjectDisposedException>(ex);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|Assert.Equal(1, classToDispose.DisposeCount); // Already disposed in InitializeAsync|await classUnderTest.DisposeAsync();|Assert.Equal(1, classToDispose.DisposeCount);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var classUnderTest = new DisposalTracker();|var obj = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|classUnderTest.Add(obj);|var ex = await Record.ExceptionAsync(() => classUnderTest.DisposeAsync());|Assert.Null(ex);|obj.Received().Dispose();|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var classUnderTest = new DisposalTracker();|var obj1 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|classUnderTest.Add(obj1);|var thrown = new DivideByZeroException();|var obj2 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|obj2.When(x => x.Dispose()).Throw(thrown);|classUnderTest.Add(obj2);|var obj3 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|classUnderTest.Add(obj3);|var ex = await Record.ExceptionAsync(() => classUnderTest.DisposeAsync());|Assert.Same(thrown, ex);|obj1.Received().Dispose();|obj2.Received().Dispose();|obj3.Received().Dispose();|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var classUnderTest = new DisposalTracker();|var obj1 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|obj1.When(x => x.Dispose()).Throw<DivideByZeroException>();|classUnderTest.Add(obj1);|var obj2 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|obj2.When(x => x.Dispose()).Throw<InvalidOperationException>();|classUnderTest.Add(obj2);|var ex = await Record.ExceptionAsync(() => classUnderTest.DisposeAsync());|var aggEx = Assert.IsType<AggregateException>(ex);|Assert.Collection(|aggEx.InnerExceptions,|ex => Assert.IsType<InvalidOperationException>(ex),|ex => Assert.IsType<DivideByZeroException>(ex)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messages = new List<string>();|var obj1 = new TrackingAsyncDisposable(\"1\", messages);|classUnderTest.Add(obj1);|var obj2 = new TrackingAsyncDisposable(\"2\", messages);|classUnderTest.Add(obj2);|await classUnderTest.DisposeAsync();|Assert.Collection(|messages,|msg => Assert.Equal(\"2: DisposeAsync\", msg),|msg => Assert.Equal(\"1: DisposeAsync\", msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messages = new List<string>();|var obj1 = new TrackingDisposable(\"1\", messages);|classUnderTest.Add(obj1);|var obj2 = new TrackingDisposable(\"2\", messages);|classUnderTest.Add(obj2);|await classUnderTest.DisposeAsync();|Assert.Collection(|messages,|msg => Assert.Equal(\"2: Dispose\", msg),|msg => Assert.Equal(\"1: Dispose\", msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messages = new List<string>();|var obj1 = new TrackingDisposable(\"1\", messages);|classUnderTest.Add(obj1);|var obj2 = new TrackingAsyncDisposable(\"2\", messages);|classUnderTest.Add(obj2);|var obj3 = new TrackingDisposable(\"3\", messages);|classUnderTest.Add(obj3);|var obj4 = new TrackingAsyncDisposable(\"4\", messages);|classUnderTest.Add(obj4);|await classUnderTest.DisposeAsync();|Assert.Collection(|messages,|msg => Assert.Equal(\"4: DisposeAsync\", msg),|msg => Assert.Equal(\"3: Dispose\", msg),|msg => Assert.Equal(\"2: DisposeAsync\", msg),|msg => Assert.Equal(\"1: Dispose\", msg)|);|}"
      },
      {
        "name": "TrackedObjectsReturnsReverseOrder",
        "body": "{|var obj1 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|classUnderTest.Add(obj1);|var obj2 = Substitute.For<IAsyncDisposable, InterfaceProxy<IAsyncDisposable>>();|classUnderTest.Add(obj2);|var obj3 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();|classUnderTest.Add(obj3);|var obj4 = Substitute.For<IAsyncDisposable, InterfaceProxy<IAsyncDisposable>>();|classUnderTest.Add(obj4);|var trackedObjects = classUnderTest.TrackedObjects;|Assert.Collection(|trackedObjects,|obj => Assert.Same(obj4, obj),|obj => Assert.Same(obj3, obj),|obj => Assert.Same(obj2, obj),|obj => Assert.Same(obj1, obj)|);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|var ex = Record.Exception(() => classUnderTest.AddAction(null!));|Assert.NotNull(ex);|var argEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"cleanupAction\", argEx.ParamName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await classUnderTest.DisposeAsync();|Assert.True(disposed);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|var ex = Record.Exception(() => classUnderTest.AddAsyncAction(null!));|Assert.NotNull(ex);|var argEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"cleanupAction\", argEx.ParamName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await classUnderTest.DisposeAsync();|Assert.True(disposed);|}"
      },
      {
        "name": "ClearRemovesAllObjects",
        "body": "{|Assert.NotEmpty(classUnderTest.TrackedObjects);|classUnderTest.Clear();|Assert.Empty(classUnderTest.TrackedObjects);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await classUnderTest.DisposeAsync();|_ = expected.Received().DisposeAsync();|}"
      },
      {
        "name": "ClearRemovesAllObjects",
        "body": "{|Assert.NotEmpty(classUnderTest.TrackedObjects);|classUnderTest.Clear();|Assert.Empty(classUnderTest.TrackedObjects);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await classUnderTest.DisposeAsync();|expected.Received().Dispose();|}"
      },
      {
        "name": "ClearRemovesAllObjects",
        "body": "{|Assert.NotEmpty(classUnderTest.TrackedObjects);|classUnderTest.Clear();|Assert.Empty(classUnderTest.TrackedObjects);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await classUnderTest.DisposeAsync();|var op = Assert.Single(expected.Operations);|Assert.Equal(\"DisposeAsync\", op);|}"
      }
    ]
  },
  {
    "file": "UniqueIDGeneratorTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|using var generator = new UniqueIDGenerator();|var ex = Record.Exception(() => generator.Add(null!));|var anex = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"value\", anex.ParamName);|}"
      },
      {
        "name": "NoData",
        "body": "{|using var generator = new UniqueIDGenerator();|var result = generator.Compute();|Assert.Equal(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\", result);|}"
      },
      {
        "name": "SingleString",
        "body": "{|using var generator = new UniqueIDGenerator();|generator.Add(\"Hello, world!\");|var result = generator.Compute();|Assert.Equal(\"5450bb49d375ba935c1fe9c4dc48775d7d343fb97f22f07f8950f34a75a2708f\", result);|}"
      },
      {
        "name": "CannotAddAfterCompute",
        "body": "{|using var generator = new UniqueIDGenerator();|generator.Compute();|var ex = Record.Exception(() => generator.Add(\"Hello, world!\"));|Assert.IsType<ObjectDisposedException>(ex);|Assert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);|}"
      },
      {
        "name": "CannotComputeTwice",
        "body": "{|using var generator = new UniqueIDGenerator();|generator.Compute();|var ex = Record.Exception(() => generator.Compute());|Assert.IsType<ObjectDisposedException>(ex);|Assert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);|}"
      },
      {
        "name": "CannotAddAfterDipose",
        "body": "{|using var generator = new UniqueIDGenerator();|generator.Dispose();|var ex = Record.Exception(() => generator.Add(\"Hello, world!\"));|Assert.IsType<ObjectDisposedException>(ex);|Assert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);|}"
      },
      {
        "name": "CannotComputeAfterDispose",
        "body": "{|using var generator = new UniqueIDGenerator();|generator.Dispose();|var ex = Record.Exception(() => generator.Compute());|Assert.IsType<ObjectDisposedException>(ex);|Assert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);|}"
      },
      {
        "name": "GuardClause",
        "body": "{|var ex = Record.Exception(() => UniqueIDGenerator.ForAssembly(null!, \"config-path\"));|var argnEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"assemblyPath\", argnEx.ParamName);|}"
      }
    ]
  },
  {
    "file": "AsyncAcceptanceTests.cs",
    "methods": [
      {
        "name": "Async40AcceptanceTest",
        "body": "{|IEnumerable<MethodResult> results = RunClass(typeof(Async40AcceptanceTestClass));|MethodResult result = Assert.Single(results);|FailedResult failedResult = Assert.IsType<FailedResult>(result);|Assert.Equal(typeof(TrueException).FullName, failedResult.ExceptionType);|}"
      },
      {
        "name": "Task",
        "body": "{|return Task.Factory.StartNew(() =>|{|Thread.Sleep(1);|})|.ContinueWith(_ =>|{|Assert.True(false);|});|}"
      }
    ]
  },
  {
    "file": "CollectionAcceptanceTests.cs",
    "methods": [
      {
        "name": "TwoClasses_OneInExplicitCollection_OneInDefaultCollection",
        "body": "{|var results = Run(new[] { typeof(ClassInExplicitCollection), typeof(ClassInDefaultCollection) });|var defaultResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName.StartsWith(\"Test collection for \"));|AssertMessageSequence(defaultResults, \"CollectionAcceptanceTests+ClassInDefaultCollection.Passing\");|var explicitResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName == \"Explicit Collection\");|AssertMessageSequence(explicitResults, \"CollectionAcceptanceTests+ClassInExplicitCollection.Passing\");|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "DynamicSkipAcceptanceTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"reason\", () => Assert.Skip(null!));|}"
      },
      {
        "name": "Task",
        "body": "{|var results = await RunAsync(typeof(ClassUnderTest));|var skipResult = Assert.Single(results.OfType<ITestSkipped>());|Assert.Equal(\"This test was skipped\", skipResult.Reason);|}"
      },
      {
        "name": "Unconditional",
        "body": "{|Assert.Skip(\"This test was skipped\");|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"reason\", () => Assert.SkipUnless(true, null!));|}"
      },
      {
        "name": "Task",
        "body": "{|var results = await RunAsync(typeof(ClassUnderTest));|var skipResult = Assert.Single(results.OfType<ITestSkipped>());|var skipMethodStarting = Assert.Single(results.OfType<ITestMethodStarting>(), s => s.TestMethodUniqueID == skipResult.TestMethodUniqueID);|Assert.Equal(\"Skipped\", skipMethodStarting.MethodName);|Assert.Equal(\"This test was skipped\", skipResult.Reason);|var passResult = Assert.Single(results.OfType<ITestPassed>());|var passMethodStarting = results.OfType<ITestMethodStarting>().Where(ts => ts.TestMethodUniqueID == passResult.TestMethodUniqueID).Single();|Assert.Equal(\"Passed\", passMethodStarting.MethodName);|}"
      },
      {
        "name": "Skipped",
        "body": "{|Assert.SkipUnless(false, \"This test was skipped\");|}"
      },
      {
        "name": "Passed",
        "body": "{|Assert.SkipUnless(true, \"This test is not skipped\");|}"
      },
      {
        "name": "GuardClause",
        "body": "{|Assert.Throws<ArgumentNullException>(\"reason\", () => Assert.SkipWhen(true, null!));|}"
      },
      {
        "name": "Task",
        "body": "{|var results = await RunAsync(typeof(ClassUnderTest));|var skipResult = Assert.Single(results.OfType<ITestSkipped>());|var skipMethodStarting = Assert.Single(results.OfType<ITestMethodStarting>(), s => s.TestMethodUniqueID == skipResult.TestMethodUniqueID);|Assert.Equal(\"Skipped\", skipMethodStarting.MethodName);|Assert.Equal(\"This test was skipped\", skipResult.Reason);|var passResult = Assert.Single(results.OfType<ITestPassed>());|var passMethodStarting = results.OfType<ITestMethodStarting>().Where(ts => ts.TestMethodUniqueID == passResult.TestMethodUniqueID).Single();|Assert.Equal(\"Passed\", passMethodStarting.MethodName);|}"
      },
      {
        "name": "Skipped",
        "body": "{|Assert.SkipWhen(true, \"This test was skipped\");|}"
      },
      {
        "name": "Passed",
        "body": "{|Assert.SkipWhen(false, \"This test is not skipped\");|}"
      }
    ]
  },
  {
    "file": "FixtureAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestClassMustHaveSinglePublicConstructor",
        "body": "{|var messages = Run(typeof(ClassWithTooManyConstructors));|Assert.Collection(messages,|message => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),|message => Assert.IsAssignableFrom<ITestCollectionStarting>(message),|message => Assert.IsAssignableFrom<ITestClassStarting>(message),|// TestMethod1|message => Assert.IsAssignableFrom<ITestMethodStarting>(message),|message => Assert.IsAssignableFrom<ITestCaseStarting>(message),|message => Assert.IsAssignableFrom<ITestStarting>(message),|message =>|{|var failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);|Assert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());|Assert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());|},|message => Assert.IsAssignableFrom<ITestFinished>(message),|message => Assert.IsAssignableFrom<ITestCaseFinished>(message),|message => Assert.IsAssignableFrom<ITestMethodFinished>(message),|// TestMethod2|message => Assert.IsAssignableFrom<ITestMethodStarting>(message),|message => Assert.IsAssignableFrom<ITestCaseStarting>(message),|message => Assert.IsAssignableFrom<ITestStarting>(message),|message =>|{|var failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);|Assert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());|Assert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());|},|message => Assert.IsAssignableFrom<ITestFinished>(message),|message => Assert.IsAssignableFrom<ITestCaseFinished>(message),|message => Assert.IsAssignableFrom<ITestMethodFinished>(message),|message => Assert.IsAssignableFrom<ITestClassFinished>(message),|message => Assert.IsAssignableFrom<ITestCollectionFinished>(message),|message => Assert.IsAssignableFrom<ITestAssemblyFinished>(message)|);|}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());|Assert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));|var msg = Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));|var msg = Assert.Single(messages);|Assert.Collection(|msg.ExceptionTypes,|type => Assert.Equal(typeof(TestClassException).FullName, type),|type => Assert.Equal(typeof(DivideByZeroException).FullName, type)|);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureDisposeResultsInFailedTest",
        "body": "{|var messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithDefaultParameter",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithDefaultCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithDefaultCtorArg.TheTest\", msg.Test.DisplayName);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithOptionalParameter",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithOptionalCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithOptionalCtorArg.TheTest\", msg.Test.DisplayName);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithParamsParameter",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithParamsArg));|var msg = Assert.Single(messages);|Assert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithParamsArg.TheTest\", msg.Test.DisplayName);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataShouldHaveBeenSetup",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ThrowingAsyncSetupShouldResultInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetup));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureAsyncDisposeResultsInFailedTest",
        "body": "{|var messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotBeDecoratedWithICollectionFixture",
        "body": "{|var messages = Run<ITestFailed>(typeof(TestClassWithCollectionFixture));|var msg = Assert.Single(messages);|Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());|Assert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", msg.Messages.Single());|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));|var msg = Assert.Single(messages);|Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());|Assert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));|var msg = Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeResultsInFailedTest",
        "body": "{|var messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsSameInstanceAcrossClasses",
        "body": "{|Run<ITestPassed>(new[] { typeof(FixtureSaver1), typeof(FixtureSaver2) });|Assert.Same(FixtureSaver1.Fixture, FixtureSaver2.Fixture);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnCollectionDecorationWorks",
        "body": "{|var messages = Run<ITestPassed>(typeof(FixtureSpy_ClassFixture));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnTestClassTakesPrecedenceOverClassFixtureOnCollection",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithCountedFixture));|Assert.Single(messages);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureSetupAsyncResultsInFailedTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetupAsync));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest",
        "body": "{|var messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureAsyncDispose));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "CollectionFixtureAsyncSetupShouldOnlyRunOnce",
        "body": "{|var results = Run<ITestPassed>(new[] { typeof(Fixture1), typeof(Fixture2) });|Assert.Equal(2, results.Count);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ExceptionAggregatorTests.cs",
    "methods": [
      {
        "name": "EmptyByDefault",
        "body": "{|var aggregator = new ExceptionAggregator();|Assert.False(aggregator.HasExceptions);|}"
      },
      {
        "name": "CanAddOneAggregatorToAnother",
        "body": "{|var aggregator1 = new ExceptionAggregator();|aggregator1.Add(new DivideByZeroException());|var aggregator2 = new ExceptionAggregator();|aggregator2.Add(new InvalidOperationException());|aggregator2.Aggregate(aggregator1);|var result = aggregator2.ToException();|var aggEx = Assert.IsType<AggregateException>(result);|Assert.Collection(|aggEx.InnerExceptions,|ex => Assert.IsType<InvalidOperationException>(ex),|ex => Assert.IsType<DivideByZeroException>(ex)|);|}"
      },
      {
        "name": "CapturesException",
        "body": "{|var aggregator = new ExceptionAggregator();|aggregator.Run(() => throw new DivideByZeroException());|var result = aggregator.ToException();|Assert.IsType<DivideByZeroException>(result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var aggregator = new ExceptionAggregator();|await aggregator.RunAsync(async () =>|{|await Task.Yield();|throw new DivideByZeroException();|});|var result = aggregator.ToException();|Assert.IsType<DivideByZeroException>(result);|}"
      }
    ]
  },
  {
    "file": "CollectionPerAssemblyTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "ReturnsDefaultTestCollectionForUndecoratedTestClass",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\");|var type2 = Mocks.TypeInfo(\"type2\");|var assemblyFileName = Path.DirectorySeparatorChar == '/' ? \"/foo/bar.dll\" : @\"C:\\Foo\\bar.dll\";|var assembly = Mocks.TestAssembly(assemblyFileName);|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"Test collection for bar.dll\", result1.DisplayName);|}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{|var attr = Mocks.CollectionAttribute(\"My Collection\");|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"My Collection\", result1.DisplayName);|}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.NotSame(result1, result2);|Assert.Equal(\"Collection 1\", result1.DisplayName);|Assert.Equal(\"Collection 2\", result2.DisplayName);|}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());|var result = factory.Get(testType);|Assert.Same(collectionDefinitionType, result.CollectionDefinition);|}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var spy = SpyMessageSink.Create(messages: messages);|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });|var factory = new CollectionPerAssemblyTestCollectionFactory(assembly, spy);|factory.Get(testType);|var msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));|Assert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);|}"
      }
    ]
  },
  {
    "file": "CollectionPerClassTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultCollectionBehaviorIsCollectionPerClass",
        "body": "{|var type1 = Mocks.TypeInfo(\"FullyQualified.Type.Number1\");|var type2 = Mocks.TypeInfo(\"FullyQualified.Type.Number2\");|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.NotSame(result1, result2);|Assert.Equal(\"Test collection for FullyQualified.Type.Number1\", result1.DisplayName);|Assert.Equal(\"Test collection for FullyQualified.Type.Number2\", result2.DisplayName);|Assert.Null(result1.CollectionDefinition);|Assert.Null(result2.CollectionDefinition);|}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{|var attr = Mocks.CollectionAttribute(\"My Collection\");|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"My Collection\", result1.DisplayName);|}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.NotSame(result1, result2);|Assert.Equal(\"Collection 1\", result1.DisplayName);|Assert.Equal(\"Collection 2\", result2.DisplayName);|}"
      },
      {
        "name": "ExplicitlySpecifyingACollectionWithTheSameNameAsAnImplicitWorks",
        "body": "{|var type1 = Mocks.TypeInfo(\"type1\");|var type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Test collection for type1\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result1 = factory.Get(type1);|var result2 = factory.Get(type2);|Assert.Same(result1, result2);|Assert.Equal(\"Test collection for type1\", result1.DisplayName);|}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });|var factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());|var result = factory.Get(testType);|Assert.Same(collectionDefinitionType, result.CollectionDefinition);|}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var spy = SpyMessageSink.Create(messages: messages);|var testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });|var collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });|var assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });|var factory = new CollectionPerClassTestCollectionFactory(assembly, spy);|factory.Get(testType);|var msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));|Assert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);|}"
      }
    ]
  },
  {
    "file": "DefaultTestCaseOrdererTests.cs",
    "methods": [
      {
        "name": "OrderIsStable",
        "body": "{|var orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());|var result1 = orderer.OrderTestCases(TestCases);|var result2 = orderer.OrderTestCases(TestCases);|var result3 = orderer.OrderTestCases(TestCases);|Assert.Equal(result1, result2);|Assert.Equal(result2, result3);|}"
      },
      {
        "name": "OrderIsUnpredictable",
        "body": "{|var orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());|var result = orderer.OrderTestCases(TestCases);|Assert.NotEqual(TestCases, result);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test4",
        "body": "{ }"
      },
      {
        "name": "Test5",
        "body": "{ }"
      },
      {
        "name": "Test6",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "DefaultTestCollectionOrdererTests.cs",
    "methods": [
      {
        "name": "OrderIsStable",
        "body": "{|var orderer = DefaultTestCollectionOrderer.Instance;|var result1 = orderer.OrderTestCollections(TestCollections);|var result2 = orderer.OrderTestCollections(TestCollections);|var result3 = orderer.OrderTestCollections(TestCollections);|Assert.Equal(result1, result2);|Assert.Equal(result2, result3);|}"
      },
      {
        "name": "OrderIsUnpredictable",
        "body": "{|var orderer = DefaultTestCollectionOrderer.Instance;|var result = orderer.OrderTestCollections(TestCollections);|// If this test fails, rearrange the test collection list above|Assert.NotEqual(TestCollections, result);|}"
      }
    ]
  },
  {
    "file": "FactDiscovererTests.cs",
    "methods": [
      {
        "name": "FactWithoutParameters_ReturnsTestCaseThatRunsFact",
        "body": "{|var discoverer = TestableFactDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithNoParameters\");|var testCases = discoverer.Discover(options, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|await testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);|Assert.Single(messageBus.Messages.OfType<ITestPassed>());|}"
      },
      {
        "name": "FactWithParameters_ReturnsTestCaseWhichThrows",
        "body": "{|var discoverer = TestableFactDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithParameters\");|var testCases = discoverer.Discover(options, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|await testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());|Assert.Equal(\"[Fact] methods are not allowed to have parameters. Did you mean to use [Theory]?\", failed.Messages.Single());|}"
      },
      {
        "name": "GenericFact_ReturnsTestCaseWhichThrows",
        "body": "{|var discoverer = TestableFactDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"GenericFact\");|var testCases = discoverer.Discover(options, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|await testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());|Assert.Equal(\"[Fact] methods are not allowed to be generic.\", failed.Messages.Single());|}"
      },
      {
        "name": "FactWithNoParameters",
        "body": "{ }"
      },
      {
        "name": "FactWithParameters",
        "body": "{ }"
      },
      {
        "name": "GenericFact",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "InProcessFrontControllerTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|var testFramework = Mocks.TestFramework();|Assert.Throws<ArgumentNullException>(\"testFramework\", () => new InProcessFrontController(null!, thisAssembly, null));|Assert.Throws<ArgumentNullException>(\"testAssembly\", () => new InProcessFrontController(testFramework, null!, null));|}"
      },
      {
        "name": "PropertiesReturnValuesFromDiscoverer",
        "body": "{|var frontController = TestableInProcessFrontController.Create();|Assert.Equal(TestData.DefaultTestFrameworkDisplayName, frontController.TestFrameworkDisplayName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var frontController = TestableInProcessFrontController.Create();|var options = TestData.TestFrameworkDiscoveryOptions();|var filter = (ITestCase testCase) => true;|await Assert.ThrowsAsync<ArgumentNullException>(\"options\", () => frontController.Find(null, null!, filter).AsTask());|await Assert.ThrowsAsync<ArgumentNullException>(\"filter\", () => frontController.Find(null, options, null!).AsTask());|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var frontController = TestableInProcessFrontController.Create(configFilePath: \"/path/to/config.json\");|var messageSink = SpyMessageSink.Capture();|var options = TestData.TestFrameworkDiscoveryOptions();|var filter = (ITestCase testCase) => true;|await frontController.Find(messageSink, options, filter);|Assert.Collection(|messageSink.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<IDiscoveryStarting>(msg);|#if BUILD_X86|Assert.StartsWith(\"xunit.v3.core.x86.tests\", starting.AssemblyName);|Assert.Equal(\"xunit.v3.core.x86.tests\", Path.GetFileNameWithoutExtension(starting.AssemblyPath));|#else|Assert.StartsWith(\"xunit.v3.core.tests\", starting.AssemblyName);|Assert.Equal(\"xunit.v3.core.tests\", Path.GetFileNameWithoutExtension(starting.AssemblyPath));|#endif|Assert.Equal(frontController.TestAssemblyUniqueID, starting.AssemblyUniqueID);|Assert.Equal(\"/path/to/config.json\", starting.ConfigFilePath);|},|msg =>|{|var complete = Assert.IsAssignableFrom<IDiscoveryComplete>(msg);|Assert.Equal(frontController.TestAssemblyUniqueID, complete.AssemblyUniqueID);|Assert.Equal(0, complete.TestCasesToRun);|}|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var frontController = TestableInProcessFrontController.Create();|var messageSink = SpyMessageSink.Capture();|var options = TestData.TestFrameworkDiscoveryOptions();|var validTestCase = Mocks.XunitTestCase<Find>(nameof(ReportsDiscoveredTestCasesAndCountsTestCasesWhichPassFilter));|var invalidTestCase = Mocks.XunitTestCase<Find>(nameof(SendsStartingAndCompleteMessages));|var filter = (ITestCase testCase) => testCase == validTestCase;|var callbackCalls = new List<(ITestCase testCase, bool passedFilter)>();|frontController|.Discoverer|.WhenForAnyArgs(d => d.Find(null!, null!))|.Do(callInfo =>|{|var callback = callInfo.Arg<Func<ITestCase, ValueTask<bool>>>();|#pragma warning disable xUnit1031 // Test methods must not use blocking task operations|callback(validTestCase).GetAwaiter().GetResult();|callback(invalidTestCase).GetAwaiter().GetResult();|#pragma warning restore xUnit1031 // Test methods must not use blocking task operations|});|ValueTask<bool> frontControllerCallback(|ITestCase testCase,|bool passedFilter)|{|callbackCalls.Add((testCase, passedFilter));|return new(true);|}|await frontController.Find(messageSink, options, filter, discoveryCallback: frontControllerCallback);|var complete = Assert.Single(messageSink.Messages.OfType<IDiscoveryComplete>());|Assert.Equal(1, complete.TestCasesToRun);|Assert.Collection(|callbackCalls,|callback =>|{|Assert.Same(validTestCase, callback.testCase);|Assert.True(callback.passedFilter);|},|callback =>|{|Assert.Same(invalidTestCase, callback.testCase);|Assert.False(callback.passedFilter);|}|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var frontController = TestableInProcessFrontController.Create();|var messageSink = SpyMessageSink.Capture();|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions();|var executionOptions = TestData.TestFrameworkExecutionOptions();|var filter = (ITestCase testCase) => true;|await Assert.ThrowsAsync<ArgumentNullException>(\"messageSink\", () => frontController.FindAndRun(null!, discoveryOptions, executionOptions, filter).AsTask());|await Assert.ThrowsAsync<ArgumentNullException>(\"discoveryOptions\", () => frontController.FindAndRun(messageSink, null!, executionOptions, filter).AsTask());|await Assert.ThrowsAsync<ArgumentNullException>(\"executionOptions\", () => frontController.FindAndRun(messageSink, discoveryOptions, null!, filter).AsTask());|await Assert.ThrowsAsync<ArgumentNullException>(\"filter\", () => frontController.FindAndRun(messageSink, discoveryOptions, executionOptions, null!).AsTask());|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var frontController = TestableInProcessFrontController.Create();|var messageSink = SpyMessageSink.Capture();|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions();|var executionOptions = TestData.TestFrameworkExecutionOptions();|var validTestCase = Mocks.XunitTestCase<FindAndRun>(nameof(RunsTestCasesWhichPassFilter));|var invalidTestCase = Mocks.XunitTestCase<Find>(nameof(GuardClauses));|var filter = (ITestCase testCase) => testCase == validTestCase;|var executedTestCases = default(IReadOnlyCollection<ITestCase>?);|frontController|.Discoverer|.WhenForAnyArgs(d => d.Find(null!, null!))|.Do(callInfo =>|{|var callback = callInfo.Arg<Func<ITestCase, ValueTask<bool>>>();|#pragma warning disable xUnit1031 // Test methods must not use blocking task operations|callback(validTestCase).GetAwaiter().GetResult();|callback(invalidTestCase).GetAwaiter().GetResult();|#pragma warning restore xUnit1031 // Test methods must not use blocking task operations|});|frontController|.Executor|.WhenForAnyArgs(e => e.RunTestCases(null!, null!, null!))|.Do(callInfo => executedTestCases = callInfo.Arg<IReadOnlyCollection<ITestCase>>());|await frontController.FindAndRun(messageSink, discoveryOptions, executionOptions, filter);|Assert.NotNull(executedTestCases);|var runTestCase = Assert.Single(executedTestCases);|Assert.Same(validTestCase, runTestCase);|}"
      }
    ]
  },
  {
    "file": "TestCollectionFactoryBaseTests.cs",
    "methods": [
      {
        "name": "AcquiresBeforeAfterTestAttributesFromCollectionDefinition_AndMergesThemWithTheAssemblyAttributes",
        "body": "{|var testAssembly = Mocks.XunitTestAssembly(beforeAfterTestAttributes: [new BeforeAfterTestAttribute1()]);|var factory = new TestableTestCollectionFactory(testAssembly);|var testCollection = factory.Get(typeof(TestClassForBeforeAfterAttribute));|Assert.Collection(|testCollection.BeforeAfterTestAttributes.OrderBy(a => a.GetType().Name),|a => Assert.Equal(\"BeforeAfterTestAttribute1\", a.GetType().Name),|a => Assert.Equal(\"BeforeAfterTestAttribute2\", a.GetType().Name)|);|}"
      },
      {
        "name": "AcquiresFixtureTypesFromCollectionDefinition",
        "body": "{|var testAssembly = Mocks.XunitTestAssembly();|var factory = new TestableTestCollectionFactory(testAssembly);|var testCollection = factory.Get(typeof(TestClassForFixtures));|var collectionFixtureType = Assert.Single(testCollection.CollectionFixtureTypes);|Assert.Equal(typeof(object), collectionFixtureType);|var classFixtureType = Assert.Single(testCollection.ClassFixtureTypes);|Assert.Equal(typeof(string), classFixtureType);|}"
      },
      {
        "name": "ReadsCollectionDefinitionAttributeForParallelization",
        "body": "{|// Decorated definitions are read and cached by the test assembly|var definitions = new Dictionary<string, (Type, CollectionDefinitionAttribute)>|{|[\"foo\"] = (typeof(TestCollectionWithoutParallelization), new CollectionDefinitionAttribute { DisableParallelization = true })|};|var testAssembly = Mocks.XunitTestAssembly(collectionDefinitions: definitions);|var factory = new TestableTestCollectionFactory(testAssembly);|var testCollection = factory.Get(typeof(TestClassForParallelization));|Assert.True(testCollection.DisableParallelization);|}"
      }
    ]
  },
  {
    "file": "TestFrameworkDiscovererTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|var framework = TestableTestFrameworkDiscoverer.Create();|await Assert.ThrowsAsync<ArgumentNullException>(\"callback\", () => framework.Find(callback: null!, discoveryOptions: TestData.TestFrameworkDiscoveryOptions()).AsTask());|await Assert.ThrowsAsync<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(callback: _ => new(true), discoveryOptions: null!).AsTask());|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var spy = SpyMessageSink.Capture();|TestContext.CurrentInternal.DiagnosticMessageSink = spy;|var discoverer = TestableTestFrameworkDiscoverer.Create();|discoverer.FindTestsForType_Exception = new DivideByZeroException();|await discoverer.Find();|var message = Assert.Single(spy.Messages.OfType<IDiagnosticMessage>());|Assert.StartsWith($\"Exception during discovery:{Environment.NewLine}System.DivideByZeroException: Attempted to divide by zero.\", message.Message);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var discoverer = TestableTestFrameworkDiscoverer.Create();|await discoverer.Find();|var context = discoverer.FindTestsForType_Context;|Assert.NotNull(context);|Assert.Equal(TestEngineStatus.Discovering, context.TestAssemblyStatus);|Assert.Equal(TestPipelineStage.Discovery, context.PipelineStage);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var discoverer = TestableTestFrameworkDiscoverer.Create(typeof(object), typeof(int));|await discoverer.Find();|Assert.Collection(|discoverer.FindTestsForType_TestClasses.Select(c => c.TestClassName).OrderBy(x => x),|typeName => Assert.Equal(typeof(int).FullName, typeName), // System.Int32|typeName => Assert.Equal(typeof(object).FullName, typeName) // System.Object|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var discoverer = TestableTestFrameworkDiscoverer.Create(typeof(AbstractClass));|await discoverer.Find();|Assert.Empty(discoverer.FindTestsForType_TestClasses);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var discoverer = TestableTestFrameworkDiscoverer.Create();|await discoverer.Find(types: [typeof(object)]);|var testClass = Assert.Single(discoverer.FindTestsForType_TestClasses);|Assert.Equal(typeof(object).FullName, testClass.TestClassName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var discoverer = TestableTestFrameworkDiscoverer.Create();|await discoverer.Find(types: [typeof(AbstractClass)]);|Assert.Empty(discoverer.FindTestsForType_TestClasses);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|CultureInfo.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");|var discoverer = TestableTestFrameworkDiscoverer.Create();|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions(culture: null);|await discoverer.Find(discoveryOptions);|Assert.NotNull(discoverer.FindTestsForType_CurrentCulture);|Assert.Equal(\"en-US\", discoverer.FindTestsForType_CurrentCulture.Name);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|CultureInfo.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");|var discoverer = TestableTestFrameworkDiscoverer.Create();|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions(culture: string.Empty);|await discoverer.Find(discoveryOptions);|Assert.NotNull(discoverer.FindTestsForType_CurrentCulture);|Assert.Equal(string.Empty, discoverer.FindTestsForType_CurrentCulture.Name);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|CultureInfo.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");|var discoverer = TestableTestFrameworkDiscoverer.Create();|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions(culture: \"en-GB\");|await discoverer.Find(discoveryOptions);|Assert.NotNull(discoverer.FindTestsForType_CurrentCulture);|Assert.Equal(\"en-GB\", discoverer.FindTestsForType_CurrentCulture.Name);|}"
      },
      {
        "name": "ATestNotToBeRun",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TheoryDiscovererTests.cs",
    "methods": [
      {
        "name": "NoDataAttributes",
        "body": "{|var failures = Run<ITestFailed>(typeof(NoDataAttributesClass));|var failure = Assert.Single(failures);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"No data found for TheoryDiscovererTests+NoDataAttributesClass.TheoryMethod\", failure.Messages.Single());|}"
      },
      {
        "name": "NullMemberData_ThrowsInvalidOperationException",
        "body": "{|var results = Run<ITestFailed>(typeof(NullDataClass));|var failure = Assert.Single(results);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"Test data returned null for TheoryDiscovererTests+NullDataClass.NullMemberData. Make sure it is statically initialized before this test method is called.\", failure.Messages.Single());|}"
      },
      {
        "name": "EmptyTheoryData",
        "body": "{|var failures = Run<ITestFailed>(typeof(EmptyTheoryDataClass));|var failure = Assert.Single(failures);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"No data found for TheoryDiscovererTests+EmptyTheoryDataClass.TheoryMethod\", failure.Messages.Single());|}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToTrue_YieldsTestCasePerDataRow",
        "body": "{|discoveryOptions.SetPreEnumerateTheories(true);|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();|Assert.Equal(2, testCases.Count);|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 42)\");|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 2112)\");|}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToFalse_YieldsSingleTheoryTestCase",
        "body": "{|discoveryOptions.SetPreEnumerateTheories(false);|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+MultipleDataClass.TheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "DiscoverOptions_PreEnumerateTheoriesSetToTrueWithSkipOnData_YieldsSkippedTestCasePerDataRow",
        "body": "{|discoveryOptions.SetPreEnumerateTheories(true);|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MultipleDataClassSkipped), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();|Assert.Equal(2, testCases.Count);|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 42)\" && testCase.SkipReason == \"Skip this attribute\");|Assert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 2112)\" && testCase.SkipReason == \"Skip this attribute\");|}"
      },
      {
        "name": "ThrowingData",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(ThrowingDataClass), \"TheoryWithMisbehavingData\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData\", theoryTestCase.DisplayName);|var message = Assert.Single(discoverer.DiagnosticMessages);|var diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);|Assert.StartsWith($\"Exception thrown during theory discovery on 'TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData'; falling back to single test case.{Environment.NewLine}System.DivideByZeroException:\", diagnostic.Message);|}"
      },
      {
        "name": "DataDiscovererReturningNullYieldsSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var theoryAttribute = Mocks.TheoryAttribute();|var dataAttribute = Mocks.DataAttribute();|var testMethod = Mocks.TestMethod(\"MockTheoryType\", \"MockTheoryMethod\", methodAttributes: new[] { theoryAttribute, dataAttribute });|var testCases = discoverer.Discover(discoveryOptions, testMethod, theoryAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"MockTheoryType.MockTheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "NonSerializableDataYieldsSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(NonSerializableDataClass), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod\", theoryTestCase.DisplayName);|var message = Assert.Single(discoverer.DiagnosticMessages);|var diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);|Assert.Equal(\"Non-serializable data ('System.Object[]') found for 'TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod'; falling back to single test case.\", diagnostic.Message);|}"
      },
      {
        "name": "NoSuchDataDiscoverer_ThrowsInvalidOperationException",
        "body": "{|var results = Run<ITestFailed>(typeof(NoSuchDataDiscovererClass));|var failure = Assert.Single(results);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NoSuchDataDiscovererAttribute on TheoryDiscovererTests+NoSuchDataDiscovererClass.Test does not exist.\", failure.Messages.Single());|}"
      },
      {
        "name": "NotADataDiscoverer_ThrowsInvalidOperationException",
        "body": "{|var results = Run<ITestFailed>(typeof(NotADataDiscovererClass));|var failure = Assert.Single(results);|Assert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());|Assert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NotADataDiscovererAttribute on TheoryDiscovererTests+NotADataDiscovererClass.Test does not implement IDataDiscoverer.\", failure.Messages.Single());|}"
      },
      {
        "name": "NonDiscoveryEnumeratedDataYieldsSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(NonDiscoveryEnumeratedData), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+NonDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "MixedDiscoveryEnumerationDataYieldSingleTheoryTestCase",
        "body": "{|var discoverer = TestableTheoryDiscoverer.Create();|var testMethod = Mocks.TestMethod(typeof(MixedDiscoveryEnumeratedData), \"TheoryMethod\");|var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();|var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);|var testCase = Assert.Single(testCases);|var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);|Assert.Equal(\"TheoryDiscovererTests+MixedDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);|}"
      },
      {
        "name": "SkippedTheoryWithNoData",
        "body": "{|var skips = Run<ITestSkipped>(typeof(SkippedWithNoData));|var skip = Assert.Single(skips);|Assert.Equal(\"TheoryDiscovererTests+SkippedWithNoData.TestMethod\", skip.Test.DisplayName);|Assert.Equal(\"I have no data\", skip.Reason);|}"
      },
      {
        "name": "SkippedTheoryWithData",
        "body": "{|var skips = Run<ITestSkipped>(typeof(SkippedWithData));|var skip = Assert.Single(skips);|Assert.Equal(\"TheoryDiscovererTests+SkippedWithData.TestMethod\", skip.Test.DisplayName);|Assert.Equal(\"I have data\", skip.Reason);|}"
      }
    ]
  },
  {
    "file": "XunitTestFrameworkDiscovererTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|var assembly = Substitute.For<IAssemblyInfo>();|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var diagnosticMessageSink = SpyMessageSink.Create();|Assert.Throws<ArgumentNullException>(\"assemblyInfo\", () => new XunitTestFrameworkDiscoverer(null, sourceProvider, diagnosticMessageSink));|Assert.Throws<ArgumentNullException>(\"sourceProvider\", () => new XunitTestFrameworkDiscoverer(assembly, null, diagnosticMessageSink));|Assert.Throws<ArgumentNullException>(\"diagnosticMessageSink\", () => new XunitTestFrameworkDiscoverer(assembly, sourceProvider, null));|}"
      },
      {
        "name": "GuardClauses",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|Assert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: TestFrameworkOptions.ForDiscovery()));|Assert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: Substitute.For<IMessageSink>(), discoveryOptions: null));|}"
      },
      {
        "name": "AssemblyWithNoTypes_ReturnsNoTestCases",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|framework.Find();|Assert.Empty(framework.TestCases);|}"
      },
      {
        "name": "RequestsOnlyPublicTypesFromAssembly",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create(collectionFactory: Substitute.For<IXunitTestCollectionFactory>());|framework.Find();|framework.Assembly.Received(1).GetTypes(includePrivateTypes: false);|}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{|var abstractClassTypeInfo = Reflector.Wrap(typeof(AbstractClass));|var assembly = Mocks.AssemblyInfo(types: new[] { abstractClassTypeInfo });|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);|framework.FindTestsForClass(null).ReturnsForAnyArgs(true);|framework.Find();|framework.Sink.Finished.WaitOne();|framework.Received(0).FindTestsForClass(Arg.Any<ITestClass>(), Arg.Any<bool>());|}"
      },
      {
        "name": "CallsFindImplWhenTypesAreFoundInAssembly",
        "body": "{|var objectTypeInfo = Reflector.Wrap(typeof(object));|var intTypeInfo = Reflector.Wrap(typeof(int));|var assembly = Mocks.AssemblyInfo(types: new[] { objectTypeInfo, intTypeInfo });|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);|framework.FindTestsForClass(null).ReturnsForAnyArgs(true);|framework.Find();|framework.Sink.Finished.WaitOne();|framework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == objectTypeInfo), false);|framework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == intTypeInfo), false);|}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));|var mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });|var framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);|framework.Find();|framework.Sink.Finished.WaitOne();|sourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());|}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|sourceProvider|.GetSourceInformation(null)|.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });|var typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));|var mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });|var framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);|framework.Find(includeSourceInformation: true);|Assert.Collection(framework.TestCases,|testCase =>|{|Assert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);|Assert.Equal(\"Source File\", testCase.SourceInformation.FileName);|Assert.Equal(42, testCase.SourceInformation.LineNumber);|}|);|}"
      },
      {
        "name": "GuardClauses",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var typeName = typeof(object).FullName;|var sink = Substitute.For<IMessageSink>();|var options = TestFrameworkOptions.ForDiscovery();|Assert.Throws<ArgumentNullException>(\"typeName\", () => framework.Find(typeName: null, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));|Assert.Throws<ArgumentException>(\"typeName\", () => framework.Find(typeName: \"\", includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));|Assert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: options));|Assert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: null));|}"
      },
      {
        "name": "RequestsPublicAndPrivateMethodsFromType",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var type = Substitute.For<ITypeInfo>();|framework.Assembly.GetType(\"abc\").Returns(type);|framework.Find(\"abc\");|framework.Sink.Finished.WaitOne();|type.Received(1).GetMethods(includePrivateMethods: true);|}"
      },
      {
        "name": "CallsFindImplWhenMethodsAreFoundOnType",
        "body": "{|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();|var type = Substitute.For<ITypeInfo>();|framework.Assembly.GetType(\"abc\").Returns(type);|framework.Find(\"abc\");|framework.Sink.Finished.WaitOne();|framework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), false);|}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{|var framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();|var type = Substitute.For<ITypeInfo>();|type.IsAbstract.Returns(true);|framework.Assembly.GetType(\"abc\").Returns(type);|framework.Find(\"abc\");|framework.Sink.Finished.WaitOne();|framework.Received(0).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), Arg.Any<bool>());|}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|var framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);|framework.Find(\"abc\");|sourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());|}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{|var sourceProvider = Substitute.For<ISourceInformationProvider>();|sourceProvider|.GetSourceInformation(null)|.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });|var framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);|var typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));|framework.Assembly.GetType(\"abc\").Returns(typeInfo);|framework.Find(\"abc\", includeSourceInformation: true);|Assert.Collection(framework.TestCases,|testCase =>|{|Assert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);|Assert.Equal(\"Source File\", testCase.SourceInformation.FileName);|Assert.Equal(42, testCase.SourceInformation.LineNumber);|}|);|}"
      },
      {
        "name": "ClassWithNoTests_ReturnsNoTestCases",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithNoTests)));|framework.FindTestsForClass(testClass);|Assert.False(framework.Sink.Finished.WaitOne(0));|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithFact_ReturnsOneTestCaseOfTypeXunitTestCase",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithOneFact)));|framework.FindTestsForClass(testClass);|var testCase = Assert.Single(framework.Sink.TestCases);|Assert.IsType<XunitTestCase>(testCase);|}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithMixOfFactsAndNonTests_ReturnsTestCasesOnlyForFacts",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithMixOfFactsAndNonFacts)));|framework.FindTestsForClass(testClass);|Assert.Equal(2, framework.Sink.TestCases.Count);|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod1\");|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod2\");|}"
      },
      {
        "name": "AssemblyWithTheoryWithInlineData_ReturnsOneTestCasePerDataRecord",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = Mocks.TestClass(typeof(TheoryWithInlineData));|framework.FindTestsForClass(testClass);|Assert.Equal(2, framework.Sink.TestCases.Count);|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: \\\"Hello world\\\")\");|Assert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: 42)\");|}"
      },
      {
        "name": "AssemblyWithTheoryWithPropertyData_ReturnsOneTestCasePerDataRecord",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = Mocks.TestClass(typeof(TheoryWithPropertyData));|framework.FindTestsForClass(testClass);|Assert.Equal(2, framework.Sink.TestCases.Count);|Assert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 42)\");|Assert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 2112)\");|}"
      },
      {
        "name": "AssemblyWithMultiLevelHierarchyWithFactOverridenInNonImmediateDerivedClass_ReturnsOneTestCase",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var testClass = Mocks.TestClass(typeof(Child));|framework.FindTestsForClass(testClass);|Assert.Equal(1, framework.Sink.TestCases.Count);|Assert.Equal(\"XunitTestFrameworkDiscovererTests+FindImpl+Child.FactOverridenInNonImmediateDerivedClass\", framework.Sink.TestCases[0].DisplayName);|}"
      },
      {
        "name": "FactOverridenInNonImmediateDerivedClass",
        "body": "{|Assert.True(true);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefaultTestCollection",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var type = Reflector.Wrap(typeof(ClassWithNoCollection));|var testClass = framework.CreateTestClass(type);|Assert.NotNull(testClass.TestCollection);|Assert.Equal(\"Test collection for XunitTestFrameworkDiscovererTests+CreateTestClass+ClassWithNoCollection\", testClass.TestCollection.DisplayName);|Assert.Null(testClass.TestCollection.CollectionDefinition);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "UndeclaredTestCollection",
        "body": "{|var framework = TestableXunitTestFrameworkDiscoverer.Create();|var type = Reflector.Wrap(typeof(ClassWithUndeclaredCollection));|var testClass = framework.CreateTestClass(type);|Assert.NotNull(testClass.TestCollection);|Assert.Equal(\"This a collection without declaration\", testClass.TestCollection.DisplayName);|Assert.Null(testClass.TestCollection.CollectionDefinition);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefinedTestCollection",
        "body": "{|var type = Reflector.Wrap(typeof(ClassWithDefinedCollection));|var framework = TestableXunitTestFrameworkDiscoverer.Create(type.Assembly);|var testClass = framework.CreateTestClass(type);|Assert.NotNull(testClass.TestCollection);|Assert.Equal(\"This a defined collection\", testClass.TestCollection.DisplayName);|Assert.NotNull(testClass.TestCollection.CollectionDefinition);|Assert.Equal(\"XunitTestFrameworkDiscovererTests+CreateTestClass+DeclaredCollection\", testClass.TestCollection.CollectionDefinition.Name);|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "ATestNotToBeRun",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestFrameworkTests.cs",
    "methods": [
      {
        "name": "Defaults",
        "body": "{|var framework = new XunitTestFramework();|Assert.Matches(@\"xUnit.net v3 \\d+\\.\\d+\\.\\d+(-pre\\.\\d+(-dev)?(\\+[0-9a-f]+)?)?\", framework.TestFrameworkDisplayName);|}"
      }
    ]
  },
  {
    "file": "ConsoleCaptureTestOutputWriterTests.cs",
    "methods": [
      {
        "name": "CapturesConsoleOut",
        "body": "{|Console.WriteLine(\"This is a line of text from Console.WriteLine\");|Assert.Equal(\"This is a line of text from Console.WriteLine\" + Environment.NewLine, testOutputHelper.Output);|}"
      },
      {
        "name": "CapturesConsoleError",
        "body": "{|Console.Error.WriteLine(\"This is a line of text from Console.Error.WriteLine\");|Assert.Equal(\"This is a line of text from Console.Error.WriteLine\" + Environment.NewLine, testOutputHelper.Output);|}"
      },
      {
        "name": "OutputIsInterleaved",
        "body": "{|Console.WriteLine(\"This is a line of text from Console.WriteLine\");|testOutputHelper.WriteLine(\"This is a line of text from the output helper\");|Console.Error.WriteLine(\"This is a line of text from Console.Error.WriteLine\");|Assert.Equal(|\"This is a line of text from Console.WriteLine\" + Environment.NewLine +|\"This is a line of text from the output helper\" + Environment.NewLine +|\"This is a line of text from Console.Error.WriteLine\" + Environment.NewLine,|testOutputHelper.Output|);|}"
      }
    ]
  },
  {
    "file": "MessageBusTests.cs",
    "methods": [
      {
        "name": "QueuedMessageShowUpInMessageSink",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var sink = SpyMessageSink.Create(messages: messages);|var msg1 = Substitute.For<IMessageSinkMessage>();|var msg2 = Substitute.For<IMessageSinkMessage>();|var msg3 = Substitute.For<IMessageSinkMessage>();|using (var bus = new MessageBus(sink))|{|bus.QueueMessage(msg1);|bus.QueueMessage(msg2);|bus.QueueMessage(msg3);|}|Assert.Collection(messages,|message => Assert.Same(msg1, message),|message => Assert.Same(msg2, message),|message => Assert.Same(msg3, message)|);|}"
      },
      {
        "name": "TryingToQueueMessageAfterDisposingThrows",
        "body": "{|var bus = new MessageBus(SpyMessageSink.Create());|bus.Dispose();|var exception = Record.Exception(|() => bus.QueueMessage(Substitute.For<IMessageSinkMessage>())|);|Assert.IsType<ObjectDisposedException>(exception);|}"
      },
      {
        "name": "WhenSinkThrowsMessagesContinueToBeDelivered",
        "body": "{|var sink = Substitute.For<IMessageSink>();|var msg1 = Substitute.For<IMessageSinkMessage>();|var msg2 = Substitute.For<IMessageSinkMessage>();|var msg3 = Substitute.For<IMessageSinkMessage>();|var messages = new List<IMessageSinkMessage>();|sink.OnMessage(Arg.Any<IMessageSinkMessage>())|.Returns(callInfo =>|{|var msg = (IMessageSinkMessage)callInfo[0];|if (msg == msg2)|throw new DivideByZeroException(\"whee!\");|else|messages.Add(msg);|return false;|});|using (var bus = new MessageBus(sink))|{|bus.QueueMessage(msg1);|bus.QueueMessage(msg2);|bus.QueueMessage(msg3);|}|Assert.Collection(messages,|message => Assert.Same(message, msg1),|message =>|{|var errorMessage = Assert.IsAssignableFrom<IErrorMessage>(message);|Assert.Equal(\"System.DivideByZeroException\", errorMessage.ExceptionTypes.Single());|Assert.Equal(\"whee!\", errorMessage.Messages.Single());|},|message => Assert.Same(message, msg3)|);|}"
      },
      {
        "name": "QueueReturnsTrueForFailIfStopOnFailFalse",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var sink = SpyMessageSink.Create(messages: messages);|var msg1 = Substitute.For<IMessageSinkMessage>();|var msg2 = Substitute.For<ITestFailed>();|var msg3 = Substitute.For<IMessageSinkMessage>();|using (var bus = new MessageBus(sink))|{|Assert.True(bus.QueueMessage(msg1));|Assert.True(bus.QueueMessage(msg2));|Assert.True(bus.QueueMessage(msg3));|}|Assert.Collection(messages,|message => Assert.Same(msg1, message),|message => Assert.Same(msg2, message),|message => Assert.Same(msg3, message)|);|}"
      }
    ]
  },
  {
    "file": "SynchronousMessageBusTests.cs",
    "methods": [
      {
        "name": "MessagesAreDispatchedImmediatelyFromBus",
        "body": "{|var msg1 = Substitute.For<IMessageSinkMessage>();|var dispatchedMessages = new List<IMessageSinkMessage>();|using (var bus = new SynchronousMessageBus(SpyMessageSink.Create(messages: dispatchedMessages), stopOnFail: false))|{|Assert.True(bus.QueueMessage(msg1));|}|var message = Assert.Single(dispatchedMessages);|Assert.Same(msg1, message);|}"
      },
      {
        "name": "BusShouldReportShutdownWhenMessageSinkReturnsFalse",
        "body": "{|using (var bus = new SynchronousMessageBus(SpyMessageSink.Create(returnResult: false), stopOnFail: false))|{|Assert.False(bus.QueueMessage(Substitute.For<IMessageSinkMessage>()));|}|}"
      }
    ]
  },
  {
    "file": "TraceCaptureTestOutputWriterTests.cs",
    "methods": [
      {
        "name": "CapturesTrace",
        "body": "{|Trace.WriteLine(\"This is a line of text from Trace.WriteLine\");|Assert.Equal(\"This is a line of text from Trace.WriteLine\" + Environment.NewLine, testOutputHelper.Output);|}"
      },
      {
        "name": "CapturesDebug",
        "body": "{|Debug.WriteLine(\"This is a line of text from Debug.WriteLine\");|#if DEBUG|Assert.Equal(\"This is a line of text from Debug.WriteLine\" + Environment.NewLine, testOutputHelper.Output);|#else|Assert.Empty(testOutputHelper.Output);|#endif|}"
      },
      {
        "name": "OutputIsInterleaved",
        "body": "{|Trace.WriteLine(\"This is a line of text from Trace.WriteLine\");|testOutputHelper.WriteLine(\"This is a line of text from the output helper\");|Debug.WriteLine(\"This is a line of text from Debug.WriteLine\");|Assert.Equal(|\"This is a line of text from Trace.WriteLine\" + Environment.NewLine +|\"This is a line of text from the output helper\" + Environment.NewLine +|#if DEBUG|\"This is a line of text from Debug.WriteLine\" + Environment.NewLine,|#else|\"\",|#endif|testOutputHelper.Output|);|}"
      }
    ]
  },
  {
    "file": "MatrixTheoryDataTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|var nonEmptyData = new[] { new object() };|Assert.Throws<ArgumentNullException>(\"dimension1\", () => new MatrixTheoryData<object?, object?>(null!, nonEmptyData));|Assert.Throws<ArgumentNullException>(\"dimension2\", () => new MatrixTheoryData<object?, object?>(nonEmptyData, null!));|var emptyData = Array.Empty<object>();|Assert.Throws<ArgumentException>(\"dimension1\", () => new MatrixTheoryData<object?, object?>(emptyData, nonEmptyData));|Assert.Throws<ArgumentException>(\"dimension2\", () => new MatrixTheoryData<object?, object?>(nonEmptyData, emptyData));|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messages = await RunAsync(typeof(SampleUsage));|Assert.Collection(|messages.OfType<ITestPassed>().Select(passed => messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == passed.TestUniqueID).TestDisplayName).OrderBy(x => x),|displayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"Hello\\\", y: 5)\", displayName),|displayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"world!\\\", y: 6)\", displayName)|);|Assert.Collection(|messages.OfType<ITestFailed>().Select(failed => messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID).TestDisplayName).OrderBy(x => x),|displayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"Hello\\\", y: 42)\", displayName),|displayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"Hello\\\", y: 6)\", displayName),|displayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"world!\\\", y: 42)\", displayName),|displayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"world!\\\", y: 5)\", displayName)|);|}"
      }
    ]
  },
  {
    "file": "MessageSinkMessageTests.cs",
    "methods": [
      {
        "name": "WithoutJsonTypeID_Throws",
        "body": "{|var msg = new DerivedMessageSinkMessage();|var ex = Record.Exception(() => msg.ToJson());|Assert.IsType<InvalidOperationException>(ex);|Assert.Equal($\"Message sink message type '{typeof(DerivedMessageSinkMessage).SafeName()}' is missing its [JsonTypeID] decoration\", ex.Message);|}"
      },
      {
        "name": "SerializationExcludesNullValuesAndEmptyTraits",
        "body": "{|var startTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));|var msg = new TestAssemblyStarting|{|AssemblyUniqueID = \"asm-id\",|AssemblyName = \"asm-name\",|AssemblyPath = \"asm-path\",|ConfigFilePath = null,|Seed = null,|StartTime = startTime,|TargetFramework = null,|TestEnvironment = \"test-env\",|TestFrameworkDisplayName = \"test-framework\",|Traits = TestData.EmptyTraits,|};|var json = msg.ToJson();|Assert.NotNull(json);|var expected =|@\"{| \"\"$type\"\": \"\"test-assembly-starting\"\",| \"\"AssemblyUniqueID\"\": \"\"asm-id\"\",| \"\"AssemblyName\"\": \"\"asm-name\"\",| \"\"AssemblyPath\"\": \"\"asm-path\"\",| \"\"StartTime\"\": \"\"2020-09-26T13:55:27.2120000-07:00\"\",| \"\"TestEnvironment\"\": \"\"test-env\"\",| \"\"TestFrameworkDisplayName\"\": \"\"test-framework\"\"|}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");|Assert.Equal(expected, json);|}"
      },
      {
        "name": "SerializesEnumsAsStringsAndExcludesEmptyOutput",
        "body": "{|var finishTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));|var msg = new TestFailed|{|AssemblyUniqueID = \"asm-id\",|Cause = FailureCause.Assertion,|ExceptionParentIndices = [-1],|ExceptionTypes = [\"exception-type\"],|ExecutionTime = 123.45m,|FinishTime = finishTime,|Messages = [\"exception-message\"],|Output = \"\",|StackTraces = [null],|TestCaseUniqueID = \"test-case-id\",|TestClassUniqueID = null,|TestCollectionUniqueID = \"test-collection-id\",|TestMethodUniqueID = null,|TestUniqueID = \"test-id\",|Warnings = null,|};|var json = msg.ToJson();|Assert.NotNull(json);|var expected =|@\"{| \"\"$type\"\": \"\"test-failed\"\",| \"\"AssemblyUniqueID\"\": \"\"asm-id\"\",| \"\"TestCollectionUniqueID\"\": \"\"test-collection-id\"\",| \"\"TestCaseUniqueID\"\": \"\"test-case-id\"\",| \"\"TestUniqueID\"\": \"\"test-id\"\",| \"\"ExecutionTime\"\": 123.45,| \"\"FinishTime\"\": \"\"2020-09-26T13:55:27.2120000-07:00\"\",| \"\"Cause\"\": \"\"Assertion\"\",| \"\"ExceptionParentIndices\"\": [-1],| \"\"ExceptionTypes\"\": [\"\"exception-type\"\"],| \"\"Messages\"\": [\"\"exception-message\"\"],| \"\"StackTraces\"\": [null]|}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");|Assert.Equal(expected, json);|}"
      },
      {
        "name": "ValidatesAllDerivedTypesAreSupported",
        "body": "{|var excludedTypes = new HashSet<Type> {|typeof(MessageSinkMessage),|typeof(DerivedMessageSinkMessage),|};|var derivedTypes =|typeof(MessageSinkMessage)|.Assembly|.GetTypes()|.Where(t => !t.IsAbstract && !excludedTypes.Contains(t) && typeof(IMessageSinkMessage).IsAssignableFrom(t))|.ToList();|var missingTypes =|derivedTypes|.Where(t => t.GetCustomAttribute<JsonTypeIDAttribute>() is null)|.ToList();|if (missingTypes.Count > 0)|throw new XunitException($\"The following message classes are missing [JsonTypeID]:{Environment.NewLine}{string.Join(Environment.NewLine, missingTypes.Select(t => $\" - {t.SafeName()}\").OrderBy(t => t))}\");|}"
      }
    ]
  },
  {
    "file": "TestFailedTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|var ex = Record.Exception(() => new TestFailed|{|Cause = (FailureCause)2112,|AssemblyUniqueID = \"\",|ExceptionParentIndices = [],|ExceptionTypes = [],|ExecutionTime = 0,|FinishTime = DateTimeOffset.UtcNow,|Messages = [],|Output = \"\",|StackTraces = [],|TestCaseUniqueID = \"\",|TestClassUniqueID = \"\",|TestCollectionUniqueID = \"\",|TestMethodUniqueID = \"\",|TestUniqueID = \"\",|Warnings = [],|});|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"Cause\", argEx.ParamName);|Assert.StartsWith($\"Enum value 2112 not in valid set: [Assertion, Exception, Other, Timeout]\", argEx.Message);|}"
      },
      {
        "name": "NonAssertionException",
        "body": "{|var ex = new DivideByZeroException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Exception, failed.Cause);|}"
      },
      {
        "name": "BuiltInAssertionException",
        "body": "{|var ex = EqualException.ForMismatchedValues(42, 2112);|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Assertion, failed.Cause);|}"
      },
      {
        "name": "CustomAssertionException",
        "body": "{|var ex = new MyAssertionException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Assertion, failed.Cause);|}"
      },
      {
        "name": "BuiltInTimeoutException",
        "body": "{|var ex = TestTimeoutException.ForTimedOutTest(2112);|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Timeout, failed.Cause);|}"
      },
      {
        "name": "CustomTimeoutException",
        "body": "{|var ex = new MyTimeoutException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Timeout, failed.Cause);|}"
      },
      {
        "name": "TimeoutExceptionTrumpsAssertionException",
        "body": "{|var ex = new MyMultiException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Timeout, failed.Cause);|}"
      }
    ]
  },
  {
    "file": "XunitTestAssemblyTests.cs",
    "methods": [
      {
        "name": "AssemblyFixtureTypes",
        "body": "{|var fixtures = testAssembly.AssemblyFixtureTypes;|var fixture = Assert.Single(fixtures);|Assert.Equal(\"SomeNamespace.SomeFixtureClass\", fixture.FullName);|}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{|var attributes = testAssembly.BeforeAfterTestAttributes;|var attribute = Assert.Single(attributes);|Assert.Equal(\"SomeNamespace.BeforeAfterTest1Attribute\", attribute.GetType().FullName);|}"
      },
      {
        "name": "CollectionBehavior",
        "body": "{|var behavior = testAssembly.CollectionBehavior;|Assert.NotNull(behavior);|Assert.True(behavior.DisableTestParallelization);|Assert.Equal(42, behavior.MaxParallelThreads);|}"
      },
      {
        "name": "CollectionDefinitions",
        "body": "{|var definitions = testAssembly.CollectionDefinitions;|Assert.Collection(|definitions.OrderBy(d => d.Key),|definition =>|{|Assert.Equal(\"Foo\", definition.Key);|Assert.Equal(\"SomeNamespace.NamedCollectionDefinition\", definition.Value.Type.FullName);|},|definition =>|{|// The ID is based on the assembly ID, which is based on the assembly name. Since we rebuild every time|// and get a random assembly name every time, this ID will change every time. This is the same reason we|// don't check the unique ID of the test assembly itself.|Assert.Matches(\"Test collection for SomeNamespace.UnnamedCollectionDefinition \\\\(id: [0-9a-f]{64}\\\\)\", definition.Key);|Assert.Equal(\"SomeNamespace.UnnamedCollectionDefinition\", definition.Value.Type.FullName);|}|);|}"
      },
      {
        "name": "TargetFramework",
        "body": "{|Assert.Equal(\".NETFramework,Version=v4.7.2\", testAssembly.TargetFramework);|}"
      },
      {
        "name": "TestCaseOrderer",
        "body": "{|var orderer = testAssembly.TestCaseOrderer;|Assert.NotNull(orderer);|Assert.Equal(\"SomeNamespace.MyTestCaseOrderer\", orderer.GetType().FullName);|}"
      },
      {
        "name": "TestCollectionOrderer",
        "body": "{|var orderer = testAssembly.TestCollectionOrderer;|Assert.NotNull(orderer);|Assert.Equal(\"SomeNamespace.MyTestCollectionOrderer\", orderer.GetType().FullName);|}"
      },
      {
        "name": "Traits",
        "body": "{|var traits = testAssembly.Traits;|var trait = Assert.Single(traits);|Assert.Equal(\"Hello\", trait.Key);|var value = Assert.Single(trait.Value);|Assert.Equal(\"World\", value);|}"
      },
      {
        "name": "Version",
        "body": "{|var version = testAssembly.Version;|Assert.Equal(new Version(1, 2, 3, 4), version);|}"
      },
      {
        "name": "Serialization",
        "body": "{|var serialized = SerializationHelper.Instance.Serialize(testAssembly);|var deserialized = SerializationHelper.Instance.Deserialize(serialized);|Assert.IsType<XunitTestAssembly>(deserialized);|Assert.Equivalent(testAssembly, deserialized);|}"
      }
    ]
  },
  {
    "file": "XunitTestCaseTests.cs",
    "methods": [
      {
        "name": "DefaultBehavior",
        "body": "{|var testMethod = Mocks.TestMethod(\"MockType\", \"MockMethod\");|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"MockType.MockMethod\", testCase.DisplayName);|Assert.Null(testCase.SkipReason);|Assert.Empty(testCase.Traits);|}"
      },
      {
        "name": "SkipReason",
        "body": "{|var testMethod = Mocks.TestMethod(skip: \"Skip Reason\");|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Skip Reason\", testCase.SkipReason);|}"
      },
      {
        "name": "Timeout",
        "body": "{|var testMethod = Mocks.TestMethod(timeout: 42);|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(42, testCase.Timeout);|}"
      },
      {
        "name": "TraitsOnTestMethod",
        "body": "{|var trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");|var trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");|var testMethod = Mocks.TestMethod(methodAttributes: new[] { trait1, trait2 });|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));|Assert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));|}"
      },
      {
        "name": "TraitsOnTestClass",
        "body": "{|var trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");|var trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");|var testMethod = Mocks.TestMethod(classAttributes: new[] { trait1, trait2 });|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));|Assert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));|}"
      },
      {
        "name": "CustomTrait",
        "body": "{|var passingTests = Run<ITestPassed>(typeof(ClassWithCustomTraitTest));|var passingTest = Assert.Single(passingTests);|if (passingTest != null)|Assert.Collection(|passingTest.TestCase.Traits.OrderBy(x => x.Key),|namedTrait =>|{|Assert.Equal(\"Assembly\", namedTrait.Key);|var value = Assert.Single(namedTrait.Value);|Assert.Equal(\"Trait\", value);|},|namedTrait =>|{|Assert.Equal(\"Author\", namedTrait.Key);|var value = Assert.Single(namedTrait.Value);|Assert.Equal(\"Some Schmoe\", value);|},|namedTrait =>|{|Assert.Equal(\"Bug\", namedTrait.Key);|var value = Assert.Single(namedTrait.Value);|Assert.Equal(\"2112\", value);|});|}"
      },
      {
        "name": "CustomTraitWithoutDiscoverer",
        "body": "{|var trait = Mocks.TraitAttribute<BadTraitAttribute>();|var testMethod = Mocks.TestMethod(classAttributes: new[] { trait });|var messages = new List<IMessageSinkMessage>();|var spy = SpyMessageSink.Create(messages: messages);|var testCase = new XunitTestCase(spy, TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Empty(testCase.Traits);|var diagnosticMessages = messages.OfType<IDiagnosticMessage>();|var diagnosticMessage = Assert.Single(diagnosticMessages);|Assert.Equal($\"Trait attribute on '{testCase.DisplayName}' did not have [TraitDiscoverer]\", diagnosticMessage.Message);|}"
      },
      {
        "name": "BugFix",
        "body": "{ }"
      },
      {
        "name": "CustomDisplayName",
        "body": "{|var testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\");|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);|Assert.Equal(\"Custom Display Name\", testCase.DisplayName);|}"
      },
      {
        "name": "CustomDisplayNameWithArguments",
        "body": "{|var param1 = Mocks.ParameterInfo(\"p1\");|var param2 = Mocks.ParameterInfo(\"p2\");|var param3 = Mocks.ParameterInfo(\"p3\");|var testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\", parameters: new[] { param1, param2, param3 });|var arguments = new object[] { 42, \"Hello, world!\", 'A' };|var testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod, arguments);|Assert.Equal(\"Custom Display Name(p1: 42, p2: \\\"Hello, world!\\\", p3: 'A')\", testCase.DisplayName);|}"
      }
    ]
  },
  {
    "file": "XunitTestClassTests.cs",
    "methods": [
      {
        "name": "Metadata",
        "body": "{|Assert.Equal(typeof(ClassUnderTest), testClass.Class);|Assert.Equal(\"SomeNamespace.ClassUnderTest\", testClass.TestClassName);|Assert.Equal(\"SomeNamespace\", testClass.TestClassNamespace);|Assert.Equal(\"ClassUnderTest\", testClass.TestClassSimpleName);|}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{|var result = testClass.BeforeAfterTestAttributes;|Assert.Collection(|result.OrderBy(a => a.GetType().Name),|attr => Assert.IsType<BeforeAfterOnAssembly>(attr),|attr => Assert.IsType<BeforeAfterOnClass>(attr),|attr => Assert.IsType<BeforeAfterOnCollection>(attr)|);|}"
      },
      {
        "name": "ClassFixtureTypes",
        "body": "{|var fixtures = testClass.ClassFixtureTypes;|var fixture = Assert.Single(fixtures);|Assert.Equal(typeof(MyClassFixture), fixture);|}"
      },
      {
        "name": "Constructors",
        "body": "{|var constructors = testClass.Constructors;|Assert.NotNull(constructors);|Assert.Collection(|constructors.OrderBy(c => c.GetParameters().Length),|constructor => Assert.Empty(constructor.GetParameters()),|constructor => Assert.Single(constructor.GetParameters())|);|}"
      },
      {
        "name": "Methods",
        "body": "{|var methods = testClass.Methods;|static string displayName(MethodInfo method)|{|var parameterTexts =|method|.GetParameters()|.Select(p => $\"{p.ParameterType.FullName} {p.Name}\");|return $\"{method.DeclaringType?.FullName}.{method.Name}({string.Join(\", \", parameterTexts)})\";|}|Assert.Collection(|methods.Where(m => m.DeclaringType != typeof(object)).Select(displayName).OrderBy(x => x),|method => Assert.Equal(\"SomeNamespace.BaseClass.BaseMethod()\", method),|method => Assert.Equal(\"SomeNamespace.BaseClass.BaseStaticMethod()\", method),|method => Assert.Equal(\"SomeNamespace.ClassUnderTest.InternalMethod()\", method),|method => Assert.Equal(\"SomeNamespace.ClassUnderTest.PrivateMethod()\", method),|method => Assert.Equal(\"SomeNamespace.ClassUnderTest.ProtectedMethod()\", method),|method => Assert.Equal(\"SomeNamespace.ClassUnderTest.PublicMethod()\", method)|);|}"
      },
      {
        "name": "TestCaseOrderer",
        "body": "{|var orderer = testClass.TestCaseOrderer;|Assert.IsType<SomeNamespace.MyTestCaseOrderer>(orderer);|}"
      },
      {
        "name": "Traits",
        "body": "{|var traits = testClass.Traits;|var trait = Assert.Single(traits);|Assert.Equal(\"Hello\", trait.Key);|var value = Assert.Single(trait.Value);|Assert.Equal(\"World\", value);|}"
      },
      {
        "name": "Serialization",
        "body": "{|// We can't use the XunitTestClass backed by mocks because they don't serialize, so we'll create|// one here that's backed by an actual XunitTestAssembly object.|var testCollection = TestData.XunitTestCollection<ClassUnderTest>();|var testClass = new XunitTestClass(typeof(ClassUnderTest), testCollection);|var serialized = SerializationHelper.Instance.Serialize(testClass);|var deserialized = SerializationHelper.Instance.Deserialize(serialized);|Assert.IsType<XunitTestClass>(deserialized);|Assert.Equivalent(testClass, deserialized);|}"
      }
    ]
  },
  {
    "file": "XunitTestCollectionTests.cs",
    "methods": [
      {
        "name": "Metadata",
        "body": "{|Assert.Equal(typeof(MyCollection), testCollection.CollectionDefinition);|Assert.Equal(\"XunitTestCollectionTests+MyCollection\", testCollection.TestCollectionClassName);|Assert.Equal(\"display name\", testCollection.TestCollectionDisplayName);|}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{|var result = testCollection.BeforeAfterTestAttributes;|Assert.Collection(|result.OrderBy(a => a.GetType().Name),|attr => Assert.IsType<BeforeAfterOnAssembly>(attr),|attr => Assert.IsType<BeforeAfterOnCollection>(attr)|);|}"
      },
      {
        "name": "ClassFixtureTypes",
        "body": "{|var fixtures = testCollection.ClassFixtureTypes;|var fixture = Assert.Single(fixtures);|Assert.Equal(typeof(MyClassFixture), fixture);|}"
      },
      {
        "name": "CollectionFixtureTypes",
        "body": "{|var fixtures = testCollection.CollectionFixtureTypes;|var fixture = Assert.Single(fixtures);|Assert.Equal(typeof(MyCollectionFixture), fixture);|}"
      },
      {
        "name": "DisableParallelization",
        "body": "{|var disableParallelization = testCollection.DisableParallelization;|Assert.True(disableParallelization);|}"
      },
      {
        "name": "TestCaseOrderer",
        "body": "{|var orderer = testCollection.TestCaseOrderer;|Assert.IsType<MyTestCaseOrderer>(orderer);|}"
      },
      {
        "name": "Serialization",
        "body": "{|// We can't use the XunitTestCollection backed by mocks because they don't serialize, so we'll create|// one here that's backed by an actual XunitTestAssembly object.|var testAssembly = TestData.XunitTestAssembly<ClassUnderTest>();|var testCollection = new XunitTestCollection(testAssembly, typeof(MyCollection), true, \"display name\");|var serialized = SerializationHelper.Instance.Serialize(testCollection);|var deserialized = SerializationHelper.Instance.Deserialize(serialized);|Assert.IsType<XunitTestCollection>(deserialized);|Assert.Equivalent(testCollection, deserialized);|}"
      }
    ]
  },
  {
    "file": "XunitTestMethodTests.cs",
    "methods": [
      {
        "name": "Metadata",
        "body": "{|Assert.Equal(nameof(ClassUnderTest.Passing), testMethod.MethodName);|}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{|var result = testMethod.BeforeAfterTestAttributes;|Assert.Collection(|result.OrderBy(a => a.GetType().Name),|attr => Assert.IsType<BeforeAfterOnAssembly>(attr),|attr => Assert.IsType<BeforeAfterOnClass>(attr),|attr => Assert.IsType<BeforeAfterOnCollection>(attr),|attr => Assert.IsType<BeforeAfterOnMethod>(attr)|);|}"
      },
      {
        "name": "DataAttributes",
        "body": "{|var attributes = testMethod.DataAttributes;|var attribute = Assert.Single(attributes);|Assert.IsType<InlineDataAttribute>(attribute);|}"
      },
      {
        "name": "FactAttributes",
        "body": "{|var attributes = testMethod.FactAttributes;|Assert.Collection(|attributes.OrderBy(x => x.GetType().Name),|attribute => Assert.IsType<FactAttribute>(attribute),|attribute => Assert.IsType<TheoryAttribute>(attribute)|);|}"
      },
      {
        "name": "Parameters",
        "body": "{|var parameters = testMethod.Parameters;|Assert.Collection(|parameters,|parameter => Assert.Equal(\"x\", parameter.Name),|parameter => Assert.Equal(\"y\", parameter.Name)|);|}"
      },
      {
        "name": "Traits",
        "body": "{|var traits = testMethod.Traits;|var trait = Assert.Single(traits);|Assert.Equal(\"Hello\", trait.Key);|var value = Assert.Single(trait.Value);|Assert.Equal(\"World\", value);|}"
      },
      {
        "name": "Serialization",
        "body": "{|// We can't use the XunitTestMethod backed by mocks because they don't serialize, so we'll create|// one here that's backed by an actual XunitTestAssembly object.|var testClass = TestData.XunitTestClass<ClassUnderTest>();|var method = typeof(ClassUnderTest).GetMethod(\"Passing\") ?? throw new InvalidOperationException(\"Could not find test method\");|var testMethod = new XunitTestMethod(testClass, method, []);|var serialized = SerializationHelper.Instance.Serialize(testMethod);|var deserialized = SerializationHelper.Instance.Deserialize(serialized);|Assert.IsType<XunitTestMethod>(deserialized);|Assert.Equivalent(testMethod, deserialized);|}"
      },
      {
        "name": "CanSerializeClosedGenericTestMethod",
        "body": "{|var methodInfo = typeof(ClassUnderTest).GetMethod(nameof(ClassUnderTest.TheoryWithTypeArgument))!;|var closedMethodInfo = methodInfo.MakeGenericMethod(typeof(string));|var testClass = TestData.XunitTestClass<ClassUnderTest>();|var testMethod = new XunitTestMethod(testClass, closedMethodInfo, [\"data\"]);|var serialized = SerializationHelper.Instance.Serialize(testMethod);|var deserialized = SerializationHelper.Instance.Deserialize(serialized);|Assert.IsType<XunitTestMethod>(deserialized);|Assert.Equivalent(testMethod, deserialized);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "RecordTests.cs",
    "methods": [
      {
        "name": "Exception",
        "body": "{|Exception ex = Record.Exception(delegate { throw new InvalidOperationException(); });|Assert.NotNull(ex);|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "NoException",
        "body": "{|Exception ex = Record.Exception(delegate { });|Assert.Null(ex);|}"
      },
      {
        "name": "Exception",
        "body": "{|StubAccessor accessor = new StubAccessor();|Exception ex = Record.Exception(() => accessor.FailingProperty);|Assert.NotNull(ex);|Assert.IsType<InvalidOperationException>(ex);|}"
      },
      {
        "name": "NoException",
        "body": "{|StubAccessor accessor = new StubAccessor();|Exception ex = Record.Exception(() => accessor.SuccessfulProperty);|Assert.Null(ex);|}"
      }
    ]
  },
  {
    "file": "ExecutionErrorTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var testCase = Mocks.ExecutionErrorTestCase(\"This is my error message\");|var runner = new ExecutionErrorTestCaseRunner(testCase, messageBus, aggregator, tokenSource);|var result = await runner.RunAsync();|Assert.Equal(1, result.Total);|Assert.Equal(0m, result.Time);|Assert.Collection(messageBus.Messages,|msg =>|{|var testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);|Assert.Same(testCase, testCaseStarting.TestCase);|},|msg =>|{|var testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);|Assert.Same(testCase, testStarting.TestCase);|},|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, failed.TestCollection);|Assert.Same(testCase, failed.TestCase);|Assert.Equal(0m, failed.ExecutionTime);|Assert.Empty(failed.Output);|var exceptionType = Assert.Single(failed.ExceptionTypes);|Assert.Equal(\"System.InvalidOperationException\", exceptionType);|var type = Assert.Single(failed.Messages);|Assert.Equal(\"This is my error message\", type);|},|msg =>|{|var testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);|Assert.Same(testCase, testFinished.TestCase);|Assert.Equal(0m, testFinished.ExecutionTime);|Assert.Empty(testFinished.Output);|},|msg =>|{|var testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);|Assert.Same(testCase, testCaseFinished.TestCase);|Assert.Equal(0m, testCaseFinished.ExecutionTime);|Assert.Equal(1, testCaseFinished.TestsRun);|Assert.Equal(1, testCaseFinished.TestsFailed);|Assert.Equal(0, testCaseFinished.TestsSkipped);|}|);|}"
      }
    ]
  },
  {
    "file": "TestAssemblyRunnerContextTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|await using var ctxt = TestableTestAssemblyRunnerContext.Create();|var ex = Record.Exception(() => ctxt.MessageBus);|var upex = Assert.IsType<UnsetPropertyException>(ex);|Assert.Equal(nameof(TestableTestAssemblyRunnerContext.MessageBus), upex.PropertyName);|Assert.Equal(typeof(TestableTestAssemblyRunnerContext).FullName, upex.TypeName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await using var ctxt = TestableTestAssemblyRunnerContext.Create();|await ctxt.InitializeAsync();|var result = ctxt.MessageBus;|Assert.IsType<MessageBus>(result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var executionOptions = TestData.TestFrameworkExecutionOptions();|executionOptions.SetSynchronousMessageReporting(true);|await using var ctxt = TestableTestAssemblyRunnerContext.Create(executionOptions);|await ctxt.InitializeAsync();|var result = ctxt.MessageBus;|Assert.IsType<SynchronousMessageBus>(result);|}"
      }
    ]
  },
  {
    "file": "TestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "DefaultMessageBus",
        "body": "{|var runner = TestableTestAssemblyRunner.Create();|var messageBus = runner.CreateMessageBus_Public();|Assert.IsType<MessageBus>(messageBus);|}"
      },
      {
        "name": "SyncMessageBusOption",
        "body": "{|var executionOptions = TestFrameworkOptions.ForExecution();|executionOptions.SetSynchronousMessageReporting(true);|var runner = TestableTestAssemblyRunner.Create(executionOptions: executionOptions);|var messageBus = runner.CreateMessageBus_Public();|Assert.IsType<SynchronousMessageBus>(messageBus);|}"
      },
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messages = new List<IMessageSinkMessage>();|var messageSink = SpyMessageSink.Create(messages: messages);|var runner = TestableTestAssemblyRunner.Create(messageSink, summary);|var thisAssembly = Assembly.GetExecutingAssembly();|var thisAppDomain = AppDomain.CurrentDomain;|var result = await runner.RunAsync();|Assert.Equal(4, result.Total);|Assert.Equal(2, result.Failed);|Assert.Equal(1, result.Skipped);|Assert.NotEqual(21.12m, result.Time); // Uses clock time, not result time|Assert.Collection(messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestAssemblyStarting>(msg);|#if NETFRAMEWORK|Assert.Equal(thisAssembly.GetLocalCodeBase(), starting.TestAssembly.Assembly.AssemblyPath);|Assert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, starting.TestAssembly.ConfigFileName);|#endif|Assert.InRange(starting.StartTime, DateTime.Now.AddMinutes(-15), DateTime.Now);|Assert.Equal(\"The test framework environment\", starting.TestEnvironment);|Assert.Equal(\"The test framework display name\", starting.TestFrameworkDisplayName);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(msg);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|Assert.Equal(result.Time, finished.ExecutionTime);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestAssemblyStarting_DoesNotQueueTestAssemblyFinished_DoesNotRunTestCollections",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageSink = Substitute.For<IMessageSink>();|messageSink.OnMessage(null)| .ReturnsForAnyArgs(callInfo =>| {| var msg = callInfo.Arg<IMessageSinkMessage>();| messages.Add(msg);| if (msg is ITestAssemblyStarting)| throw new InvalidOperationException();| return true;| });|var runner = TestableTestAssemblyRunner.Create(messageSink);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestAssemblyStarting>(starting);|Assert.Empty(runner.CollectionsRun);|}"
      },
      {
        "name": "FailureInAfterTestAssemblyStarting_GivesErroredAggregatorToTestCollectionRunner_NoCleanupFailureMessage",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageSink = SpyMessageSink.Create(messages: messages);|var runner = TestableTestAssemblyRunner.Create(messageSink);|var ex = new DivideByZeroException();|runner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestCollectionAsync_AggregatorResult);|Assert.Empty(messages.OfType<ITestAssemblyCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestAssemblyFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestAssemblyStarting",
        "body": "{|var thisAssembly = Assembly.GetExecutingAssembly();|var thisAppDomain = AppDomain.CurrentDomain;|var messages = new List<IMessageSinkMessage>();|var messageSink = SpyMessageSink.Create(messages: messages);|var testCases = new[] { Mocks.TestCase() };|var runner = TestableTestAssemblyRunner.Create(messageSink, testCases: testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestAssemblyFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messages.OfType<ITestAssemblyCleanupFailure>());|#if NETFRAMEWORK|Assert.Equal(thisAssembly.GetLocalCodeBase(), cleanupFailure.TestAssembly.Assembly.AssemblyPath);|Assert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, cleanupFailure.TestAssembly.ConfigFileName);|#endif|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestAssemblyStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{|var messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyStarting));|var runner = TestableTestAssemblyRunner.Create(messageSink);|await runner.RunAsync();|Assert.False(runner.AfterTestAssemblyStarting_Called);|Assert.False(runner.BeforeTestAssemblyFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestAssemblyFinished_CallsCallExtensibilityCallbacks",
        "body": "{|var messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyFinished));|var runner = TestableTestAssemblyRunner.Create(messageSink);|await runner.RunAsync();|Assert.True(runner.AfterTestAssemblyStarting_Called);|Assert.True(runner.BeforeTestAssemblyFinished_Called);|}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{|var collection1 = Mocks.TestCollection(displayName: \"1\");|var testCase1a = Mocks.TestCase(collection1);|var testCase1b = Mocks.TestCase(collection1);|var collection2 = Mocks.TestCollection(displayName: \"2\");|var testCase2a = Mocks.TestCase(collection2);|var testCase2b = Mocks.TestCase(collection2);|var runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1a, testCase2a, testCase2b, testCase1b });|await runner.RunAsync();|Assert.Collection(runner.CollectionsRun.OrderBy(c => c.Item1.DisplayName),|tuple =>|{|Assert.Same(collection1, tuple.Item1);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(testCase1a, testCase),|testCase => Assert.Same(testCase1b, testCase)|);|},|tuple =>|{|Assert.Same(collection2, tuple.Item1);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(testCase2a, testCase),|testCase => Assert.Same(testCase2b, testCase)|);|}|);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningCollections",
        "body": "{|var collection1 = Mocks.TestCollection();|var testCase1 = Mocks.TestCase(collection1);|var collection2 = Mocks.TestCollection();|var testCase2 = Mocks.TestCase(collection2);|var runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1, testCase2 }, cancelInRunTestCollectionAsync: true);|await runner.RunAsync();|Assert.Single(runner.CollectionsRun);|}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{|var runner = TestableTestAssemblyRunner.Create();|Assert.IsType<DefaultTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{|var runner = TestableTestAssemblyRunner.Create();|Assert.IsType<DefaultTestCollectionOrderer>(runner.TestCollectionOrderer);|}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var collection1 = Mocks.TestCollection(displayName: \"AAA\");|var testCase1 = Mocks.TestCase(collection1);|var collection2 = Mocks.TestCollection(displayName: \"ZZZZ\");|var testCase2 = Mocks.TestCase(collection2);|var collection3 = Mocks.TestCollection(displayName: \"MM\");|var testCase3 = Mocks.TestCase(collection3);|var testCases = new[] { testCase1, testCase2, testCase3 };|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableTestAssemblyRunner.Create(testCases: testCases, executionMessageSink: executionSink);|runner.TestCollectionOrderer = new ThrowingOrderer();|await runner.RunAsync();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Test collection orderer 'TestAssemblyRunnerTests+TestCollectionOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);|Assert.Empty(runner.CollectionsRun);|}"
      }
    ]
  },
  {
    "file": "TestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var runner = TestableTestCaseRunner.Create(messageBus, result: summary);|var result = await runner.RunAsync();|Assert.Same(result, summary);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);|Assert.Same(runner.TestCase, testCaseStarting.TestCase);|},|msg =>|{|var testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);|Assert.Same(runner.TestCase, testCaseFinished.TestCase);|Assert.Equal(21.12m, testCaseFinished.ExecutionTime);|Assert.Equal(4, testCaseFinished.TestsRun);|Assert.Equal(2, testCaseFinished.TestsFailed);|Assert.Equal(1, testCaseFinished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestCaseStarting_DoesNotQueueTestCaseFinished_DoesNotRunTests",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestCaseStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestCaseRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestCaseStarting>(starting);|Assert.False(runner.RunTestAsync_Called);|}"
      },
      {
        "name": "RunTestAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestCaseRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestCaseStarting_GivesErroredAggregatorToTestRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestCaseRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestCaseFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCaseStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");|var runner = TestableTestCaseRunner.Create(messageBus, testCase);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCaseCleanupFailure>());|Assert.Same(testCase, cleanupFailure.TestCase);|Assert.Equal(new[] { testCase }, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestCaseStarting_DoesNotCallExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCaseStarting));|var runner = TestableTestCaseRunner.Create(messageBus);|await runner.RunAsync();|Assert.False(runner.AfterTestCaseStarting_Called);|Assert.False(runner.BeforeTestCaseFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCaseFinished_CallsExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCaseFinished));|var runner = TestableTestCaseRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.AfterTestCaseStarting_Called);|Assert.True(runner.BeforeTestCaseFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCaseCleanupFailure));|var runner = TestableTestCaseRunner.Create(messageBus);|runner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      }
    ]
  },
  {
    "file": "TestClassRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var runner = TestableTestClassRunner.Create(messageBus, new[] { testCase }, result: summary);|var result = await runner.RunAsync();|Assert.Equal(result.Total, summary.Total);|Assert.Equal(result.Failed, summary.Failed);|Assert.Equal(result.Skipped, summary.Skipped);|Assert.Equal(result.Time, summary.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestClassStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Equal(\"TestClassRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestClassFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Equal(\"TestClassRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);|Assert.Equal(21.12m, finished.ExecutionTime);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestClassStarting_DoesNotQueueTestClassFinished_DoesNotRunTestMethods",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus.QueueMessage(null)| .ReturnsForAnyArgs(callInfo =>| {| var msg = callInfo.Arg<IMessageSinkMessage>();| messages.Add(msg);| if (msg is ITestClassStarting)| throw new InvalidOperationException();| return true;| });|var runner = TestableTestClassRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestClassStarting>(starting);|Assert.Empty(runner.MethodsRun);|}"
      },
      {
        "name": "RunTestMethodAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestClassRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestClassStarting_GivesErroredAggregatorToTestMethodRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestClassRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestClassFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestClassStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };|var runner = TestableTestClassRunner.Create(messageBus, testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestClassCleanupFailure>());|Assert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestClassStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestClassStarting));|var runner = TestableTestClassRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestClassStarting_Called);|Assert.False(runner.BeforeTestClassFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestClassFinished_CallsExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestClassFinished));|var runner = TestableTestClassRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.True(runner.AfterTestClassStarting_Called);|Assert.True(runner.BeforeTestClassFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestClassCleanupFailure));|var runner = TestableTestClassRunner.Create(messageBus);|runner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      },
      {
        "name": "TestsAreGroupedByMethod",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, other2, passing2 });|await runner.RunAsync();|Assert.Collection(runner.MethodsRun,|tuple =>|{|Assert.Equal(\"Passing\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing1, testCase),|testCase => Assert.Same(passing2, testCase)|);|},|tuple =>|{|Assert.Equal(\"Other\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(other1, testCase),|testCase => Assert.Same(other2, testCase)|);|}|);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{|var passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestClassRunner.Create(testCases: new[] { passing, other }, cancelInRunTestMethodAsync: true);|await runner.RunAsync();|var tuple = Assert.Single(runner.MethodsRun);|Assert.Equal(\"Passing\", tuple.Item1.Name);|}"
      },
      {
        "name": "TestsOrdererIsUsedToDetermineRunOrder",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, passing2, other2 }, orderer: new MockTestCaseOrderer(reverse: true));|await runner.RunAsync();|Assert.Collection(runner.MethodsRun,|tuple =>|{|Assert.Equal(\"Other\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(other2, testCase),|testCase => Assert.Same(other1, testCase)|);|},|tuple =>|{|Assert.Equal(\"Passing\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing2, testCase),|testCase => Assert.Same(passing1, testCase)|);|}|);|}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var messageBus = new SpyMessageBus();|var runner = TestableTestClassRunner.Create(messageBus, [passing1, other1, passing2, other2], new ThrowingOrderer());|await runner.RunAsync();|var errorMessage = Assert.Single(messageBus.Messages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Test case orderer 'TestClassRunnerTests+TestCaseOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);|Assert.Empty(runner.MethodsRun);|}"
      },
      {
        "name": "TestClassMustHaveParameterlessConstructor",
        "body": "{|var test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");|var runner = TestableTestClassRunner.Create(testCases: new[] { test });|await runner.RunAsync();|var tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"A test class must have a parameterless constructor.\", tcex.Message);|}"
      },
      {
        "name": "ConstructorWithMissingArguments",
        "body": "{|var test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");|var constructor = typeof(ClassWithConstructor).GetConstructors().Single();|var args = new object[] { \"Hello, world!\" };|var runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);|await runner.RunAsync();|var tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"The following constructor parameters did not have matching arguments: Int32 x, Decimal z\", tcex.Message);|}"
      },
      {
        "name": "ConstructorWithMatchingArguments",
        "body": "{|var test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");|var constructor = typeof(ClassWithConstructor).GetConstructors().Single();|var args = new object[] { \"Hello, world!\", 21.12m, 42, DateTime.Now };|var runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);|await runner.RunAsync();|var tuple = Assert.Single(runner.MethodsRun);|Assert.Collection(tuple.Item3,|arg => Assert.Equal(42, arg),|arg => Assert.Equal(\"Hello, world!\", arg),|arg => Assert.Equal(21.12m, arg)|);|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var runner = TestableTestCollectionRunner.Create(messageBus, new[] { testCase }, summary);|var result = await runner.RunAsync();|Assert.Equal(result.Total, summary.Total);|Assert.Equal(result.Failed, summary.Failed);|Assert.Equal(result.Skipped, summary.Skipped);|Assert.Equal(result.Time, summary.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestCollectionStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestCollectionFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Equal(21.12m, finished.ExecutionTime);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestCollectionStarting_DoesNotQueueTestCollectionFinished_DoesNotRunTestClasses",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestCollectionStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestCollectionRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestCollectionStarting>(starting);|Assert.Empty(runner.ClassesRun);|}"
      },
      {
        "name": "RunTestClassAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestCollectionRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestClassAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestCollectionStarting_GivesErroredAggregatorToTestClassRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestCollectionRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestClassAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestCollectionFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCollectionStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };|var runner = TestableTestCollectionRunner.Create(messageBus, testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());|Assert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestCollectionStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionStarting));|var runner = TestableTestCollectionRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestCollectionStarting_Called);|Assert.False(runner.BeforeTestCollectionFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCollectionFinished_CallsExtensibilityCallbacks",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionFinished));|var runner = TestableTestCollectionRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.True(runner.AfterTestCollectionStarting_Called);|Assert.True(runner.BeforeTestCollectionFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCollectionCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionCleanupFailure));|var runner = TestableTestCollectionRunner.Create(messageBus);|runner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");|var passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");|var other2 = Mocks.TestCase<ClassUnderTest2>(\"Other\");|var runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2, other2, other1 });|await runner.RunAsync();|Assert.Collection(runner.ClassesRun,|tuple =>|{|Assert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing1, testCase),|testCase => Assert.Same(other1, testCase)|);|},|tuple =>|{|Assert.Equal(\"TestCollectionRunnerTests+ClassUnderTest2\", tuple.Item1.Name);|Assert.Collection(tuple.Item2,|testCase => Assert.Same(passing2, testCase),|testCase => Assert.Same(other2, testCase)|);|}|);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningClasses",
        "body": "{|var passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");|var runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2 }, cancelInRunTestClassAsync: true);|await runner.RunAsync();|var tuple = Assert.Single(runner.ClassesRun);|Assert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestInvokerTests.cs",
    "methods": [
      {
        "name": "Messages_StaticTestMethod",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"StaticPassing\", messageBus);|await invoker.RunAsync();|Assert.Empty(messageBus.Messages);|Assert.True(invoker.BeforeTestMethodInvoked_Called);|Assert.True(invoker.AfterTestMethodInvoked_Called);|}"
      },
      {
        "name": "Messages_NonStaticTestMethod_NoDispose",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, \"Display Name\");|await invoker.RunAsync();|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Same(invoker.TestCase, starting.TestCase);|Assert.Equal(\"Display Name\", starting.Test.DisplayName);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Same(invoker.TestCase, finished.TestCase);|Assert.Equal(\"Display Name\", finished.Test.DisplayName);|}|);|}"
      },
      {
        "name": "Messages_NonStaticTestMethod_WithDispose",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<DisposableClass>(\"Passing\", messageBus, \"Display Name\");|await invoker.RunAsync();|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg =>|{|var starting = Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Same(invoker.TestCase, starting.TestCase);|Assert.Equal(\"Display Name\", starting.Test.DisplayName);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Same(invoker.TestCase, finished.TestCase);|Assert.Equal(\"Display Name\", finished.Test.DisplayName);|}|);|}"
      },
      {
        "name": "Passing",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus);|var result = await invoker.RunAsync();|Assert.NotEqual(0m, result);|Assert.Null(invoker.Aggregator.ToException());|}"
      },
      {
        "name": "Failing",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);|var result = await invoker.RunAsync();|Assert.NotEqual(0m, result);|Assert.IsType<TrueException>(invoker.Aggregator.ToException());|}"
      },
      {
        "name": "TooManyParameterValues",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, testMethodArguments: new object[] { 42 });|await invoker.RunAsync();|var ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());|Assert.Equal(\"The test method expected 0 parameter values, but 1 parameter value was provided.\", ex.Message);|}"
      },
      {
        "name": "NotEnoughParameterValues",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"FactWithParameter\", messageBus);|await invoker.RunAsync();|var ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());|Assert.Equal(\"The test method expected 1 parameter value, but 0 parameter values were provided.\", ex.Message);|}"
      },
      {
        "name": "CancellationRequested_DoesNotInvokeTestMethod",
        "body": "{|var messageBus = new SpyMessageBus();|var invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);|invoker.TokenSource.Cancel();|var result = await invoker.RunAsync();|Assert.Equal(0m, result);|Assert.Null(invoker.Aggregator.ToException());|Assert.False(invoker.BeforeTestMethodInvoked_Called);|Assert.False(invoker.AfterTestMethodInvoked_Called);|}"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "{|Assert.True(false);|}"
      },
      {
        "name": "FactWithParameter",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestMethodRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var runner = TestableTestMethodRunner.Create(messageBus, new[] { testCase }, result: summary);|var result = await runner.RunAsync();|Assert.Equal(result.Total, summary.Total);|Assert.Equal(result.Failed, summary.Failed);|Assert.Equal(result.Skipped, summary.Skipped);|Assert.Equal(result.Time, summary.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestMethodStarting>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);|Assert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);|Assert.Equal(\"Passing\", starting.TestMethod.Method.Name);|},|msg =>|{|var finished = Assert.IsAssignableFrom<ITestMethodFinished>(msg);|Assert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);|Assert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);|Assert.Equal(\"Passing\", finished.TestMethod.Method.Name);|Assert.Equal(21.12m, finished.ExecutionTime);|Assert.Equal(4, finished.TestsRun);|Assert.Equal(2, finished.TestsFailed);|Assert.Equal(1, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "FailureInQueueOfTestMethodStarting_DoesNotQueueTestMethodFinished_DoesNotRunTestCases",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestMethodStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestMethodRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestMethodStarting>(starting);|Assert.Empty(runner.TestCasesRun);|}"
      },
      {
        "name": "RunTestCaseAsync_AggregatorIncludesPassedInExceptions",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestMethodRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestMethodStarting_GivesErroredAggregatorToTestCaseRunner_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestMethodRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|Assert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);|Assert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestMethodFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestMethodStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };|var runner = TestableTestMethodRunner.Create(messageBus, testCases);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestMethodCleanupFailure>());|Assert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);|Assert.Equal(testCases, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestMethodStarting_DoesNotCallExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestMethodStarting));|var runner = TestableTestMethodRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestMethodStarting_Called);|Assert.False(runner.BeforeTestMethodFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestMethodFinished_CallsExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestMethodFinished));|var runner = TestableTestMethodRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.True(runner.AfterTestMethodStarting_Called);|Assert.True(runner.BeforeTestMethodFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestMethodCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestMethodCleanupFailure));|var runner = TestableTestMethodRunner.Create(messageBus);|runner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{|var passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.TestCase<ClassUnderTest>(\"Other\");|var runner = TestableTestMethodRunner.Create(testCases: new[] { passing, other }, cancelInRunTestCaseAsync: true);|await runner.RunAsync();|var testCase = Assert.Single(runner.TestCasesRun);|Assert.Same(passing, testCase);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);|var result = await runner.RunAsync();|Assert.Equal(21.12m, result.Time);|Assert.False(runner.TokenSource.IsCancellationRequested);|Assert.Collection(messageBus.Messages,|msg =>|{|var testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);|Assert.Same(runner.TestCase, testStarting.TestCase);|Assert.Equal(\"Display Name\", testStarting.Test.DisplayName);|},|msg => { }, // Pass/fail/skip, will be tested elsewhere|msg =>|{|var testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);|Assert.Same(runner.TestCase, testFinished.TestCase);|Assert.Equal(\"Display Name\", testFinished.Test.DisplayName);|Assert.Equal(21.12m, testFinished.ExecutionTime);|Assert.Empty(testFinished.Output);|}|);|}"
      },
      {
        "name": "Passing",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);|var result = await runner.RunAsync();|// Direct run summary|Assert.Equal(1, result.Total);|Assert.Equal(0, result.Failed);|Assert.Equal(0, result.Skipped);|Assert.Equal(21.12m, result.Time);|// Pass message|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, passed.TestCollection);|Assert.Same(runner.TestCase, passed.TestCase);|Assert.Equal(\"Display Name\", passed.Test.DisplayName);|Assert.Equal(21.12m, passed.ExecutionTime);|Assert.Empty(passed.Output);|}"
      },
      {
        "name": "Failing",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m, lambda: () => Assert.True(false));|var result = await runner.RunAsync();|// Direct run summary|Assert.Equal(1, result.Total);|Assert.Equal(1, result.Failed);|Assert.Equal(0, result.Skipped);|Assert.Equal(21.12m, result.Time);|// Fail message|var failed = messageBus.Messages.OfType<ITestFailed>().Single();|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);|Assert.Same(runner.TestCase, failed.TestCase);|Assert.Equal(\"Display Name\", failed.Test.DisplayName);|Assert.Equal(21.12m, failed.ExecutionTime);|Assert.Empty(failed.Output);|Assert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());|}"
      },
      {
        "name": "Skipping",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", skipReason: \"Please don't run me\", runTime: 21.12m, lambda: () => Assert.True(false));|var result = await runner.RunAsync();|// Direct run summary|Assert.Equal(1, result.Total);|Assert.Equal(0, result.Failed);|Assert.Equal(1, result.Skipped);|Assert.Equal(0m, result.Time);|// Skip message|var failed = messageBus.Messages.OfType<ITestSkipped>().Single();|Assert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);|Assert.Same(runner.TestCase, failed.TestCase);|Assert.Equal(\"Display Name\", failed.Test.DisplayName);|Assert.Equal(0m, failed.ExecutionTime);|Assert.Empty(failed.Output);|Assert.Equal(\"Please don't run me\", failed.Reason);|}"
      },
      {
        "name": "Output",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus, output: \"This is my text output\");|await runner.RunAsync();|var passed = messageBus.Messages.OfType<ITestPassed>().Single();|Assert.Equal(\"This is my text output\", passed.Output);|}"
      },
      {
        "name": "FailureInQueueOfTestStarting_DoesNotQueueTestFinished_DoesNotInvokeTest",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var messageBus = Substitute.For<IMessageBus>();|messageBus|.QueueMessage(null)|.ReturnsForAnyArgs(callInfo =>|{|var msg = callInfo.Arg<IMessageSinkMessage>();|messages.Add(msg);|if (msg is ITestStarting)|throw new InvalidOperationException();|return true;|});|var runner = TestableTestRunner.Create(messageBus);|await Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());|var starting = Assert.Single(messages);|Assert.IsAssignableFrom<ITestStarting>(starting);|Assert.False(runner.InvokeTestAsync_Called);|}"
      },
      {
        "name": "WithPreSeededException_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var ex = new DivideByZeroException();|var runner = TestableTestRunner.Create(messageBus, aggregatorSeedException: ex);|await runner.RunAsync();|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());|Assert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());|}"
      },
      {
        "name": "FailureInAfterTestStarting_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{|var messageBus = new SpyMessageBus();|var runner = TestableTestRunner.Create(messageBus);|var ex = new DivideByZeroException();|runner.AfterTestStarting_Callback = aggregator => aggregator.Add(ex);|await runner.RunAsync();|var failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());|Assert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());|Assert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());|}"
      },
      {
        "name": "FailureInBeforeTestFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestStarting",
        "body": "{|var messageBus = new SpyMessageBus();|var testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");|var runner = TestableTestRunner.Create(messageBus, testCase);|var startingException = new DivideByZeroException();|var finishedException = new InvalidOperationException();|runner.AfterTestStarting_Callback = aggregator => aggregator.Add(startingException);|runner.BeforeTestFinished_Callback = aggregator => aggregator.Add(finishedException);|await runner.RunAsync();|var cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCleanupFailure>());|Assert.Same(testCase, cleanupFailure.TestCase);|Assert.Equal(new[] { testCase }, cleanupFailure.TestCases);|Assert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());|}"
      },
      {
        "name": "Cancellation_TestStarting_DoesNotCallExtensibilityMethods",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestStarting));|var runner = TestableTestRunner.Create(messageBus);|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|Assert.False(runner.AfterTestStarting_Called);|Assert.False(runner.BeforeTestFinished_Called);|}"
      },
      {
        "name": "Cancellation_TestCleanupFailure_SetsCancellationToken",
        "body": "{|var messageBus = new SpyMessageBus(msg => !(msg is ITestCleanupFailure));|var runner = TestableTestRunner.Create(messageBus);|runner.BeforeTestFinished_Callback = aggregator => aggregator.Add(new Exception());|await runner.RunAsync();|Assert.True(runner.TokenSource.IsCancellationRequested);|}"
      }
    ]
  },
  {
    "file": "XunitDelayEnumeratedTheoryTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithData));|var runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };|var summary = await runner.RunAsync();|Assert.NotEqual(0m, summary.Time);|Assert.Equal(2, summary.Total);|Assert.Equal(1, summary.Failed);|var messages = runner.MessageBus.Messages;|var passed = messages.OfType<ITestPassed>().Single();|var passedStarting = messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == passed.TestUniqueID);|Assert.Equal($\"Display Name(x: 42, _1: {21.12:G17}, _2: \\\"Hello\\\")\", passedStarting.TestDisplayName);|var failed = messages.OfType<ITestFailed>().Single();|var failedStarting = messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID);|Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"World!\\\")\", failedStarting.TestDisplayName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithThrowingData));|var runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };|var summary = await runner.RunAsync();|Assert.Equal(0m, summary.Time);|Assert.Equal(1, summary.Total);|Assert.Equal(1, summary.Failed);|var messages = runner.MessageBus.Messages;|var failed = messages.OfType<ITestFailed>().Single();|var failedStarting = messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID);|Assert.Equal(\"Display Name\", failedStarting.TestDisplayName);|Assert.Equal(typeof(DivideByZeroException).SafeName(), failed.ExceptionTypes.Single());|Assert.Equal(\"Attempted to divide by zero.\", failed.Messages.Single());|Assert.Contains($\"{nameof(ClassUnderTest)}.get_{nameof(ClassUnderTest.ThrowingData)}\", failed.StackTraces.Single());|}"
      },
      {
        "name": "ValueTask",
        "body": "{|ClassUnderTest.DataWasDisposed = false;|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithDisposableData));|var runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase);|await runner.RunAsync();|Assert.True(ClassUnderTest.DataWasDisposed);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithSomeDataSkipped));|var runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };|var summary = await runner.RunAsync();|var messages = runner.MessageBus.Messages;|Assert.NotEqual(0m, summary.Time);|Assert.Equal(6, summary.Total);|Assert.Equal(3, summary.Skipped);|Assert.Equal(2, summary.Failed);|Assert.Collection(|messages.OfType<ITestPassed>().Select(p => messages.OfType<ITestStarting>().Single(s => s.TestUniqueID == p.TestUniqueID).TestDisplayName).OrderBy(x => x),|displayName => Assert.Equal($\"Display Name(x: 1, _1: {2.1:G17}, _2: \\\"not skipped\\\")\", displayName)|);|Assert.Collection(|messages.OfType<ITestFailed>().Select(p => messages.OfType<ITestStarting>().Single(s => s.TestUniqueID == p.TestUniqueID).TestDisplayName).OrderBy(x => x),|displayName => Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"also not skipped\\\")\", displayName),|displayName => Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"SomeData2 not skipped\\\")\", displayName)|);|Assert.Collection(|messages.OfType<ITestSkipped>().Select(p => messages.OfType<ITestStarting>().Single(s => s.TestUniqueID == p.TestUniqueID).TestDisplayName).OrderBy(x => x),|displayName => Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"World!\\\")\", displayName),|displayName => Assert.Equal($\"Display Name(x: 18, _1: {36.48:G17}, _2: \\\"SomeData2 skipped\\\")\", displayName),|displayName => Assert.Equal($\"Display Name(x: 42, _1: {21.12:G17}, _2: \\\"Hello\\\")\", displayName)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassWithThrowingToString>(nameof(ClassWithThrowingToString.Test));|var runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };|await runner.RunAsync();|var passed = runner.MessageBus.Messages.OfType<ITestPassed>().Single();|var passedStarting = runner.MessageBus.Messages.OfType<ITestStarting>().Where(ts => ts.TestUniqueID == passed.TestUniqueID).Single();|Assert.Equal(\"Display Name(c: TargetInvocationException was thrown formatting an object of type \\\"XunitDelayEnumeratedTheoryTestCaseRunnerTests+ClassWithThrowingToString\\\")\", passedStarting.TestDisplayName);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassWithThrowingEnumerator>(nameof(ClassWithThrowingEnumerator.Test));|var runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };|var summary = await runner.RunAsync();|var passed = runner.MessageBus.Messages.OfType<ITestPassed>().Single();|var passedStarting = runner.MessageBus.Messages.OfType<ITestStarting>().Where(ts => ts.TestUniqueID == passed.TestUniqueID).Single();|Assert.Equal(\"Display Name(_: [ClassWithThrowingEnumerator { }])\", passedStarting.TestDisplayName);|}"
      }
    ]
  },
  {
    "file": "XunitTestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "IsXunit",
        "body": "{|var runner = TestableXunitTestAssemblyRunner.Create();|var result = runner.GetTestFrameworkDisplayName();|Assert.StartsWith(\"xUnit.net \", result);|}"
      },
      {
        "name": "Default",
        "body": "{|var runner = TestableXunitTestAssemblyRunner.Create();|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith($\"[collection-per-class, parallel ({Environment.ProcessorCount} threads)]\", result);|}"
      },
      {
        "name": "Attribute_NonParallel",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, non-parallel]\", result);|}"
      },
      {
        "name": "Attribute_MaxThreads",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: 3);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);|}"
      },
      {
        "name": "Attribute_Unlimited",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: -1);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (unlimited threads)]\", result);|}"
      },
      {
        "name": "Attribute_CustomCollectionFactory",
        "body": "{|var factoryType = typeof(MyTestCollectionFactory);|var attr = Mocks.CollectionBehaviorAttribute(factoryType.FullName, factoryType.Assembly.FullName, disableTestParallelization: true);|var assembly = Mocks.TestAssembly(new[] { attr });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[My Factory, non-parallel]\", result);|}"
      },
      {
        "name": "TestOptions_NonParallel",
        "body": "{|var options = TestFrameworkOptions.ForExecution();|options.SetDisableParallelization(true);|var runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, non-parallel]\", result);|}"
      },
      {
        "name": "TestOptions_MaxThreads",
        "body": "{|var options = TestFrameworkOptions.ForExecution();|options.SetMaxParallelThreads(3);|var runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);|}"
      },
      {
        "name": "TestOptions_MaxThreads_Aggressive",
        "body": "{|var options = TestFrameworkOptions.ForExecution();|options.SetMaxParallelThreads(3);|options.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);|var runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads/aggressive)]\", result);|}"
      },
      {
        "name": "TestOptionsOverrideAttribute",
        "body": "{|var attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true, maxParallelThreads: 127);|var options = TestFrameworkOptions.ForExecution();|options.SetDisableParallelization(false);|options.SetMaxParallelThreads(3);|var assembly = Mocks.TestAssembly(new[] { attribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionOptions: options);|var result = runner.GetTestFrameworkEnvironment();|Assert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);|}"
      },
      {
        "name": "Parallel_SingleThread_Aggressive",
        "body": "{|var passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");|var options = TestFrameworkOptions.ForExecution();|options.SetMaxParallelThreads(1);|options.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);|var runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);|await runner.RunAsync();|var threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();|Assert.Equal(threadIDs[0], threadIDs[1]);|}"
      },
      {
        "name": "NonParallel",
        "body": "{|var passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");|var options = TestFrameworkOptions.ForExecution();|options.SetDisableParallelization(true);|var runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);|await runner.RunAsync();|var threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();|Assert.Equal(threadIDs[0], threadIDs[1]);|}"
      },
      {
        "name": "CanSetTestCaseOrdererInAssemblyAttribute",
        "body": "{|var ordererAttribute = Mocks.TestCaseOrdererAttribute<MyTestCaseOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|runner.Initialize();|Assert.IsType<MyTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{|var ordererAttribute = Mocks.TestCaseOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test case orderer\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var ordererAttribute = Mocks.TestCaseOrdererAttribute<MyCtorThrowingTestCaseOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Assembly-level test case orderer 'XunitTestAssemblyRunnerTests+TestCaseOrderer+MyCtorThrowingTestCaseOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "CanSetTestCollectionOrdererInAssemblyAttribute",
        "body": "{|var ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyTestCollectionOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);|runner.Initialize();|Assert.IsType<MyTestCollectionOrderer>(runner.TestCollectionOrderer);|}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{|var ordererAttribute = Mocks.TestCollectionOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test collection orderer\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{|Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;|var ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyCtorThrowingTestCollectionOrderer>();|var assembly = Mocks.TestAssembly(new[] { ordererAttribute });|var executionMessages = new List<IMessageSinkMessage>();|var executionSink = SpyMessageSink.Create(messages: executionMessages);|var runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);|runner.Initialize();|var errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());|var type = Assert.Single(errorMessage.ExceptionTypes);|Assert.Equal(typeof(XunitException).FullName, type);|var index = Assert.Single(errorMessage.ExceptionParentIndices);|Assert.Equal(-1, index);|var msg = Assert.Single(errorMessage.Messages);|Assert.Equal(\"Assembly-level test collection orderer 'XunitTestAssemblyRunnerTests+TestCollectionOrderer+MyCtorThrowingTestCollectionOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);|Assert.Empty(runner.TestCases);|}"
      },
      {
        "name": "Passing",
        "body": "{ Thread.Sleep(0); }"
      },
      {
        "name": "Other",
        "body": "{ Thread.Sleep(0); }"
      }
    ]
  },
  {
    "file": "XunitTestCaseRunnerBaseTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Passing));|var runner = new TestableXunitTestCaseRunnerBase(testCase);|await runner.RunAsync();|Assert.Null(runner.Aggregator.ToException());|Assert.Collection(|runner.MessageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);|verifyTestCaseMessage(starting);|// Reading the assembly-level trait on the test project|var trait = Assert.Single(starting.Traits);|Assert.Equal(\"Assembly\", trait.Key);|var value = Assert.Single(trait.Value);|Assert.Equal(\"Trait\", value);|},|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => verifyTestCaseMessage(Assert.IsAssignableFrom<ITestCaseFinished>(msg))|);|static void verifyTestCaseMessage(ITestCaseMessage message)|{|Assert.Equal(\"assembly-id\", message.AssemblyUniqueID);|Assert.Equal(\"test-case-id\", message.TestCaseUniqueID);|Assert.Equal(\"test-class-id\", message.TestClassUniqueID);|Assert.Equal(\"test-collection-id\", message.TestCollectionUniqueID);|Assert.Equal(\"test-method-id\", message.TestMethodUniqueID);|}|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.StaticPassing));|var runner = new TestableXunitTestCaseRunnerBase(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Failing));|var runner = new TestableXunitTestCaseRunnerBase(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Equal(-1, failed.ExceptionParentIndices.Single());|Assert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaAttribute));|var runner = new TestableXunitTestCaseRunnerBase(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"Don't run me\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaException));|var runner = new TestableXunitTestCaseRunnerBase(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"This isn't a good time\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.ExplicitTest));|var runner = new TestableXunitTestCaseRunnerBase(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestNotRun>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)|);|}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "No body available"
      },
      {
        "name": "SkippedViaAttribute",
        "body": "{ }"
      },
      {
        "name": "SkippedViaException",
        "body": "No body available"
      },
      {
        "name": "ExplicitTest",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "XunitTestClassRunnerTests.cs",
    "methods": [
      {
        "name": "ClassCannotBeDecoratedWithICollectionFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithCollectionFixture>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", runner.RunTestMethodAsync_AggregatorResult.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotHaveMoreThanOneConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithTwoConstructors>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"A test class may only define a single public constructor.\", runner.RunTestMethodAsync_AggregatorResult.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHavePublicAndPrivateConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithMixedConstructors>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHaveStaticConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassWithStaticConstructor>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CreatesFixturesFromClassAndCollection",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\", collection);|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Collection(runner.ClassFixtureMappings.OrderBy(mapping => mapping.Key.Name),|mapping => Assert.IsType<FixtureUnderTest>(mapping.Value),|mapping => Assert.IsType<object>(mapping.Value)|);|}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureUnderTest>().Single();|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassForFixtureAsyncLifetimeAndDisposableUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|var runnerSessionTask = runner.RunAsync();|await Task.Delay(500);|var fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();|Assert.True(fixtureUnderTest.DisposeAsyncCalled);|Assert.False(fixtureUnderTest.Disposed);|fixtureUnderTest.DisposeAsyncSignaler.SetResult(true);|await runnerSessionTask;|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "MultiplePublicConstructorsOnClassFixture_ReturnsError",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithMultiCtorClassFixture>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UnresolvedConstructorParameterOnClassFixture_ReturnsError",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);|Assert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);|}"
      },
      {
        "name": "CanInjectCollectionFixtureIntoClassFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");|var collectionFixture = new DependentCollectionFixture();|var runner = TestableXunitTestClassRunner.Create(testCase, collectionFixture);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|var classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithCollectionFixtureDependency>().Single();|Assert.Same(collectionFixture, classFixture.CollectionFixture);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CanInjectMessageSinkIntoClassFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestMethodAsync_AggregatorResult);|var classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithMessageSinkDependency>().Single();|Assert.NotNull(classFixture.MessageSink);|Assert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);|}"
      },
      {
        "name": "CanLogSinkMessageFromClassFixture",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"ClassFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{|var testCase = Mocks.XunitTestCase<TestClassWithUnknownTestCaseOrderer>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for class-level test case orderer on test class 'XunitTestClassRunnerTests+TestCaseOrderer+TestClassWithUnknownTestCaseOrderer'\", diagnosticMessage.Message);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "PassesFixtureValuesToConstructor",
        "body": "{|var testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");|var runner = TestableXunitTestClassRunner.Create(testCase, 42, \"Hello, world!\", 21.12m);|await runner.RunAsync();|var args = Assert.Single(runner.ConstructorArguments);|Assert.Collection(args,|arg => Assert.IsType<FixtureUnderTest>(arg),|arg => Assert.Equal(\"Hello, world!\", arg),|arg => Assert.Equal(21.12m, arg)|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "CreatesFixtures",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.Collection(runner.CollectionFixtureMappings.OrderBy(mapping => mapping.Key.Name),|mapping => Assert.IsType<FixtureUnderTest>(mapping.Value),|mapping => Assert.IsType<object>(mapping.Value)|);|}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureUnderTest>().Single();|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionForFixtureAsyncLifetimeAndDisposableUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|var runnerSessionTask = runner.RunAsync();|await Task.Delay(500);|var fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();|Assert.True(fixtureUnderTest.DisposeAsyncCalled);|Assert.False(fixtureUnderTest.Disposed);|fixtureUnderTest.DisposeAsyncSignaler.SetResult(true);|await runnerSessionTask;|Assert.True(fixtureUnderTest.Disposed);|}"
      },
      {
        "name": "MultiplePublicConstructorsOnCollectionFixture_ReturnsError",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionsWithMultiCtorCollectionFixture)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);|Assert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);|}"
      },
      {
        "name": "UnresolvedConstructorParameterOnCollectionFixture_ReturnsError",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithDependency)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);|Assert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);|}"
      },
      {
        "name": "CanInjectMessageSinkIntoCollectionFixture",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.Null(runner.RunTestClassAsync_AggregatorResult);|var classFixture = runner.CollectionFixtureMappings.Values.OfType<CollectionFixtureWithMessageSinkDependency>().Single();|Assert.NotNull(classFixture.MessageSink);|Assert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);|}"
      },
      {
        "name": "CanLogSinkMessageFromCollectionFixture",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"CollectionFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);|}"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);|}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{|var collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithUnknownTestCaseOrderer)), \"TestCollectionDisplayName\");|var testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);|var runner = TestableXunitTestCollectionRunner.Create(testCase);|await runner.RunAsync();|Assert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);|var diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());|Assert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for collection-level test case orderer on test collection 'TestCollectionDisplayName'\", diagnosticMessage.Message);|}"
      }
    ]
  },
  {
    "file": "XunitTestInvokerTests.cs",
    "methods": [
      {
        "name": "Success",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest();|var invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute });|await invoker.RunAsync();|Assert.Null(invoker.Aggregator.ToException());|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg), // From TestInvoker|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg), // From TestInvoker|msg =>|{|var beforeStarting = Assert.IsAssignableFrom<IBeforeTestStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeStarting.TestCollection);|Assert.Same(invoker.TestCase, beforeStarting.TestCase);|Assert.Equal(\"Display Name\", beforeStarting.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", beforeStarting.AttributeName);|},|msg =>|{|var beforeFinished = Assert.IsAssignableFrom<IBeforeTestFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeFinished.TestCollection);|Assert.Same(invoker.TestCase, beforeFinished.TestCase);|Assert.Equal(\"Display Name\", beforeFinished.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", beforeFinished.AttributeName);|},|// Test method is invoked here; no directly observable message (tested below)|msg =>|{|var afterStarting = Assert.IsAssignableFrom<IAfterTestStarting>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterStarting.TestCollection);|Assert.Same(invoker.TestCase, afterStarting.TestCase);|Assert.Equal(\"Display Name\", afterStarting.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", afterStarting.AttributeName);|},|msg =>|{|var afterFinished = Assert.IsAssignableFrom<IAfterTestFinished>(msg);|Assert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterFinished.TestCollection);|Assert.Same(invoker.TestCase, afterFinished.TestCase);|Assert.Equal(\"Display Name\", afterFinished.Test.DisplayName);|Assert.Equal(\"SpyBeforeAfterTest\", afterFinished.AttributeName);|}|);|}"
      },
      {
        "name": "FailedBefore",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest { ThrowInBefore = true };|var invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));|await invoker.RunAsync();|Assert.IsType<SpyBeforeAfterTest.BeforeException>(invoker.Aggregator.ToException());|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg)|);|}"
      },
      {
        "name": "FailedAfter",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest { ThrowInAfter = true };|var invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));|await invoker.RunAsync();|var aggEx = Assert.IsType<AggregateException>(invoker.Aggregator.ToException());|Assert.Collection(aggEx.InnerExceptions,|ex => Assert.IsType<TrueException>(ex),|ex => Assert.IsType<SpyBeforeAfterTest.AfterException>(ex)|);|Assert.Collection(messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),|msg => Assert.IsAssignableFrom<IAfterTestStarting>(msg),|msg => Assert.IsAssignableFrom<IAfterTestFinished>(msg)|);|}"
      },
      {
        "name": "Successful",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingBefore_First",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInBefore = true };|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|var msg = Assert.Single(messages);|Assert.Equal(\"Before #1\", msg);|}"
      },
      {
        "name": "FailingBefore_Second",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInBefore = true };|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|// No cleanup for #2, since it threw|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingAfter_First",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInAfter = true };|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingAfter_Second",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInAfter = true };|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => messages.Add(\"Test method invocation\")|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "FailingTest",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2);|var invoker = TestableXunitTestInvoker.Create(|beforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },|lambda: () => { messages.Add(\"Test method invocation\"); Assert.True(false); }|);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestMethodRunnerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Passing));|var runner = new TestableXunitTestMethodRunner(testCase);|await runner.RunAsync();|Assert.Null(runner.Aggregator.ToException());|Assert.Collection(|runner.MessageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestMethodStarting>(msg);|verifyTestMethodMessage(starting);|Assert.Equal(\"Passing\", starting.MethodName);|// Trait comes from an assembly-level trait attribute on this test assembly|var trait = Assert.Single(starting.Traits);|Assert.Equal(\"Assembly\", trait.Key);|var value = Assert.Single(trait.Value);|Assert.Equal(\"Trait\", value);|},|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),|msg => verifyTestMethodMessage(Assert.IsAssignableFrom<ITestMethodFinished>(msg))|);|static void verifyTestMethodMessage(ITestMethodMessage message)|{|Assert.Equal(\"assembly-id\", message.AssemblyUniqueID);|Assert.Equal(\"test-class-id\", message.TestClassUniqueID);|Assert.Equal(\"test-collection-id\", message.TestCollectionUniqueID);|Assert.Equal(\"test-method-id\", message.TestMethodUniqueID);|}|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.StaticPassing));|var runner = new TestableXunitTestMethodRunner(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),|msg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Failing));|var runner = new TestableXunitTestMethodRunner(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Equal(-1, failed.ExceptionParentIndices.Single());|Assert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),|msg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaAttribute));|var runner = new TestableXunitTestMethodRunner(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"Don't run me\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),|msg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaException));|var runner = new TestableXunitTestMethodRunner(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"This isn't a good time\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),|msg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.ExplicitTest));|var runner = new TestableXunitTestMethodRunner(testCase);|await runner.RunAsync();|Assert.Collection(|runner.MessageBus.Messages,|msg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),|msg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestNotRun>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),|msg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)|);|}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "No body available"
      },
      {
        "name": "SkippedViaAttribute",
        "body": "{ }"
      },
      {
        "name": "SkippedViaException",
        "body": "No body available"
      },
      {
        "name": "ExplicitTest",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "XunitTestRunnerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Passing), @explicit: true, timeout: 12345678);|var runner = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute], messageBus: messageBus, explicitOption: ExplicitOption.On);|await runner.RunAsync();|Assert.Null(runner.Aggregator.ToException());|Assert.Collection(|messageBus.Messages,|msg =>|{|var starting = Assert.IsAssignableFrom<ITestStarting>(msg);|verifyTestMessage(starting);|Assert.True(starting.Explicit);|Assert.Equal(\"test-display-name\", starting.TestDisplayName);|Assert.Equal(12345678, starting.Timeout);|// Trait comes from an assembly-level trait attribute on this test assembly|var trait = Assert.Single(starting.Traits);|Assert.Equal(\"Assembly\", trait.Key);|var value = Assert.Single(trait.Value);|Assert.Equal(\"Trait\", value);|},|msg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg)),|msg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg)),|msg =>|{|var beforeStarting = Assert.IsAssignableFrom<IBeforeTestStarting>(msg);|verifyTestMessage(beforeStarting);|Assert.Equal(\"SpyBeforeAfterTest\", beforeStarting.AttributeName);|},|msg =>|{|var beforeFinished = Assert.IsAssignableFrom<IBeforeTestFinished>(msg);|verifyTestMessage(beforeFinished);|Assert.Equal(\"SpyBeforeAfterTest\", beforeFinished.AttributeName);|},|// Test method is invoked here|msg =>|{|var afterStarting = Assert.IsAssignableFrom<IAfterTestStarting>(msg);|verifyTestMessage(afterStarting);|Assert.Equal(\"SpyBeforeAfterTest\", afterStarting.AttributeName);|},|msg =>|{|var afterFinished = Assert.IsAssignableFrom<IAfterTestFinished>(msg);|verifyTestMessage(afterFinished);|Assert.Equal(\"SpyBeforeAfterTest\", afterFinished.AttributeName);|},|msg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg)),|msg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg)),|msg => verifyTestMessage(Assert.IsAssignableFrom<ITestPassed>(msg)),|msg => verifyTestMessage(Assert.IsAssignableFrom<ITestFinished>(msg))|);|static void verifyTestMessage(ITestMessage testMethod)|{|Assert.Equal(\"assembly-id\", testMethod.AssemblyUniqueID);|Assert.Equal(\"test-case-id\", testMethod.TestCaseUniqueID);|Assert.Equal(\"test-class-id\", testMethod.TestClassUniqueID);|Assert.Equal(\"test-collection-id\", testMethod.TestCollectionUniqueID);|Assert.Equal(\"test-method-id\", testMethod.TestMethodUniqueID);|Assert.Equal(\"test-id\", testMethod.TestUniqueID);|}|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.StaticPassing));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Failing));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Equal(-1, failed.ExceptionParentIndices.Single());|Assert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaAttribute));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"Don't run me\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaSkipUnless));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"Conditionally don't run me\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaSkipWhen));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"Conditionally don't run me\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.NotSkippedViaSkipUnless));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.NotSkippedViaSkipWhen));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg => Assert.IsAssignableFrom<ITestPassed>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaException));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);|Assert.Equal(\"This isn't a good time\", skipped.Reason);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.ExplicitTest));|var runner = new TestableXunitTestRunner(test, messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestNotRun>(msg),|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest { ThrowInBefore = true };|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Failing));|var runner = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute], messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),|// No after messages because nothing to clean up, and test method is NOT invoked|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Equal(-1, failed.ExceptionParentIndices.Single());|Assert.Equal(\"SpyBeforeAfterTest+BeforeException\", failed.ExceptionTypes.Single());|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messageBus = new SpyMessageBus();|var attribute = new SpyBeforeAfterTest { ThrowInAfter = true };|var test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Failing));|var runner = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute], messageBus: messageBus);|await runner.RunAsync();|Assert.Collection(|messageBus.Messages,|msg => Assert.IsAssignableFrom<ITestStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),|msg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),|// Test method is invoked here|msg => Assert.IsAssignableFrom<IAfterTestStarting>(msg),|msg => Assert.IsAssignableFrom<IAfterTestFinished>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),|msg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),|msg =>|{|var failed = Assert.IsAssignableFrom<ITestFailed>(msg);|Assert.Equivalent(new[] { -1, 0, 0 }, failed.ExceptionParentIndices);|Assert.Collection(|failed.ExceptionTypes,|type => Assert.Equal(\"System.AggregateException\", type),|type => Assert.Equal(\"Xunit.Sdk.TrueException\", type),|type => Assert.Equal(\"SpyBeforeAfterTest+AfterException\", type)|);|},|msg => Assert.IsAssignableFrom<ITestFinished>(msg)|);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var messages = new List<string>();|var attribute1 = new RecordingBeforeAfter(messages, 1);|var attribute2 = new RecordingBeforeAfter(messages, 2);|var test = TestData.XunitTest<RecordingTestClass>(nameof(RecordingTestClass.ExecutionRecorder));|var invoker = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute1, attribute2], constructorArguments: [messages]);|await invoker.RunAsync();|Assert.Collection(messages,|msg => Assert.Equal(\"Before #1\", msg),|msg => Assert.Equal(\"Before #2\", msg),|msg => Assert.Equal(\"Test method invocation\", msg),|msg => Assert.Equal(\"After #2\", msg),|msg => Assert.Equal(\"After #1\", msg)|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "No body available"
      },
      {
        "name": "SkippedViaAttribute",
        "body": "{ }"
      },
      {
        "name": "SkippedViaSkipUnless",
        "body": "{ }"
      },
      {
        "name": "SkippedViaSkipWhen",
        "body": "{ }"
      },
      {
        "name": "NotSkippedViaSkipUnless",
        "body": "{ }"
      },
      {
        "name": "NotSkippedViaSkipWhen",
        "body": "{ }"
      },
      {
        "name": "SkippedViaException",
        "body": "No body available"
      },
      {
        "name": "ExplicitTest",
        "body": "No body available"
      },
      {
        "name": "ExecutionRecorder",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "TestContextTests.cs",
    "methods": [
      {
        "name": "AmbientTestContextIsAvailableInTest",
        "body": "{|var context = TestContext.Current;|Assert.NotNull(context);|// Test|Assert.Equal(TestEngineStatus.Running, context.TestStatus);|Assert.Equal(TestPipelineStage.TestExecution, context.PipelineStage);|var test = context.Test;|Assert.NotNull(test);|Assert.Equal($\"{nameof(TestContextTests)}.{nameof(AmbientTestContextIsAvailableInTest)}\", test.TestDisplayName);|Assert.Null(context.TestState);|// Test case|Assert.Equal(TestEngineStatus.Running, context.TestCaseStatus);|Assert.Same(test.TestCase, context.TestCase);|// Test method|Assert.Equal(TestEngineStatus.Running, context.TestMethodStatus);|Assert.Same(test.TestCase.TestMethod, context.TestMethod);|// Test class|Assert.Equal(TestEngineStatus.Running, context.TestClassStatus);|Assert.Same(test.TestCase.TestMethod!.TestClass, context.TestClass);|// Test collection|Assert.Equal(TestEngineStatus.Running, context.TestCollectionStatus);|Assert.Same(test.TestCase.TestCollection, context.TestCollection);|// Test assembly|Assert.Equal(TestEngineStatus.Running, context.TestAssemblyStatus);|Assert.Same(test.TestCase.TestCollection.TestAssembly, context.TestAssembly);|}"
      },
      {
        "name": "KeyValueStorageIsAvailableThroughoutPipeline",
        "body": "{|Assert.Equal(42, TestContext.Current.KeyValueStorage[\"collectionValue\"]);|Assert.Equal(2112, TestContext.Current.KeyValueStorage[\"classValue\"]);|TestContext.Current.KeyValueStorage[\"testValue\"] = 2600;|}"
      }
    ]
  },
  {
    "file": "FixtureMappingManagerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|var result = await manager.GetFixture(typeof(int));|Assert.Null(result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager(12);|var result = await manager.GetFixture(typeof(int));|Assert.Equal(12, result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var parent = new TestableFixtureMappingManager(12);|var manager = new TestableFixtureMappingManager(parent);|var result = await manager.GetFixture(typeof(int));|Assert.Equal(12, result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|await manager.InitializeAsync(typeof(object));|var result = await manager.GetFixture(typeof(object));|Assert.IsType<object>(result);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|var ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(FixtureWithThrowingCtor)));|Assert.IsType<TestPipelineException>(ex);|Assert.Equal(\"Testable fixture type 'FixtureMappingManagerTests+FixtureWithThrowingCtor' threw in its constructor\", ex.Message);|Assert.IsType<DivideByZeroException>(ex.InnerException);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|var ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(FixtureWithThrowingInitializeAsync)));|Assert.IsType<TestPipelineException>(ex);|Assert.Equal(\"Testable fixture type 'FixtureMappingManagerTests+FixtureWithThrowingInitializeAsync' threw in InitializeAsync\", ex.Message);|Assert.IsType<DivideByZeroException>(ex.InnerException);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|var ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(FixtureWithDependency)));|Assert.IsType<TestPipelineException>(ex);|Assert.Equal(\"Testable fixture type 'FixtureMappingManagerTests+FixtureWithDependency' had one or more unresolved constructor arguments: Object dependency\", ex.Message);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var parent = new TestableFixtureMappingManager();|await parent.InitializeAsync(typeof(object));|var manager = new TestableFixtureMappingManager(parent);|await manager.InitializeAsync(typeof(FixtureWithDependency));|var result = await manager.GetFixture(typeof(FixtureWithDependency));|var typedResult = Assert.IsType<FixtureWithDependency>(result);|Assert.IsType<object>(typedResult.Dependency);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|await manager.InitializeAsync(typeof(FixtureWithMessageSinkAndTestContext));|var result = await manager.GetFixture(typeof(FixtureWithMessageSinkAndTestContext));|var typedResult = Assert.IsType<FixtureWithMessageSinkAndTestContext>(result);|Assert.NotNull(TestContext.Current);|Assert.Same(TestContext.Current, typedResult.ContextAccessor.Current);|Assert.Same(TestContext.CurrentInternal.DiagnosticMessageSink, typedResult.MessageSink);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|await manager.InitializeAsync(typeof(FixtureWithDispose));|var result = await manager.GetFixture(typeof(FixtureWithDispose));|var typedResult = Assert.IsType<FixtureWithDispose>(result);|Assert.False(typedResult.DisposeCalled);|await manager.DisposeAsync();|Assert.True(typedResult.DisposeCalled);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|await manager.InitializeAsync(typeof(FixtureWithThrowingDispose));|await manager.GetFixture(typeof(FixtureWithThrowingDispose));|var ex = await Record.ExceptionAsync(manager.DisposeAsync);|Assert.IsType<TestPipelineException>(ex);|Assert.Equal($\"Testable fixture type '{typeof(FixtureWithThrowingDispose).SafeName()}' threw in Dispose\", ex.Message);|Assert.IsType<DivideByZeroException>(ex.InnerException);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|await manager.InitializeAsync(typeof(FixtureWithDisposeAsync));|var result = await manager.GetFixture(typeof(FixtureWithDisposeAsync));|var typedResult = Assert.IsType<FixtureWithDisposeAsync>(result);|Assert.False(typedResult.DisposeAsyncCalled);|await manager.DisposeAsync();|Assert.True(typedResult.DisposeAsyncCalled);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|await manager.InitializeAsync(typeof(FixtureWithThrowingDisposeAsync));|await manager.GetFixture(typeof(FixtureWithThrowingDisposeAsync));|var ex = await Record.ExceptionAsync(manager.DisposeAsync);|Assert.IsType<TestPipelineException>(ex);|Assert.Equal($\"Testable fixture type '{typeof(FixtureWithThrowingDisposeAsync).SafeName()}' threw in DisposeAsync\", ex.Message);|Assert.IsType<DivideByZeroException>(ex.InnerException);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var manager = new TestableFixtureMappingManager();|var ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(int)));|Assert.IsType<TestPipelineException>(ex);|Assert.Equal(\"Testable fixture type 'System.Int32' may only define a single public constructor.\", ex.Message);|}"
      }
    ]
  },
  {
    "file": "TestIntrospectionHelperTests.cs",
    "methods": [
      {
        "name": "NullDiscoveryOptionsThrows",
        "body": "{|var ex = Record.Exception(() => TestIntrospectionHelper.GetTestCaseDetails(null!, Mocks.XunitTestMethod(), Mocks.FactAttribute()));|var argnEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"discoveryOptions\", argnEx.ParamName);|}"
      },
      {
        "name": "NullTestMethodThrows",
        "body": "{|var ex = Record.Exception(() => TestIntrospectionHelper.GetTestCaseDetails(discoveryOptions, null!, Mocks.FactAttribute()));|var argnEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"testMethod\", argnEx.ParamName);|}"
      },
      {
        "name": "NullFactAttributeThrows",
        "body": "{|var ex = Record.Exception(() => TestIntrospectionHelper.GetTestCaseDetails(discoveryOptions, Mocks.XunitTestMethod(), null!));|var argEx = Assert.IsType<ArgumentNullException>(ex);|Assert.Equal(\"factAttribute\", argEx.ParamName);|}"
      },
      {
        "name": "DisplayName",
        "body": "{|var testMethod = TestData.XunitTestMethod<GetTestCaseDetails>(nameof(DisplayName));|var details = _GetTestCaseDetails(discoveryOptions, testMethod);|Assert.Equal(\"TestIntrospectionHelperTests+GetTestCaseDetails.DisplayName\", details.TestCaseDisplayName);|}"
      },
      {
        "name": "NonStandardMethodDisplay",
        "body": "{|var testMethod = Mocks.XunitTestMethod(methodName: \"method-name\");|discoveryOptions.SetMethodDisplay(TestMethodDisplay.Method);|var details = _GetTestCaseDetails(discoveryOptions, testMethod);|Assert.Equal(\"method-name\", details.TestCaseDisplayName);|}"
      },
      {
        "name": "NonStandardMethodDisplayOptions",
        "body": "{|var testClass = Mocks.XunitTestClass(testClassName: \"With_an_empty_stack\");|var testMethod = Mocks.XunitTestMethod(testClass: testClass, methodName: \"count_eq_0X21\");|discoveryOptions.SetMethodDisplayOptions(TestMethodDisplayOptions.All);|var details = _GetTestCaseDetails(discoveryOptions, testMethod);|Assert.Equal(\"With an empty stack, count = 0!\", details.TestCaseDisplayName);|}"
      },
      {
        "name": "CustomDisplayName",
        "body": "{|var factAttribute = Mocks.FactAttribute(displayName: \"Custom Display Name\");|var testMethod = Mocks.XunitTestMethod(factAttributes: [factAttribute]);|var details = _GetTestCaseDetails(discoveryOptions, testMethod);|Assert.Equal(\"Custom Display Name\", details.TestCaseDisplayName);|}"
      },
      {
        "name": "CustomDisplayNameWithArguments",
        "body": "{|var testMethod = TestData.XunitTestMethod<CustomDisplayNameWithArgumentsTestClass>(nameof(CustomDisplayNameWithArgumentsTestClass.TestMethod));|var details = _GetTestCaseDetails(discoveryOptions, testMethod, [42, \"Hello, world!\", 'A']);|Assert.Equal(\"Custom Display Name(_1: 42, _2: \\\"Hello, world!\\\", _3: 'A')\", details.TestCaseDisplayName);|}"
      },
      {
        "name": "NotEnoughTestArguments",
        "body": "{|var testMethod = TestData.XunitTestMethod<CustomDisplayNameWithArgumentsTestClass>(nameof(CustomDisplayNameWithArgumentsTestClass.TestMethod));|var details = _GetTestCaseDetails(discoveryOptions, testMethod, [42]);|Assert.Equal(\"Custom Display Name(_1: 42, _2: ???, _3: ???)\", details.TestCaseDisplayName);|}"
      },
      {
        "name": "SkipReason",
        "body": "{|var factAttribute = Mocks.FactAttribute(skip: \"Skip Reason\");|var testMethod = Mocks.XunitTestMethod(factAttributes: [factAttribute]);|var details = _GetTestCaseDetails(discoveryOptions, testMethod);|Assert.Equal(\"Skip Reason\", details.SkipReason);|}"
      },
      {
        "name": "Timeout",
        "body": "{|var factAttribute = Mocks.FactAttribute(timeout: 42);|var testMethod = Mocks.XunitTestMethod(factAttributes: [factAttribute]);|var details = _GetTestCaseDetails(discoveryOptions, testMethod);|Assert.Equal(42, details.Timeout);|}"
      }
    ]
  },
  {
    "file": "QueryFilterParserTests.cs",
    "methods": [
      {
        "name": "EscapedSegmentCharacters",
        "body": "{|var filter = QueryFilterParser.Parse(\"/a&#x28;b&#x29;c\");|Assert.True(filter.Filter(\"a(b)c\", GetTestCase()));|}"
      },
      {
        "name": "EscapedTraitCharacters",
        "body": "{|var filter = QueryFilterParser.Parse(\"/[&#x5b;&#x3d;=&#x3d;&#x5d;]\");|Assert.True(filter.Filter(\"asm1\", GetTestCase(traitKey: \"[=\", traitValue: \"=]\")));|}"
      }
    ]
  },
  {
    "file": "TestFrameworkOptionsTests.cs",
    "methods": [
      {
        "name": "DefaultOptions_EmptyJson",
        "body": "{|ITestFrameworkDiscoveryOptions options = TestFrameworkOptions.Empty();|var result = options.ToJson();|Assert.Equal(\"{}\", result);|}"
      },
      {
        "name": "EmptyJson_DeserializesToDefaultValues",
        "body": "{|var result = TestFrameworkOptions.ForDiscoveryFromSerialization(\"{}\");|Assert.Null(result.GetCulture());|Assert.Null(result.GetDiagnosticMessages());|Assert.Null(result.GetIncludeSourceInformation());|Assert.Null(result.GetInternalDiagnosticMessages());|Assert.Null(result.GetMethodDisplay());|Assert.Null(result.GetMethodDisplayOptions());|Assert.Null(result.GetPreEnumerateTheories());|Assert.Null(result.GetSynchronousMessageReporting());|}"
      },
      {
        "name": "SettingValue_RoundTripsValue",
        "body": "{|// Set one of each known supported CLR type|var overrideEnumValue = TestMethodDisplayOptions.ReplaceUnderscoreWithSpace | TestMethodDisplayOptions.UseEscapeSequences;|ITestFrameworkDiscoveryOptions options = TestFrameworkOptions.Empty();|options.SetCulture(\"foo\");|options.SetDiagnosticMessages(true);|options.SetMethodDisplayOptions(overrideEnumValue);|var serialized = options.ToJson();|var deserialized = TestFrameworkOptions.ForDiscoveryFromSerialization(serialized);|Assert.Equal(\"foo\", deserialized.GetCulture());|Assert.True(deserialized.GetDiagnosticMessages());|Assert.Equal(overrideEnumValue, deserialized.GetMethodDisplayOptions());|}"
      },
      {
        "name": "DefaultOptions_EmptyJson",
        "body": "{|ITestFrameworkExecutionOptions options = TestFrameworkOptions.Empty();|var result = options.ToJson();|Assert.Equal(\"{}\", result);|}"
      },
      {
        "name": "EmptyJson_DeserializesToDefaultValues",
        "body": "{|var result = TestFrameworkOptions.ForExecutionFromSerialization(\"{}\");|Assert.Null(result.GetCulture());|Assert.Null(result.GetDiagnosticMessages());|Assert.Null(result.GetDisableParallelization());|Assert.Null(result.GetInternalDiagnosticMessages());|Assert.Null(result.GetMaxParallelThreads());|Assert.Null(result.GetSynchronousMessageReporting());|}"
      },
      {
        "name": "SettingValue_RoundTripsValue",
        "body": "{|// Set one of each known supported CLR type|ITestFrameworkExecutionOptions options = TestFrameworkOptions.Empty();|options.SetCulture(\"foo\");|options.SetDiagnosticMessages(true);|options.SetMaxParallelThreads(42);|var serialized = options.ToJson();|var deserialized = TestFrameworkOptions.ForExecutionFromSerialization(serialized);|Assert.Equal(\"foo\", deserialized.GetCulture());|Assert.True(deserialized.GetDiagnosticMessages());|Assert.Equal(42, deserialized.GetMaxParallelThreads());|}"
      }
    ]
  },
  {
    "file": "XunitFiltersTests.cs",
    "methods": [
      {
        "name": "NoFilters_AlwaysPass",
        "body": "{|var filters = new XunitFilters();|Assert.True(filters.Filter(\"asm1\", NonClassTest));|Assert.True(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|Assert.True(filters.Filter(\"asm1\", MethodWithNoTraits));|Assert.True(filters.Filter(\"asm1\", MethodWithFooBarTrait));|Assert.True(filters.Filter(\"asm1\", MethodWithBazBiffTrait));|}"
      },
      {
        "name": "MixedFilters_NotAllowed_SimpleFirst",
        "body": "{|var filters = new XunitFilters();|filters.AddIncludedClassFilter(\"class\");|var ex = Record.Exception(() => filters.AddQueryFilter(\"/1/2/3/4\"));|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"query\", argEx.ParamName);|Assert.StartsWith(\"Cannot add query filter; simple filters already exist\", argEx.Message);|}"
      },
      {
        "name": "SingleFilter_MatchesQuery",
        "body": "{|var filters = new XunitFilters();|filters.AddQueryFilter($\"/asm1/{typeof(InnerClassOne).Namespace}/{typeof(InnerClassOne).Name}/{nameof(InnerClassOne.NameOne)}\");|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddQueryFilter($\"/asm1/{typeof(InnerClassOne).Namespace}/{typeof(InnerClassOne).Name}\");|filters.AddQueryFilter($\"/asm1/{typeof(InnerClassOne).Namespace}/{typeof(InnerClassTwo).Name}\");|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddExcludedClassFilter(typeof(InnerClassOne).FullName!);|filters.AddExcludedClassFilter(typeof(InnerClassTwo).FullName!.ToUpperInvariant());|Assert.True(filters.Filter(\"asm1\", NonClassTest));|Assert.True(filters.Filter(\"asm1\", NonMethodTest));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|}"
      },
      {
        "name": "MultipleFilters_ActsAsOrOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddExcludedMethodFilter($\"{typeof(InnerClassOne).FullName}.{nameof(InnerClassOne.NameOne)}\");|filters.AddExcludedMethodFilter($\"*.nAmEtWo\");|Assert.True(filters.Filter(\"asm1\", NonClassTest));|Assert.True(filters.Filter(\"asm1\", NonMethodTest));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddExcludedNamespaceFilter(typeof(InnerClassOne).Namespace!);|filters.AddExcludedNamespaceFilter(typeof(ClassWithTraits).Namespace!.ToUpperInvariant());|Assert.True(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|Assert.False(filters.Filter(\"asm1\", MethodWithNoTraits));|Assert.False(filters.Filter(\"asm1\", MethodWithFooBarTrait));|Assert.False(filters.Filter(\"asm1\", MethodWithBazBiffTrait));|}"
      },
      {
        "name": "MultipleFilters_ActsAsOrOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddExcludedTraitFilter(\"fOo\", \"bAr\");|filters.AddExcludedTraitFilter(\"bAz\", \"bIff\");|Assert.True(filters.Filter(\"asm1\", NonClassTest));|Assert.True(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", MethodWithNoTraits));|Assert.False(filters.Filter(\"asm1\", MethodWithFooBarTrait));|Assert.False(filters.Filter(\"asm1\", MethodWithBazBiffTrait));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAnAndOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddIncludedClassFilter(typeof(InnerClassOne).FullName!);|filters.AddIncludedClassFilter(typeof(InnerClassTwo).FullName!.ToUpperInvariant());|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAndOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddIncludedMethodFilter($\"{typeof(InnerClassOne).FullName}.{nameof(InnerClassOne.NameOne)}\");|filters.AddIncludedMethodFilter($\"*.{nameof(InnerClassOne.NameTwo).ToUpperInvariant()}\");|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddIncludedNamespaceFilter(typeof(InnerClassOne).Namespace!);|filters.AddIncludedNamespaceFilter(typeof(ClassWithTraits).Namespace!.ToUpperInvariant());|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.True(filters.Filter(\"asm1\", NonMethodTest));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|Assert.True(filters.Filter(\"asm1\", MethodWithNoTraits));|Assert.True(filters.Filter(\"asm1\", MethodWithFooBarTrait));|Assert.True(filters.Filter(\"asm1\", MethodWithBazBiffTrait));|}"
      },
      {
        "name": "MultipleFilters_ActsAsAndOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddIncludedTraitFilter(\"fOo\", \"bAr\");|filters.AddIncludedTraitFilter(\"bAz\", \"bIff\");|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.False(filters.Filter(\"asm1\", MethodWithNoTraits));|Assert.True(filters.Filter(\"asm1\", MethodWithFooBarTrait));|Assert.True(filters.Filter(\"asm1\", MethodWithBazBiffTrait));|}"
      },
      {
        "name": "ActsAsAnAndOperation",
        "body": "{|var filters = new XunitFilters();|filters.AddIncludedClassFilter(typeof(InnerClassOne).FullName!);|filters.AddIncludedMethodFilter(\"*.nAmEtHrEe\");|Assert.False(filters.Filter(\"asm1\", NonClassTest));|Assert.False(filters.Filter(\"asm1\", NonMethodTest));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));|Assert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));|Assert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));|Assert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));|Assert.False(filters.Filter(\"asm1\", MethodWithNoTraits));|Assert.False(filters.Filter(\"asm1\", MethodWithFooBarTrait));|Assert.False(filters.Filter(\"asm1\", MethodWithBazBiffTrait));|}"
      },
      {
        "name": "NameOne",
        "body": "{ }"
      },
      {
        "name": "NameTwo",
        "body": "{ }"
      },
      {
        "name": "NameThree",
        "body": "{ }"
      },
      {
        "name": "NameThree",
        "body": "{ }"
      },
      {
        "name": "NoTraits",
        "body": "{ }"
      },
      {
        "name": "FooBar",
        "body": "{ }"
      },
      {
        "name": "BazBiff",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ConsoleRunnerLoggerTests.cs",
    "methods": [
      {
        "name": "LogError_InRed",
        "body": "{|sut.LogError(\"This is an error message\");|Assert.Equal(\"\\u001b[91mThis is an error message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());|}"
      },
      {
        "name": "LogImportantMessage_InGray",
        "body": "{|sut.LogImportantMessage(\"This is an important message\");|Assert.Equal(\"\\u001b[37mThis is an important message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());|}"
      },
      {
        "name": "LogMessage_InDarkGray",
        "body": "{|sut.LogMessage(\"This is a message\");|Assert.Equal(\"\\u001b[90mThis is a message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());|}"
      },
      {
        "name": "LogRaw_NoColor",
        "body": "{|sut.LogRaw(\"This is a raw message\");|Assert.Equal(\"This is a raw message\" + Environment.NewLine, writer.ToString());|}"
      },
      {
        "name": "LogWarning_InYellow",
        "body": "{|sut.LogWarning(\"This is a warning message\");|Assert.Equal(\"\\u001b[93mThis is a warning message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());|}"
      },
      {
        "name": "Disabled_DoesNotConsumesStdIn",
        "body": "{|var reader = new StringReader(Environment.NewLine + \"abc\");|var sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(reader, TextWriter.Null), waitForAcknowledgment: false);|sut.WaitForAcknowledgment();|Assert.Equal(Environment.NewLine + \"abc\", reader.ReadToEnd());|}"
      },
      {
        "name": "Enabled_ConsumesOneLineFromStdIn",
        "body": "{|var reader = new StringReader(Environment.NewLine + \"abc\");|var sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(reader, TextWriter.Null), waitForAcknowledgment: true);|sut.WaitForAcknowledgment();|Assert.Equal(\"abc\", reader.ReadToEnd());|}"
      },
      {
        "name": "ColorsEnabled_PlainText",
        "body": "{|var writer = new StringWriter();|var message = \"foo bar\";|var sut = new ConsoleRunnerLogger(true, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);|sut.WriteLine(message);|Assert.Equal(message + Environment.NewLine, writer.ToString());|}"
      },
      {
        "name": "ColorsEnabled_AnsiText",
        "body": "{|var writer = new StringWriter();|var message = \"\\x1b[3m\\x1b[36mhello world\\u001b[0m || \\x1b[94;103mbright blue on bright yellow\\x1b[m\";|var sut = new ConsoleRunnerLogger(true, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);|sut.WriteLine(message);|Assert.Equal(message + Environment.NewLine, writer.ToString());|}"
      },
      {
        "name": "ColorsDisabled_PlainText",
        "body": "{|var writer = new StringWriter();|var message = \"foo bar\";|var sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);|sut.WriteLine(message);|Assert.Equal(message + Environment.NewLine, writer.ToString());|}"
      },
      {
        "name": "ColorsDisabled_AnsiText",
        "body": "{|var writer = new StringWriter();|var sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);|sut.WriteLine(\"\\x1b[3m\\x1b[36mhello world\\u001b[0m || \\x1b[94;103mbright blue on bright yellow\\x1b[m\");|Assert.Equal(\"hello world || bright blue on bright yellow\" + Environment.NewLine, writer.ToString());|}"
      }
    ]
  },
  {
    "file": "MessageSinkMessageTests.cs",
    "methods": [
      {
        "name": "WithoutJsonTypeID_Throws",
        "body": "{|var msg = new DerivedMessageSinkMessage();|var ex = Record.Exception(() => msg.ToJson());|Assert.IsType<InvalidOperationException>(ex);|Assert.Equal($\"Message sink message type '{typeof(DerivedMessageSinkMessage).SafeName()}' is missing its [JsonTypeID] decoration\", ex.Message);|}"
      },
      {
        "name": "SerializationExcludesNullValuesAndEmptyTraits",
        "body": "{|var startTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));|var msg = new TestAssemblyStarting|{|AssemblyUniqueID = \"asm-id\",|AssemblyName = \"asm-name\",|AssemblyPath = \"asm-path\",|ConfigFilePath = null,|Seed = null,|StartTime = startTime,|TargetFramework = null,|TestEnvironment = \"test-env\",|TestFrameworkDisplayName = \"test-framework\",|Traits = TestData.EmptyTraits,|};|var json = msg.ToJson();|Assert.NotNull(json);|var expected =|@\"{| \"\"$type\"\": \"\"test-assembly-starting\"\",| \"\"AssemblyUniqueID\"\": \"\"asm-id\"\",| \"\"AssemblyName\"\": \"\"asm-name\"\",| \"\"AssemblyPath\"\": \"\"asm-path\"\",| \"\"StartTime\"\": \"\"2020-09-26T13:55:27.2120000-07:00\"\",| \"\"TestEnvironment\"\": \"\"test-env\"\",| \"\"TestFrameworkDisplayName\"\": \"\"test-framework\"\"|}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");|Assert.Equal(expected, json);|}"
      },
      {
        "name": "SerializesEnumsAsStringsAndExcludesEmptyOutput",
        "body": "{|var finishTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));|var msg = new TestFailed|{|AssemblyUniqueID = \"asm-id\",|Cause = FailureCause.Assertion,|ExceptionParentIndices = [-1],|ExceptionTypes = [\"exception-type\"],|ExecutionTime = 123.45m,|FinishTime = finishTime,|Messages = [\"exception-message\"],|Output = \"\",|StackTraces = [null],|TestCaseUniqueID = \"test-case-id\",|TestClassUniqueID = null,|TestCollectionUniqueID = \"test-collection-id\",|TestMethodUniqueID = null,|TestUniqueID = \"test-id\",|Warnings = null,|};|var json = msg.ToJson();|Assert.NotNull(json);|var expected =|@\"{| \"\"$type\"\": \"\"test-failed\"\",| \"\"AssemblyUniqueID\"\": \"\"asm-id\"\",| \"\"TestCollectionUniqueID\"\": \"\"test-collection-id\"\",| \"\"TestCaseUniqueID\"\": \"\"test-case-id\"\",| \"\"TestUniqueID\"\": \"\"test-id\"\",| \"\"ExecutionTime\"\": 123.45,| \"\"FinishTime\"\": \"\"2020-09-26T13:55:27.2120000-07:00\"\",| \"\"Cause\"\": \"\"Assertion\"\",| \"\"ExceptionParentIndices\"\": [-1],| \"\"ExceptionTypes\"\": [\"\"exception-type\"\"],| \"\"Messages\"\": [\"\"exception-message\"\"],| \"\"StackTraces\"\": [null]|}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");|Assert.Equal(expected, json);|}"
      },
      {
        "name": "ValidatesAllDerivedTypesAreSupported",
        "body": "{|var excludedTypes = new HashSet<Type> {|typeof(MessageSinkMessage),|typeof(DerivedMessageSinkMessage),|};|var derivedTypes =|typeof(MessageSinkMessage)|.Assembly|.GetTypes()|.Where(t => !t.IsAbstract && !excludedTypes.Contains(t) && typeof(IMessageSinkMessage).IsAssignableFrom(t))|.ToList();|var missingTypes =|derivedTypes|.Where(t => t.GetCustomAttribute<JsonTypeIDAttribute>() is null)|.ToList();|if (missingTypes.Count > 0)|throw new XunitException($\"The following message classes are missing [JsonTypeID]:{Environment.NewLine}{string.Join(Environment.NewLine, missingTypes.Select(t => $\" - {t.SafeName()}\").OrderBy(t => t))}\");|}"
      }
    ]
  },
  {
    "file": "TestFailedTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{|var ex = Record.Exception(() => new TestFailed|{|Cause = (FailureCause)2112,|AssemblyUniqueID = \"\",|ExceptionParentIndices = [],|ExceptionTypes = [],|ExecutionTime = 0,|FinishTime = DateTimeOffset.UtcNow,|Messages = [],|Output = \"\",|StackTraces = [],|TestCaseUniqueID = \"\",|TestClassUniqueID = \"\",|TestCollectionUniqueID = \"\",|TestMethodUniqueID = \"\",|TestUniqueID = \"\",|Warnings = [],|});|var argEx = Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"Cause\", argEx.ParamName);|Assert.StartsWith($\"Enum value 2112 not in valid set: [Assertion, Exception, Other, Timeout]\", argEx.Message);|}"
      },
      {
        "name": "NonAssertionException",
        "body": "{|var ex = new DivideByZeroException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Exception, failed.Cause);|}"
      },
      {
        "name": "BuiltInAssertionException",
        "body": "{|var ex = EqualException.ForMismatchedValues(42, 2112);|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Assertion, failed.Cause);|}"
      },
      {
        "name": "CustomAssertionException",
        "body": "{|var ex = new MyAssertionException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Assertion, failed.Cause);|}"
      },
      {
        "name": "BuiltInTimeoutException",
        "body": "{|var ex = TestTimeoutException.ForTimedOutTest(2112);|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Timeout, failed.Cause);|}"
      },
      {
        "name": "CustomTimeoutException",
        "body": "{|var ex = new MyTimeoutException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Timeout, failed.Cause);|}"
      },
      {
        "name": "TimeoutExceptionTrumpsAssertionException",
        "body": "{|var ex = new MyMultiException();|var failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);|Assert.Equal(FailureCause.Timeout, failed.Cause);|}"
      }
    ]
  },
  {
    "file": "DefaultRunnerReporterMessageHandlerTests.cs",
    "methods": [
      {
        "name": "ErrorMessage",
        "body": "{|var errorMessage = new ErrorMessage|{|ExceptionParentIndices = exceptionParentIndices,|ExceptionTypes = exceptionTypes,|Messages = messages,|StackTraces = stackTraces,|};|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(errorMessage);|AssertFailureMessages(handler.Messages, \"FATAL ERROR\");|}"
      },
      {
        "name": "TestAssemblyCleanupFailure",
        "body": "{|var assemblyStarting = TestData.TestAssemblyStarting(assemblyPath: @\"C:\\Foo\\bar.dll\");|var assemblyCleanupFailure = TestData.TestAssemblyCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(assemblyStarting);|handler.OnMessage(assemblyCleanupFailure);|AssertFailureMessages(handler.Messages, @\"Test Assembly Cleanup Failure (C:\\Foo\\bar.dll)\");|}"
      },
      {
        "name": "TestCaseCleanupFailure",
        "body": "{|var caseStarting = TestData.TestCaseStarting(testCaseDisplayName: \"MyTestCase\");|var caseCleanupFailure = TestData.TestCaseCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(caseStarting);|handler.OnMessage(caseCleanupFailure);|AssertFailureMessages(handler.Messages, \"Test Case Cleanup Failure (MyTestCase)\");|}"
      },
      {
        "name": "TestClassCleanupFailure",
        "body": "{|var classStarting = TestData.TestClassStarting(testClassName: \"MyType\");|var classCleanupFailure = TestData.TestClassCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(classStarting);|handler.OnMessage(classCleanupFailure);|AssertFailureMessages(handler.Messages, \"Test Class Cleanup Failure (MyType)\");|}"
      },
      {
        "name": "TestCleanupFailure",
        "body": "{|var testStarting = TestData.TestStarting(testDisplayName: \"MyTest\");|var testCleanupFailure = TestData.TestCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(testStarting);|handler.OnMessage(testCleanupFailure);|AssertFailureMessages(handler.Messages, \"Test Cleanup Failure (MyTest)\");|}"
      },
      {
        "name": "TestCollectionCleanupFailure",
        "body": "{|var collectionStarting = TestData.TestCollectionStarting(testCollectionDisplayName: \"FooBar\");|var collectionCleanupFailure = TestData.TestCollectionCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(collectionStarting);|handler.OnMessage(collectionCleanupFailure);|AssertFailureMessages(handler.Messages, \"Test Collection Cleanup Failure (FooBar)\");|}"
      },
      {
        "name": "TestMethodCleanupFailure",
        "body": "{|var methodStarting = TestData.TestMethodStarting(methodName: \"MyMethod\");|var methodCleanupFailure = TestData.TestMethodCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(methodStarting);|handler.OnMessage(methodCleanupFailure);|AssertFailureMessages(handler.Messages, \"Test Method Cleanup Failure (MyMethod)\");|}"
      },
      {
        "name": "LogsMessage",
        "body": "{|var message = TestData.TestAssemblyExecutionFinished();|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(message);|var msg = Assert.Single(handler.Messages);|Assert.Equal(\"[Imp] => Finished: test-assembly\", msg);|}"
      },
      {
        "name": "LogsTestNameWithExceptionAndStackTraceAndOutput",
        "body": "{|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(failedMessage);|Assert.Collection(|handler.Messages,|msg => Assert.Equal(\"[Err @ SomeFolder\\\\SomeClass.cs:18] => This is my display name \\\\t\\\\r\\\\n [FAIL]\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => ExceptionType : This is my message \\t\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => Message Line 2\", msg),|msg => Assert.Equal(\"[--- @ SomeFolder\\\\SomeClass.cs:18] => Stack Trace:\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => Line 1\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => SomeFolder\\\\SomeClass.cs(18,0): at SomeClass.SomeMethod()\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => Line 3\", msg),|msg => Assert.Equal(\"[--- @ SomeFolder\\\\SomeClass.cs:18] => Output:\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => This is\\t\", msg),|msg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] => output\", msg),|msg => Assert.Equal(\"[--- @ SomeFolder\\\\SomeClass.cs:18] => Warnings:\", msg),|msg => Assert.Equal(\"[Wrn @ SomeFolder\\\\SomeClass.cs:18] =>  warning1\", msg),|msg => Assert.Equal(\"[Wrn @ SomeFolder\\\\SomeClass.cs:18] =>  warning2 line 1\", msg),|msg => Assert.Equal(\"[Wrn @ SomeFolder\\\\SomeClass.cs:18] => warning2 line 2\", msg)|);|}"
      },
      {
        "name": "WithoutFlag_LogsNothing",
        "body": "{|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(outputMessage);|Assert.Empty(handler.Messages);|}"
      },
      {
        "name": "WithFlag_LogsOutput",
        "body": "{|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(TestData.TestAssemblyExecutionStarting(showLiveOutput: true));|handler.OnMessage(TestData.TestAssemblyStarting());|handler.Messages.Clear(); // Reset any output from previous messages|handler.OnMessage(startingMessage);|handler.OnMessage(outputMessage);|var msg = Assert.Single(handler.Messages);|Assert.Equal(\"[---] => This is my display name \\\\t\\\\r\\\\n [OUTPUT] This is\\\\t\\\\r\\\\noutput\", msg);|}"
      },
      {
        "name": "DoesNotLogOutputByDefault",
        "body": "{|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(TestData.TestAssemblyExecutionStarting(diagnosticMessages: false));|handler.OnMessage(TestData.TestAssemblyStarting());|handler.Messages.Clear(); // Reset any output from previous messages|handler.OnMessage(startingMessage);|handler.OnMessage(passedMessage);|Assert.Empty(handler.Messages);|}"
      },
      {
        "name": "LogsOutputWhenDiagnosticsAreEnabled",
        "body": "{|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(TestData.TestAssemblyExecutionStarting(diagnosticMessages: true));|handler.OnMessage(TestData.TestAssemblyStarting());|handler.Messages.Clear(); // Reset any output from previous messages|handler.OnMessage(startingMessage);|handler.OnMessage(passedMessage);|Assert.Collection(|handler.Messages,|msg => Assert.Equal(\"[Imp] => This is my display name \\\\t\\\\r\\\\n [PASS]\", msg),|msg => Assert.Equal(\"[---] => Output:\", msg),|msg => Assert.Equal(\"[Imp] => This is\\t\", msg),|msg => Assert.Equal(\"[Imp] => output\", msg)|);|}"
      },
      {
        "name": "DoesNotLogOutputWhenEnvVarIsSetupWithDiagnosticsEnabled",
        "body": "{|using (EnvironmentHelper.RestoreEnvironment(DefaultRunnerReporterMessageHandler.EnvVar_HidePassingOutput))|{|Environment.SetEnvironmentVariable(DefaultRunnerReporterMessageHandler.EnvVar_HidePassingOutput, \"1\");|var handler = TestableDefaultRunnerReporterMessageHandler.Create();|handler.OnMessage(TestData.TestAssemblyExecutionStarting(diagnosticMessages: true));|handler.OnMessage(TestData.TestAssemblyStarting());|handler.Messages.Clear(); // Reset any output from previous messages|handler.OnMessage(startingMessage);|handler.OnMessage(passedMessage);|Assert.Empty(handler.Messages);|}|}"
      }
    ]
  },
  {
    "file": "TeamCityReporterMessageHandlerTests.cs",
    "methods": [
      {
        "name": "ErrorMessage",
        "body": "{|var errorMessage = new ErrorMessage|{|ExceptionParentIndices = exceptionParentIndices,|ExceptionTypes = exceptionTypes,|Messages = messages,|StackTraces = stackTraces|};|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(errorMessage);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"FATAL ERROR\");|}"
      },
      {
        "name": "TestAssemblyCleanupFailure",
        "body": "{|var collectionStarting = TestData.TestAssemblyStarting(assemblyUniqueID: assemblyID, assemblyPath: @\"C:\\Foo\\Bar.dll\");|var collectionCleanupFailure = TestData.TestAssemblyCleanupFailure(|assemblyUniqueID: assemblyID,|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(collectionStarting);|handler.OnMessage(collectionCleanupFailure);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Assembly Cleanup Failure (C:|0x005CFoo|0x005CBar.dll)\", assemblyID);|}"
      },
      {
        "name": "TestCaseCleanupFailure",
        "body": "{|var caseStarting = TestData.TestCaseStarting(testCollectionUniqueID: collectionID, testCaseDisplayName: \"MyTestCase\\t\\r\\n\");|var caseCleanupFailure = TestData.TestCaseCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces,|testCollectionUniqueID: collectionID|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(caseStarting);|handler.OnMessage(caseCleanupFailure);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Case Cleanup Failure (MyTestCase\\t|r|n)\", collectionID);|}"
      },
      {
        "name": "TestClassCleanupFailure",
        "body": "{|var classStarting = TestData.TestClassStarting(testCollectionUniqueID: collectionID, testClassName: \"MyType\\t\\r\\n\");|var classCleanupFailure = TestData.TestClassCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces,|testCollectionUniqueID: collectionID|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(classStarting);|handler.OnMessage(classCleanupFailure);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Class Cleanup Failure (MyType\\t|r|n)\", collectionID);|}"
      },
      {
        "name": "TestCleanupFailure",
        "body": "{|var testStarting = TestData.TestStarting(testCollectionUniqueID: collectionID, testDisplayName: \"MyTest\\t\\r\\n\");|var testCleanupFailure = TestData.TestCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces,|testCollectionUniqueID: collectionID|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(testStarting);|handler.OnMessage(testCleanupFailure);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Cleanup Failure (MyTest\\t|r|n)\", collectionID);|}"
      },
      {
        "name": "TestCollectionCleanupFailure",
        "body": "{|var collectionStarting = TestData.TestCollectionStarting(testCollectionUniqueID: collectionID, testCollectionDisplayName: \"FooBar\\t\\r\\n\");|var collectionCleanupFailure = TestData.TestCollectionCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces,|testCollectionUniqueID: collectionID|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(collectionStarting);|handler.OnMessage(collectionCleanupFailure);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Collection Cleanup Failure (FooBar\\t|r|n (test-collection-id\\t|r|n))\", collectionID);|}"
      },
      {
        "name": "TestMethodCleanupFailure",
        "body": "{|var methodStarting = TestData.TestMethodStarting(testCollectionUniqueID: collectionID, methodName: \"MyMethod\\t\\r\\n\");|var methodCleanupFailure = TestData.TestMethodCleanupFailure(|exceptionParentIndices: exceptionParentIndices,|exceptionTypes: exceptionTypes,|messages: messages,|stackTraces: stackTraces,|testCollectionUniqueID: collectionID|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(methodStarting);|handler.OnMessage(methodCleanupFailure);|AssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Method Cleanup Failure (MyMethod\\t|r|n)\", collectionID);|}"
      },
      {
        "name": "StartsAndEndsFlowAndSuite",
        "body": "{|var startingMessage = TestData.TestAssemblyStarting(assemblyUniqueID: \"assembly-id\\t\\r\\n\", assemblyPath: @\"/path/to\\test-assembly.exe\");|var finishedMessage = TestData.TestAssemblyFinished(assemblyUniqueID: \"assembly-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(finishedMessage);|Assert.Collection(|handler.Messages.Where(msg => msg.Contains(\"##teamcity\")),|msg => Assert.Equal(\"[Raw] => ##teamcity[flowStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n']\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n' name='/path/to|0x005Ctest-assembly.exe']\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n' name='/path/to|0x005Ctest-assembly.exe']\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[flowFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n']\", msg)|);|}"
      },
      {
        "name": "UsesRootFlowIDFromTeamCityEnvironment",
        "body": "{|var startingMessage = TestData.TestAssemblyStarting(assemblyUniqueID: \"assembly-id\\t\\r\\n\", assemblyPath: \"test-assembly.exe\\t\\r\\n\");|var finishedMessage = TestData.TestAssemblyFinished(assemblyUniqueID: \"assembly-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create(\"root-flow-id\\t\\r\\n\");|handler.OnMessage(startingMessage);|handler.OnMessage(finishedMessage);|var msg = handler.Messages.Where(msg => msg.Contains(\"##teamcity\")).First();|Assert.Equal(\"[Raw] => ##teamcity[flowStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n' parent='root-flow-id\\t|r|n']\", msg);|}"
      },
      {
        "name": "StartsAndEndsFlowAndSuite",
        "body": "{|var startingMessage = TestData.TestCollectionStarting(testCollectionUniqueID: \"test-collection-id\\t\\r\\n\", testCollectionDisplayName: \"my-test-collection\\t\\r\\n\");|var finishedMessage = TestData.TestCollectionFinished(testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(finishedMessage);|Assert.Collection(|handler.Messages.Where(msg => msg.Contains(\"##teamcity\")),|msg => Assert.Equal(\"[Raw] => ##teamcity[flowStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' parent='assembly-id']\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='my-test-collection\\t|r|n (test-collection-id\\t|r|n)']\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='my-test-collection\\t|r|n (test-collection-id\\t|r|n)']\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[flowFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n']\", msg)|);|}"
      },
      {
        "name": "LogsTestFailed",
        "body": "{|var startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var failedMessage = TestData.TestFailed(|exceptionParentIndices: new[] { -1 },|exceptionTypes: new[] { \"ExceptionType\" },|executionTime: 1.2345m,|messages: new[] { \"This is my message \\t\\r\\n\" },|output: \"This is\\t\\r\\noutput\",|stackTraces: new[] { \"Line 1\\r\\nLine 2\\r\\nLine 3\" },|testCollectionUniqueID: \"test-collection-id\\t\\r\\n\"|);|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(failedMessage);|Assert.Collection(|handler.Messages.Where(msg => msg.Contains(\"##teamcity\")),|msg => { }, // testStarting|msg => Assert.Equal(\"[Raw] => ##teamcity[testFailed timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' details='ExceptionType : This is my message ||r|n|r|nLine 1|r|nLine 2|r|nLine 3']\", msg)|);|}"
      },
      {
        "name": "WithoutOutput",
        "body": "{|var startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var finishedMessage = TestData.TestFinished(executionTime: 1.2345m, output: \"\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(finishedMessage);|var msg = handler.Messages.Last();|Assert.Collection(|handler.Messages.Where(msg => msg.Contains(\"##teamcity\")),|msg => { }, // testStarted|msg => Assert.Equal(\"[Raw] => ##teamcity[testFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' duration='1234']\", msg)|);|}"
      },
      {
        "name": "WithOutput",
        "body": "{|var startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var finishedMessage = TestData.TestFinished(executionTime: 1.2345m, output: \"This is\\t\\r\\noutput\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(finishedMessage);|var msg = handler.Messages.Last();|Assert.Collection(|handler.Messages.Where(msg => msg.Contains(\"##teamcity\")),|msg => { }, // testStarted|msg => Assert.Equal(\"[Raw] => ##teamcity[testStdOut timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' out='This is||r|noutput' tc:tags='tc:parseServiceMessagesInside']]\", msg),|msg => Assert.Equal(\"[Raw] => ##teamcity[testFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' duration='1234']\", msg)|);|}"
      },
      {
        "name": "LogsTestIgnored",
        "body": "{|var startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var skippedMessage = TestData.TestSkipped(reason: \"This is my skip reason \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|handler.OnMessage(skippedMessage);|Assert.Collection(|handler.Messages.Where(msg => msg.Contains(\"##teamcity\")),|msg => { }, // testStarted|msg => Assert.Equal(\"[Raw] => ##teamcity[testIgnored timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' message='This is my skip reason \\t|r|n']\", msg)|);|}"
      },
      {
        "name": "LogsTestName",
        "body": "{|var startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");|var handler = TestableTeamCityReporterMessageHandler.Create();|handler.OnMessage(startingMessage);|var msg = Assert.Single(handler.Messages);|Assert.Equal(\"[Raw] => ##teamcity[testStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n']\", msg);|}"
      }
    ]
  },
  {
    "file": "MessageMetadataCacheTests.cs",
    "methods": [
      {
        "name": "AssemblyTest",
        "body": "{|var starting = TestData.TestAssemblyStarting();|var failure = TestData.TestAssemblyCleanupFailure();|var finished = TestData.TestAssemblyFinished();|var cache = new MessageMetadataCache();|// Starts empty|Assert.Null(cache.TryGetAssemblyMetadata(failure));|// Set the cache, should be able to retrieve it|cache.Set(starting);|Assert.Same(starting, cache.TryGetAssemblyMetadata(failure));|Assert.Same(starting, cache.TryGetAssemblyMetadata(failure.AssemblyUniqueID, remove: false));|Assert.Same(starting, cache.TryGetAssemblyMetadata(failure.AssemblyUniqueID, remove: true));|// After removal, we're empty again|Assert.Null(cache.TryGetAssemblyMetadata(failure));|// Now set and use the explicit finish removal|cache.Set(starting);|Assert.Same(starting, cache.TryRemove(finished));|// Finish empty|Assert.Null(cache.TryGetAssemblyMetadata(failure));|}"
      },
      {
        "name": "TestCaseTest",
        "body": "{|var starting = TestData.TestCaseStarting();|var failure = TestData.TestCaseCleanupFailure();|var finished = TestData.TestCaseFinished();|var cache = new MessageMetadataCache();|// Starts empty|Assert.Null(cache.TryGetTestCaseMetadata(failure));|// Set the cache, should be able to retrieve it|cache.Set(starting);|Assert.Same(starting, cache.TryGetTestCaseMetadata(failure));|Assert.Same(starting, cache.TryGetTestCaseMetadata(failure.TestCaseUniqueID, remove: false));|Assert.Same(starting, cache.TryGetTestCaseMetadata(failure.TestCaseUniqueID, remove: true));|// After removal, we're empty again|Assert.Null(cache.TryGetTestCaseMetadata(failure));|// Now set and use the explicit finish removal|cache.Set(starting);|Assert.Same(starting, cache.TryRemove(finished));|// Finish empty|Assert.Null(cache.TryGetTestCaseMetadata(failure));|}"
      },
      {
        "name": "TestClassTest",
        "body": "{|var starting = TestData.TestClassStarting();|var failure = TestData.TestClassCleanupFailure();|var finished = TestData.TestClassFinished();|var cache = new MessageMetadataCache();|// Starts empty|Assert.Null(cache.TryGetClassMetadata(failure));|// Set the cache, should be able to retrieve it|cache.Set(starting);|Assert.Same(starting, cache.TryGetClassMetadata(failure));|Assert.Same(starting, cache.TryGetClassMetadata(failure.TestClassUniqueID!, remove: false));|Assert.Same(starting, cache.TryGetClassMetadata(failure.TestClassUniqueID!, remove: true));|// After removal, we're empty again|Assert.Null(cache.TryGetClassMetadata(failure));|// Now set and use the explicit finish removal|cache.Set(starting);|Assert.Same(starting, cache.TryRemove(finished));|// Finish empty|Assert.Null(cache.TryGetClassMetadata(failure));|}"
      },
      {
        "name": "TestCollectionTest",
        "body": "{|var starting = TestData.TestCollectionStarting();|var failure = TestData.TestCollectionCleanupFailure();|var finished = TestData.TestCollectionFinished();|var cache = new MessageMetadataCache();|// Starts empty|Assert.Null(cache.TryGetCollectionMetadata(failure));|// Set the cache, should be able to retrieve it|cache.Set(starting);|Assert.Same(starting, cache.TryGetCollectionMetadata(failure));|Assert.Same(starting, cache.TryGetCollectionMetadata(failure.TestCollectionUniqueID, remove: false));|Assert.Same(starting, cache.TryGetCollectionMetadata(failure.TestCollectionUniqueID, remove: true));|// After removal, we're empty again|Assert.Null(cache.TryGetCollectionMetadata(failure));|// Now set and use the explicit finish removal|cache.Set(starting);|Assert.Same(starting, cache.TryRemove(finished));|// Finish empty|Assert.Null(cache.TryGetCollectionMetadata(failure));|}"
      },
      {
        "name": "TestTest",
        "body": "{|var starting = TestData.TestStarting();|var failure = TestData.TestCleanupFailure();|var finished = TestData.TestFinished();|var cache = new MessageMetadataCache();|// Starts empty|Assert.Null(cache.TryGetTestMetadata(failure));|// Set the cache, should be able to retrieve it|cache.Set(starting);|Assert.Same(starting, cache.TryGetTestMetadata(failure));|Assert.Same(starting, cache.TryGetTestMetadata(failure.TestUniqueID, remove: false));|Assert.Same(starting, cache.TryGetTestMetadata(failure.TestUniqueID, remove: true));|// After removal, we're empty again|Assert.Null(cache.TryGetTestMetadata(failure));|// Now set and use the explicit finish removal|cache.Set(starting);|Assert.Same(starting, cache.TryRemove(finished));|// Finish empty|Assert.Null(cache.TryGetTestMetadata(failure));|}"
      },
      {
        "name": "TestMethodTest",
        "body": "{|var starting = TestData.TestMethodStarting();|var failure = TestData.TestMethodCleanupFailure();|var finished = TestData.TestMethodFinished();|var cache = new MessageMetadataCache();|// Starts empty|Assert.Null(cache.TryGetMethodMetadata(failure));|// Set the cache, should be able to retrieve it|cache.Set(starting);|Assert.Same(starting, cache.TryGetMethodMetadata(failure));|Assert.Same(starting, cache.TryGetMethodMetadata(failure.TestMethodUniqueID!, remove: false));|Assert.Same(starting, cache.TryGetMethodMetadata(failure.TestMethodUniqueID!, remove: true));|// After removal, we're empty again|Assert.Null(cache.TryGetMethodMetadata(failure));|// Now set and use the explicit finish removal|cache.Set(starting);|Assert.Same(starting, cache.TryRemove(finished));|// Finish empty|Assert.Null(cache.TryGetMethodMetadata(failure));|}"
      }
    ]
  },
  {
    "file": "CommandLineTests.cs",
    "methods": [
      {
        "name": "UnknownOptionThrows",
        "body": "{|var commandLine = new TestableCommandLine(\"-unknown\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"unknown option: -unknown\", exception.Message);|}"
      },
      {
        "name": "AssemblyDoesNotExist_Throws",
        "body": "{|var commandLine = new TestableCommandLine(\"badAssembly.dll\");|var exception = Record.Exception(commandLine.Parse);|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"assembly not found: badAssembly.dll\", exception.Message);|}"
      },
      {
        "name": "SingleAssembly_NoConfigFile",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location);|var project = commandLine.Parse();|var assembly = Assert.Single(project.Assemblies);|Assert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);|Assert.Null(assembly.ConfigFileName);|}"
      },
      {
        "name": "SingleAssembly_WithConfigFile",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"assembly1.json\");|var project = commandLine.Parse();|var assembly = Assert.Single(project.Assemblies);|Assert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);|var assemblyFolder = Guard.NotNull(\"Assembly folder cannot be null\", Path.GetDirectoryName(typeof(CommandLineTests).Assembly.Location));|Assert.Equal(Path.Combine(assemblyFolder, \"assembly1.json\"), assembly.ConfigFileName);|}"
      },
      {
        "name": "MultipleAssemblies_NoConfigFiles",
        "body": "{|var arguments = new[] { typeof(CommandLineTests).Assembly.Location, typeof(CommandLine).Assembly.Location };|var commandLine = new TestableCommandLine(arguments);|var project = commandLine.Parse();|Assert.Collection(|project.Assemblies,|a =>|{|Assert.Equal(typeof(CommandLineTests).Assembly.Location, a.AssemblyFileName);|Assert.Null(a.ConfigFileName);|},|a =>|{|Assert.Equal(typeof(CommandLine).Assembly.Location, a.AssemblyFileName);|Assert.Null(a.ConfigFileName);|}|);|}"
      },
      {
        "name": "NoColorSetsEnvironmentVariable",
        "body": "{|Assert.Null(Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor));|new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-nocolor\").Parse();|// Any set (non-null, non-empty) value is acceptable, see https://no-color.org/|var envValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor);|Assert.NotNull(envValue);|Assert.NotEmpty(envValue);|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.AppDomain);|}"
      },
      {
        "name": "MissingValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"missing argument for -appdomains\", exception.Message);|}"
      },
      {
        "name": "InvalidValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\", \"foo\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"incorrect argument value for -appdomains (must be 'denied', 'required', or 'ifavailable')\", exception.Message);|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.Culture);|}"
      },
      {
        "name": "ExplicitDefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"default\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.Culture);|}"
      },
      {
        "name": "InvariantCultureIsEmptyString",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"invariant\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Equal(string.Empty, assembly.Configuration.Culture);|}"
      },
      {
        "name": "ValueIsPreserved",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"foo\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Equal(\"foo\", assembly.Configuration.Culture);|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|{|Assert.Null(assembly.Configuration.DiagnosticMessages);|Assert.Null(assembly.Configuration.LongRunningTestSeconds);|}|}"
      },
      {
        "name": "MissingValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\");|var exception = Record.Exception(commandLine.Parse);|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"missing argument for -longRunning\", exception.Message);|}"
      },
      {
        "name": "InvalidValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\", \"abc\");|var exception = Record.Exception(commandLine.Parse);|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"incorrect argument value for -longRunning (must be a positive integer)\", exception.Message);|}"
      },
      {
        "name": "ValidValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-LONGRUNNING\", \"123\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|{|Assert.True(assembly.Configuration.DiagnosticMessages);|Assert.Equal(123, assembly.Configuration.LongRunningTestSeconds);|}|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.MaxParallelThreads);|}"
      },
      {
        "name": "MissingValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-maxthreads\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"missing argument for -maxThreads\", exception.Message);|}"
      },
      {
        "name": "ParallelizationOptionsAreNullByDefault",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|{|Assert.Null(assembly.Configuration.ParallelizeAssembly);|Assert.Null(assembly.Configuration.ParallelizeTestCollections);|}|}"
      },
      {
        "name": "FailsWithoutOptionOrWithIncorrectOptions",
        "body": "{|var commandLine1 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\");|var exception1 = Record.Exception(() => commandLine1.Parse());|Assert.IsType<ArgumentException>(exception1);|Assert.Equal(\"missing argument for -parallel\", exception1.Message);|var commandLine2 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\", \"nonsense\");|var exception2 = Record.Exception(() => commandLine2.Parse());|Assert.IsType<ArgumentException>(exception2);|Assert.Equal(\"incorrect argument value for -parallel\", exception2.Message);|}"
      },
      {
        "name": "DefaultFilters",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|var filters = project.Assemblies.Single().Configuration.Filters;|Assert.True(filters.Empty);|}"
      },
      {
        "name": "NoReporters_UsesDefaultReporter",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter);|}"
      },
      {
        "name": "NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter",
        "body": "{|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false);|var commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter);|}"
      },
      {
        "name": "ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var commandLine = new TestableCommandLine([explicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");|var project = commandLine.Parse();|Assert.Same(explicitReporter, project.RunnerReporter);|}"
      },
      {
        "name": "ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var commandLine = new TestableCommandLine([explicitReporter, implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");|var project = commandLine.Parse();|Assert.Same(implicitReporter, project.RunnerReporter);|}"
      },
      {
        "name": "WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter",
        "body": "{|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-noautoreporters\");|var project = commandLine.Parse();|Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter);|}"
      },
      {
        "name": "NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var commandLine = new TestableCommandLine([explicitReporter, implicitReporter1, implicitReporter2], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|Assert.Same(implicitReporter1, project.RunnerReporter);|}"
      }
    ]
  },
  {
    "file": "CommandLineTests.cs",
    "methods": [
      {
        "name": "UnknownOptionThrows",
        "body": "{|var commandLine = new TestableCommandLine(\"-unknown\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"unknown option: -unknown\", exception.Message);|}"
      },
      {
        "name": "AssemblyDoesNotExist_Throws",
        "body": "{|var commandLine = new TestableCommandLine(\"badAssembly.dll\");|var exception = Record.Exception(commandLine.Parse);|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"assembly not found: badAssembly.dll\", exception.Message);|}"
      },
      {
        "name": "SingleAssembly_NoConfigFile",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location);|var project = commandLine.Parse();|var assembly = Assert.Single(project.Assemblies);|Assert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);|Assert.Null(assembly.ConfigFileName);|}"
      },
      {
        "name": "SingleAssembly_WithConfigFile",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"assembly1.json\");|var project = commandLine.Parse();|var assembly = Assert.Single(project.Assemblies);|Assert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);|var assemblyFolder = Guard.NotNull(\"Assembly folder cannot be null\", Path.GetDirectoryName(typeof(CommandLineTests).Assembly.Location));|Assert.Equal(Path.Combine(assemblyFolder, \"assembly1.json\"), assembly.ConfigFileName);|}"
      },
      {
        "name": "MultipleAssemblies_NoConfigFiles",
        "body": "{|var arguments = new[] { typeof(CommandLineTests).Assembly.Location, typeof(CommandLine).Assembly.Location };|var commandLine = new TestableCommandLine(arguments);|var project = commandLine.Parse();|Assert.Collection(|project.Assemblies,|a =>|{|Assert.Equal(typeof(CommandLineTests).Assembly.Location, a.AssemblyFileName);|Assert.Null(a.ConfigFileName);|},|a =>|{|Assert.Equal(typeof(CommandLine).Assembly.Location, a.AssemblyFileName);|Assert.Null(a.ConfigFileName);|}|);|}"
      },
      {
        "name": "NoColorSetsEnvironmentVariable",
        "body": "{|Assert.Null(Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor));|new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-nocolor\").Parse();|// Any set (non-null, non-empty) value is acceptable, see https://no-color.org/|var envValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor);|Assert.NotNull(envValue);|Assert.NotEmpty(envValue);|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.AppDomain);|}"
      },
      {
        "name": "MissingValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"missing argument for -appdomains\", exception.Message);|}"
      },
      {
        "name": "InvalidValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\", \"foo\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"incorrect argument value for -appdomains (must be 'denied', 'required', or 'ifavailable')\", exception.Message);|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.Culture);|}"
      },
      {
        "name": "ExplicitDefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"default\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.Culture);|}"
      },
      {
        "name": "InvariantCultureIsEmptyString",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"invariant\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Equal(string.Empty, assembly.Configuration.Culture);|}"
      },
      {
        "name": "ValueIsPreserved",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"foo\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Equal(\"foo\", assembly.Configuration.Culture);|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|{|Assert.Null(assembly.Configuration.DiagnosticMessages);|Assert.Null(assembly.Configuration.LongRunningTestSeconds);|}|}"
      },
      {
        "name": "MissingValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\");|var exception = Record.Exception(commandLine.Parse);|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"missing argument for -longRunning\", exception.Message);|}"
      },
      {
        "name": "InvalidValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\", \"abc\");|var exception = Record.Exception(commandLine.Parse);|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"incorrect argument value for -longRunning (must be a positive integer)\", exception.Message);|}"
      },
      {
        "name": "ValidValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-LONGRUNNING\", \"123\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|{|Assert.True(assembly.Configuration.DiagnosticMessages);|Assert.Equal(123, assembly.Configuration.LongRunningTestSeconds);|}|}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|Assert.Null(assembly.Configuration.MaxParallelThreads);|}"
      },
      {
        "name": "MissingValue",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-maxthreads\");|var exception = Record.Exception(() => commandLine.Parse());|Assert.IsType<ArgumentException>(exception);|Assert.Equal(\"missing argument for -maxThreads\", exception.Message);|}"
      },
      {
        "name": "ParallelizationOptionsAreNullByDefault",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|foreach (var assembly in project.Assemblies)|{|Assert.Null(assembly.Configuration.ParallelizeAssembly);|Assert.Null(assembly.Configuration.ParallelizeTestCollections);|}|}"
      },
      {
        "name": "FailsWithoutOptionOrWithIncorrectOptions",
        "body": "{|var commandLine1 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\");|var exception1 = Record.Exception(() => commandLine1.Parse());|Assert.IsType<ArgumentException>(exception1);|Assert.Equal(\"missing argument for -parallel\", exception1.Message);|var commandLine2 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\", \"nonsense\");|var exception2 = Record.Exception(() => commandLine2.Parse());|Assert.IsType<ArgumentException>(exception2);|Assert.Equal(\"incorrect argument value for -parallel\", exception2.Message);|}"
      },
      {
        "name": "DefaultFilters",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|var filters = project.Assemblies.Single().Configuration.Filters;|Assert.True(filters.Empty);|}"
      },
      {
        "name": "NoReporters_UsesDefaultReporter",
        "body": "{|var commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter);|}"
      },
      {
        "name": "NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter",
        "body": "{|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false);|var commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter);|}"
      },
      {
        "name": "ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var commandLine = new TestableCommandLine([explicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");|var project = commandLine.Parse();|Assert.Same(explicitReporter, project.RunnerReporter);|}"
      },
      {
        "name": "ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var commandLine = new TestableCommandLine([explicitReporter, implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");|var project = commandLine.Parse();|Assert.Same(implicitReporter, project.RunnerReporter);|}"
      },
      {
        "name": "WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter",
        "body": "{|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-noautoreporters\");|var project = commandLine.Parse();|Assert.IsType<DefaultRunnerReporter>(project.RunnerReporter);|}"
      },
      {
        "name": "NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var commandLine = new TestableCommandLine([explicitReporter, implicitReporter1, implicitReporter2], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");|var project = commandLine.Parse();|Assert.Same(implicitReporter1, project.RunnerReporter);|}"
      }
    ]
  },
  {
    "file": "CommandLineOptionsProviderTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{|Assert.Throws<ArgumentNullException>(\"configuration\", () => CommandLineOptionsProvider.Parse(null!, commandLineOptions, projectAssembly));|Assert.Throws<ArgumentNullException>(\"commandLineOptions\", () => CommandLineOptionsProvider.Parse(configuration, null!, projectAssembly));|Assert.Throws<ArgumentNullException>(\"projectAssembly\", () => CommandLineOptionsProvider.Parse(configuration, commandLineOptions, null!));|}"
      },
      {
        "name": "AutoReporters_Invalid",
        "body": "{|commandLineOptions.Set(\"auto-reporters\", [\"foo\"]);|var ex = Record.Exception(() => CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly));|Assert.IsType<ArgumentException>(ex);|Assert.Equal(\"Invalid value 'foo' (must be one of: 'on', 'off')\", ex.Message);|}"
      },
      {
        "name": "ConfigFile",
        "body": "{|commandLineOptions.Set(\"xunit-config-filename\", [\"foo-bar-baz.json\"]);|var ex = Record.Exception(() => CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly));|Assert.IsType<ArgumentException>(ex);|Assert.Equal($\"Config file '{Path.GetFullPath(\"foo-bar-baz.json\")}' was not found\", ex.Message);|}"
      },
      {
        "name": "LongRunning",
        "body": "{|commandLineOptions.Set(\"long-running\", [\"123\"]);|CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly);|Assert.Equal(123, projectAssembly.Configuration.LongRunningTestSeconds);|}"
      },
      {
        "name": "Seed",
        "body": "{|commandLineOptions.Set(\"seed\", [\"42\"]);|CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly);|Assert.Equal(42, projectAssembly.Configuration.Seed);|}"
      },
      {
        "name": "FilterTraits",
        "body": "{|commandLineOptions.Set(\"filter-trait\", [\"foo=bar\"]);|commandLineOptions.Set(\"filter-not-trait\", [\"baz=biff\"]);|CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly);|Assert.Collection(|projectAssembly.Configuration.Filters.ToXunit3Arguments(),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"foo=bar\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"baz=biff\", arg)|);|}"
      }
    ]
  },
  {
    "file": "TestPlatformDiscoveryMessageSinkTests.cs",
    "methods": [
      {
        "name": "ReturnsFalseWhenCancellationTokenIsCancelled",
        "body": "{|var message = TestData.DiagnosticMessage();|var classUnderTest = TestableTestPlatformDiscoveryMessageSink.Create();|classUnderTest.InnerSink.Callback = _ => true;|classUnderTest.CancellationTokenSource.Cancel();|var result = classUnderTest.OnMessage(message);|Assert.False(result);|}"
      },
      {
        "name": "ITestCaseDiscovered",
        "body": "{|var discovered = TestData.TestCaseDiscovered(|sourceFilePath: \"/path/to/file.cs\",|sourceLineNumber: 42,|testClassName: \"test-class\",|testMethodName: \"test-method\",|testMethodParameterTypesVSTest: [\"System.Int32\", \"System.String\"],|testMethodReturnTypeVSTest: \"System.Void\",|testClassNamespace: \"ns\",|traits: TestData.DefaultTraits|);|var classUnderTest = TestableTestPlatformDiscoveryMessageSink.Create();|classUnderTest.OnMessage(discovered);|var message = Assert.Single(classUnderTest.TestNodeMessageBus.PublishedData);|var updateMessage = Assert.IsType<TestNodeUpdateMessage>(message);|var testNode = updateMessage.TestNode;|Assert.Equal(\"test-case-display-name\", testNode.DisplayName);|Assert.Equal(\"test-case-id\", testNode.Uid.Value);|var testMethodProperty = testNode.Properties.Single<TestMethodIdentifierProperty>();|Assert.Equal(AssemblyFullName, testMethodProperty.AssemblyFullName);|Assert.Equal(\"test-method\", testMethodProperty.MethodName);|Assert.Equal(\"ns\", testMethodProperty.Namespace);|Assert.Equivalent(new[] { \"System.Int32\", \"System.String\" }, testMethodProperty.ParameterTypeFullNames);|Assert.Equal(\"System.Void\", testMethodProperty.ReturnTypeFullName);|Assert.Equal(\"test-class\", testMethodProperty.TypeName);|var testLocationProperty = testNode.Properties.Single<TestFileLocationProperty>();|Assert.Equal(\"/path/to/file.cs\", testLocationProperty.FilePath);|Assert.Equal(42, testLocationProperty.LineSpan.Start.Line);|Assert.Equal(-1, testLocationProperty.LineSpan.Start.Column);|Assert.Equal(42, testLocationProperty.LineSpan.End.Line);|Assert.Equal(-1, testLocationProperty.LineSpan.End.Column);|var testMetadataProperties = testNode.Properties.OfType<TestMetadataProperty>();|Assert.Collection(|testMetadataProperties.OrderBy(p => p.Key).ThenBy(p => p.Value).Select(p => $\"'{p.Key}' = '{p.Value}'\"),|keyValue => Assert.Equal(\"'biff' = 'bang'\", keyValue),|keyValue => Assert.Equal(\"'foo' = 'bar'\", keyValue),|keyValue => Assert.Equal(\"'foo' = 'baz'\", keyValue)|);|}"
      }
    ]
  },
  {
    "file": "TestPlatformExecutionMessageSinkTests.cs",
    "methods": [
      {
        "name": "ReturnsFalseWhenCancellationTokenIsCancelled",
        "body": "{|var message = TestData.DiagnosticMessage();|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create();|classUnderTest.InnerSink.Callback = _ => true;|classUnderTest.CancellationTokenSource.Cancel();|var result = classUnderTest.OnMessage(message);|Assert.False(result);|}"
      },
      {
        "name": "ITestFailed_Timeout",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create();|SendStartingMessages(classUnderTest);|SendTestFailed(classUnderTest, FailureCause.Timeout);|var testNode = AssertStandardMetadata(classUnderTest);|var timeout = testNode.Properties.Single<TimeoutTestNodeStateProperty>();|Assert.Equal($\"exception 1 : message 1{Environment.NewLine}---- exception 2 : message 2\", timeout.Explanation);|Assert.NotNull(timeout.Exception);|Assert.Equal($\"exception 1 : message 1{Environment.NewLine}---- exception 2 : message 2\", timeout.Exception.Message);|Assert.Equal($\"stack trace 1{Environment.NewLine}----- Inner Stack Trace -----{Environment.NewLine}stack trace 2\", timeout.Exception.StackTrace);|}"
      },
      {
        "name": "ITestNotRun",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create();|SendStartingMessages(classUnderTest);|classUnderTest.OnMessage(TestData.TestNotRun());|Assert.Empty(classUnderTest.TestNodeMessageBus.PublishedData);|}"
      },
      {
        "name": "ITestSkipped",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create();|SendStartingMessages(classUnderTest);|classUnderTest.OnMessage(TestData.TestSkipped());|var testNode = AssertStandardMetadata(classUnderTest);|var skipped = testNode.Properties.Single<SkippedTestNodeStateProperty>();|Assert.Equal(TestData.DefaultSkipReason, skipped.Explanation);|}"
      },
      {
        "name": "ITestStarting",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create();|SendStartingMessages(classUnderTest, includeTestStarting: false);|classUnderTest.OnMessage(TestData.TestStarting());|var testNode = AssertStandardMetadata(classUnderTest, expectTiming: false);|var inProgress = testNode.Properties.Single<InProgressTestNodeStateProperty>();|Assert.Null(inProgress.Explanation);|}"
      },
      {
        "name": "ITestOutput_Off",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create(showLiveOutput: false);|classUnderTest.OnMessage(TestData.TestOutput());|Assert.Empty(classUnderTest.OutputDevice.DisplayedData);|}"
      },
      {
        "name": "ITestOutput_On",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create(showLiveOutput: true);|SendStartingMessages(classUnderTest);|classUnderTest.OnMessage(TestData.TestOutput());|var data = Assert.Single(classUnderTest.OutputDevice.DisplayedData);|AssertColorOutput(data, $\"OUTPUT: [{TestData.DefaultTestDisplayName}] {TestData.DefaultOutput}\", ConsoleColor.DarkGray);|}"
      },
      {
        "name": "Warnings",
        "body": "{|var classUnderTest = TestableTestPlatformExecutionMessageSink.Create();|SendStartingMessages(classUnderTest);|classUnderTest.OnMessage(TestData.TestPassed(warnings: [\"w1\", \"w2\"]));|AssertStandardMetadata(classUnderTest, expectWarnings: true);|}"
      }
    ]
  },
  {
    "file": "TestPlatformTestFrameworkTests.cs",
    "methods": [
      {
        "name": "CanCreateAndCloseSession",
        "body": "{|var uid = new SessionUid(\"abc\");|var framework = TestableTestPlatformTestFramework.Create();|var createResult = framework.CreateTestSession(uid);|Assert.True(createResult.IsSuccess);|var closeResult = framework.CloseTestSession(uid);|Assert.True(closeResult.IsSuccess);|}"
      },
      {
        "name": "CreateSession_WithLogo",
        "body": "{|var uid = new SessionUid(\"abc\");|var framework = TestableTestPlatformTestFramework.Create();|framework.ProjectAssembly.Project.Configuration.NoLogo = false;|framework.CreateTestSession(uid);|var log = Assert.Single(framework.RunnerLogger.Messages);|Assert.StartsWith(\"[Imp] xUnit.net v3 In-Process Runner\", log);|}"
      },
      {
        "name": "CreateSession_WithoutLogo",
        "body": "{|var uid = new SessionUid(\"abc\");|var framework = TestableTestPlatformTestFramework.Create();|framework.ProjectAssembly.Project.Configuration.NoLogo = true;|framework.CreateTestSession(uid);|Assert.Empty(framework.RunnerLogger.Messages);|}"
      },
      {
        "name": "CannotCreateSameSessionTwice",
        "body": "{|var uid = new SessionUid(\"abc\");|var framework = TestableTestPlatformTestFramework.Create();|var firstResult = framework.CreateTestSession(uid);|var secondResult = framework.CreateTestSession(uid);|Assert.True(firstResult.IsSuccess);|Assert.False(secondResult.IsSuccess);|Assert.Equal(\"Attempted to reuse session UID 'abc' already in progress\", secondResult.ErrorMessage);|}"
      },
      {
        "name": "CannotCloseUnstartedSession",
        "body": "{|var uid = new SessionUid(\"abc\");|var framework = TestableTestPlatformTestFramework.Create();|var result = framework.CloseTestSession(uid);|Assert.False(result.IsSuccess);|Assert.Equal(\"Attempted to close unknown session UID 'abc'\", result.ErrorMessage);|}"
      },
      {
        "name": "CannotRecloseSession",
        "body": "{|var uid = new SessionUid(\"abc\");|var framework = TestableTestPlatformTestFramework.Create();|framework.CreateTestSession(uid);|var firstResult = framework.CloseTestSession(uid);|var secondResult = framework.CloseTestSession(uid);|Assert.True(firstResult.IsSuccess);|Assert.False(secondResult.IsSuccess);|Assert.Equal(\"Attempted to close unknown session UID 'abc'\", secondResult.ErrorMessage);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var completionCalled = false;|var uid = new SessionUid(\"abc\");|var messageBus = new SpyTestPlatformMessageBus();|var framework = TestableTestPlatformTestFramework.Create();|var ex = await Record.ExceptionAsync(() => framework.OnDiscover(uid, messageBus, () => completionCalled = true, CancellationToken.None));|Assert.False(completionCalled);|Assert.IsType<ArgumentException>(ex);|Assert.StartsWith(\"Attempted to execute request against unknown session UID 'abc'\", ex.Message);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var completionCalled = false;|var uid = new SessionUid(\"abc\");|var messageBus = new SpyTestPlatformMessageBus();|var framework = TestableTestPlatformTestFramework.Create();|var ex = await Record.ExceptionAsync(() => framework.OnExecute(uid, filter: null, messageBus, () => completionCalled = true, CancellationToken.None));|Assert.False(completionCalled);|Assert.IsType<ArgumentException>(ex);|Assert.StartsWith(\"Attempted to execute request against unknown session UID 'abc'\", ex.Message);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|var completionCalled = false;|var uid = new SessionUid(\"abc\");|var messageBus = new SpyTestPlatformMessageBus();|var framework = TestableTestPlatformTestFramework.Create();|framework.ProjectAssembly.Configuration.Filters.AddIncludedClassFilter(typeof(SessionManagement).FullName!);|framework.CreateTestSession(uid);|// Discover tests|await framework.OnDiscover(uid, messageBus, () => completionCalled = true, CancellationToken.None);|Assert.True(completionCalled);|var testNodeUpdates = messageBus.PublishedData.OfType<TestNodeUpdateMessage>().ToArray();|Assert.Collection(|testNodeUpdates.Select(tnu => tnu.TestNode.DisplayName).OrderBy(x => x),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CanCreateAndCloseSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCloseUnstartedSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCreateSameSessionTwice)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotRecloseSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithLogo)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithoutLogo)}\", testCaseDisplayName)|);|// Reset observation|messageBus.PublishedData.Clear();|completionCalled = false;|// Execute the discovered tests|var testNodeUIDs = testNodeUpdates.Select(tnu => tnu.TestNode.Uid).ToArray();|var filter = new TestNodeUidListFilter(testNodeUIDs);|await framework.OnExecute(uid, filter, messageBus, () => completionCalled = true, CancellationToken.None);|Assert.True(completionCalled);|testNodeUpdates = messageBus.PublishedData.OfType<TestNodeUpdateMessage>().ToArray();|var inProgressTestNodes = testNodeUpdates.Where(tnu => tnu.TestNode.Properties.Any<InProgressTestNodeStateProperty>()).ToArray();|Assert.Collection(|inProgressTestNodes.Select(tnu => tnu.TestNode.DisplayName).OrderBy(x => x),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CanCreateAndCloseSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCloseUnstartedSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCreateSameSessionTwice)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotRecloseSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithLogo)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithoutLogo)}\", testCaseDisplayName)|);|var passingTestNodes = testNodeUpdates.Where(tnu => tnu.TestNode.Properties.Any<PassedTestNodeStateProperty>()).ToArray();|Assert.Collection(|passingTestNodes.Select(tnu => tnu.TestNode.DisplayName).OrderBy(x => x),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CanCreateAndCloseSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCloseUnstartedSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCreateSameSessionTwice)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotRecloseSession)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithLogo)}\", testCaseDisplayName),|testCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithoutLogo)}\", testCaseDisplayName)|);|}"
      }
    ]
  },
  {
    "file": "TraitParserTests.cs",
    "methods": [
      {
        "name": "ReturnsEmptyWhenNull",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(null, (name, value) => traits.Add(name, value));|Assert.Empty(traits);|}"
      },
      {
        "name": "ReturnsEmptyWhenEmpty",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(string.Empty, (name, value) => traits.Add(name, value));|Assert.Empty(traits);|}"
      },
      {
        "name": "ReturnsTraits",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"One=1;Two=2\", (name, value) => traits.Add(name, value));|Assert.Collection(|traits.Keys,|key =>|{|Assert.Equal(\"One\", key);|Assert.Equal(\"1\", Assert.Single(traits[key]));|},|key =>|{|Assert.Equal(\"Two\", key);|Assert.Equal(\"2\", Assert.Single(traits[key]));|}|);|}"
      },
      {
        "name": "IgnoresExtraTraitSeperatorsAndWhitespace",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"; One = 1 ;;\", (name, value) => traits.Add(name, value));|var key = Assert.Single(traits.Keys);|Assert.Equal(\"One\", key);|Assert.Equal(\"1\", Assert.Single(traits[key]));|}"
      },
      {
        "name": "IncludesExtraKeyValueSeperatorsInValue",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"One=1=2=3\", (name, value) => traits.Add(name, value));|var key = Assert.Single(traits.Keys);|Assert.Equal(\"One\", key);|Assert.Equal(\"1=2=3\", Assert.Single(traits[key]));|}"
      },
      {
        "name": "IgnoresMissingKeyValueSeperator",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"One1\", (name, value) => traits.Add(name, value));|Assert.Empty(traits);|}"
      },
      {
        "name": "IgnoresMissingKey",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"=1\", (name, value) => traits.Add(name, value));|Assert.Empty(traits);|}"
      },
      {
        "name": "IgnoresMissingValue",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"1=\", (name, value) => traits.Add(name, value));|Assert.Empty(traits);|}"
      },
      {
        "name": "ContinuesOnError",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|new TraitParser().Parse(\"One;Two=2\", (name, value) => traits.Add(name, value));|var key = Assert.Single(traits.Keys);|Assert.Equal(\"Two\", key);|Assert.Equal(\"2\", Assert.Single(traits[key]));|}"
      },
      {
        "name": "RaisesWarningOnError",
        "body": "{|var traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);|var messages = new List<string>();|var parser = new TraitParser(messages.Add);|parser.Parse(\"One1\", (name, value) => traits.Add(name, value));|var msg = Assert.Single(messages);|Assert.Equal(\"Invalid trait 'One1'. The format should be 'name=value'. This trait will be ignored.\", msg);|}"
      }
    ]
  },
  {
    "file": "xunitTests.cs",
    "methods": [
      {
        "name": "ChangesCurrentDirectoryWhenWorkingFolderIsNotNull",
        "body": "{|var tempFolder =|Environment.GetEnvironmentVariable(\"TEMP\")|?? Environment.GetEnvironmentVariable(\"TMP\")|?? Environment.GetEnvironmentVariable(\"TMPDIR\")|?? \"/tmp\";|tempFolder = Path.GetFullPath(tempFolder); // Ensure that the 8.3 path is not used|// For macOS compatibility, switch to the folder and then get it, because the temp folder|// is usually under /var/folders/... which is softlinked to /private/var/folders|var originalDirectory = Directory.GetCurrentDirectory();|Directory.SetCurrentDirectory(tempFolder);|tempFolder = Directory.GetCurrentDirectory();|Directory.SetCurrentDirectory(originalDirectory);|var xunit = new Testable_xunit { WorkingFolder = tempFolder };|xunit.Execute();|var actual = Directory.GetCurrentDirectory();|var expected = tempFolder;|if (actual[actual.Length - 1] != Path.DirectorySeparatorChar)|actual += Path.DirectorySeparatorChar;|if (expected[expected.Length - 1] != Path.DirectorySeparatorChar)|expected += Path.DirectorySeparatorChar;|Assert.Equal(expected, actual);|}"
      },
      {
        "name": "LogsWelcomeBanner",
        "body": "{|var xunit = new Testable_xunit();|xunit.Execute();|var versionAttribute = typeof(xunit).Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>();|var eventArgs = Assert.IsType<BuildMessageEventArgs>(xunit.BuildEngine.Captured(x => x.LogMessageEvent(null)).Args().Single());|Assert.Equal($\"xUnit.net v3 MSBuild Runner v{versionAttribute!.InformationalVersion} ({IntPtr.Size * 8}-bit {RuntimeInformation.FrameworkDescription})\", eventArgs.Message);|Assert.Equal(MessageImportance.High, eventArgs.Importance);|}"
      },
      {
        "name": "ReturnsTrueWhenExitCodeIsZeroAndFailCountIsZero",
        "body": "{|var xunit = new Testable_xunit(exitCode: 0);|var result = xunit.Execute();|Assert.True(result);|}"
      },
      {
        "name": "ReturnsFalseWhenExitCodeIsNonZero",
        "body": "{|var xunit = new Testable_xunit(exitCode: 1);|var result = xunit.Execute();|Assert.False(result);|}"
      },
      {
        "name": "NoReporters_UsesDefaultReporter",
        "body": "{|var xunit = new Testable_xunit();|var reporter = xunit.GetReporter();|Assert.IsType<DefaultRunnerReporter>(reporter);|}"
      },
      {
        "name": "NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter",
        "body": "{|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false);|var xunit = new Testable_xunit();|xunit.AvailableReporters.Add(implicitReporter);|var reporter = xunit.GetReporter();|Assert.IsType<DefaultRunnerReporter>(reporter);|}"
      },
      {
        "name": "ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var xunit = new Testable_xunit { Reporter = \"switch\" };|xunit.AvailableReporters.Add(explicitReporter);|var reporter = xunit.GetReporter();|Assert.Same(explicitReporter, reporter);|}"
      },
      {
        "name": "ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var xunit = new Testable_xunit { Reporter = \"switch\" };|xunit.AvailableReporters.AddRange(new[] { explicitReporter, implicitReporter });|var reporter = xunit.GetReporter();|Assert.Same(implicitReporter, reporter);|}"
      },
      {
        "name": "WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter",
        "body": "{|var implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var xunit = new Testable_xunit { NoAutoReporters = true };|xunit.AvailableReporters.Add(implicitReporter);|var reporter = xunit.GetReporter();|Assert.IsType<DefaultRunnerReporter>(reporter);|}"
      },
      {
        "name": "NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter",
        "body": "{|var explicitReporter = Mocks.RunnerReporter(\"switch\");|var implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);|var xunit = new Testable_xunit();|xunit.AvailableReporters.AddRange(new[] { explicitReporter, implicitReporter1, implicitReporter2 });|var reporter = xunit.GetReporter();|Assert.Same(implicitReporter1, reporter);|}"
      },
      {
        "name": "BadChosenReporter_NoAvailableReporters",
        "body": "{|var xunit = new Testable_xunit { Reporter = \"foo\" };|var reporter = xunit.GetReporter();|Assert.Null(reporter);|var eventArgs = Assert.IsType<BuildErrorEventArgs>(xunit.BuildEngine.Captured(x => x.LogErrorEvent(null)).Args().Single());|Assert.Equal(\"Reporter value 'foo' is invalid. There are no available reporters.\", eventArgs.Message);|}"
      },
      {
        "name": "BadChosenReporter_WithAvailableReporters",
        "body": "{|var xunit = new Testable_xunit { Reporter = \"foo\" };|xunit.AvailableReporters.AddRange(new[] { Mocks.RunnerReporter(\"switch1\"), Mocks.RunnerReporter(\"switch2\") });|var reporter = xunit.GetReporter();|Assert.Null(reporter);|var eventArgs = Assert.IsType<BuildErrorEventArgs>(xunit.BuildEngine.Captured(x => x.LogErrorEvent(null)).Args().Single());|Assert.Equal(\"Reporter value 'foo' is invalid. Available reporters: switch1, switch2\", eventArgs.Message);|}"
      }
    ]
  },
  {
    "file": "ConfigReaderTests.cs",
    "methods": [
      {
        "name": "SupportDefaultCulture",
        "body": "{|var configuration = new TestAssemblyConfiguration { Culture = \"override-me\" };|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_CultureDefault.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Null(configuration.Culture);|}"
      },
      {
        "name": "SupportInvariantCulture",
        "body": "{|var configuration = new TestAssemblyConfiguration();|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_CultureInvariant.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Equal(string.Empty, configuration.Culture);|}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsAsMultiplier_ReturnsMultipliedValue",
        "body": "{|var configuration = new TestAssemblyConfiguration();|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsMultiplier.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Equal(Environment.ProcessorCount * 2, configuration.MaxParallelThreadsOrDefault);|}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsAsMultiplierWithComma_ReturnsMultipliedValue",
        "body": "{|var configuration = new TestAssemblyConfiguration();|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsMultiplierComma.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Equal(Environment.ProcessorCount * 2, configuration.MaxParallelThreadsOrDefault);|}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsAsMultiplierWithDecimal_ReturnsMultipliedValue",
        "body": "{|var configuration = new TestAssemblyConfiguration();|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsMultiplierDecimal.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Equal(Environment.ProcessorCount * 2, configuration.MaxParallelThreadsOrDefault);|}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsExplicitDefault_ReturnsProcessorCount",
        "body": "{|var configuration = new TestAssemblyConfiguration { MaxParallelThreads = 2112 };|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsDefault.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Equal(Environment.ProcessorCount, configuration.MaxParallelThreadsOrDefault);|}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsExplicitUnlimited_ReturnsUnlimited",
        "body": "{|var configuration = new TestAssemblyConfiguration();|var warnings = new List<string>();|var result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsUnlimited.json\"), warnings);|Assert.True(result);|Assert.Empty(warnings);|Assert.Equal(-1, configuration.MaxParallelThreadsOrDefault);|}"
      }
    ]
  },
  {
    "file": "TestClassCallbackHandlerTests.cs",
    "methods": [
      {
        "name": "WithClassNode_ParsesNumbersWithInvariantCulture",
        "body": "{|var handler = new TestClassCallbackHandler([], Substitute.For<IMessageSink>());|var xml = new XmlDocument();|xml.LoadXml(\"<class time='1.234' total='4' failed='3' skipped='2' />\");|handler.OnXmlNode(xml.FirstChild);|Assert.Equal(1.234M, handler.TestClassResults.Time);|Assert.Equal(4, handler.TestClassResults.Total);|Assert.Equal(3, handler.TestClassResults.Failed);|Assert.Equal(2, handler.TestClassResults.Skipped);|}"
      },
      {
        "name": "WithTestNode_ParsesNumberWithInvariantCulture",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var sink = SpyMessageSink.Create(messages: messages);|var testCase = CreateTestCase(\"assembly\", \"config\", \"foo\", \"bar\", \"foo.bar\");|var handler = new TestClassCallbackHandler([testCase], sink);|var startXml = new XmlDocument();|startXml.LoadXml(\"<start type='foo' method='bar' name='foo.bar'></start>\");|var passXml = new XmlDocument();|passXml.LoadXml(\"<test type='foo' method='bar' name='foo.bar' time='1.234' result='Pass' />\");|handler.OnXmlNode(startXml.FirstChild);|handler.OnXmlNode(passXml.FirstChild);|var message = Assert.Single(messages.OfType<ITestFinished>());|Assert.Equal(1.234M, message.ExecutionTime);|}"
      },
      {
        "name": "WithTestNode_OutputResultsInOutputMessage",
        "body": "{|var messages = new List<IMessageSinkMessage>();|var sink = SpyMessageSink.Create(messages: messages);|var testCase = CreateTestCase(\"assembly\", \"config\", \"foo\", \"bar\", \"foo.bar\");|var handler = new TestClassCallbackHandler([testCase], sink);|var startXml = new XmlDocument();|startXml.LoadXml(\"<start type='foo' method='bar' name='foo.bar'></start>\");|var passXml = new XmlDocument();|passXml.LoadXml(\"<test type='foo' method='bar' name='foo.bar' time='1.234' result='Pass'><output>This is output text</output></test>\");|handler.OnXmlNode(startXml.FirstChild);|handler.OnXmlNode(passXml.FirstChild);|var message = Assert.Single(messages.OfType<ITestOutput>());|Assert.Equal(\"This is output text\", message.Output);|}"
      }
    ]
  },
  {
    "file": "Xunit1ExceptionUtilityTests.cs",
    "methods": [
      {
        "name": "CanParseEmbeddedExceptions",
        "body": "{|try|{|try|{|throw new DivideByZeroException();|}|catch (Exception ex)|{|throw new Exception(\"failure\", ex);|}|}|catch (Exception ex)|{|var (exceptionTypes, messages, stackTraces, exceptionParentIndices) = Xunit1ExceptionUtility.ConvertToErrorMetadata(ex);|Assert.Collection(|exceptionTypes,|type => Assert.Equal(\"System.Exception\", type),|type => Assert.Equal(\"System.DivideByZeroException\", type)|);|Assert.Collection(|messages,|msg => Assert.Equal(\"failure\", msg),|msg => Assert.Equal(\"Attempted to divide by zero.\", msg)|);|Assert.Collection(|stackTraces,|stack => Assert.Contains(\"Xunit1ExceptionUtilityTests.CanParseEmbeddedExceptions\", stack),|stack => Assert.Contains(\"Xunit1ExceptionUtilityTests.CanParseEmbeddedExceptions\", stack)|);|Assert.Collection(|exceptionParentIndices,|index => Assert.Equal(-1, index),|index => Assert.Equal(0, index)|);|}|}"
      }
    ]
  },
  {
    "file": "Xunit1TestCaseTests.cs",
    "methods": [
      {
        "name": "CanRoundTrip_PublicClass_PublicTestMethod",
        "body": "{|var testCase = Create(typeof(Serialization), nameof(CanRoundTrip_PublicClass_PublicTestMethod));|var serialized = SerializationHelper.Instance.Serialize(testCase);|var deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);|Assert.NotNull(deserialized);|}"
      },
      {
        "name": "CanRoundTrip_PublicClass_PrivateTestMethod",
        "body": "{|var testCase = Create(typeof(Serialization), nameof(PrivateTestMethod));|var serialized = SerializationHelper.Instance.Serialize(testCase);|var deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);|Assert.NotNull(deserialized);|}"
      },
      {
        "name": "CanRoundTrip_PrivateClass",
        "body": "{|var testCase = Create(typeof(PrivateClass), nameof(PrivateClass.TestMethod));|var serialized = SerializationHelper.Instance.Serialize(testCase);|var deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);|Assert.NotNull(deserialized);|}"
      },
      {
        "name": "CanSerializeTraits_StayCaseInsensitive",
        "body": "{|var traits = new Dictionary<string, IReadOnlyCollection<string>>|{|{ \"foo\", new List<string> { \"bar\", \"baz\" } },|{ \"biff\", new List<string> { \"Hello, world!\" } }|};|var testCase = Create(typeof(Serialization), nameof(CanRoundTrip_PublicClass_PublicTestMethod), traits: traits);|var serialized = SerializationHelper.Instance.Serialize(testCase);|var deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);|Assert.NotNull(deserialized);|Assert.NotNull(deserialized.Traits);|Assert.Collection(|deserialized.Traits[\"FOO\"],|bar => Assert.Equal(\"bar\", bar),|baz => Assert.Equal(\"baz\", baz)|);|var helloWorld = Assert.Single(deserialized.Traits[\"biff\"]);|Assert.Equal(\"Hello, world!\", helloWorld);|}"
      },
      {
        "name": "PrivateTestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{|Assert.True(false);|}"
      },
      {
        "name": "TraitNamesAreCaseInsensitive_PreSeeded",
        "body": "{|var traits = new Dictionary<string, IReadOnlyCollection<string>> { { \"FOO\", new List<string> { \"BAR\" } } };|var testCase = Create(typeof(Traits), \"TraitNamesAreCaseInsensitive_PreSeeded\", traits: traits);|var fooTraitValues = testCase.Traits[\"foo\"];|var fooTraitValue = Assert.Single(fooTraitValues);|Assert.Equal(\"BAR\", fooTraitValue);|}"
      }
    ]
  },
  {
    "file": "Xunit2AcceptanceTests.cs",
    "methods": [
      {
        "name": "NoTests",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(NoTestsClass));|Assert.Collection(results,|message => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),|message =>|{|var finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);|Assert.Equal(0, finished.TestsRun);|Assert.Equal(0, finished.TestsFailed);|Assert.Equal(0, finished.TestsSkipped);|}|);|}"
      },
      {
        "name": "SinglePassingTest",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(SinglePassingTestClass));|Assert.Collection(results,|message => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),|message =>|{|var collectionStarting = Assert.IsAssignableFrom<ITestCollectionStarting>(message);|Assert.NotNull(collectionStarting.TestCollection);|// TODO: There will need to be more tests here eventually...|},|message =>|{|var classStarting = Assert.IsAssignableFrom<ITestClassStarting>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", classStarting.TestClass.Class.Name);|},|message =>|{|var testMethodStarting = Assert.IsAssignableFrom<ITestMethodStarting>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodStarting.TestClass.Class.Name);|Assert.Equal(\"TestMethod\", testMethodStarting.TestMethod.Method.Name);|},|message =>|{|var testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass.TestMethod\", testCaseStarting.TestCase.DisplayName);|},|message =>|{|var starting = Assert.IsAssignableFrom<ITestStarting>(message);|Assert.Equal(starting.TestCase.DisplayName, starting.Test.DisplayName);|},|message =>|{|var classConstructionStarting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(message);|Assert.Equal(classConstructionStarting.TestCase.DisplayName, classConstructionStarting.Test.DisplayName);|},|message =>|{|var classConstructionFinished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(message);|Assert.Equal(classConstructionFinished.TestCase.DisplayName, classConstructionFinished.Test.DisplayName);|},|message =>|{|var testPassed = Assert.IsAssignableFrom<ITestPassed>(message);|Assert.Equal(testPassed.TestCase.DisplayName, testPassed.Test.DisplayName);|Assert.NotEqual(0M, testPassed.ExecutionTime);|},|message =>|{|var testFinished = Assert.IsAssignableFrom<ITestFinished>(message);|Assert.Equal(testFinished.TestCase.DisplayName, testFinished.Test.DisplayName);|},|message =>|{|var testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(message);|Assert.Equal(1, testCaseFinished.TestsRun);|Assert.Equal(0, testCaseFinished.TestsFailed);|Assert.Equal(0, testCaseFinished.TestsSkipped);|Assert.NotEqual(0M, testCaseFinished.ExecutionTime);|},|message =>|{|var testMethodFinished = Assert.IsAssignableFrom<ITestMethodFinished>(message);|Assert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodFinished.TestClass.Class.Name);|Assert.Equal(\"TestMethod\", testMethodFinished.TestMethod.Method.Name);|},|message =>|{|var classFinished = Assert.IsAssignableFrom<ITestClassFinished>(message);|Assert.Equal(1, classFinished.TestsRun);|Assert.Equal(0, classFinished.TestsFailed);|Assert.Equal(0, classFinished.TestsSkipped);|Assert.NotEqual(0M, classFinished.ExecutionTime);|},|message =>|{|var collectionFinished = Assert.IsAssignableFrom<ITestCollectionFinished>(message);|Assert.NotNull(collectionFinished.TestCollection);|Assert.Equal(1, collectionFinished.TestsRun);|Assert.Equal(0, collectionFinished.TestsFailed);|Assert.Equal(0, collectionFinished.TestsSkipped);|Assert.NotEqual(0M, collectionFinished.ExecutionTime);|// TODO: There will need to be more tests here eventually...|},|message =>|{|var assemblyFinished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);|Assert.Equal(1, assemblyFinished.TestsRun);|Assert.Equal(0, assemblyFinished.TestsFailed);|Assert.Equal(0, assemblyFinished.TestsSkipped);|Assert.NotEqual(0M, assemblyFinished.ExecutionTime);|}|);|}"
      },
      {
        "name": "SingleSkippedTest",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(SingleSkippedTestClass));|var skippedMessage = Assert.Single(results.OfType<ITestSkipped>());|Assert.Equal(\"Xunit2AcceptanceTests+SingleSkippedTestClass.TestMethod\", skippedMessage.Test.DisplayName);|Assert.Equal(\"This is a skipped test\", skippedMessage.Reason);|var classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());|Assert.Equal(1, classFinishedMessage.TestsSkipped);|var collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());|Assert.Equal(1, collectionFinishedMessage.TestsSkipped);|}"
      },
      {
        "name": "TimedOutTest",
        "body": "{|var stopwatch = Stopwatch.StartNew();|var results = Run(typeof(ClassUnderTest));|stopwatch.Stop();|var passedMessage = Assert.Single(results.OfType<ITestPassed>());|Assert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.ShortRunningTest\", passedMessage.Test.DisplayName);|var failedMessage = Assert.Single(results.OfType<ITestFailed>());|Assert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.LongRunningTest\", failedMessage.Test.DisplayName);|Assert.Equal(\"Test execution timed out after 10 milliseconds\", failedMessage.Messages.Single());|Assert.True(stopwatch.ElapsedMilliseconds < 10000, \"Elapsed time should be less than 10 seconds\");|}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "TestWithUnstartedTaskThrows",
        "body": "{|var stopwatch = Stopwatch.StartNew();|var results = Run(typeof(ClassUnderTest));|stopwatch.Stop();|var failedMessage = Assert.Single(results.OfType<ITestFailed>());|Assert.Equal(\"Xunit2AcceptanceTests+NonStartedTasks+ClassUnderTest.NonStartedTask\", failedMessage.Test.DisplayName);|Assert.Equal(\"Test method returned a non-started Task (tasks must be started before being returned)\", failedMessage.Messages.Single());|}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "SingleFailingTest",
        "body": "{|List<IMessageSinkMessage> results = Run(typeof(SingleFailingTestClass));|var failedMessage = Assert.Single(results.OfType<ITestFailed>());|Assert.Equal(typeof(TrueException).FullName, failedMessage.ExceptionTypes.Single());|var classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());|Assert.Equal(1, classFinishedMessage.TestsFailed);|var collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());|Assert.Equal(1, collectionFinishedMessage.TestsFailed);|}"
      },
      {
        "name": "TestFailureResultsFromThrowingCtorInTestClass",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassUnderTest_CtorFailure));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "TestFailureResultsFromThrowingDisposeInTestClass",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassUnderTest_DisposeFailure));|var msg = Assert.Single(messages);|Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());|}"
      },
      {
        "name": "CompositeTestFailureResultsFromFailingTestsPlusThrowingDisposeInTestClass",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassUnderTest_FailingTestAndDisposeFailure));|var msg = Assert.Single(messages);|var combinedMessage = Xunit.ExceptionUtility.CombineMessages(msg);|Assert.StartsWith(\"System.AggregateException : \", combinedMessage);|Assert.Contains(|\"---- Assert.Equal() Failure: Values differ\" + Environment.NewLine +|\"Expected: 2\" + Environment.NewLine +|\"Actual: 3\" + Environment.NewLine +|\"---- System.DivideByZeroException : \",|combinedMessage);|}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{|Assert.Equal(2, 3);|}"
      },
      {
        "name": "TestsCanBeInStaticClasses",
        "body": "{|var testMessages = Run<ITestResultMessage>(typeof(StaticClassUnderTest));|var testMessage = Assert.Single(testMessages);|Assert.Equal(\"Xunit2AcceptanceTests+StaticClassSupport+StaticClassUnderTest.Passing\", testMessage.Test.DisplayName);|Assert.IsAssignableFrom<ITestPassed>(testMessage);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "EachTestMethodHasIndividualExceptionMessage",
        "body": "{|var testMessages = Run<ITestFailed>(typeof(ClassUnderTest));|var equalFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.EqualFailure\");|Assert.Contains(\"Assert.Equal() Failure\", equalFailure.Messages.Single());|var notNullFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.NotNullFailure\");|Assert.Contains(\"Assert.NotNull() Failure\", notNullFailure.Messages.Single());|}"
      },
      {
        "name": "EqualFailure",
        "body": "{|Assert.Equal(42, 40);|}"
      },
      {
        "name": "NotNullFailure",
        "body": "{|Assert.NotNull(null);|}"
      },
      {
        "name": "OverrideOfOrderingAtCollectionLevel",
        "body": "{|var testMessages = Run<ITestPassed>(typeof(TestClassUsingCollection));|Assert.Collection(testMessages,|message => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)|);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "OverrideOfOrderingAtClassLevel",
        "body": "{|var testMessages = Run<ITestPassed>(typeof(TestClassWithoutCollection));|Assert.Collection(testMessages,|message => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)|);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "NonParallelCollectionsRunLast",
        "body": "{|var testMessages = Run<ITestPassed>(new[] {|typeof(TestClassNonParallelCollection),|typeof(TestClassParallelCollection)|});|Assert.Collection(testMessages,|message => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"IShouldBeLast1\", message.TestCase.TestMethod.Method.Name),|message => Assert.Equal(\"IShouldBeLast2\", message.TestCase.TestMethod.Method.Name)|);|}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast1",
        "body": "{ }"
      },
      {
        "name": "CanUseCustomFactAttribute",
        "body": "{|var msgs = Run<ITestPassed>(typeof(ClassWithCustomFact));|var msg = Assert.Single(msgs);|Assert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomFact.Passing\", msg.Test.DisplayName);|}"
      },
      {
        "name": "CanUseCustomFactWithArrayParameters",
        "body": "{|var msgs = Run<ITestPassed>(typeof(ClassWithCustomArrayFact));|var msg = Assert.Single(msgs);|Assert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomArrayFact.Passing\", msg.Test.DisplayName);|}"
      },
      {
        "name": "CannotMixMultipleFactDerivedAttributes",
        "body": "{|var msgs = Run<ITestFailed>(typeof(ClassWithMultipleFacts)).ToList();|Assert.Collection(msgs,|msg =>|{|Assert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing\", msg.Test.DisplayName);|Assert.Equal(\"System.InvalidOperationException\", msg.ExceptionTypes.Single());|Assert.Equal(\"Test method 'Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing' has multiple [Fact]-derived attributes\", msg.Messages.Single());|}|);|}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "SendOutputMessages",
        "body": "{|var msgs = Run(typeof(ClassUnderTest));|var idxOfTestPassed = msgs.FindIndex(msg => msg is ITestPassed);|Assert.True(idxOfTestPassed >= 0, \"Test should have passed\");|var idxOfFirstTestOutput = msgs.FindIndex(msg => msg is ITestOutput);|Assert.True(idxOfFirstTestOutput >= 0, \"Test should have output\");|Assert.True(idxOfFirstTestOutput < idxOfTestPassed, \"Test output messages should precede test result\");|Assert.Collection(msgs.OfType<ITestOutput>(),|msg =>|{|var outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);|Assert.Equal(\"This is output in the constructor\" + Environment.NewLine, outputMessage.Output);|},|msg =>|{|var outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);|Assert.Equal(\"This is test output\" + Environment.NewLine, outputMessage.Output);|},|msg =>|{|var outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);|Assert.Equal(\"This is output in Dispose\" + Environment.NewLine, outputMessage.Output);|}|);|}"
      },
      {
        "name": "TestMethod",
        "body": "{|output.WriteLine(\"This is test output\");|}"
      },
      {
        "name": "AsyncLifetimeAcceptanceTest",
        "body": "{|var messages = Run<ITestPassed>(typeof(ClassWithAsyncLifetime));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");|}"
      },
      {
        "name": "TheTest",
        "body": "{|output.WriteLine(\"Run Test\");|}"
      },
      {
        "name": "ThrowingConstructor",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingCtor));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\");|}"
      },
      {
        "name": "ThrowingInitializeAsync",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingInitializeAsync));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Dispose\");|}"
      },
      {
        "name": "ThrowingDisposeAsync",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingDisposeAsync));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");|}"
      },
      {
        "name": "FailingTest",
        "body": "{|var messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_FailingTest));|var message = Assert.Single(messages);|AssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");|}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{|Assert.True(false);|}"
      },
      {
        "name": "TestMethod",
        "body": "{|Assert.True(false);|}"
      }
    ]
  },
  {
    "file": "Xunit2MessageAdapterTests.cs",
    "methods": [
      {
        "name": "AfterTestFinished",
        "body": "{|var v2Message = Xunit2Mocks.AfterTestFinished(Test, BeforeAfterAttributeName);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IAfterTestFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "AfterTestStarting",
        "body": "{|var v2Message = Xunit2Mocks.AfterTestStarting(Test, BeforeAfterAttributeName);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IAfterTestStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "BeforeTestFinished",
        "body": "{|var v2Message = Xunit2Mocks.BeforeTestFinished(Test, BeforeAfterAttributeName);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IBeforeTestFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "BeforeTestStarting",
        "body": "{|var v2Message = Xunit2Mocks.BeforeTestStarting(Test, BeforeAfterAttributeName);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IBeforeTestStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "DiagnosticMessage",
        "body": "{|var v2Message = Xunit2Mocks.DiagnosticMessage(\"Hello, world!\");|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IDiagnosticMessage>(adapted);|Assert.Equal(\"Hello, world!\", v3Message.Message);|}"
      },
      {
        "name": "TestCaseDiscoveryMessage",
        "body": "{|var v2Message = Xunit2Mocks.TestCaseDiscoveryMessage(TestCase);|var discoverer = Substitute.For<ITestFrameworkDiscoverer>();|discoverer.Serialize(TestCase).Returns(\"abc123\");|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID, discoverer);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseDiscovered>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(\"abc123\", v3Message.Serialization);|Assert.Equal(\"skip-reason\", v3Message.SkipReason);|Assert.Equal(\"source-file\", v3Message.SourceFilePath);|Assert.Equal(2112, v3Message.SourceLineNumber);|Assert.Equal(\"test-case-display-name\", v3Message.TestCaseDisplayName);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Collection(|v3Message.Traits.OrderBy(kvp => kvp.Key),|trait =>|{|Assert.Equal(\"key1\", trait.Key);|Assert.Equal([\"value1a\", \"value1b\"], trait.Value);|},|trait =>|{|Assert.Equal(\"key2\", trait.Key);|Assert.Equal([\"value2\"], trait.Value);|},|trait =>|{|Assert.Equal(\"key3\", trait.Key);|Assert.Empty(trait.Value);|}|);|}"
      },
      {
        "name": "ErrorMessage",
        "body": "{|var v2Message = Xunit2Mocks.ErrorMessage(ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IErrorMessage>(adapted);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestAssemblyCleanupFailure",
        "body": "{|var v2Message = Xunit2Mocks.TestAssemblyCleanupFailure(TestAssembly, ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestAssemblyCleanupFailure>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestAssemblyFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestAssemblyFinished(|TestAssembly,|testsRun: 2112,|testsFailed: 42,|testsSkipped: 6,|executionTime: 123.4567m|);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestAssemblyFinished>(adapted);|Assert.NotEmpty(v3Message.AssemblyUniqueID);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(42, v3Message.TestsFailed);|Assert.Equal(0, v3Message.TestsNotRun);|Assert.Equal(6, v3Message.TestsSkipped);|Assert.Equal(2112, v3Message.TestsTotal);|}"
      },
      {
        "name": "TestAssemblyStarting",
        "body": "{|var assemblyPath =|RuntimeInformation.IsOSPlatform(OSPlatform.Windows)|? @\"C:\\Users\\bradwilson\\assembly.dll\"|: \"/home/bradwilson/assembly.dll\";|var configFilePath =|RuntimeInformation.IsOSPlatform(OSPlatform.Windows)|? @\"C:\\Users\\bradwilson\\xunit.runner.json\"|: \"/home/bradwilson/xunit.runner.json\";|var testAssembly = Xunit2Mocks.TestAssembly(assemblyPath, configFilePath, \"target-framework\");|var v2Message = Xunit2Mocks.TestAssemblyStarting(|testAssembly,|new DateTime(2020, 11, 3, 17, 55, 0, DateTimeKind.Utc),|\"test-environment\",|\"test-framework\"|);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestAssemblyStarting>(adapted);|Assert.Equal(Path.GetFileNameWithoutExtension(assemblyPath), v3Message.AssemblyName);|Assert.Equal(assemblyPath, v3Message.AssemblyPath);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(configFilePath, v3Message.ConfigFilePath);|Assert.Equal(new DateTimeOffset(2020, 11, 3, 17, 55, 0, TimeSpan.Zero), v3Message.StartTime);|Assert.Equal(\"target-framework\", v3Message.TargetFramework);|Assert.Equal(\"test-environment\", v3Message.TestEnvironment);|Assert.Equal(\"test-framework\", v3Message.TestFrameworkDisplayName);|}"
      },
      {
        "name": "TestCaseCleanupFailure",
        "body": "{|var v2Message = Xunit2Mocks.TestCaseCleanupFailure(TestCase, ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseCleanupFailure>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestCaseFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestCaseFinished(|TestCase,|testsRun: 2112,|testsFailed: 42,|testsSkipped: 404,|executionTime: 123.4567m|);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(42, v3Message.TestsFailed);|Assert.Equal(0, v3Message.TestsNotRun);|Assert.Equal(404, v3Message.TestsSkipped);|Assert.Equal(2112, v3Message.TestsTotal);|}"
      },
      {
        "name": "TestCaseStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestCaseStarting(TestCase);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(\"skip-reason\", v3Message.SkipReason);|Assert.Equal(\"source-file\", v3Message.SourceFilePath);|Assert.Equal(2112, v3Message.SourceLineNumber);|Assert.Equal(\"test-case-display-name\", v3Message.TestCaseDisplayName);|Assert.Equal(\"test-case-id\", v3Message.TestCaseUniqueID);|Assert.Equal(\"TestNamespace.TestClass+EmbeddedClass\", v3Message.TestClassName);|Assert.Equal(\"TestNamespace\", v3Message.TestClassNamespace);|Assert.Equal(\"TestClass+EmbeddedClass\", v3Message.TestClassSimpleName);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(\"MyTestMethod\", v3Message.TestMethodName);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Collection(|v3Message.Traits.OrderBy(kvp => kvp.Key),|trait =>|{|Assert.Equal(\"key1\", trait.Key);|Assert.Equal([\"value1a\", \"value1b\"], trait.Value);|},|trait =>|{|Assert.Equal(\"key2\", trait.Key);|Assert.Equal([\"value2\"], trait.Value);|},|trait =>|{|Assert.Equal(\"key3\", trait.Key);|Assert.Empty(trait.Value);|}|);|}"
      },
      {
        "name": "TestClassCleanupFailure",
        "body": "{|var v2Message = Xunit2Mocks.TestClassCleanupFailure(TestClass, ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassCleanupFailure>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestClassFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestClassFinished(|TestClass,|testsRun: 2112,|testsFailed: 42,|testsSkipped: 404,|executionTime: 123.4567m|);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(42, v3Message.TestsFailed);|Assert.Equal(0, v3Message.TestsNotRun);|Assert.Equal(404, v3Message.TestsSkipped);|Assert.Equal(2112, v3Message.TestsTotal);|}"
      },
      {
        "name": "TestClassStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestClassStarting(TestClass);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(v2Message.TestClass.Class.Name, v3Message.TestClassName);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|}"
      },
      {
        "name": "TestCollectionCleanupFailure",
        "body": "{|var v2Message = Xunit2Mocks.TestCollectionCleanupFailure(TestCollection, ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCollectionCleanupFailure>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestCollectionFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestCollectionFinished(|TestCollection,|testsRun: 2112,|testsFailed: 42,|testsSkipped: 404,|executionTime: 123.4567m|);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCollectionFinished>(adapted);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(42, v3Message.TestsFailed);|Assert.Equal(0, v3Message.TestsNotRun);|Assert.Equal(404, v3Message.TestsSkipped);|Assert.Equal(2112, v3Message.TestsTotal);|}"
      },
      {
        "name": "TestCollectionStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestCollectionStarting(TestCollection);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCollectionStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCollectionDefinition.Name, v3Message.TestCollectionClassName);|Assert.Equal(TestCollection.DisplayName, v3Message.TestCollectionDisplayName);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|}"
      },
      {
        "name": "TestMethodCleanupFailure",
        "body": "{|var v2Message = Xunit2Mocks.TestMethodCleanupFailure(TestMethod, ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestMethodCleanupFailure>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestMethodFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestMethodFinished(|TestMethod,|testsRun: 2112,|testsFailed: 42,|testsSkipped: 404,|executionTime: 123.4567m|);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestMethodFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(42, v3Message.TestsFailed);|Assert.Equal(0, v3Message.TestsNotRun);|Assert.Equal(404, v3Message.TestsSkipped);|Assert.Equal(2112, v3Message.TestsTotal);|}"
      },
      {
        "name": "TestMethodStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestMethodStarting(TestMethod);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestMethodStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethod.Method.Name, v3Message.MethodName);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|}"
      },
      {
        "name": "TestClassConstructionFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestClassConstructionFinished(Test);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassConstructionFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestClassConstructionStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestClassConstructionStarting(Test);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassConstructionStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestClassDisposeFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestClassDisposeFinished(Test);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassDisposeFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestClassDisposeStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestClassDisposeStarting(Test);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassDisposeStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestCleanupFailure",
        "body": "{|var v2Message = Xunit2Mocks.TestCleanupFailure(Test, ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCleanupFailure>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestFinished",
        "body": "{|var v2Message = Xunit2Mocks.TestFinished(Test, 123.4567m, \"abc123\");|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestFinished>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(\"abc123\", v3Message.Output);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestFailed",
        "body": "{|var v2Message = Xunit2Mocks.TestFailed(Test, 123.4567m, \"abc123\", ThrownException);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestFailed>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(FailureCause.Assertion, v3Message.Cause);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(\"abc123\", v3Message.Output);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|AssertErrorMetadata(v3Message, ThrownException);|}"
      },
      {
        "name": "TestOutput",
        "body": "{|var v2Message = Xunit2Mocks.TestOutput(Test, \"this is my test output\");|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestOutput>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(\"this is my test output\", v3Message.Output);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestPassed",
        "body": "{|var v2Message = Xunit2Mocks.TestPassed(Test, 123.4567m, \"abc123\");|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestPassed>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(123.4567m, v3Message.ExecutionTime);|Assert.Equal(\"abc123\", v3Message.Output);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestSkipped",
        "body": "{|var v2Message = Xunit2Mocks.TestSkipped(Test, \"I am not running\");|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestSkipped>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(0m, v3Message.ExecutionTime); // Statically skipped tests always take no runtime|Assert.Empty(v3Message.Output);|Assert.Equal(\"I am not running\", v3Message.Reason);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      },
      {
        "name": "TestStarting",
        "body": "{|var v2Message = Xunit2Mocks.TestStarting(Test);|var v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);|var adapted = v2Adapter.Adapt(v2Message);|var v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestStarting>(adapted);|Assert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);|Assert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);|Assert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);|Assert.Equal(\"test-display-name\", v3Message.TestDisplayName);|Assert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);|Assert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);|Assert.Equal(TestUniqueID, v3Message.TestUniqueID);|}"
      }
    ]
  },
  {
    "file": "Xunit3ArgumentFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultOptions",
        "body": "{|var options = TestData.TestFrameworkDiscoveryOptions();|var arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options);|var arg = Assert.Single(arguments);|Assert.Equal(\"-automated\", arg);|}"
      },
      {
        "name": "DoesNotSendSyncParameterToAutomatedForOlderTestProjects",
        "body": "{|var options = TestData.TestFrameworkDiscoveryOptions(synchronousMessageReporting: true);|var arguments = Xunit3ArgumentFactory.ForFind(Version_0_2_999, options);|var argument = Assert.Single(arguments);|Assert.Equal(\"-automated\", argument);|}"
      },
      {
        "name": "AddConfigFile",
        "body": "{|var options = TestData.TestFrameworkDiscoveryOptions();|var arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options, configFileName: \"/config/file/name.json\");|Assert.Collection(|arguments,|arg => Assert.Equal(\"/config/file/name.json\", arg),|arg => Assert.Equal(\"-automated\", arg)|);|}"
      },
      {
        "name": "AddFilters",
        "body": "{|var options = TestData.TestFrameworkDiscoveryOptions();|var filters = new XunitFilters();|filters.AddIncludedClassFilter(\"class1\");|filters.AddIncludedClassFilter(\"class2\");|filters.AddExcludedClassFilter(\"class3\");|filters.AddExcludedClassFilter(\"class4\");|filters.AddIncludedMethodFilter(\"method1\");|filters.AddIncludedMethodFilter(\"method2\");|filters.AddExcludedMethodFilter(\"method3\");|filters.AddExcludedMethodFilter(\"method4\");|filters.AddIncludedNamespaceFilter(\"namespace1\");|filters.AddIncludedNamespaceFilter(\"namespace2\");|filters.AddExcludedNamespaceFilter(\"namespace3\");|filters.AddExcludedNamespaceFilter(\"namespace4\");|filters.AddIncludedTraitFilter(\"trait1\", \"value1a\");|filters.AddIncludedTraitFilter(\"trait1\", \"value1b\");|filters.AddIncludedTraitFilter(\"trait2\", \"value2a\");|filters.AddIncludedTraitFilter(\"trait2\", \"value2b\");|filters.AddExcludedTraitFilter(\"trait3\", \"value3a\");|filters.AddExcludedTraitFilter(\"trait3\", \"value3b\");|filters.AddExcludedTraitFilter(\"trait4\", \"value4a\");|filters.AddExcludedTraitFilter(\"trait4\", \"value4b\");|var arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options, filters: filters);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-class\", arg),|arg => Assert.Equal(\"class1\", arg),|arg => Assert.Equal(\"-class\", arg),|arg => Assert.Equal(\"class2\", arg),|arg => Assert.Equal(\"-class-\", arg),|arg => Assert.Equal(\"class3\", arg),|arg => Assert.Equal(\"-class-\", arg),|arg => Assert.Equal(\"class4\", arg),|arg => Assert.Equal(\"-method\", arg),|arg => Assert.Equal(\"method1\", arg),|arg => Assert.Equal(\"-method\", arg),|arg => Assert.Equal(\"method2\", arg),|arg => Assert.Equal(\"-method-\", arg),|arg => Assert.Equal(\"method3\", arg),|arg => Assert.Equal(\"-method-\", arg),|arg => Assert.Equal(\"method4\", arg),|arg => Assert.Equal(\"-namespace\", arg),|arg => Assert.Equal(\"namespace1\", arg),|arg => Assert.Equal(\"-namespace\", arg),|arg => Assert.Equal(\"namespace2\", arg),|arg => Assert.Equal(\"-namespace-\", arg),|arg => Assert.Equal(\"namespace3\", arg),|arg => Assert.Equal(\"-namespace-\", arg),|arg => Assert.Equal(\"namespace4\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait1=value1a\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait1=value1b\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait2=value2a\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait2=value2b\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait3=value3a\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait3=value3b\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait4=value4a\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait4=value4b\", arg)|);|}"
      },
      {
        "name": "AddWaitForDebugger",
        "body": "{|var options = TestData.TestFrameworkDiscoveryOptions();|var arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options, waitForDebugger: true);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-waitForDebugger\", arg)|);|}"
      },
      {
        "name": "DefaultOptions",
        "body": "{|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions();|var executionOptions = TestData.TestFrameworkExecutionOptions();|var arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions);|var arg = Assert.Single(arguments);|Assert.Equal(\"-automated\", arg);|}"
      },
      {
        "name": "AddConfigFile",
        "body": "{|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions();|var executionOptions = TestData.TestFrameworkExecutionOptions();|var arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions, configFileName: \"/config/file/name.json\");|Assert.Collection(|arguments,|arg => Assert.Equal(\"/config/file/name.json\", arg),|arg => Assert.Equal(\"-automated\", arg)|);|}"
      },
      {
        "name": "AddFilters",
        "body": "{|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions();|var executionOptions = TestData.TestFrameworkExecutionOptions();|var filters = new XunitFilters();|filters.AddIncludedClassFilter(\"class1\");|filters.AddIncludedClassFilter(\"class2\");|filters.AddExcludedClassFilter(\"class3\");|filters.AddExcludedClassFilter(\"class4\");|filters.AddIncludedMethodFilter(\"method1\");|filters.AddIncludedMethodFilter(\"method2\");|filters.AddExcludedMethodFilter(\"method3\");|filters.AddExcludedMethodFilter(\"method4\");|filters.AddIncludedNamespaceFilter(\"namespace1\");|filters.AddIncludedNamespaceFilter(\"namespace2\");|filters.AddExcludedNamespaceFilter(\"namespace3\");|filters.AddExcludedNamespaceFilter(\"namespace4\");|filters.AddIncludedTraitFilter(\"trait1\", \"value1a\");|filters.AddIncludedTraitFilter(\"trait1\", \"value1b\");|filters.AddIncludedTraitFilter(\"trait2\", \"value2a\");|filters.AddIncludedTraitFilter(\"trait2\", \"value2b\");|filters.AddExcludedTraitFilter(\"trait3\", \"value3a\");|filters.AddExcludedTraitFilter(\"trait3\", \"value3b\");|filters.AddExcludedTraitFilter(\"trait4\", \"value4a\");|filters.AddExcludedTraitFilter(\"trait4\", \"value4b\");|var arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions, filters: filters);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-class\", arg),|arg => Assert.Equal(\"class1\", arg),|arg => Assert.Equal(\"-class\", arg),|arg => Assert.Equal(\"class2\", arg),|arg => Assert.Equal(\"-class-\", arg),|arg => Assert.Equal(\"class3\", arg),|arg => Assert.Equal(\"-class-\", arg),|arg => Assert.Equal(\"class4\", arg),|arg => Assert.Equal(\"-method\", arg),|arg => Assert.Equal(\"method1\", arg),|arg => Assert.Equal(\"-method\", arg),|arg => Assert.Equal(\"method2\", arg),|arg => Assert.Equal(\"-method-\", arg),|arg => Assert.Equal(\"method3\", arg),|arg => Assert.Equal(\"-method-\", arg),|arg => Assert.Equal(\"method4\", arg),|arg => Assert.Equal(\"-namespace\", arg),|arg => Assert.Equal(\"namespace1\", arg),|arg => Assert.Equal(\"-namespace\", arg),|arg => Assert.Equal(\"namespace2\", arg),|arg => Assert.Equal(\"-namespace-\", arg),|arg => Assert.Equal(\"namespace3\", arg),|arg => Assert.Equal(\"-namespace-\", arg),|arg => Assert.Equal(\"namespace4\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait1=value1a\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait1=value1b\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait2=value2a\", arg),|arg => Assert.Equal(\"-trait\", arg),|arg => Assert.Equal(\"trait2=value2b\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait3=value3a\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait3=value3b\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait4=value4a\", arg),|arg => Assert.Equal(\"-trait-\", arg),|arg => Assert.Equal(\"trait4=value4b\", arg)|);|}"
      },
      {
        "name": "AddWaitForDebugger",
        "body": "{|var discoveryOptions = TestData.TestFrameworkDiscoveryOptions();|var executionOptions = TestData.TestFrameworkExecutionOptions();|var arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions, waitForDebugger: true);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-waitForDebugger\", arg)|);|}"
      },
      {
        "name": "DefaultOptions",
        "body": "{|var options = TestData.TestFrameworkExecutionOptions();|var arguments = Xunit3ArgumentFactory.ForRun(Version_0_3_0, options, [\"abc\", \"123\"]);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-run\", arg),|arg => Assert.Equal(\"abc\", arg),|arg => Assert.Equal(\"-run\", arg),|arg => Assert.Equal(\"123\", arg)|);|}"
      },
      {
        "name": "DoesNotSendSyncParameterToAutomatedForOlderTestProjects",
        "body": "{|var options = TestData.TestFrameworkExecutionOptions(synchronousMessageReporting: true);|var arguments = Xunit3ArgumentFactory.ForRun(Version_0_2_999, options, [\"abc\"]);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-run\", arg),|arg => Assert.Equal(\"abc\", arg)|);|}"
      },
      {
        "name": "AddConfigFile",
        "body": "{|var options = TestData.TestFrameworkExecutionOptions();|var arguments = Xunit3ArgumentFactory.ForRun(Version_0_3_0, options, [\"abc\"], configFileName: \"/config/file/name.json\");|Assert.Collection(|arguments,|arg => Assert.Equal(\"/config/file/name.json\", arg),|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-run\", arg),|arg => Assert.Equal(\"abc\", arg)|);|}"
      },
      {
        "name": "AddWaitForDebugger",
        "body": "{|var options = TestData.TestFrameworkExecutionOptions();|var arguments = Xunit3ArgumentFactory.ForRun(Version_0_3_0, options, [\"abc\"], waitForDebugger: true);|Assert.Collection(|arguments,|arg => Assert.Equal(\"-automated\", arg),|arg => Assert.Equal(\"-run\", arg),|arg => Assert.Equal(\"abc\", arg),|arg => Assert.Equal(\"-waitForDebugger\", arg)|);|}"
      }
    ]
  },
  {
    "file": "Xunit3Tests.cs",
    "methods": [
      {
        "name": "GuardClauses_Ctor",
        "body": "{|Assert.Throws<ArgumentNullException>(\"projectAssembly\", () => Xunit3.ForDiscoveryAndExecution(null!));|var assembly = new XunitProjectAssembly(new XunitProject(), \"/this/file/does/not/exist.exe\", new(3, \".NETCoreApp,Version=v6.0\"));|var argEx = Assert.Throws<ArgumentException>(\"projectAssembly.AssemblyFileName\", () => Xunit3.ForDiscoveryAndExecution(assembly));|Assert.StartsWith(\"File not found: /this/file/does/not/exist.exe\", argEx.Message);|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await using var xunit3 = Xunit3.ForDiscoveryAndExecution(Assembly);|Assert.Throws<ArgumentNullException>(\"messageSink\", () => xunit3.Find(null!, new FrontControllerFindSettings(DiscoveryOptions)));|Assert.Throws<ArgumentNullException>(\"settings\", () => xunit3.Find(SpyMessageSink.Capture(), null!));|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await using var xunit3 = Xunit3.ForDiscoveryAndExecution(Assembly);|Assert.Throws<ArgumentNullException>(\"messageSink\", () => xunit3.FindAndRun(null!, new FrontControllerFindAndRunSettings(DiscoveryOptions, ExecutionOptions)));|Assert.Throws<ArgumentNullException>(\"settings\", () => xunit3.FindAndRun(SpyMessageSink.Capture(), null!));|}"
      },
      {
        "name": "ValueTask",
        "body": "{|await using var xunit3 = Xunit3.ForDiscoveryAndExecution(Assembly);|Assert.Throws<ArgumentNullException>(\"messageSink\", () => xunit3.Run(null!, new FrontControllerRunSettings(ExecutionOptions, [])));|Assert.Throws<ArgumentNullException>(\"settings\", () => xunit3.Run(SpyMessageSink.Capture(), null!));|}"
      }
    ]
  },
  {
    "file": "AssemblyUtilityTests.cs",
    "methods": [
      {
        "name": "GetAssemblyMetadata",
        "body": "{|var metadata = AssemblyUtility.GetAssemblyMetadata(typeof(AssemblyUtilityTests).Assembly.Location);|Assert.NotNull(metadata);|Assert.Equal(3, metadata.XunitVersion);|#if NET472|Assert.Equal(TargetFrameworkIdentifier.DotNetFramework, metadata.TargetFrameworkIdentifier);|Assert.Equal(new Version(4, 7, 2), metadata.TargetFrameworkVersion);|#elif NET6_0|Assert.Equal(TargetFrameworkIdentifier.DotNetCore, metadata.TargetFrameworkIdentifier);|Assert.Equal(new Version(6, 0), metadata.TargetFrameworkVersion);|#else|#error Unknown target framework|#endif|}"
      }
    ]
  },
  {
    "file": "ExceptionUtilityTests.cs",
    "methods": [
      {
        "name": "XunitException",
        "body": "{|var errorMetadata = new ErrorMetadata { new XunitException(\"This is the message\") };|var result = ExceptionUtility.CombineMessages(errorMetadata);|Assert.Equal(\"This is the message\", result);|}"
      },
      {
        "name": "NonXunitException",
        "body": "{|var errorMetadata = new ErrorMetadata { new Exception(\"This is the message\") };|var result = ExceptionUtility.CombineMessages(errorMetadata);|Assert.Equal(\"System.Exception : This is the message\", result);|}"
      },
      {
        "name": "NonXunitExceptionWithInnerExceptions",
        "body": "{|var errorMetadata = new ErrorMetadata {|{ new Exception(\"outer exception\"), -1 },|{ new DivideByZeroException(\"inner exception\"), 0 },|{ new XunitException(\"inner inner exception\"), 1 }|};|var result = ExceptionUtility.CombineMessages(errorMetadata);|Assert.Equal(|\"System.Exception : outer exception\" + Environment.NewLine +|\"---- System.DivideByZeroException : inner exception\" + Environment.NewLine +|\"-------- inner inner exception\",|result|);|}"
      },
      {
        "name": "AggregateException",
        "body": "{|var errorMetadata = new ErrorMetadata {|{ new AggregateException(), -1 },|{ new DivideByZeroException(\"inner #1\"), 0 },|{ new NotImplementedException(\"inner #2\"), 0 },|{ new XunitException(\"this is crazy\"), 0 },|};|var result = ExceptionUtility.CombineMessages(errorMetadata);|Assert.Equal(|\"System.AggregateException : One or more errors occurred.\" + Environment.NewLine +|\"---- System.DivideByZeroException : inner #1\" + Environment.NewLine +|\"---- System.NotImplementedException : inner #2\" + Environment.NewLine +|\"---- this is crazy\",|result|);|}"
      },
      {
        "name": "MissingExceptionTypes",
        "body": "{|var errorMetadata = new ErrorMetadata();|errorMetadata.AddMessage(\"Message 1\");|errorMetadata.AddMessage(\"Message 2\");|errorMetadata.AddMessage(\"Message 3\");|errorMetadata.AddIndex(-1);|errorMetadata.AddIndex(0);|errorMetadata.AddIndex(0);|errorMetadata.AddExceptionType(\"ExceptionType1\");|errorMetadata.AddExceptionType(\"Xunit.Sdk.ExceptionType2\");|var result = ExceptionUtility.CombineMessages(errorMetadata);|Assert.Equal(|\"ExceptionType1 : Message 1\" + Environment.NewLine +|\"---- Message 2\" + Environment.NewLine +|\"---- : Message 3\",|result|);|}"
      },
      {
        "name": "XunitException",
        "body": "{|#if DEBUG|Assert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");|#else|static void testCode()|{|throw new XunitException(\"Hello world\");|}|var ex = Record.Exception(testCode)!;|var errorMetadata = new ErrorMetadata { ex };|var result = ExceptionUtility.CombineStackTraces(errorMetadata);|Assert.DoesNotContain(typeof(Record).FullName!, result);|Assert.DoesNotContain(typeof(XunitException).FullName!, result);|Assert.Contains(\"XunitException\", result);|#endif|}"
      },
      {
        "name": "NonXunitException",
        "body": "{|#if DEBUG|Assert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");|#else|static void testCode()|{|throw new Exception();|}|var ex = Record.Exception(testCode)!;|var errorMetadata = new ErrorMetadata { ex };|var result = ExceptionUtility.CombineStackTraces(errorMetadata);|Assert.DoesNotContain(typeof(Record).FullName!, result);|Assert.DoesNotContain(typeof(XunitException).FullName!, result);|Assert.Contains(\"NonXunitException\", result);|#endif|}"
      },
      {
        "name": "NonXunitExceptionWithInnerExceptions",
        "body": "{|#if DEBUG|Assert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");|#else|static void innerTestCode()|{|throw new DivideByZeroException();|}|var inner = Record.Exception(innerTestCode)!;|void outerTestCode()|{|throw new Exception(\"message\", inner);|}|var outer = Record.Exception(outerTestCode)!;|var errorMetadata = new ErrorMetadata { { outer, -1 }, { inner, 0 } };|var result = ExceptionUtility.CombineStackTraces(errorMetadata);|Assert.NotNull(result);|Assert.Collection(|result.Split(new[] { Environment.NewLine }, StringSplitOptions.None),|line => Assert.Contains(\"NonXunitExceptionWithInnerExceptions\", line),|line => Assert.Equal(\"----- Inner Stack Trace -----\", line),|line => Assert.Contains(\"NonXunitExceptionWithInnerExceptions\", line)|);|#endif|}"
      },
      {
        "name": "HandlesAggregateException",
        "body": "{|#if DEBUG|Assert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");|#else|static void inner1TestCode()|{|throw new DivideByZeroException();|}|var inner1 = Record.Exception(inner1TestCode)!;|static void inner2TestCode()|{|throw new NotImplementedException(\"inner #2\");|}|var inner2 = Record.Exception(inner2TestCode)!;|static void inner3TestCode()|{|throw new XunitException(\"this is crazy\");|}|var inner3 = Record.Exception(inner3TestCode)!;|void outerTestCode()|{|throw new AggregateException(inner1, inner2, inner3);|}|var outer = Record.Exception(outerTestCode)!;|var errorMetadata = new ErrorMetadata { { outer, -1 }, { inner1, 0 }, { inner2, 0 }, { inner3, 0 } };|var result = ExceptionUtility.CombineStackTraces(errorMetadata);|Assert.NotNull(result);|Assert.Collection(|result.Split(new[] { Environment.NewLine }, StringSplitOptions.None),|line => Assert.Contains(\"HandlesAggregateException\", line),|line => Assert.Equal(\"----- Inner Stack Trace #1 (System.DivideByZeroException) -----\", line),|line => Assert.Contains(\"HandlesAggregateException\", line),|line => Assert.Equal(\"----- Inner Stack Trace #2 (System.NotImplementedException) -----\", line),|line => Assert.Contains(\"HandlesAggregateException\", line),|line => Assert.Equal(\"----- Inner Stack Trace #3 (Xunit.Sdk.XunitException) -----\", line),|line => Assert.Contains(\"HandlesAggregateException\", line)|);|#endif|}"
      },
      {
        "name": "MissingStackTracesAndExceptionTypes",
        "body": "{|var errorMetadata = new ErrorMetadata();|errorMetadata.AddMessage(\"Message 1\");|errorMetadata.AddMessage(\"Message 2\");|errorMetadata.AddMessage(\"Message 3\");|errorMetadata.AddIndex(-1);|errorMetadata.AddIndex(0);|errorMetadata.AddIndex(0);|errorMetadata.AddExceptionType(\"ExceptionType1\");|errorMetadata.AddExceptionType(\"Xunit.Sdk.ExceptionType2\");|errorMetadata.AddStackTrace(\"Stack Trace 1\");|errorMetadata.AddStackTrace(\"Stack Trace 2\");|var result = ExceptionUtility.CombineStackTraces(errorMetadata);|Assert.Equal(|\"Stack Trace 1\" + Environment.NewLine +|\"----- Inner Stack Trace #1 (Xunit.Sdk.ExceptionType2) -----\" + Environment.NewLine +|\"Stack Trace 2\" + Environment.NewLine +|\"----- Inner Stack Trace #2 () -----\" + Environment.NewLine,|result|);|}"
      }
    ]
  },
  {
    "file": "TestDiscoverySinkTests.cs",
    "methods": [
      {
        "name": "CollectsTestCases",
        "body": "{|var visitor = new TestDiscoverySink();|var testCase1 = TestData.TestCaseDiscovered();|var testCase2 = TestData.TestCaseDiscovered();|var testCase3 = TestData.TestCaseDiscovered();|visitor.OnMessage(testCase1);|visitor.OnMessage(testCase2);|visitor.OnMessage(testCase3);|visitor.OnMessage(TestData.DiagnosticMessage()); // Ignored|Assert.Collection(|visitor.TestCases,|msg => Assert.Same(testCase1, msg),|msg => Assert.Same(testCase2, msg),|msg => Assert.Same(testCase3, msg)|);|}"
      }
    ]
  },
  {
    "file": "UnitTest1.cs",
    "methods": [
      {
        "name": "Test1",
        "body": "{| Assert.True(true);| }"
      }
    ]
  }
]