[
  {
    "file": "AcceptanceTestAssembly.cs",
    "methods": []
  },
  {
    "file": "CSharpAcceptanceTestAssembly.cs",
    "methods": []
  },
  {
    "file": "CSharpAcceptanceTestV1Assembly.cs",
    "methods": []
  },
  {
    "file": "CSharpAcceptanceTestV2Assembly.cs",
    "methods": []
  },
  {
    "file": "CSharpAcceptanceTestV3Assembly.cs",
    "methods": []
  },
  {
    "file": "CulturedXunitTestCase.cs",
    "methods": []
  },
  {
    "file": "CulturedXunitTheoryTestCase.cs",
    "methods": []
  },
  {
    "file": "CulturedXunitTheoryTestCaseRunner.cs",
    "methods": []
  },
  {
    "file": "Mocks.TestFrameworks.cs",
    "methods": []
  },
  {
    "file": "Mocks.TestObjectModel.cs",
    "methods": []
  },
  {
    "file": "TestData.TestObjectModel.cs",
    "methods": []
  },
  {
    "file": "TestData.cs",
    "methods": []
  },
  {
    "file": "AfterTestFinished.cs",
    "methods": []
  },
  {
    "file": "AfterTestStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyMessage.cs",
    "methods": []
  },
  {
    "file": "TestCaseMessage.cs",
    "methods": []
  },
  {
    "file": "TestClassMessage.cs",
    "methods": []
  },
  {
    "file": "TestCollectionMessage.cs",
    "methods": []
  },
  {
    "file": "TestMessage.cs",
    "methods": []
  },
  {
    "file": "TestMethodMessage.cs",
    "methods": []
  },
  {
    "file": "TestResultMessage.cs",
    "methods": []
  },
  {
    "file": "BeforeTestFinished.cs",
    "methods": []
  },
  {
    "file": "BeforeTestStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyFinished.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyStarting.cs",
    "methods": []
  },
  {
    "file": "TestCaseCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCaseDiscovered.cs",
    "methods": []
  },
  {
    "file": "TestCaseFinished.cs",
    "methods": []
  },
  {
    "file": "TestCaseStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestClassConstructionFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassConstructionStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassDisposeFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassDisposeStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassStarting.cs",
    "methods": []
  },
  {
    "file": "TestCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCollectionCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCollectionFinished.cs",
    "methods": []
  },
  {
    "file": "TestCollectionStarting.cs",
    "methods": []
  },
  {
    "file": "TestFailed.cs",
    "methods": []
  },
  {
    "file": "TestFinished.cs",
    "methods": []
  },
  {
    "file": "TestMethodCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestMethodFinished.cs",
    "methods": []
  },
  {
    "file": "TestMethodStarting.cs",
    "methods": []
  },
  {
    "file": "TestNotRun.cs",
    "methods": []
  },
  {
    "file": "TestOutput.cs",
    "methods": []
  },
  {
    "file": "TestPassed.cs",
    "methods": []
  },
  {
    "file": "TestSkipped.cs",
    "methods": []
  },
  {
    "file": "TestStarting.cs",
    "methods": []
  },
  {
    "file": "AcceptanceTest.cs",
    "methods": []
  },
  {
    "file": "TestTimingAttribute.cs",
    "methods": []
  },
  {
    "file": "AssumeIdentityAttributeAcceptanceTests.cs",
    "methods": [
      {
        "name": "AttributeChangesRoleInTestMethod",
        "body": "{\n\t\t\tAssert.True(Thread.CurrentPrincipal.IsInRole(\"casper\"));\n\t\t}"
      },
      {
        "name": "CallingSecuredMethodWillThrow",
        "body": "{\n\t\t\t// Mono does not appear to properly support PrincipalPermission\n\t\t\tif (!EnvironmentHelper.IsMono)\n\t\t\t\tAssert.Throws<SecurityException>(() => DefeatVillian());\n\t\t}"
      },
      {
        "name": "CallingSecuredMethodWithWrongIdentityWillThrow",
        "body": "{\n\t\t\t// Mono does not appear to properly support PrincipalPermission\n\t\t\tif (!EnvironmentHelper.IsMono)\n\t\t\t\tAssert.Throws<SecurityException>(() => DefeatVillian());\n\t\t}"
      },
      {
        "name": "CallingSecuredMethodWithAssumedIdentityPasses",
        "body": "{\n\t\t\t// Mono does not appear to properly support PrincipalPermission\n\t\t\tif (!EnvironmentHelper.IsMono)\n\t\t\t\tAssert.DoesNotThrow(() => DefeatVillian());\n\t\t}"
      }
    ]
  },
  {
    "file": "ClassDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "ClassDataTest",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(ClassDataTestClass)).Single();\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.ClassDataAcceptanceTests+ClassDataTestClass.PassingTestData(foo: 1, bar: \"\"hello world\"\", baz: 2.3)\", result.DisplayName);\n\t\t}"
      }
    ]
  },
  {
    "file": "InlineDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "MultipleDataSets",
        "body": "{\n\t\t\tMethodResult[] results = RunClass(typeof(MultipleDataSetsClass)).ToArray();\n\n\t\t\tAssert.Equal(2, results.Length);\n\t\t\tPassedResult passedResult = results.OfType<PassedResult>().Single();\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.InlineDataAcceptanceTests+MultipleDataSetsClass.PassingTestData(foo: 1, bar: \"\"hello\"\", baz: 2.3)\", passedResult.DisplayName);\n\t\t\tFailedResult failedResult = results.OfType<FailedResult>().Single();\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.InlineDataAcceptanceTests+MultipleDataSetsClass.PassingTestData(foo: 42, bar: \"\"world\"\", baz: 21.12)\", failedResult.DisplayName);\n\t\t}"
      },
      {
        "name": "NullValue",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(NullValueClass)).Single();\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.InlineDataAcceptanceTests+NullValueClass.PassingTestData(foo: null)\", result.DisplayName);\n\t\t}"
      }
    ]
  },
  {
    "file": "PropertyDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "PropertyDataTest",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(PropertyDataTestClass)).Single();\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.PropertyDataAcceptanceTests+PropertyDataTestClass.PassingTestData(foo: 1, bar: \"\"hello world\"\", baz: 2.3)\", result.DisplayName);\n\t\t}"
      }
    ]
  },
  {
    "file": "TheoryAcceptanceTests.cs",
    "methods": [
      {
        "name": "IncorrectParameterCount",
        "body": "{\n\t\t\tMethodResult[] results = RunClass(typeof(IncorrectParameterCountClass)).ToArray();\n\n\t\t\tAssert.Equal(2, results.Length);\n\t\t\tPassedResult passedResult = results.OfType<PassedResult>().Single();\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+IncorrectParameterCountClass.PassingTestData(x: 1)\", passedResult.DisplayName);\n\t\t\tFailedResult failedResult = results.OfType<FailedResult>().Single();\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+IncorrectParameterCountClass.PassingTestData(x: 2, ???: 3)\", failedResult.DisplayName);\n\t\t}"
      },
      {
        "name": "NoDataAttributes",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(NoDataAttributesClass)).Single();\n\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+NoDataAttributesClass.TheoryMethod\", failedResult.DisplayName);\n\t\t\tAssert.Equal(\"System.InvalidOperationException : No data found for Xunit1.Extensions.TheoryAcceptanceTests+NoDataAttributesClass.TheoryMethod\", failedResult.Message);\n\t\t}"
      },
      {
        "name": "EmptyTheoryData",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(EmptyTheoryDataClass)).Single();\n\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+EmptyTheoryDataClass.TheoryMethod\", failedResult.DisplayName);\n\t\t\tAssert.Equal(\"System.InvalidOperationException : No data found for Xunit1.Extensions.TheoryAcceptanceTests+EmptyTheoryDataClass.TheoryMethod\", failedResult.Message);\n\t\t}"
      },
      {
        "name": "ThrowingData",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(ThrowingDataClass)).Single();\n\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAcceptanceTests+ThrowingDataClass.TheoryWithMisbehavingData\", failedResult.DisplayName);\n\t\t\tAssert.Contains(\"System.InvalidOperationException : An exception was thrown while getting data for theory Xunit1.Extensions.TheoryAcceptanceTests+ThrowingDataClass.TheoryWithMisbehavingData\", failedResult.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "DataAdapterDataAttributeTests.cs",
    "methods": [
      {
        "name": "WillConvertDBNullToNull",
        "body": "{\n\t\t\tDataAdapterDataAttribute attr = new TestableDataAdapterDataAttribute(DBNull.Value);\n\n\t\t\tList<object[]> results = new List<object[]>(attr.GetData(null, new Type[] { typeof(object) }));\n\n\t\t\tobject[] result = Assert.Single(results);\n\t\t\tobject singleResult = Assert.Single(result);\n\t\t\tAssert.Null(singleResult);\n\t\t}"
      },
      {
        "name": "WillNotThrowWhenGivenInsufficientParameterTypeLength",
        "body": "{\n\t\t\tDataAdapterDataAttribute attr = new TestableDataAdapterDataAttribute(DBNull.Value);\n\n\t\t\tAssert.DoesNotThrow(() => new List<object[]>(attr.GetData(null, new Type[0])));\n\t\t}"
      }
    ]
  },
  {
    "file": "GenericTheoryTests.cs",
    "methods": []
  },
  {
    "file": "TheoryAttributeTests.cs",
    "methods": [
      {
        "name": "TestDataFromProperty",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestViaProperty\");\n\t\t\tTheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];\n\n\t\t\tList<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tITestCommand command = Assert.Single(commands);\n\t\t\tTheoryCommand theoryCommand = Assert.IsType<TheoryCommand>(command);\n\t\t\tobject parameter = Assert.Single(theoryCommand.Parameters);\n\t\t\tAssert.Equal(2, parameter);\n\t\t}"
      },
      {
        "name": "TestDataFromPropertyOnBaseClass",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestViaPropertyOnBaseClass\");\n\t\t\tTheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];\n\n\t\t\tList<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tITestCommand command = Assert.Single(commands);\n\t\t\tTheoryCommand theoryCommand = Assert.IsType<TheoryCommand>(command);\n\t\t\tobject parameter = Assert.Single(theoryCommand.Parameters);\n\t\t\tAssert.Equal(4, parameter);\n\t\t}"
      },
      {
        "name": "TestDataFromOtherTypeProperty",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestViaOtherTypeProperty\");\n\t\t\tTheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];\n\n\t\t\tList<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tITestCommand command = Assert.Single(commands);\n\t\t\tTheoryCommand theoryCommand = Assert.IsType<TheoryCommand>(command);\n\t\t\tobject parameter = Assert.Single(theoryCommand.Parameters);\n\t\t\tAssert.Equal(3, parameter);\n\t\t}"
      },
      {
        "name": "ResolvedGenericTypeIsIncludedInDisplayName",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"GenericTest\");\n\t\t\tTheoryAttribute attr = (TheoryAttribute)(method.GetCustomAttributes(typeof(TheoryAttribute), false))[0];\n\n\t\t\tList<ITestCommand> commands = new List<ITestCommand>(attr.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tAssert.Equal(4, commands.Count);\n\t\t\tTheoryCommand command1 = Assert.IsType<TheoryCommand>(commands[0]);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<Int32>(value: 42)\", command1.DisplayName);\n\t\t\tTheoryCommand command2 = Assert.IsType<TheoryCommand>(commands[1]);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<String>(value: \"\"Hello, world!\"\")\", command2.DisplayName);\n\t\t\tTheoryCommand command3 = Assert.IsType<TheoryCommand>(commands[2]);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<Int32[]>(value: System.Int32[])\", command3.DisplayName);\n\t\t\t// TODO: Would like to see @\"TheoryAttributeTests+TestMethodCommandClass.GenericTest<Int32[]>(value: Int32[] { 1, 2, 3 })\"\n\t\t\tTheoryCommand command4 = Assert.IsType<TheoryCommand>(commands[3]);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryAttributeTests+TestMethodCommandClass.GenericTest<List<String>>(value: System.Collections.Generic.List`1[System.String])\", command4.DisplayName);\n\t\t\t// TODO: Would like to see @\"TheoryAttributeTests+TestMethodCommandClass.GenericTest<List<String>>(value: List<String> { \"\"a\"\", \"\"b\"\", \"\"c\"\" })\"\n\t\t}"
      }
    ]
  },
  {
    "file": "TheoryCommandTests.cs",
    "methods": [
      {
        "name": "ExecuteCreatesClassAndRunsTest",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(InstrumentedSpy).GetMethod(\"PassedTest\");\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);\n\t\t\tInstrumentedSpy.ctorCounter = 0;\n\t\t\tInstrumentedSpy.passedTestCounter = 0;\n\n\t\t\tcommand.Execute(new InstrumentedSpy());\n\n\t\t\tAssert.Equal(1, InstrumentedSpy.ctorCounter);\n\t\t\tAssert.Equal(1, InstrumentedSpy.passedTestCounter);\n\t\t}"
      },
      {
        "name": "ExecuteStubTestFixtureVerifyBeforeAfterTestCalledOnce",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(DisposableSpy).GetMethod(\"PassedTest\");\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);\n\t\t\tDisposableSpy.ctorCalled = 0;\n\t\t\tDisposableSpy.disposeCalled = 0;\n\n\t\t\tITestResult result = command.Execute(new DisposableSpy());\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t}"
      },
      {
        "name": "NotEnoughData",
        "body": "{\n\t\t\tTheoryCommand command = new TheoryCommand(\n\t\t\t\tReflector.Wrap(typeof(ParameterSpy).GetMethod(\"Method\")),\n\t\t\t\tnew object[] { 2 });\n\n\t\t\tAssert.Throws<InvalidOperationException>(() => command.Execute(new ParameterSpy()));\n\t\t}"
      },
      {
        "name": "UsesDisplayName",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(DummyWithAttributes).GetMethod(\"TheoryMethod\");\n\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42, 24.5 });\n\n\t\t\tAssert.Equal(\"My display name(x: 42, y: 24.5)\", command.DisplayName);\n\t\t}"
      },
      {
        "name": "DisplayNameWithTooManyValues",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(DummyWithAttributes).GetMethod(\"TheoryMethod\");\n\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42, 24.5, \"Hello!\", 'c' });\n\n\t\t\tAssert.Equal(\"My display name(x: 42, y: 24.5, ???: \\\"Hello!\\\", ???: 'c')\", command.DisplayName);\n\t\t}"
      },
      {
        "name": "DisplayNameWithTooFewValues",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(DummyWithAttributes).GetMethod(\"TheoryMethod\");\n\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42 });\n\n\t\t\tAssert.Equal(\"My display name(x: 42, y: ???)\", command.DisplayName);\n\t\t}"
      },
      {
        "name": "PassesParametersToTest",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(SpyWithDataPassed).GetMethod(\"Test\");\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), new object[] { 42, 24.5, \"foo\" });\n\t\t\tSpyWithDataPassed.X = 0;\n\t\t\tSpyWithDataPassed.Y = 0.0;\n\t\t\tSpyWithDataPassed.Z = null;\n\n\t\t\tcommand.Execute(new SpyWithDataPassed());\n\n\t\t\tAssert.Equal(42, SpyWithDataPassed.X);\n\t\t\tAssert.Equal(24.5, SpyWithDataPassed.Y);\n\t\t\tAssert.Equal(\"foo\", SpyWithDataPassed.Z);\n\t\t}"
      },
      {
        "name": "TestMethodReturnPassedResult",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);\n\n\t\t\tMethodResult result = command.Execute(new TestMethodCommandClass());\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t}"
      },
      {
        "name": "ThrowsExceptionReturnFailedResult",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(methodInfo), null);\n\n\t\t\tAssert.Throws<InvalidOperationException>(() => command.Execute(new TestMethodCommandClass()));\n\t\t}"
      },
      {
        "name": "TooMuchData",
        "body": "{\n\t\t\tTheoryCommand command = new TheoryCommand(\n\t\t\t\tReflector.Wrap(typeof(ParameterSpy).GetMethod(\"Method\")),\n\t\t\t\tnew object[] { 2, \"foo\", 3.14 });\n\n\t\t\tAssert.Throws<InvalidOperationException>(() => command.Execute(new ParameterSpy()));\n\t\t}"
      },
      {
        "name": "TruncatesVeryLongStrings",
        "body": "{\n\t\t\tStringBuilder sb = new StringBuilder(500);\n\n\t\t\tfor (int idx = 0; idx < 50; idx++)\n\t\t\t\tsb.Append(\"----=----|\");\n\n\t\t\tTheoryCommand command = new TheoryCommand(\n\t\t\t\tReflector.Wrap(typeof(ParameterSpy).GetMethod(\"Method\")),\n\t\t\t\tnew object[] { 2, sb.ToString() });\n\n\t\t\tMethodResult result = command.Execute(new ParameterSpy());\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t\tAssert.Equal(@\"Xunit1.Extensions.TheoryCommandTests+ParameterSpy.Method(x: 2, y: \"\"----=----|----=----|----=----|----=----|----=----|\"\"...)\", result.DisplayName);\n\t\t}"
      },
      {
        "name": "SettingTheoryTimeoutSetsTimeout",
        "body": "{\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(typeof(DummyWithAttributes).GetMethod(\"TimeoutMethod\")), null);\n\n\t\t\tAssert.Equal(153, command.Timeout);\n\t\t}"
      },
      {
        "name": "StringDataWithEmbeddedNullCreatesValidXml",
        "body": "{\n\t\t\tstring expectedXml = @\"<start name=\"\"Xunit1.Extensions.TheoryCommandTests+DummyWithAttributes.StringMethod(s: &quot;\\x0\\xFFFF&quot;)\"\" type=\"\"Xunit1.Extensions.TheoryCommandTests+DummyWithAttributes\"\" method=\"\"StringMethod\"\" />\";\n\n\t\t\tTheoryCommand command = new TheoryCommand(Reflector.Wrap(typeof(DummyWithAttributes).GetMethod(\"StringMethod\")), new object[] { \"\\0\\xffff\" });\n\n\t\t\tAssert.Equal(expectedXml, command.ToStartXml().OuterXml);\n\t\t}"
      }
    ]
  },
  {
    "file": "FreezeClockAttributeAcceptanceTests.cs",
    "methods": [
      {
        "name": "FrozenWithCurrentTime",
        "body": "{\n\t\t\tDateTime reference = DateTime.Now;\n\n\t\t\tDateTime result1 = Clock.Now;\n\t\t\tThread.Sleep(100);\n\t\t\tDateTime result2 = Clock.Now;\n\n\t\t\tAssert.Equal(result1, result2);\n\t\t\tAssert.True((reference - result1).TotalMilliseconds < 1000);\n\t\t}"
      },
      {
        "name": "FrozenWithSpecificDate",
        "body": "{\n\t\t\tDateTime result = Clock.Now;\n\n\t\t\tAssert.Equal(new DateTime(2006, 12, 31), result);\n\t\t}"
      },
      {
        "name": "FrozenWithSpecificLocalDateTime",
        "body": "{\n\t\t\tDateTime result = Clock.Now;\n\n\t\t\tAssert.Equal(new DateTime(2006, 12, 31, 4, 5, 6), result);\n\t\t}"
      },
      {
        "name": "FrozenWithSpecificUTCDateTime",
        "body": "{\n\t\t\tDateTime result = Clock.Now;\n\n\t\t\tAssert.Equal(new DateTime(2006, 12, 31, 4, 5, 6, DateTimeKind.Utc).ToLocalTime(), result);\n\t\t}"
      },
      {
        "name": "NotFrozen",
        "body": "{\n\t\t\tDateTime result1 = Clock.Now;\n\t\t\tThread.Sleep(100);\n\t\t\tDateTime result2 = Clock.Now;\n\n\t\t\tAssert.NotEqual(result1, result2);\n\t\t}"
      }
    ]
  },
  {
    "file": "ApartmentAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestsRunsInTheSingleThreadedApartment",
        "body": "{\n\t\t\tAssert.Equal(ApartmentState.STA, Thread.CurrentThread.GetApartmentState());\n\t\t}"
      }
    ]
  },
  {
    "file": "AsyncAcceptanceTests.cs",
    "methods": [
      {
        "name": "Async40AcceptanceTest",
        "body": "{\n\t\t\tIEnumerable<MethodResult> results = RunClass(typeof(Async40AcceptanceTestClass));\n\n\t\t\tMethodResult result = Assert.Single(results);\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(typeof(TrueException).FullName, failedResult.ExceptionType);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\t\treturn Task.Factory.StartNew(() =>\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(1);\n\t\t\t\t})\n\t\t\t\t.ContinueWith(_ =>\n\t\t\t\t{\n\t\t\t\t\tAssert.True(false);\n\t\t\t\t});\n\t\t\t}"
      }
    ]
  },
  {
    "file": "FactMethodWithArgumentsTests.cs",
    "methods": [
      {
        "name": "FactMethodsCannotHaveArguments",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(ClassUnderTest)).Single();\n\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(typeof(InvalidOperationException).FullName, failedResult.ExceptionType);\n\t\t\tAssert.Equal(\"System.InvalidOperationException : Fact method Xunit1.FactMethodWithArgumentsTests+ClassUnderTest.FactWithParameters cannot have parameters\", failedResult.Message);\n\t\t}"
      },
      {
        "name": "FactWithParameters",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "FailureTimingAcceptanceTests.cs",
    "methods": [
      {
        "name": "TimingForFailedTestShouldReflectActualRunTime",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(ClassUnderTest)).Single();\n\n\t\t\tAssert.IsType<FailedResult>(result);\n\t\t\tAssert.NotEqual(0.0, result.ExecutionTime);\n\t\t}"
      },
      {
        "name": "TwoNumbersAreNotEqual",
        "body": "{\n\t\t\t\tThread.Sleep(100);\n\t\t\t\tAssert.Equal(2, 3);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "FixtureDataAcceptanceTests.cs",
    "methods": [
      {
        "name": "ClassWithFixtureAndSkippedFactDoesNotSetFixtureData",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(FixtureWithAllSkips)).Single();\n\n\t\t\t// If it ran the fixture, then we would get a class failure\n\t\t\tAssert.IsType<SkipResult>(result);\n\t\t}"
      },
      {
        "name": "SkippedTest",
        "body": "{ }"
      },
      {
        "name": "ClassWithFixtureAndStaticFactDoesNotSetFixtureData",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(FixtureWithAllStatics)).Single();\n\n\t\t\t// If it ran the fixture, then we would get a class failure\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t}"
      },
      {
        "name": "StaticPassingTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "SkipAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestClassIsNotInstantiatedForSkippedTests",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(ClassUnderTest)).Single();\n\n\t\t\t// If we ran the constructor, we would get a failure instead of a skip.\n\t\t\tAssert.IsType<SkipResult>(result);\n\t\t}"
      },
      {
        "name": "TestThatShouldBeSkipped",
        "body": "{\n\t\t\t}"
      }
    ]
  },
  {
    "file": "TestTimeoutTests.cs",
    "methods": [
      {
        "name": "TestHasTimeoutAndExceeds",
        "body": "{\n\t\t\tMethodResult result = RunClass(typeof(ClassUnderTest)).Single();\n\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.InRange(failedResult.ExecutionTime, 0.049, 0.051);\n\t\t\tAssert.Equal(\"Test execution time exceeded: 50ms\", failedResult.Message);\n\t\t}"
      },
      {
        "name": "TestShouldTimeout",
        "body": "{\n\t\t\t\tThread.Sleep(120);\n\t\t\t\tAssert.Equal(2, 2);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "ContainsTests.cs",
    "methods": [
      {
        "name": "CanFindNullInContainer",
        "body": "{\n\t\t\t\tList<object> list = new List<object> { 16, null, \"Hi there\" };\n\n\t\t\t\tAssert.Contains(null, list);\n\t\t\t}"
      },
      {
        "name": "CanUseComparer",
        "body": "{\n\t\t\t\tList<int> list = new List<int> { 42 };\n\n\t\t\t\tAssert.Contains(43, list, new MyComparer());\n\t\t\t}"
      },
      {
        "name": "ItemInContainer",
        "body": "{\n\t\t\t\tList<int> list = new List<int> { 42 };\n\n\t\t\t\tAssert.Contains(42, list);\n\t\t\t}"
      },
      {
        "name": "ItemNotInContainer",
        "body": "{\n\t\t\t\tList<int> list = new List<int>();\n\n\t\t\t\tContainsException ex = Assert.Throws<ContainsException>(() => Assert.Contains(42, list));\n\n\t\t\t\tAssert.Equal(\"Assert.Contains() failure: Not found: 42\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "NullsAllowedInContainer",
        "body": "{\n\t\t\t\tList<object> list = new List<object> { null, 16, \"Hi there\" };\n\n\t\t\t\tAssert.Contains(\"Hi there\", list);\n\t\t\t}"
      },
      {
        "name": "NullContainerThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ContainsException>(() => Assert.Contains(14, (List<int>)null));\n\t\t\t}"
      },
      {
        "name": "CanSearchForSubstrings",
        "body": "{\n\t\t\t\tAssert.Contains(\"wor\", \"Hello, world!\");\n\t\t\t}"
      },
      {
        "name": "CanSearchForSubstringsCaseInsensitive",
        "body": "{\n\t\t\t\tAssert.Contains(\"WORLD\", \"Hello, world!\", StringComparison.InvariantCultureIgnoreCase);\n\t\t\t}"
      },
      {
        "name": "SubstringContainsIsCaseSensitiveByDefault",
        "body": "{\n\t\t\t\tvar ex = Record.Exception(() => Assert.Contains(\"WORLD\", \"Hello, world!\"));\n\n\t\t\t\tAssert.IsType<ContainsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Contains() failure:\" + Environment.NewLine +\n\t\t\t\t\t\"Not found: WORLD\" + Environment.NewLine +\n\t\t\t\t\t\"In value:  Hello, world!\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "SubstringNotFound",
        "body": "{\n\t\t\t\tAssert.Throws<ContainsException>(() => Assert.Contains(\"hey\", \"Hello, world!\"));\n\t\t\t}"
      },
      {
        "name": "NullActualStringThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ContainsException>(() => Assert.Contains(\"foo\", (string)null));\n\t\t\t}"
      }
    ]
  },
  {
    "file": "DoesNotContainTests.cs",
    "methods": [
      {
        "name": "CanSearchForNullInContainer",
        "body": "{\n\t\t\t\tList<object> list = new List<object> { 16, \"Hi there\" };\n\n\t\t\t\tAssert.DoesNotContain(null, list);\n\t\t\t}"
      },
      {
        "name": "CanUseComparer",
        "body": "{\n\t\t\t\tList<int> list = new List<int>();\n\t\t\t\tlist.Add(42);\n\n\t\t\t\tAssert.DoesNotContain(42, list, new MyComparer());\n\t\t\t}"
      },
      {
        "name": "ItemInContainer",
        "body": "{\n\t\t\t\tList<int> list = new List<int> { 42 };\n\n\t\t\t\tDoesNotContainException ex =\n\t\t\t\t\tAssert.Throws<DoesNotContainException>(() => Assert.DoesNotContain(42, list));\n\n\t\t\t\tAssert.Equal(\"Assert.DoesNotContain() failure: Found: 42\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "ItemNotInContainer",
        "body": "{\n\t\t\t\tList<int> list = new List<int>();\n\n\t\t\t\tAssert.DoesNotContain(42, list);\n\t\t\t}"
      },
      {
        "name": "NullsAllowedInContainer",
        "body": "{\n\t\t\t\tList<object> list = new List<object> { null, 16, \"Hi there\" };\n\n\t\t\t\tAssert.DoesNotContain(42, list);\n\t\t\t}"
      },
      {
        "name": "NullContainerDoesNotThrow",
        "body": "{\n\t\t\t\tAssert.DoesNotThrow(() => Assert.DoesNotContain(14, (List<int>)null));\n\t\t\t}"
      },
      {
        "name": "CanSearchForSubstrings",
        "body": "{\n\t\t\t\tAssert.DoesNotContain(\"hey\", \"Hello, world!\");\n\t\t\t}"
      },
      {
        "name": "CanSearchForSubstringsCaseInsensitive",
        "body": "{\n\t\t\t\tAssert.Throws<DoesNotContainException>(\n\t\t\t\t\t() => Assert.DoesNotContain(\"WORLD\", \"Hello, world!\", StringComparison.InvariantCultureIgnoreCase));\n\t\t\t}"
      },
      {
        "name": "SubstringDoesNotContainIsCaseSensitiveByDefault",
        "body": "{\n\t\t\t\tAssert.DoesNotContain(\"WORLD\", \"Hello, world!\");\n\t\t\t}"
      },
      {
        "name": "SubstringFound",
        "body": "{\n\t\t\t\tAssert.Throws<DoesNotContainException>(() => Assert.DoesNotContain(\"world\", \"Hello, world!\"));\n\t\t\t}"
      },
      {
        "name": "NullActualStringDoesNotThrow",
        "body": "{\n\t\t\t\tAssert.DoesNotThrow(() => Assert.DoesNotContain(\"foo\", (string)null));\n\t\t\t}"
      }
    ]
  },
  {
    "file": "DoesNotThrowTests.cs",
    "methods": [
      {
        "name": "CorrectExceptionType",
        "body": "{\n\t\t\tDoesNotThrowException ex =\n\t\t\t\tAssert.Throws<DoesNotThrowException>(\n\t\t\t\t\t() => Assert.DoesNotThrow(\n\t\t\t\t\t\t() => { throw new NotImplementedException(\"Exception Message\"); }));\n\n\t\t\tAssert.Equal(\"Assert.DoesNotThrow() failure\", ex.UserMessage);\n\t\t\tAssert.Equal(\"(No exception)\", ex.Expected);\n\t\t\tAssert.Equal(\"System.NotImplementedException: Exception Message\", ex.Actual);\n\t\t}"
      },
      {
        "name": "PassingTest",
        "body": "{\n\t\t\tAssert.DoesNotThrow(() => { });\n\t\t}"
      }
    ]
  },
  {
    "file": "EmptyTests.cs",
    "methods": [
      {
        "name": "IsEmpty",
        "body": "{\n\t\t\t\tList<int> list = new List<int>();\n\n\t\t\t\tAssert.Empty(list);\n\t\t\t}"
      },
      {
        "name": "IsNotEmpty",
        "body": "{\n\t\t\t\tList<int> list = new List<int>();\n\t\t\t\tlist.Add(42);\n\n\t\t\t\tEmptyException ex = Assert.Throws<EmptyException>(() => Assert.Empty(list));\n\n\t\t\t\tAssert.Equal(\"Assert.Empty() failure\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "NullIsNotEmpty",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(() => Assert.Empty(null));\n\t\t\t}"
      },
      {
        "name": "IsEmpty",
        "body": "{\n\t\t\t\tAssert.Empty(\"\");\n\t\t\t}"
      },
      {
        "name": "IsNotEmpty",
        "body": "{\n\t\t\t\tEmptyException ex = Assert.Throws<EmptyException>(() => Assert.Empty(\"Foo\"));\n\n\t\t\t\tAssert.Equal(\"Assert.Empty() failure\", ex.Message);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "EqualTests.cs",
    "methods": [
      {
        "name": "Array",
        "body": "{\n\t\t\t\tstring[] expected = { \"@\", \"a\", \"ab\", \"b\" };\n\t\t\t\tstring[] actual = { \"@\", \"a\", \"ab\", \"b\" };\n\n\t\t\t\tAssert.Equal(expected, actual);\n\t\t\t\tAssert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual));\n\t\t\t}"
      },
      {
        "name": "ArrayInsideArray",
        "body": "{\n\t\t\t\tstring[][] expected = { new[] { \"@\", \"a\" }, new[] { \"ab\", \"b\" } };\n\t\t\t\tstring[][] actual = { new[] { \"@\", \"a\" }, new[] { \"ab\", \"b\" } };\n\n\t\t\t\tAssert.Equal(expected, actual);\n\t\t\t\tAssert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual));\n\t\t\t}"
      },
      {
        "name": "ArraysOfDifferentLengthsAreNotEqual",
        "body": "{\n\t\t\t\tstring[] expected = { \"@\", \"a\", \"ab\", \"b\", \"c\" };\n\t\t\t\tstring[] actual = { \"@\", \"a\", \"ab\", \"b\" };\n\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(expected, actual));\n\t\t\t\tAssert.NotEqual(expected, actual);\n\t\t\t}"
      },
      {
        "name": "ArrayValuesAreDifferentNotEqual",
        "body": "{\n\t\t\t\tstring[] expected = { \"@\", \"d\", \"v\", \"d\" };\n\t\t\t\tstring[] actual = { \"@\", \"a\", \"ab\", \"b\" };\n\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(expected, actual));\n\t\t\t\tAssert.NotEqual(expected, actual);\n\t\t\t}"
      },
      {
        "name": "EnumerableEquivalence",
        "body": "{\n\t\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\t\tList<int> actual = new List<int>(expected);\n\n\t\t\t\tAssert.Equal(expected, actual);\n\t\t\t}"
      },
      {
        "name": "EnumerableInequivalence",
        "body": "{\n\t\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\t\tList<int> actual = new List<int>(new[] { 1, 2, 3, 4, 6 });\n\n\t\t\t\tEqualException ex = Assert.Throws<EqualException>(() => Assert.Equal(expected, actual));\n\n\t\t\t\tAssert.Contains(\"First difference is at position 4\" + Environment.NewLine, ex.Message);\n\t\t\t}"
      },
      {
        "name": "EnumerableEquivalenceWithSuccessfulComparer",
        "body": "{\n\t\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\t\tList<int> actual = new List<int>(new int[] { 0, 0, 0, 0, 0 });\n\n\t\t\t\tAssert.Equal(expected, actual, new IntComparer(true));\n\t\t\t}"
      },
      {
        "name": "EnumerableEquivalenceWithFailedComparer",
        "body": "{\n\t\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\t\tList<int> actual = new List<int>(new int[] { 1, 2, 3, 4, 5 });\n\n\t\t\t\tEqualException ex = Assert.Throws<EqualException>(() => Assert.Equal(expected, actual, new IntComparer(false)));\n\n\t\t\t\t// TODO: When we fix up the assert exception messages, we should allow the enumerator who\n\t\t\t\t// did the comparisons to tell us exactly where the error was, rather than determining the\n\t\t\t\t// inequivalence after the fact.\n\n\t\t\t\t// Assert.Contains(\"First difference is at position 0\\r\\n\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "DepthExample",
        "body": "{\n\t\t\t\tvar x = new List<object> { new List<object> { new List<object> { new List<object>() } } };\n\t\t\t\tvar y = new List<object> { new List<object> { new List<object> { new List<object>() } } };\n\n\t\t\t\tAssert.Equal(x, y);\n\t\t\t}"
      },
      {
        "name": "ObjectWithComparable",
        "body": "{\n\t\t\t\tComparableObject obj1 = new ComparableObject();\n\t\t\t\tComparableObject obj2 = new ComparableObject();\n\n\t\t\t\tAssert.Equal(obj1, obj2);\n\t\t\t\tAssert.True(obj1.CompareCalled);\n\t\t\t}"
      },
      {
        "name": "ObjectWithGenericComparable",
        "body": "{\n\t\t\t\tGenericComparableObject obj1 = new GenericComparableObject();\n\t\t\t\tGenericComparableObject obj2 = new GenericComparableObject();\n\n\t\t\t\tAssert.Equal(obj1, obj2);\n\t\t\t\tAssert.True(obj1.CompareCalled);\n\t\t\t}"
      },
      {
        "name": "ObjectWithoutIComparable",
        "body": "{\n\t\t\t\tNonComparableObject nco1 = new NonComparableObject();\n\t\t\t\tNonComparableObject nco2 = new NonComparableObject();\n\n\t\t\t\tAssert.Equal(nco1, nco2);\n\t\t\t}"
      },
      {
        "name": "DoubleNegativeInfinityEqualsNegativeInfinity",
        "body": "{\n\t\t\t\tAssert.Equal(double.NegativeInfinity, double.NegativeInfinity);\n\t\t\t}"
      },
      {
        "name": "DoubleNegativeInfinityNotEquals",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(1.23, double.NegativeInfinity));\n\t\t\t}"
      },
      {
        "name": "DoublePositiveInfinityEqualsPositiveInfinity",
        "body": "{\n\t\t\t\tAssert.Equal(double.PositiveInfinity, double.PositiveInfinity);\n\t\t\t}"
      },
      {
        "name": "DoublePositiveInfinityNotEquals",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(1.23, double.PositiveInfinity));\n\t\t\t}"
      },
      {
        "name": "DoublePositiveInfinityNotEqualsNegativeInfinity",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(double.NegativeInfinity, double.PositiveInfinity));\n\t\t\t}"
      },
      {
        "name": "Select_should_equal_Select",
        "body": "{\n\t\t\t\tIEnumerable<int> items = IntGenerator.Range(1, 12);\n\t\t\t\tIEnumerable<int> others = IntGenerator.Range(1, 12);\n\n\t\t\t\tAssert.Equal(items, others);\n\t\t\t}"
      },
      {
        "name": "CallsIEquatable",
        "body": "{\n\t\t\t\tEquatableObject obj1 = new EquatableObject();\n\t\t\t\tEquatableObject obj2 = new EquatableObject();\n\n\t\t\t\tAssert.Equal(obj1, obj2);\n\n\t\t\t\tAssert.True(obj1.Equals__Called);\n\t\t\t\tAssert.Same(obj2, obj1.Equals_Other);\n\t\t\t}"
      },
      {
        "name": "EqualsNaNFails",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(double.NaN, 1.234));\n\t\t\t}"
      },
      {
        "name": "NanEqualsFails",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(1.234, double.NaN));\n\t\t\t}"
      },
      {
        "name": "NanEqualsNaNSucceeds",
        "body": "{\n\t\t\t\tAssert.Equal(double.NaN, double.NaN);\n\t\t\t}"
      },
      {
        "name": "EqualsNull",
        "body": "{\n\t\t\t\tAssert.Equal<object>(null, null);\n\t\t\t}"
      },
      {
        "name": "FailsWhenActualIsNullExpectedIsNot",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(new object(), null));\n\t\t\t}"
      },
      {
        "name": "FailsWhenExpectedIsNullActualIsNot",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(null, new object()));\n\t\t\t}"
      },
      {
        "name": "DecimalEqualsFails",
        "body": "{\n\t\t\t\tdecimal expected = 25;\n\t\t\t\tdecimal actual = 42;\n\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(expected, actual));\n\t\t\t}"
      },
      {
        "name": "DoubleEqualsFails",
        "body": "{\n\t\t\t\tdouble expected = 25.3;\n\t\t\t\tdouble actual = 42.0;\n\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(expected, actual));\n\t\t\t}"
      },
      {
        "name": "EqualsByte",
        "body": "{\n\t\t\t\tbyte valueType = 35;\n\t\t\t\tByte referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<byte>(valueType, 35);\n\t\t\t\tAssert.Equal<byte>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsDecimal",
        "body": "{\n\t\t\t\tdecimal valueType = 35;\n\t\t\t\tDecimal referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<decimal>(valueType, 35);\n\t\t\t\tAssert.Equal(valueType, 35M);\n\t\t\t\tAssert.Equal<decimal>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsInt16",
        "body": "{\n\t\t\t\tshort valueType = 35;\n\t\t\t\tInt16 referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<short>(valueType, 35);\n\t\t\t\tAssert.Equal<short>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsInt32",
        "body": "{\n\t\t\t\tint valueType = 35;\n\t\t\t\tInt32 referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal(valueType, 35);\n\t\t\t\tAssert.Equal(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsInt64",
        "body": "{\n\t\t\t\tlong valueType = 35;\n\t\t\t\tInt64 referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<long>(valueType, 35);\n\t\t\t\tAssert.Equal<long>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsSByte",
        "body": "{\n\t\t\t\tsbyte valueType = 35;\n\t\t\t\tSByte referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<sbyte>(valueType, 35);\n\t\t\t\tAssert.Equal<sbyte>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsUInt16",
        "body": "{\n\t\t\t\tushort valueType = 35;\n\t\t\t\tUInt16 referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<ushort>(valueType, 35);\n\t\t\t\tAssert.Equal<ushort>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsUInt32",
        "body": "{\n\t\t\t\tuint valueType = 35;\n\t\t\t\tUInt32 referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<uint>(valueType, 35);\n\t\t\t\tAssert.Equal<uint>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "EqualsUInt64",
        "body": "{\n\t\t\t\tulong valueType = 35;\n\t\t\t\tUInt64 referenceValue = 35;\n\n\t\t\t\tAssert.True(valueType == referenceValue);\n\t\t\t\tAssert.Equal(referenceValue, valueType);\n\t\t\t\tAssert.Equal<ulong>(valueType, 35);\n\t\t\t\tAssert.Equal<ulong>(referenceValue, 35);\n\t\t\t}"
      },
      {
        "name": "Int32Int64Comparison",
        "body": "{\n\t\t\t\tlong l64 = 0;\n\t\t\t\tint i32 = 0;\n\t\t\t\tAssert.Equal<long>(l64, i32);\n\t\t\t}"
      },
      {
        "name": "IntegerLongComparison",
        "body": "{\n\t\t\t\tAssert.Equal<long>(1L, 1);\n\t\t\t\tAssert.Equal<long>(1, 1L);\n\t\t\t}"
      },
      {
        "name": "LongEquals",
        "body": "{\n\t\t\t\tAssert.Equal(2L, 2L);\n\t\t\t}"
      },
      {
        "name": "LongEqualsFails",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(3L, 2L));\n\t\t\t}"
      },
      {
        "name": "UInt64EqualsFails",
        "body": "{\n\t\t\t\tUInt64 expected = 25;\n\t\t\t\tUInt64 actual = 42;\n\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(expected, actual));\n\t\t\t}"
      },
      {
        "name": "SingleNegativeInfinityEqualsNegativeInfinity",
        "body": "{\n\t\t\t\tAssert.Equal(float.NegativeInfinity, float.NegativeInfinity);\n\t\t\t}"
      },
      {
        "name": "SingleNumberNotEqualNegativeInfinity",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(1.23f, float.NegativeInfinity));\n\t\t\t}"
      },
      {
        "name": "SingleNumberNotEqualPositiiveInfinity",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(1.23f, float.PositiveInfinity));\n\t\t\t}"
      },
      {
        "name": "SinglePositiveInfinityEqualsPositiveInfinity",
        "body": "{\n\t\t\t\tAssert.Equal(float.PositiveInfinity, float.PositiveInfinity);\n\t\t\t}"
      },
      {
        "name": "SinglePositiveInfinityNotEqualNegativeInfinity",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(float.NegativeInfinity, float.PositiveInfinity));\n\t\t\t}"
      },
      {
        "name": "EqualsFail",
        "body": "{\n\t\t\t\tAssert.Throws<EqualException>(() => Assert.Equal(\"expected\", \"actual\"));\n\t\t\t}"
      },
      {
        "name": "EqualsString",
        "body": "{\n\t\t\t\tstring testString = \"Test String\";\n\t\t\t\tstring expected = testString;\n\t\t\t\tstring actual = testString;\n\n\t\t\t\tAssert.True(actual == expected);\n\t\t\t\tAssert.Equal(expected, actual);\n\t\t\t}"
      },
      {
        "name": "EqualStringWithTrailingNull",
        "body": "{\n\t\t\t\tException ex = Record.Exception(() => Assert.Equal(\"foo\", \"foo\\0\"));\n\n\t\t\t\tAssert.IsType<EqualException>(ex);\n\t\t\t}"
      },
      {
        "name": "EqualsStringIgnoreCase",
        "body": "{\n\t\t\t\tstring expected = \"TestString\";\n\t\t\t\tstring actual = \"testString\";\n\n\t\t\t\tAssert.False(actual == expected);\n\t\t\t\tAssert.NotEqual(expected, actual);\n\t\t\t\tAssert.Equal(expected, actual, StringComparer.CurrentCultureIgnoreCase);\n\t\t\t}"
      },
      {
        "name": "String",
        "body": "{\n\t\t\t\tstring s1 = \"test\";\n\t\t\t\tstring s2 = new StringBuilder(s1).ToString();\n\n\t\t\t\tAssert.True(s1.Equals(s2));\n\t\t\t\tAssert.Equal(s2, s1);\n\t\t\t}"
      },
      {
        "name": "NullableValueTypesCanBeNull",
        "body": "{\n\t\t\t\tDateTime? dt1 = null;\n\t\t\t\tDateTime? dt2 = null;\n\n\t\t\t\tAssert.Equal(dt1, dt2);\n\t\t\t}"
      },
      {
        "name": "AssertEqualWithDoubleWithPrecision",
        "body": "{\n\t\t\t\tAssert.Equal(0.11111, 0.11444, 2);\n\t\t\t}"
      },
      {
        "name": "AssertEqualWithDoubleWithPrecisionFailure",
        "body": "{\n\t\t\t\tvar ex = Assert.Throws<EqualException>(() => Assert.Equal(0.11111, 0.11444, 3));\n\t\t\t\tAssert.Equal(string.Format(\"{0} (rounded from {1})\", 0.111, 0.11111), ex.Expected);\n\t\t\t\tAssert.Equal(string.Format(\"{0} (rounded from {1})\", 0.114, 0.11444), ex.Actual);\n\t\t\t}"
      },
      {
        "name": "AssertEqualWithDecimalWithPrecision",
        "body": "{\n\t\t\t\tAssert.Equal(0.11111M, 0.11444M, 2);\n\t\t\t}"
      },
      {
        "name": "AssertEqualWithDecimalWithPrecisionFailure",
        "body": "{\n\t\t\t\tvar ex = Assert.Throws<EqualException>(() => Assert.Equal(0.11111M, 0.11444M, 3));\n\t\t\t\tAssert.Equal(string.Format(\"{0} (rounded from {1})\", 0.111M, 0.11111M), ex.Expected);\n\t\t\t\tAssert.Equal(string.Format(\"{0} (rounded from {1})\", 0.114M, 0.11444M), ex.Actual);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "FactAttributeTests.cs",
    "methods": [
      {
        "name": "FactAttributeGeneratesFactCommand",
        "body": "{\n\t\t\tMethodInfo method = typeof(FactAttributeTests).GetMethod(\"DummyFactMethod\");\n\t\t\tFactAttribute attribute = new FactAttribute();\n\n\t\t\tList<ITestCommand> results = new List<ITestCommand>(attribute.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tITestCommand result = Assert.Single(results);\n\t\t\tAssert.IsType<FactCommand>(result);\n\t\t}"
      },
      {
        "name": "DefaultFactAttributeValues",
        "body": "{\n\t\t\tFactAttribute attrib = new FactAttribute();\n\t\t\tMethodInfo method = typeof(FactAttributeTests).GetMethod(\"DummyFactMethod\");\n\n\t\t\tvar commands = new List<ITestCommand>(attrib.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tITestCommand command = Assert.Single(commands);\n\t\t\tFactCommand factCommand = Assert.IsType<FactCommand>(command);\n\t\t\tAssert.Equal(\"Xunit1.FactAttributeTests\", factCommand.TypeName);\n\t\t\tAssert.Equal(\"DummyFactMethod\", factCommand.MethodName);\n\t\t\tAssert.Equal(\"Xunit1.FactAttributeTests.DummyFactMethod\", factCommand.DisplayName);\n\t\t}"
      },
      {
        "name": "NameOnFactAttributeOverridesDisplayName",
        "body": "{\n\t\t\tMethodInfo method = typeof(FactAttributeTests).GetMethod(\"CustomNamedFactMethod\");\n\t\t\tFactAttribute attrib = method.GetCustomAttributes(true).OfType<FactAttribute>().Single();\n\n\t\t\tvar commands = new List<ITestCommand>(attrib.CreateTestCommands(Reflector.Wrap(method)));\n\n\t\t\tITestCommand command = Assert.Single(commands);\n\t\t\tFactCommand factCommand = Assert.IsType<FactCommand>(command);\n\t\t\tAssert.Equal(\"Custom display name\", factCommand.DisplayName);\n\t\t}"
      },
      {
        "name": "SkipCanBeOverridenInDerivedAttribute",
        "body": "{\n\t\t\tMyFactAttribute attrib = new MyFactAttribute(7);\n\n\t\t\tstring result = attrib.Skip;\n\n\t\t\tAssert.Equal(\"35\", result);\n\t\t}"
      },
      {
        "name": "CustomNamedFactMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "FalseTests.cs",
    "methods": [
      {
        "name": "AssertFalse",
        "body": "{\n\t\t\tAssert.False(false);\n\t\t}"
      },
      {
        "name": "AssertFalseThrowsExceptionWhenTrue",
        "body": "{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAssert.False(true);\n\t\t\t}\n\t\t\tcatch (AssertException exception)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Assert.False() Failure\", exception.UserMessage);\n\t\t\t}\n\t\t}"
      }
    ]
  },
  {
    "file": "InRangeTests.cs",
    "methods": [
      {
        "name": "DoubleNotWithinRange",
        "body": "{\n\t\t\t\tAssert.Throws<InRangeException>(() => Assert.InRange(1.50, .75, 1.25));\n\t\t\t}"
      },
      {
        "name": "DoubleValueWithinRange",
        "body": "{\n\t\t\t\tAssert.InRange(1.0, .75, 1.25);\n\t\t\t}"
      },
      {
        "name": "IntNotWithinRangeWithZeroActual",
        "body": "{\n\t\t\t\tAssert.Throws<InRangeException>(() => Assert.InRange(0, 1, 2));\n\t\t\t}"
      },
      {
        "name": "IntNotWithinRangeWithZeroMinimum",
        "body": "{\n\t\t\t\tAssert.Throws<InRangeException>(() => Assert.InRange(2, 0, 1));\n\t\t\t}"
      },
      {
        "name": "IntValueWithinRange",
        "body": "{\n\t\t\t\tAssert.InRange(2, 1, 3);\n\t\t\t}"
      },
      {
        "name": "StringNotWithinRange",
        "body": "{\n\t\t\t\tAssert.Throws<InRangeException>(() => Assert.InRange(\"adam\", \"bob\", \"scott\"));\n\t\t\t}"
      },
      {
        "name": "StringValueWithinRange",
        "body": "{\n\t\t\t\tAssert.InRange(\"bob\", \"adam\", \"scott\");\n\t\t\t}"
      }
    ]
  },
  {
    "file": "IsAssignableFromTests.cs",
    "methods": [
      {
        "name": "IsAssignableFrom_SameType",
        "body": "{\n\t\t\tvar expected = new InvalidCastException();\n\t\t\tAssert.IsAssignableFrom(typeof(InvalidCastException), expected);\n\t\t\tAssert.IsAssignableFrom<InvalidCastException>(expected);\n\t\t}"
      },
      {
        "name": "IsAssignableFrom_BaseType",
        "body": "{\n\t\t\tvar expected = new InvalidCastException();\n\t\t\tAssert.IsAssignableFrom(typeof(Exception), expected);\n\t\t\tAssert.IsAssignableFrom<Exception>(expected);\n\t\t}"
      },
      {
        "name": "IsAssignableFrom_Interface",
        "body": "{\n\t\t\tvar expected = new DisposableClass();\n\t\t\tAssert.IsAssignableFrom(typeof(IDisposable), expected);\n\t\t\tAssert.IsAssignableFrom<IDisposable>(expected);\n\t\t}"
      },
      {
        "name": "IsAssignableFromReturnsCastObject",
        "body": "{\n\t\t\tInvalidCastException expected = new InvalidCastException();\n\t\t\tInvalidCastException actual = Assert.IsAssignableFrom<InvalidCastException>(expected);\n\t\t\tAssert.Same(expected, actual);\n\t\t}"
      },
      {
        "name": "IsAssignableFromThrowsExceptionWhenWrongType",
        "body": "{\n\t\t\tvar exception =\n\t\t\t\tAssert.Throws<IsAssignableFromException>(\n\t\t\t\t\t() => Assert.IsAssignableFrom<InvalidCastException>(new InvalidOperationException())\n\t\t\t\t);\n\n\t\t\tAssert.Equal(\"Assert.IsAssignableFrom() Failure\", exception.UserMessage);\n\t\t}"
      },
      {
        "name": "IsAssignableFromThrowsExceptionWhenPassedNull",
        "body": "{\n\t\t\tAssert.Throws<IsAssignableFromException>(() => Assert.IsAssignableFrom<object>(null));\n\t\t}"
      }
    ]
  },
  {
    "file": "IsNotTypeTests.cs",
    "methods": [
      {
        "name": "IsNotType",
        "body": "{\n\t\t\tInvalidCastException expected = new InvalidCastException();\n\t\t\tAssert.IsNotType(typeof(Exception), expected);\n\t\t\tAssert.IsNotType<Exception>(expected);\n\t\t}"
      },
      {
        "name": "IsNotTypeThrowsExceptionWhenWrongType",
        "body": "{\n\t\t\tAssertException exception =\n\t\t\t\tAssert.Throws<IsNotTypeException>(() => Assert.IsNotType<InvalidCastException>(new InvalidCastException()));\n\n\t\t\tAssert.Equal(\"Assert.IsNotType() Failure\", exception.UserMessage);\n\t\t}"
      },
      {
        "name": "NullObjectDoesNotThrow",
        "body": "{\n\t\t\tAssert.DoesNotThrow(() => Assert.IsNotType<object>(null));\n\t\t}"
      }
    ]
  },
  {
    "file": "IsTypeTests.cs",
    "methods": [
      {
        "name": "IsType",
        "body": "{\n\t\t\tInvalidCastException expected = new InvalidCastException();\n\t\t\tAssert.IsType(typeof(InvalidCastException), expected);\n\t\t\tAssert.IsType<InvalidCastException>(expected);\n\t\t}"
      },
      {
        "name": "IsTypeReturnsCastObject",
        "body": "{\n\t\t\tInvalidCastException expected = new InvalidCastException();\n\t\t\tInvalidCastException actual = Assert.IsType<InvalidCastException>(expected);\n\t\t\tAssert.Same(expected, actual);\n\t\t}"
      },
      {
        "name": "IsTypeThrowsExceptionWhenWrongType",
        "body": "{\n\t\t\tAssertException exception =\n\t\t\t\tAssert.Throws<IsTypeException>(() => Assert.IsType<InvalidCastException>(new InvalidOperationException()));\n\n\t\t\tAssert.Equal(\"Assert.IsType() Failure\", exception.UserMessage);\n\t\t}"
      },
      {
        "name": "IsTypeThrowsExceptionWhenPassedNull",
        "body": "{\n\t\t\tAssert.Throws<IsTypeException>(() => Assert.IsType<object>(null));\n\t\t}"
      }
    ]
  },
  {
    "file": "NotEmptyTests.cs",
    "methods": [
      {
        "name": "ContainerIsEmpty",
        "body": "{\n\t\t\tList<int> list = new List<int>();\n\n\t\t\tNotEmptyException ex =\n\t\t\t\tAssert.Throws<NotEmptyException>(() => Assert.NotEmpty(list));\n\n\t\t\tAssert.Equal(\"Assert.NotEmpty() failure\", ex.Message);\n\t\t}"
      },
      {
        "name": "ContainerIsNotEmpty",
        "body": "{\n\t\t\tList<int> list = new List<int>();\n\t\t\tlist.Add(42);\n\n\t\t\tAssert.NotEmpty(list);\n\t\t}"
      }
    ]
  },
  {
    "file": "NotEqualTests.cs",
    "methods": [
      {
        "name": "NotEqualFailsString",
        "body": "{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAssert.NotEqual(\"actual\", \"actual\");\n\t\t\t}\n\t\t\tcatch (NotEqualException exception)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Assert.NotEqual() Failure\", exception.UserMessage);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "NotEqualWithCustomComparer",
        "body": "{\n\t\t\tstring expected = \"TestString\";\n\t\t\tstring actual = \"testString\";\n\n\t\t\tAssert.False(actual == expected);\n\t\t\tAssert.Equal(expected, actual, StringComparer.CurrentCultureIgnoreCase);\n\t\t\tAssert.NotEqual(expected, actual, StringComparer.CurrentCulture);\n\t\t}"
      },
      {
        "name": "ValuesNotEqual",
        "body": "{\n\t\t\tAssert.NotEqual(\"bob\", \"jim\");\n\t\t}"
      },
      {
        "name": "EnumerableInequivalence",
        "body": "{\n\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\tList<int> actual = new List<int>(new[] { 1, 2, 3, 4, 6 });\n\n\t\t\tAssert.NotEqual(expected, actual);\n\t\t}"
      },
      {
        "name": "EnumerableEquivalence",
        "body": "{\n\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\tList<int> actual = new List<int>(expected);\n\n\t\t\tAssert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual));\n\t\t}"
      },
      {
        "name": "EnumerableInequivalenceWithFailedComparer",
        "body": "{\n\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\tList<int> actual = new List<int>(new int[] { 1, 2, 3, 4, 5 });\n\n\t\t\tAssert.NotEqual(expected, actual, new IntComparer(false));\n\t\t}"
      },
      {
        "name": "EnumerableEquivalenceWithSuccessfulComparer",
        "body": "{\n\t\t\tint[] expected = new[] { 1, 2, 3, 4, 5 };\n\t\t\tList<int> actual = new List<int>(new int[] { 0, 0, 0, 0, 0 });\n\n\t\t\tAssert.Throws<NotEqualException>(() => Assert.NotEqual(expected, actual, new IntComparer(true)));\n\t\t}"
      }
    ]
  },
  {
    "file": "NotInRangeTests.cs",
    "methods": [
      {
        "name": "DoubleNotWithinRange",
        "body": "{\n\t\t\t\tAssert.NotInRange(1.50, .75, 1.25);\n\t\t\t}"
      },
      {
        "name": "DoubleWithinRange",
        "body": "{\n\t\t\t\tAssert.Throws<NotInRangeException>(() => Assert.NotInRange(1.0, .75, 1.25));\n\t\t\t}"
      },
      {
        "name": "IntNotWithinRange",
        "body": "{\n\t\t\t\tAssert.NotInRange(1, 2, 3);\n\t\t\t}"
      },
      {
        "name": "IntWithinRange",
        "body": "{\n\t\t\t\tAssert.Throws<NotInRangeException>(() => Assert.NotInRange(2, 1, 3));\n\t\t\t}"
      },
      {
        "name": "StringNotWithNotInRange",
        "body": "{\n\t\t\t\tAssert.NotInRange(\"adam\", \"bob\", \"scott\");\n\t\t\t}"
      },
      {
        "name": "StringWithNotInRange",
        "body": "{\n\t\t\t\tAssert.Throws<NotInRangeException>(() => Assert.NotInRange(\"bob\", \"adam\", \"scott\"));\n\t\t\t}"
      }
    ]
  },
  {
    "file": "NotNullTests.cs",
    "methods": [
      {
        "name": "NotNull",
        "body": "{\n\t\t\tAssert.NotNull(new object());\n\t\t}"
      },
      {
        "name": "NotNullThrowsException",
        "body": "{\n\t\t\tAssert.Throws<NotNullException>(() => Assert.NotNull(null));\n\t\t}"
      }
    ]
  },
  {
    "file": "NotSameTests.cs",
    "methods": [
      {
        "name": "NotSameFailsWith",
        "body": "{\n\t\t\tobject actual = new object();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAssert.NotSame(actual, actual);\n\t\t\t}\n\t\t\tcatch (NotSameException exception)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Assert.NotSame() Failure\", exception.UserMessage);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "ValuesAreNotTheSame",
        "body": "{\n\t\t\tAssert.NotSame(\"bob\", \"jim\");\n\t\t}"
      },
      {
        "name": "ValuesAreTheSame",
        "body": "{\n\t\t\tstring jim = \"jim\";\n\n\t\t\tAssert.Throws<NotSameException>(() => Assert.NotSame(jim, jim));\n\t\t}"
      },
      {
        "name": "ValueTypesGetBoxedTwice",
        "body": "{\n\t\t\tint index = 0;\n\n\t\t\tAssert.NotSame(index, index);\n\t\t}"
      }
    ]
  },
  {
    "file": "NullTests.cs",
    "methods": [
      {
        "name": "Null",
        "body": "{\n\t\t\tAssert.Null(null);\n\t\t}"
      },
      {
        "name": "NullThrowsExceptionWhenNotNull",
        "body": "{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAssert.Null(new object());\n\t\t\t}\n\t\t\tcatch (AssertException exception)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Assert.Null() Failure\", exception.UserMessage);\n\t\t\t}\n\t\t}"
      }
    ]
  },
  {
    "file": "PropertyChangedTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tvar ex1 = Assert.Throws<ArgumentNullException>(() => Assert.PropertyChanged(null, \"propertyName\", delegate { }));\n\t\t\tAssert.Equal(\"object\", ex1.ParamName);\n\n\t\t\tvar ex2 = Assert.Throws<ArgumentNullException>(() => Assert.PropertyChanged(new Mock<INotifyPropertyChanged>().Object, \"propertyName\", null));\n\t\t\tAssert.Equal(\"testCode\", ex2.ParamName);\n\t\t}"
      },
      {
        "name": "ExceptionThrownWhenPropertyNotChanged",
        "body": "{\n\t\t\tNotifiedClass obj = new NotifiedClass();\n\n\t\t\tException ex = Record.Exception(\n\t\t\t\t() => Assert.PropertyChanged(obj, \"Property1\", () => { })\n\t\t\t);\n\n\t\t\tAssert.IsType<PropertyChangedException>(ex);\n\t\t\tAssert.Equal(\"Assert.PropertyChanged failure: Property Property1 was not set\", ex.Message);\n\t\t}"
      },
      {
        "name": "ExceptionThrownWhenWrongPropertyChanged",
        "body": "{\n\t\t\tNotifiedClass obj = new NotifiedClass();\n\n\t\t\tException ex = Record.Exception(\n\t\t\t\t() => Assert.PropertyChanged(obj, \"Property1\", () => obj.Property2 = 42)\n\t\t\t);\n\n\t\t\tAssert.IsType<PropertyChangedException>(ex);\n\t\t\tAssert.Equal(\"Assert.PropertyChanged failure: Property Property1 was not set\", ex.Message);\n\t\t}"
      },
      {
        "name": "NoExceptionThrownWhenPropertyChanged",
        "body": "{\n\t\t\tNotifiedClass obj = new NotifiedClass();\n\n\t\t\tException ex = Record.Exception(\n\t\t\t\t() => Assert.PropertyChanged(obj, \"Property1\", () => obj.Property1 = \"NewValue\")\n\t\t\t);\n\n\t\t\tAssert.Null(ex);\n\t\t}"
      },
      {
        "name": "NoExceptionThrownWhenMultiplePropertyChangesIncludesCorrectProperty",
        "body": "{\n\t\t\tNotifiedClass obj = new NotifiedClass();\n\n\t\t\tException ex = Record.Exception(\n\t\t\t\t() =>\n\t\t\t\t{\n\t\t\t\t\tAssert.PropertyChanged(obj, \"Property1\", () =>\n\t\t\t\t\t{\n\t\t\t\t\t\tobj.Property2 = 12;\n\t\t\t\t\t\tobj.Property1 = \"New Value\";\n\t\t\t\t\t\tobj.Property2 = 42;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tAssert.Null(ex);\n\t\t}"
      }
    ]
  },
  {
    "file": "RecordTests.cs",
    "methods": [
      {
        "name": "Exception",
        "body": "{\n\t\t\t\tException ex = Record.Exception(delegate { throw new InvalidOperationException(); });\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      },
      {
        "name": "NoException",
        "body": "{\n\t\t\t\tException ex = Record.Exception(delegate { });\n\n\t\t\t\tAssert.Null(ex);\n\t\t\t}"
      },
      {
        "name": "Exception",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\tException ex = Record.Exception(() => accessor.FailingProperty);\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      },
      {
        "name": "NoException",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\tException ex = Record.Exception(() => accessor.SuccessfulProperty);\n\n\t\t\t\tAssert.Null(ex);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "SameTests.cs",
    "methods": [
      {
        "name": "BoxedTypesDontWork",
        "body": "{\n\t\t\tint index = 0;\n\n\t\t\tAssert.Throws<SameException>(() => Assert.Same(index, index));\n\t\t}"
      },
      {
        "name": "SameFailsWith",
        "body": "{\n\t\t\tstring actual = \"Abc\";\n\t\t\tstring expected = \"a\".ToUpperInvariant() + \"bc\";\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAssert.Same(expected, actual);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tAssertException aex = Assert.IsAssignableFrom<AssertException>(ex);\n\t\t\t\tAssert.Equal(\"Assert.Same() Failure\", aex.UserMessage);\n\t\t\t\tAssert.DoesNotContain(\"Position:\", aex.Message);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "ValuesAreNotTheSame",
        "body": "{\n\t\t\tAssert.Throws<SameException>(() => Assert.Same(\"bob\", \"jim\"));\n\t\t}"
      },
      {
        "name": "ValuesAreTheSame",
        "body": "{\n\t\t\tstring jim = \"jim\";\n\n\t\t\tAssert.Same(jim, jim);\n\t\t}"
      }
    ]
  },
  {
    "file": "AfterTestExceptionTests.cs",
    "methods": [
      {
        "name": "SingleException",
        "body": "{\n\t\t\tException ex = Record.Exception(delegate { throw new Exception(\"Exception Message\"); });\n\n\t\t\tException result = Record.Exception(delegate { throw new AfterTestException(ex); });\n\n\t\t\tAssert.Equal(\"One or more exceptions were thrown from After methods during test cleanup\", result.Message);\n\t\t\tAssert.Contains(\"System.Exception thrown: Exception Message\", result.StackTrace);\n\t\t\tAssert.Contains(\"AfterTestExceptionTests\", result.StackTrace);\n\t\t\tAssert.Contains(\"Xunit.Record.Exception\", result.StackTrace);\n\t\t}"
      },
      {
        "name": "MultipleExceptions",
        "body": "{\n\t\t\tException ex1 = Record.Exception(delegate { throw new Exception(\"Exception Message\"); });\n\t\t\tException ex2 = Record.Exception(delegate { throw new InvalidOperationException(\"Invalid Operation Message\"); });\n\n\t\t\tException result = Record.Exception(delegate { throw new AfterTestException(ex1, ex2); });\n\n\t\t\tAssert.Equal(\"One or more exceptions were thrown from After methods during test cleanup\", result.Message);\n\t\t\tAssert.Contains(\"System.Exception thrown: Exception Message\", result.StackTrace);\n\t\t\tAssert.Contains(\"System.InvalidOperationException thrown: Invalid Operation Message\", result.StackTrace);\n\t\t}"
      },
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalInnerException = new AssertException(\"User Message\");\n\t\t\tvar originalException = new AfterTestException(originalInnerException);\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tvar deserializedInnerException = Assert.Single(deserializedException.AfterExceptions);\n\t\t\tAssert.Equal(originalInnerException.Message, deserializedInnerException.Message);\n\t\t\tvar deserializedAssertException = Assert.IsType<AssertException>(deserializedInnerException);\n\t\t\tAssert.Equal(originalInnerException.UserMessage, deserializedAssertException.UserMessage);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestClassCommandFactoryTests.cs",
    "methods": [
      {
        "name": "AbstractTestClassReturnsNull",
        "body": "{\n\t\t\tITestClassCommand command = TestClassCommandFactory.Make(typeof(AbstractTestClass));\n\n\t\t\tAssert.Null(command);\n\t\t}"
      },
      {
        "name": "NoTestMethodsShouldReturnNull",
        "body": "{\n\t\t\tType type = typeof(StubClass);\n\t\t\tITestClassCommand command = TestClassCommandFactory.Make(type);\n\n\t\t\tAssert.Null(command);\n\t\t}"
      },
      {
        "name": "RunWithClassReturnsTypeToRunWith",
        "body": "{\n\t\t\tITestClassCommand command = TestClassCommandFactory.Make(typeof(MyRunWithTestClass));\n\n\t\t\tAssert.IsType<MyRunWith>(command);\n\t\t\tAssert.Equal(typeof(MyRunWithTestClass), command.TypeUnderTest.Type);\n\t\t}"
      },
      {
        "name": "RunWithForInvalidTestClassCommandReturnsNull",
        "body": "{\n\t\t\tITestClassCommand command = TestClassCommandFactory.Make(typeof(MyInvalidRunWithTestClass));\n\n\t\t\tAssert.Null(command);\n\t\t}"
      },
      {
        "name": "StubTestClassMakesTestClassCommand",
        "body": "{\n\t\t\tType testClassType = typeof(StubTestClass);\n\t\t\tITestClassCommand command = TestClassCommandFactory.Make(testClassType);\n\n\t\t\tAssert.IsType<TestClassCommand>(command);\n\t\t\tAssert.Equal(typeof(StubTestClass), command.TypeUnderTest.Type);\n\t\t}"
      },
      {
        "name": "AllStagesOfTestLifetimeExistOnSameThread",
        "body": "{\n\t\t\tType testClassType = typeof(ThreadLifetimeSpy);\n\t\t\tITestClassCommand command = TestClassCommandFactory.Make(testClassType);\n\t\t\tThreadFixtureSpy.Reset();\n\t\t\tThreadLifetimeSpy.Reset();\n\n\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t// The fixture data may take place on a different thread from the test, but that's\n\t\t\t// an acceptable limitation, as the fixture should have no knowledge of the test\n\t\t\t// class that it's attached to. This means that fixtures cannot use thread local\n\t\t\t// storage, but there's no reason for them to need that anyway, as their own data\n\t\t\t// remains the same throughout all the tests for a given class.\n\n\t\t\tAssert.NotEqual(-1, ThreadFixtureSpy.CtorThreadId);\n\t\t\tAssert.Equal(ThreadFixtureSpy.CtorThreadId, ThreadFixtureSpy.DisposeThreadId);\n\n\t\t\tAssert.NotEqual(-1, ThreadLifetimeSpy.CtorThreadId);\n\t\t\tAssert.Equal(ThreadLifetimeSpy.CtorThreadId, ThreadLifetimeSpy.DisposeThreadId);\n\t\t\tAssert.Equal(ThreadLifetimeSpy.CtorThreadId, ThreadLifetimeSpy.TestThreadId);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\t\tTestThreadId = Thread.CurrentThread.ManagedThreadId;\n\t\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestClassCommandRunnerTests.cs",
    "methods": [
      {
        "name": "StartCallbackIsCalled",
        "body": "{\n\t\t\tint count = 0;\n\t\t\tstring passName = typeof(VarietyTestClass).FullName + \".PassedTest\";\n\t\t\tstring failName = typeof(VarietyTestClass).FullName + \".FailedTest\";\n\t\t\tstring skipName = typeof(VarietyTestClass).FullName + \".SkippedTest\";\n\t\t\tbool foundPass = false;\n\t\t\tbool foundFail = false;\n\t\t\tbool foundSkip = false;\n\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\n\t\t\tTestClassCommandRunner.Execute(\n\t\t\t\tcommand,\n\t\t\t\tnull,\n\t\t\t\tcmd =>\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t\tif (cmd.DisplayName == passName)\n\t\t\t\t\t\tfoundPass = true;\n\t\t\t\t\tif (cmd.DisplayName == failName)\n\t\t\t\t\t\tfoundFail = true;\n\t\t\t\t\tif (cmd.DisplayName == skipName)\n\t\t\t\t\t\tfoundSkip = true;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tnull\n\t\t\t);\n\n\t\t\tAssert.Equal(3, count);\n\t\t\tAssert.True(foundPass);\n\t\t\tAssert.True(foundFail);\n\t\t\tAssert.True(foundSkip);\n\t\t}"
      },
      {
        "name": "ResultCallbackIsCalledWithCorrectResults",
        "body": "{\n\t\t\tint classCounter = 0;\n\t\t\tint errorCounter = 0;\n\t\t\tint failedCounter = 0;\n\t\t\tint passedCounter = 0;\n\t\t\tint skippedCounter = 0;\n\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\n\t\t\tTestClassCommandRunner.Execute(\n\t\t\t\tcommand,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tresult =>\n\t\t\t\t{\n\t\t\t\t\tif (result is PassedResult)\n\t\t\t\t\t\tpassedCounter++;\n\t\t\t\t\telse if (result is FailedResult)\n\t\t\t\t\t\tfailedCounter++;\n\t\t\t\t\telse if (result is SkipResult)\n\t\t\t\t\t\tskippedCounter++;\n\t\t\t\t\telse if (result is ClassResult)\n\t\t\t\t\t\tclassCounter++;\n\t\t\t\t\telse\n\t\t\t\t\t\terrorCounter++;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tAssert.Equal(1, passedCounter);\n\t\t\tAssert.Equal(1, failedCounter);\n\t\t\tAssert.Equal(1, skippedCounter);\n\t\t\tAssert.Equal(1, classCounter);\n\t\t\tAssert.Equal(0, errorCounter);\n\t\t}"
      },
      {
        "name": "ClassFinishException",
        "body": "{\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\t\t\tcommand.ClassFinish__Result = new Exception();\n\n\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\tAssert.Equal(typeof(Exception) + \" : \" + command.ClassFinish__Result.Message, result.Message);\n\t\t\tAssert.Equal(command.ClassFinish__Result.StackTrace, result.StackTrace);\n\t\t}"
      },
      {
        "name": "ClassFinishExceptionSupercedesClassStartException",
        "body": "{\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\t\t\tcommand.ClassStart__Result = new NotImplementedException();\n\t\t\tcommand.ClassFinish__Result = new Exception();\n\n\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\tAssert.Equal(typeof(Exception) + \" : \" + command.ClassFinish__Result.Message, result.Message);\n\t\t\tAssert.Equal(command.ClassFinish__Result.StackTrace, result.StackTrace);\n\t\t}"
      },
      {
        "name": "ClassStartExceptionDoesNotRunTestsButDoesCallClassFinish",
        "body": "{\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\t\t\tcommand.ClassStart__Result = new Exception();\n\n\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\tAssert.True(command.ClassStart__Called);\n\t\t\tAssert.True(command.ClassFinish__Called);\n\t\t\tAssert.Equal(typeof(Exception) + \" : \" + command.ClassStart__Result.Message, result.Message);\n\t\t\tAssert.Equal(command.ClassStart__Result.StackTrace, result.StackTrace);\n\t\t\tAssert.Equal(0, result.Results.Count);\n\t\t}"
      },
      {
        "name": "ExecuteWillNotRunRequestedNonTestMethod",
        "body": "{\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\t\t\tList<IMethodInfo> methods = new List<IMethodInfo> {\n\t\t\t\tReflector.Wrap(typeof(VarietyTestClass).GetMethod(\"NonTestMethod\"))\n\t\t\t};\n\n\t\t\tClassResult result = TestClassCommandRunner.Execute(command, methods, null, null);\n\n\t\t\tAssert.Equal(0, result.Results.Count);\n\t\t}"
      },
      {
        "name": "ExecuteWithNullMethodsRunAllTestMethods",
        "body": "{\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\n\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\tAssert.Equal(VarietyTestClass.TestMethodCount, result.Results.Count);\n\t\t}"
      },
      {
        "name": "ExecuteWithSpecificMethodOnlyRunsThatMethod",
        "body": "{\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(VarietyTestClass));\n\t\t\tList<IMethodInfo> methods = new List<IMethodInfo> {\n\t\t\t\tReflector.Wrap(typeof(VarietyTestClass).GetMethod(\"PassedTest\"))\n\t\t\t};\n\n\t\t\tClassResult result = TestClassCommandRunner.Execute(command, methods, null, null);\n\n\t\t\tAssert.Single(result.Results);\n\t\t}"
      },
      {
        "name": "UsesProvidedObjectInstanceForAllTests",
        "body": "{\n\t\t\tInstanceSpy originalObject = new InstanceSpy();\n\t\t\tStubTestClassCommand command = new StubTestClassCommand(typeof(InstanceSpy));\n\t\t\tcommand.ObjectUnderTest__Result = originalObject;\n\t\t\tInstanceSpy.Reset();\n\n\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\tAssert.Equal(3, InstanceSpy.instances.Count);\n\t\t\tforeach (object obj in InstanceSpy.instances)\n\t\t\t\tAssert.Same(originalObject, obj);\n\t\t}"
      },
      {
        "name": "FailedTest",
        "body": "{\n\t\t\t\tAssert.Equal(3, 2);\n\t\t\t}"
      },
      {
        "name": "PassedTest",
        "body": "{ }"
      },
      {
        "name": "SkippedTest",
        "body": "{ }"
      },
      {
        "name": "Test1",
        "body": "{\n\t\t\t\tinstances.Add(this);\n\t\t\t}"
      },
      {
        "name": "Test2",
        "body": "{\n\t\t\t\tinstances.Add(this);\n\t\t\t}"
      },
      {
        "name": "Test3",
        "body": "{\n\t\t\t\tinstances.Add(this);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "TestClassCommandTests.cs",
    "methods": [
      {
        "name": "FixtureDataDisposeFailure_InvocationException",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand(typeof(DataDisposeFailureSpy));\n\t\t\t\tDataDisposeThrow.Exception = new TargetInvocationException(new Exception());\n\n\t\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(\"System.Reflection.TargetInvocationException\", result.ExceptionType);\n\t\t\t}"
      },
      {
        "name": "FixtureDataConstructorFailure_InvocationException",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand();\n\t\t\t\tcommand.TypeUnderTest = Reflector.Wrap(typeof(DataCtorFailureSpy));\n\t\t\t\tDataCtorThrow.Exception = new TargetInvocationException(new Exception());\n\n\t\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(\"System.Reflection.TargetInvocationException\", result.ExceptionType);\n\t\t\t}"
      },
      {
        "name": "CannotUseTestClassAsItsOwnFixture",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand(typeof(InvalidTestClassWithSelfFixture));\n\n\t\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(typeof(InvalidOperationException).FullName, result.ExceptionType);\n\t\t\t\tAssert.Equal(0, result.Results.Count);\n\t\t\t}"
      },
      {
        "name": "DummyTest",
        "body": "{\n\t\t\t\t\tdummyTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "DummyTest",
        "body": "{\n\t\t\t\t\tdummyTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "DummyTest",
        "body": "{\n\t\t\t\t\tAssert.Equal(1, 1);\n\t\t\t\t}"
      },
      {
        "name": "Test1",
        "body": "{\n\t\t\t\t}"
      },
      {
        "name": "Test2",
        "body": "{\n\t\t\t\t}"
      },
      {
        "name": "ClassResultContainsOneResultForEachTestMethod",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand();\n\t\t\t\tcommand.TypeUnderTest = Reflector.Wrap(typeof(Spy));\n\n\t\t\t\tClassResult result = TestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(3, result.Results.Count);\n\t\t\t}"
      },
      {
        "name": "CtorFailure",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand();\n\t\t\t\tcommand.TypeUnderTest = Reflector.Wrap(typeof(CtorFailureSpy));\n\t\t\t\tCtorFailureSpy.Reset();\n\t\t\t\tCtorFailureSpy.dummyTestCalled = 0;\n\n\t\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(1, CtorFailureSpy.dataCtorCalled);\n\t\t\t\tAssert.Equal(1, CtorFailureSpy.ctorCalled);\n\t\t\t\tAssert.Equal(0, CtorFailureSpy.dummyTestCalled);\n\t\t\t\tAssert.Equal(0, CtorFailureSpy.disposeCalled);\n\t\t\t\tAssert.Equal(1, CtorFailureSpy.dataDisposeCalled);\n\t\t\t}"
      },
      {
        "name": "DisposeFailure",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand();\n\t\t\t\tcommand.TypeUnderTest = Reflector.Wrap(typeof(DisposeFailureSpy));\n\t\t\t\tDisposeFailureSpy.Reset();\n\t\t\t\tDisposeFailureSpy.dummyTestCalled = 0;\n\n\t\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(1, DisposeFailureSpy.dataCtorCalled);\n\t\t\t\tAssert.Equal(1, DisposeFailureSpy.ctorCalled);\n\t\t\t\tAssert.Equal(1, DisposeFailureSpy.dummyTestCalled);\n\t\t\t\tAssert.Equal(1, DisposeFailureSpy.disposeCalled);\n\t\t\t\tAssert.Equal(1, DisposeFailureSpy.dataDisposeCalled);\n\t\t\t\tAssert.Equal(\"ctorData ctor setFixture dispose disposeData \", DisposeFailureSpy.callOrder);\n\t\t\t}"
      },
      {
        "name": "RandomizerUsedToDetermineTestOrder",
        "body": "{\n\t\t\t\tRandomSpy randomizer = new RandomSpy();\n\t\t\t\tTestClassCommand command = new TestClassCommand(typeof(OrderingSpy));\n\t\t\t\tcommand.Randomizer = randomizer;\n\n\t\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(OrderingSpy.TestMethodCount, randomizer.Next__Count);\n\t\t\t}"
      },
      {
        "name": "DummyTest",
        "body": "{\n\t\t\t\t\tdummyTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "DummyTest",
        "body": "{\n\t\t\t\t\tdummyTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test4",
        "body": "{ }"
      },
      {
        "name": "Test5",
        "body": "{ }"
      },
      {
        "name": "Test6",
        "body": "{ }"
      },
      {
        "name": "Test7",
        "body": "{ }"
      },
      {
        "name": "Test8",
        "body": "{ }"
      },
      {
        "name": "Test9",
        "body": "{ }"
      },
      {
        "name": "FailedTest",
        "body": "{\n\t\t\t\t\tthrow new InvalidOperationException();\n\t\t\t\t}"
      },
      {
        "name": "PassedTest",
        "body": "{ }"
      },
      {
        "name": "Skip",
        "body": "{ }"
      },
      {
        "name": "TestMethodCounters",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand();\n\t\t\t\tcommand.TypeUnderTest = Reflector.Wrap(typeof(InstrumentedTestClass));\n\t\t\t\tInstrumentedTestClass.Reset();\n\t\t\t\tInstrumentedTestClass.passedTestCalled = 0;\n\t\t\t\tInstrumentedTestClass.failedTestCalled = 0;\n\t\t\t\tInstrumentedTestClass.skipTestCalled = 0;\n\t\t\t\tInstrumentedTestClass.nonTestCalled = 0;\n\n\t\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.Equal(1, InstrumentedTestClass.dataCtorCalled);\n\t\t\t\tAssert.Equal(2, InstrumentedTestClass.ctorCalled);  // Two non-skipped tests, the skipped test does not create an instance\n\t\t\t\tAssert.Equal(1, InstrumentedTestClass.passedTestCalled);\n\t\t\t\tAssert.Equal(1, InstrumentedTestClass.failedTestCalled);\n\t\t\t\tAssert.Equal(0, InstrumentedTestClass.skipTestCalled);\n\t\t\t\tAssert.Equal(0, InstrumentedTestClass.nonTestCalled);\n\t\t\t\tAssert.Equal(2, InstrumentedTestClass.disposeCalled);\n\t\t\t\tAssert.Equal(1, InstrumentedTestClass.dataDisposeCalled);\n\t\t\t\tAssert.Equal(\"ctorData ctor setFixture dispose ctor setFixture dispose disposeData \", InstrumentedTestClass.callOrder);\n\t\t\t}"
      },
      {
        "name": "TestsCanBePrivateMethods",
        "body": "{\n\t\t\t\tTestClassCommand command = new TestClassCommand();\n\t\t\t\tcommand.TypeUnderTest = Reflector.Wrap(typeof(PrivateSpy));\n\t\t\t\tPrivateSpy.Reset();\n\n\t\t\t\tTestClassCommandRunner.Execute(command, null, null, null);\n\n\t\t\t\tAssert.True(PrivateSpy.WasRun);\n\t\t\t}"
      },
      {
        "name": "SettingSkipReasonGeneratesSkipCommand",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(ClassWithSkippedTest).GetMethod(\"SkippedTest\");\n\t\t\t\tTestClassCommand classCommand = new TestClassCommand(typeof(ClassWithSkippedTest));\n\n\t\t\t\tvar commands = new List<ITestCommand>(classCommand.EnumerateTestCommands(Reflector.Wrap(method)));\n\n\t\t\t\tITestCommand command = Assert.Single(commands);\n\t\t\t\tSkipCommand skipCommand = Assert.IsType<SkipCommand>(command);\n\t\t\t\tAssert.Equal(\"My Skip Reason\", skipCommand.Reason);\n\t\t\t}"
      },
      {
        "name": "FailedTest",
        "body": "{\n\t\t\t\t\tfailedTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "PassedTest",
        "body": "{\n\t\t\t\t\tpassedTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "SkippedTest",
        "body": "{\n\t\t\t\t\tskipTestCalled++;\n\t\t\t\t}"
      },
      {
        "name": "PrivateTest",
        "body": "{\n\t\t\t\t\tWasRun = true;\n\t\t\t\t}"
      },
      {
        "name": "SkippedTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "BeforeAfterCommandTests.cs",
    "methods": [
      {
        "name": "VerifyBeforeAfterTestAttributeCalledOnce",
        "body": "{\n\t\t\tMethodInfo method = typeof(SimpleTestFixtureSpy).GetMethod(\"PassedTest\");\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(new FactCommand(Reflector.Wrap(method)), method);\n\t\t\tSimpleTestFixtureSpy.Reset();\n\n\t\t\tITestResult result = command.Execute(new SimpleTestFixtureSpy());\n\n\t\t\tAssert.Equal(1, BeforeAfterSpyAttribute.beforeTestCount);\n\t\t\tAssert.Equal(1, BeforeAfterSpyAttribute.afterTestCount);\n\t\t\tAssert.Equal(\"ctor beforetest test aftertest \", SimpleTestFixtureSpy.callOrder);\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t}"
      },
      {
        "name": "MethodUnderTestProvidedToBeforeAfter",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(InstrumentedTestClass).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tInstrumentedTestClass.Reset();\n\n\t\t\tcommand.Execute(new InstrumentedTestClass());\n\n\t\t\tAssert.Same(methodInfo, BeforeAfterSpyAttribute.beforeMethod);\n\t\t\tAssert.Same(methodInfo, BeforeAfterSpyAttribute.afterMethod);\n\t\t}"
      },
      {
        "name": "BeforeTestThrows",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(InstrumentedTestClass).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tInstrumentedTestClass.Reset();\n\t\t\tBeforeAfterSpyAttribute.beforeTestThrowCount = 1;\n\n\t\t\tAssert.Throws<Exception>(() => command.Execute(new InstrumentedTestClass()));\n\n\t\t\tAssert.Equal(1, BeforeAfterSpyAttribute.beforeTestCount);\n\t\t\tAssert.Equal(0, stub.ExecuteCount);\n\t\t\tAssert.Equal(0, BeforeAfterSpyAttribute.afterTestCount);\n\t\t}"
      },
      {
        "name": "AfterTestThrows",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(InstrumentedTestClass).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tInstrumentedTestClass.Reset();\n\t\t\tBeforeAfterSpyAttribute.afterTestThrowCount = 1;\n\n\t\t\tAssert.Throws<AfterTestException>(() => command.Execute(new InstrumentedTestClass()));\n\n\t\t\tAssert.Equal(1, BeforeAfterSpyAttribute.beforeTestCount);\n\t\t\tAssert.Equal(1, stub.ExecuteCount);\n\t\t\tAssert.Equal(1, BeforeAfterSpyAttribute.afterTestCount);\n\t\t}"
      },
      {
        "name": "MultipleBeforeAfterTestAttributesAllCalled",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(BeforeAfterDoubleSpy).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tBeforeAfterDoubleSpy.Reset();\n\n\t\t\tcommand.Execute(new BeforeAfterDoubleSpy());\n\n\t\t\tAssert.Equal(2, BeforeAfterSpyAttribute.beforeTestCount);\n\t\t\tAssert.Equal(1, stub.ExecuteCount);\n\t\t\tAssert.Equal(2, BeforeAfterSpyAttribute.afterTestCount);\n\t\t}"
      },
      {
        "name": "MultipleBeforeTestsSecondThrows",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tBeforeAfterSpyAttribute.Reset();\n\t\t\tBeforeAfterSpyAttribute.beforeTestThrowCount = 2;\n\n\t\t\tAssert.Throws<Exception>(() => command.Execute(new MultipleAttributeSpy()));\n\n\t\t\tAssert.Equal(2, BeforeAfterSpyAttribute.beforeTestCount);\n\t\t\tAssert.Equal(0, stub.ExecuteCount);\n\t\t\tAssert.Equal(1, BeforeAfterSpyAttribute.afterTestCount);\n\t\t}"
      },
      {
        "name": "MultipleAfterTestsSecondThrows",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tBeforeAfterSpyAttribute.Reset();\n\t\t\tBeforeAfterSpyAttribute.afterTestThrowCount = 2;\n\n\t\t\tAfterTestException ex = Assert.Throws<AfterTestException>(() => command.Execute(new MultipleAttributeSpy()));\n\n\t\t\tAssert.Equal(3, BeforeAfterSpyAttribute.beforeTestCount);\n\t\t\tAssert.Equal(1, stub.ExecuteCount);\n\t\t\tAssert.Equal(3, BeforeAfterSpyAttribute.afterTestCount);\n\t\t\tAssert.Equal(2, ex.AfterExceptions.Count);\n\t\t}"
      },
      {
        "name": "BeforeThrowsAfterThrowsShouldResultInBeforeException",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand();\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tBeforeAfterSpyAttribute.Reset();\n\t\t\tBeforeAfterSpyAttribute.beforeTestThrowCount = 2;\n\t\t\tBeforeAfterSpyAttribute.afterTestThrowCount = 1;\n\n\t\t\tAssert.Throws<Exception>(() => command.Execute(new MultipleAttributeSpy()));\n\t\t}"
      },
      {
        "name": "TestThrowsAfterThrowsShouldResultInTestException",
        "body": "{\n\t\t\tMethodInfo methodInfo = typeof(MultipleAttributeSpy).GetMethod(\"PassedTest\");\n\t\t\tStubTestCommand stub = new StubTestCommand { ThrowsOnExecute = true };\n\t\t\tBeforeAfterCommand command = new BeforeAfterCommand(stub, methodInfo);\n\t\t\tBeforeAfterSpyAttribute.Reset();\n\t\t\tBeforeAfterSpyAttribute.afterTestThrowCount = 1;\n\n\t\t\tAssert.Throws<Exception>(() => command.Execute(new InstrumentedTestClass()));\n\t\t}"
      }
    ]
  },
  {
    "file": "ExceptionAndOutputCaptureCommandTests.cs",
    "methods": [
      {
        "name": "ShouldWrapExceptionDetailsWhenExceptionIsThrown",
        "body": "{\n\t\t\t\tExceptionThrowingCommand innerCmd = new ExceptionThrowingCommand();\n\t\t\t\tMethodInfo method = typeof(ExceptionThrowingCommand).GetMethod(\"Execute\");\n\t\t\t\tvar command = new ExceptionAndOutputCaptureCommand(innerCmd, Reflector.Wrap(method));\n\n\t\t\t\tMethodResult result = command.Execute(null);\n\n\t\t\t\tFailedResult failed = Assert.IsType<FailedResult>(result);\n\t\t\t\tAssert.Equal(method.Name, failed.MethodName);\n\t\t\t\tAssert.Equal(method.DeclaringType.FullName, failed.TypeName);\n\t\t\t\tAssert.Equal(typeof(TargetInvocationException).FullName, failed.ExceptionType);\n\t\t\t\tAssert.Contains(\"ExceptionThrowingCommand.Execute\", failed.StackTrace);\n\t\t\t}"
      },
      {
        "name": "ConsoleOutAndErrorAreReplacedDuringTestExecution",
        "body": "{\n\t\t\t\tTextWriter originalOut = Console.Out;\n\t\t\t\tTextWriter originalError = Console.Error;\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tTextWriter newOut = new StringWriter();\n\t\t\t\t\tTextWriter newError = new StringWriter();\n\t\t\t\t\tConsole.SetOut(newOut);\n\t\t\t\t\tConsole.SetError(newError);\n\t\t\t\t\tStubCommand cmd = new StubCommand();\n\t\t\t\t\tvar outputCmd = new ExceptionAndOutputCaptureCommand(cmd, null);\n\n\t\t\t\t\toutputCmd.Execute(null);\n\n\t\t\t\t\tAssert.Empty(newOut.ToString());\n\t\t\t\t\tAssert.Empty(newError.ToString());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tConsole.SetOut(originalOut);\n\t\t\t\t\tConsole.SetError(originalError);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "ConsoleOutAndErrorAndTraceIsCapturedAndPlacedInMethodResult",
        "body": "{\n\t\t\t\tstring expected = \"Standard Output\" + Environment.NewLine +\n\t\t\t\t\t\t\t\t  \"Standard Error\" + Environment.NewLine +\n\t\t\t\t\t\t\t\t  \"Trace\" + Environment.NewLine;\n\n\t\t\t\tStubCommand cmd = new StubCommand();\n\t\t\t\tvar outputCmd = new ExceptionAndOutputCaptureCommand(cmd, null);\n\n\t\t\t\tMethodResult result = outputCmd.Execute(null);\n\n\t\t\t\tAssert.Equal(expected, result.Output);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "FactCommandTests.cs",
    "methods": [
      {
        "name": "ExecuteRunsTest",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");\n\t\t\tTestCommand command = new FactCommand(Reflector.Wrap(method));\n\t\t\tTestMethodCommandClass.testCounter = 0;\n\n\t\t\tcommand.Execute(new TestMethodCommandClass());\n\n\t\t\tAssert.Equal(1, TestMethodCommandClass.testCounter);\n\t\t}"
      },
      {
        "name": "TestMethodReturnPassedResult",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");\n\t\t\tTestCommand command = new FactCommand(Reflector.Wrap(method));\n\n\t\t\tMethodResult result = command.Execute(new TestMethodCommandClass());\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t}"
      }
    ]
  },
  {
    "file": "LifetimeCommandTests.cs",
    "methods": [
      {
        "name": "CreatesNewInstanceWhenPassedNull",
        "body": "{\n\t\t\tStubCommand innerCommand = new StubCommand();\n\t\t\tMethodInfo method = typeof(StubCommand).GetMethod(\"Execute\");\n\t\t\tLifetimeCommand command = new LifetimeCommand(innerCommand, Reflector.Wrap(method));\n\n\t\t\tcommand.Execute(null);\n\n\t\t\tAssert.NotNull(innerCommand.TestClass);\n\t\t}"
      },
      {
        "name": "ConstructorThrowsTestNotCalledDisposeNotCalled",
        "body": "{\n\t\t\tMethodInfo method = typeof(SpyWithConstructorThrow).GetMethod(\"PassedTest\");\n\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\tTestCommand testCommand = new FactCommand(wrappedMethod);\n\t\t\tLifetimeCommand command = new LifetimeCommand(testCommand, wrappedMethod);\n\t\t\tSpyWithConstructorThrow.Reset();\n\n\t\t\tRecord.Exception(() => command.Execute(null));\n\n\t\t\tAssert.Equal(1, SpyWithConstructorThrow.ctorCalled);\n\t\t\tAssert.Equal(0, SpyWithConstructorThrow.testCalled);\n\t\t\tAssert.Equal(0, SpyWithConstructorThrow.disposeCalled);\n\t\t}"
      },
      {
        "name": "ConstructorThrowsTargetInvocationExceptionIsUnwrappedAndRethrown",
        "body": "{\n\t\t\tMethodInfo method = typeof(SpyWithConstructorThrow).GetMethod(\"PassedTest\");\n\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\tFactCommand factCommand = new FactCommand(wrappedMethod);\n\t\t\tLifetimeCommand command = new LifetimeCommand(factCommand, wrappedMethod);\n\t\t\tSpyWithConstructorThrow.Reset();\n\n\t\t\tException ex = Record.Exception(() => command.Execute(null));\n\n\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t}"
      },
      {
        "name": "DoesNotCreateNewInstanceWhenPassedExistingInstance",
        "body": "{\n\t\t\tStubCommand innerCommand = new StubCommand();\n\t\t\tMethodInfo method = typeof(StubCommand).GetMethod(\"Execute\");\n\t\t\tLifetimeCommand command = new LifetimeCommand(innerCommand, Reflector.Wrap(method));\n\t\t\tobject instance = new object();\n\n\t\t\tcommand.Execute(instance);\n\n\t\t\tAssert.Same(instance, innerCommand.TestClass);\n\t\t}"
      },
      {
        "name": "DisposeThrowsTestCalled",
        "body": "{\n\t\t\tMethodInfo method = typeof(SpyWithDisposeThrow).GetMethod(\"PassedTest\");\n\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\tTestCommand testCommand = new FactCommand(wrappedMethod);\n\t\t\tLifetimeCommand command = new LifetimeCommand(testCommand, wrappedMethod);\n\t\t\tSpyWithDisposeThrow.Reset();\n\n\t\t\tRecord.Exception(() => command.Execute(new SpyWithDisposeThrow()));\n\n\t\t\tAssert.Equal(1, SpyWithDisposeThrow.ctorCalled);\n\t\t\tAssert.Equal(1, SpyWithDisposeThrow.testCalled);\n\t\t\tAssert.Equal(1, SpyWithDisposeThrow.disposeCalled);\n\t\t}"
      },
      {
        "name": "DuringTestThrowsDisposeCalled",
        "body": "{\n\t\t\tMethodInfo method = typeof(SpyWithTestThrow).GetMethod(\"FailedTest\");\n\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\tTestCommand testCommand = new FactCommand(wrappedMethod);\n\t\t\tLifetimeCommand command = new LifetimeCommand(testCommand, wrappedMethod);\n\t\t\tSpyWithTestThrow.Reset();\n\n\t\t\tRecord.Exception(() => command.Execute(new SpyWithTestThrow()));\n\n\t\t\tAssert.Equal(1, SpyWithTestThrow.ctorCalled);\n\t\t\tAssert.Equal(1, SpyWithTestThrow.testCalled);\n\t\t\tAssert.Equal(1, SpyWithTestThrow.disposeCalled);\n\t\t}"
      }
    ]
  },
  {
    "file": "SkipCommandTests.cs",
    "methods": [
      {
        "name": "SkipReturnSkipResult",
        "body": "{\n\t\t\tMethodInfo method = typeof(SpyStub).GetMethod(\"Skip\");\n\t\t\tSkipCommand command = new SkipCommand(Reflector.Wrap(method), null, \"reason\");\n\n\t\t\tMethodResult result = command.Execute(new SpyStub());\n\n\t\t\tSkipResult skipResult = Assert.IsType<SkipResult>(result);\n\t\t\tAssert.Equal(\"reason\", skipResult.Reason);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestCommandFactoryTests.cs",
    "methods": [
      {
        "name": "CallsTestClassCommandToGetTestCommandsAndWrapsTheminTimedCommands",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestCommandFactoryTests).GetMethod(\"PublicTestMethod\");\n\t\t\tList<ITestCommand> testCommands = new List<ITestCommand>();\n\t\t\tStubTestClassCommand classCommand = new StubTestClassCommand();\n\t\t\ttestCommands.Add(new StubTestCommand());\n\t\t\tclassCommand.EnumerateTestCommands__Result = testCommands;\n\n\t\t\tList<ITestCommand> result = new List<ITestCommand>(TestCommandFactory.Make(classCommand, Reflector.Wrap(method)));\n\n\t\t\tAssert.Same(method, classCommand.EnumerateTestCommands_TestMethod.MethodInfo);\n\t\t\tAssert.Equal(testCommands.Count, result.Count);\n\t\t\tvar timedCommand = Assert.IsType<TimedCommand>(result[0]);\n\t\t\tvar captureCommand = Assert.IsType<ExceptionAndOutputCaptureCommand>(timedCommand.InnerCommand);\n\t\t\tvar lifetimeCommand = Assert.IsType<LifetimeCommand>(captureCommand.InnerCommand);\n\t\t\tvar beforeAfterCommand = Assert.IsType<BeforeAfterCommand>(lifetimeCommand.InnerCommand);\n\t\t\tAssert.Same(testCommands[0], beforeAfterCommand.InnerCommand);\n\t\t}"
      },
      {
        "name": "DoesNotIncludeCreationCommandWhenTestCommandSaysNotToCreateInstance",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestCommandFactoryTests).GetMethod(\"PublicTestMethod\");\n\t\t\tList<ITestCommand> testCommands = new List<ITestCommand>();\n\t\t\tStubTestClassCommand classCommand = new StubTestClassCommand();\n\t\t\tStubTestCommand testCommand = new StubTestCommand();\n\t\t\ttestCommand.ShouldCreateInstance__Result = false;\n\t\t\ttestCommands.Add(testCommand);\n\t\t\tclassCommand.EnumerateTestCommands__Result = testCommands;\n\n\t\t\tList<ITestCommand> result = new List<ITestCommand>(TestCommandFactory.Make(classCommand, Reflector.Wrap(method)));\n\n\t\t\tAssert.Same(method, classCommand.EnumerateTestCommands_TestMethod.MethodInfo);\n\t\t\tAssert.Equal(testCommands.Count, result.Count);\n\t\t\tvar timedCommand = Assert.IsType<TimedCommand>(result[0]);\n\t\t\tvar captureCommand = Assert.IsType<ExceptionAndOutputCaptureCommand>(timedCommand.InnerCommand);\n\t\t\tvar beforeAfterCommand = Assert.IsType<BeforeAfterCommand>(captureCommand.InnerCommand);\n\t\t\tAssert.Same(testCommands[0], beforeAfterCommand.InnerCommand);\n\t\t}"
      },
      {
        "name": "IncludesTimeoutCommandWhenTestCommandSaysTheresATimeout",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestCommandFactoryTests).GetMethod(\"PublicTestMethod\");\n\t\t\tList<ITestCommand> testCommands = new List<ITestCommand>();\n\t\t\tStubTestClassCommand classCommand = new StubTestClassCommand();\n\t\t\ttestCommands.Add(new StubTestCommand { Timeout__Result = 153 });\n\t\t\tclassCommand.EnumerateTestCommands__Result = testCommands;\n\n\t\t\tList<ITestCommand> result = new List<ITestCommand>(TestCommandFactory.Make(classCommand, Reflector.Wrap(method)));\n\n\t\t\tAssert.Same(method, classCommand.EnumerateTestCommands_TestMethod.MethodInfo);\n\t\t\tAssert.Equal(testCommands.Count, result.Count);\n\t\t\tAssert.IsType<TimeoutCommand>(result[0]);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestCommandTests.cs",
    "methods": [
      {
        "name": "TestCommandReturnsStartXml_WithoutDisplayName",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");\n\t\t\tMock<TestCommand> command = new Mock<TestCommand>(Reflector.Wrap(method), null, 0);\n\t\t\tcommand.CallBase = true;\n\n\t\t\tXmlNode result = command.Object.ToStartXml();\n\n\t\t\tAssert.Equal(\"start\", result.Name);\n\t\t\tResultXmlUtility.AssertAttribute(result, \"name\", typeof(TestMethodCommandClass).FullName + \".TestMethod\");\n\t\t\tResultXmlUtility.AssertAttribute(result, \"type\", typeof(TestMethodCommandClass).FullName);\n\t\t\tResultXmlUtility.AssertAttribute(result, \"method\", \"TestMethod\");\n\t\t}"
      },
      {
        "name": "TestCommandReturnsStartXml_WithDisplayName",
        "body": "{\n\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"TestMethod\");\n\t\t\tMock<TestCommand> command = new Mock<TestCommand>(Reflector.Wrap(method), \"Display Name!\", 0);\n\t\t\tcommand.CallBase = true;\n\n\t\t\tXmlNode result = command.Object.ToStartXml();\n\n\t\t\tAssert.Equal(\"start\", result.Name);\n\t\t\tResultXmlUtility.AssertAttribute(result, \"name\", \"Display Name!\");\n\t\t\tResultXmlUtility.AssertAttribute(result, \"type\", typeof(TestMethodCommandClass).FullName);\n\t\t\tResultXmlUtility.AssertAttribute(result, \"method\", \"TestMethod\");\n\t\t}"
      }
    ]
  },
  {
    "file": "TimedCommandTests.cs",
    "methods": [
      {
        "name": "MeasuresTime",
        "body": "{\n\t\t\tTimedCommand command = new TimedCommand(new DummyCommand());\n\n\t\t\tMethodResult result = command.Execute(null);\n\n\t\t\tAssert.InRange(result.ExecutionTime, 0.01, 100.0);\n\t\t}"
      }
    ]
  },
  {
    "file": "TimeoutCommandTests.cs",
    "methods": [
      {
        "name": "TestFinshedOnTimePassedResult",
        "body": "{\n\t\t\tMock<ITestCommand> testCommand = new Mock<ITestCommand>();\n\t\t\ttestCommand\n\t\t\t\t.Setup(tc => tc.Execute(null))\n\t\t\t\t.Returns(new PassedResult(GetMethodInfo(), null));\n\t\t\tTimeoutCommand command = new TimeoutCommand(testCommand.Object, 10000, GetMethodInfo());\n\n\t\t\tMethodResult result = command.Execute(null);\n\n\t\t\tAssert.IsType<PassedResult>(result);\n\t\t}"
      },
      {
        "name": "TestTookTooLongFailedResult",
        "body": "{\n\t\t\tMock<ITestCommand> testCommand = new Mock<ITestCommand>();\n\t\t\ttestCommand\n\t\t\t\t.Setup(tc => tc.Execute(null))\n\t\t\t\t.Callback<object>(_ => Thread.Sleep(500));\n\t\t\tTimeoutCommand command = new TimeoutCommand(testCommand.Object, 20, GetMethodInfo());\n\n\t\t\tMethodResult result = command.Execute(null);\n\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(\"Test execution time exceeded: 20ms\", failedResult.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "AssertActualExpectedExceptionTests.cs",
    "methods": [
      {
        "name": "ActualValueWrapsForMultiline",
        "body": "{\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 0\" + Environment.NewLine +\n\t\t\t\t\"Expected: expected\" + Environment.NewLine +\n\t\t\t\t\"Actual:   line 1\" + Environment.NewLine +\n\t\t\t\t\"          line 2\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(\n\t\t\t\t\t\"expected\",\n\t\t\t\t\t\"line 1\" + Environment.NewLine + \"line 2\",\n\t\t\t\t\t\"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "ArraysShowDifferencePoint",
        "body": "{\n\t\t\tint[] actualValue = new int[] { 1, 2, 3, 4, 5 };\n\t\t\tint[] expectedValue = new int[] { 1, 2, 5, 7, 9 };\n\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 2\" + Environment.NewLine +\n\t\t\t\t\"Expected: Int32[] { 1, 2, 5, 7, 9 }\" + Environment.NewLine +\n\t\t\t\t\"Actual:   Int32[] { 1, 2, 3, 4, 5 }\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "ListsShowDifferencePoint",
        "body": "{\n\t\t\tvar actualValue = new List<int> { 1, 2, 3, 4, 5 };\n\t\t\tvar expectedValue = new List<int> { 1, 2, 5, 7, 9 };\n\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 2\" + Environment.NewLine +\n\t\t\t\t\"Expected: List<Int32> { 1, 2, 5, 7, 9 }\" + Environment.NewLine +\n\t\t\t\t\"Actual:   List<Int32> { 1, 2, 3, 4, 5 }\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "MixedEnumerationShowDifferencePoint",
        "body": "{\n\t\t\tvar expectedValue = MakeEnumeration(1, 42, \"Hello\").ToList();\n\t\t\tvar actualValue = MakeEnumeration(1, 2.3, \"Goodbye\").ToList();\n\n\t\t\tstring expectedMessage =\n\t\t\t\tstring.Format(\"Message{0}Position: First difference is at position 1{0}Expected: List<Object> {{ 1, 42, \\\"Hello\\\" }}{0}Actual:   List<Object> {{ 1, {1}, \\\"Goodbye\\\" }}\", Environment.NewLine, 2.3);\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "NullValuesInArraysCreateCorrectExceptionMessage",
        "body": "{\n\t\t\tstring[] expectedValue = new string[] { null, \"hello\" };\n\t\t\tstring[] actualValue = new string[] { null, \"world\" };\n\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 1\" + Environment.NewLine +\n\t\t\t\t\"Expected: String[] { (null), \\\"hello\\\" }\" + Environment.NewLine +\n\t\t\t\t\"Actual:   String[] { (null), \\\"world\\\" }\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "ExpectedAndActualAreUsedInMessage",
        "body": "{\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Expected: 2\" + Environment.NewLine +\n\t\t\t\t\"Actual:   1\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(2, 1, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "ExpectedValueWrapsForMultiline",
        "body": "{\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 0\" + Environment.NewLine +\n\t\t\t\t\"Expected: line 1\" + Environment.NewLine +\n\t\t\t\t\"          line 2\" + Environment.NewLine +\n\t\t\t\t\"Actual:   actual\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(\n\t\t\t\t\t\"line 1\" + Environment.NewLine + \"line 2\",\n\t\t\t\t\t\"actual\",\n\t\t\t\t\t\"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "OneStringAddsValueToEndOfTheOtherString",
        "body": "{\n\t\t\tstring actualValue = \"first test\";\n\t\t\tstring expectedValue = \"first test 1\";\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 10\" + Environment.NewLine +\n\t\t\t\t\"Expected: first test 1\" + Environment.NewLine +\n\t\t\t\t\"Actual:   first test\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "OneStringOneNullDoesNotShowDifferencePoint",
        "body": "{\n\t\t\tstring actualValue = null;\n\t\t\tstring expectedValue = \"first test 1\";\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Expected: first test 1\" + Environment.NewLine +\n\t\t\t\t\"Actual:   (null)\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "PreservesExpectedAndActual",
        "body": "{\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(2, 1, null);\n\n\t\t\tAssert.Equal(\"1\", ex.Actual);\n\t\t\tAssert.Equal(\"2\", ex.Expected);\n\t\t\tAssert.Null(ex.UserMessage);\n\t\t}"
      },
      {
        "name": "StringsDifferInTheMiddle",
        "body": "{\n\t\t\tstring actualValue = \"first test\";\n\t\t\tstring expectedValue = \"first failure\";\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Position: First difference is at position 6\" + Environment.NewLine +\n\t\t\t\t\"Expected: first failure\" + Environment.NewLine +\n\t\t\t\t\"Actual:   first test\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(expectedValue, actualValue, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "SameVisibleValueDifferentTypes",
        "body": "{\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Expected: 1 (System.String)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   1 (System.Int32)\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(\"1\", 1, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "DifferentVisibleValueDifferentTypes",
        "body": "{\n\t\t\tstring expectedMessage =\n\t\t\t\t\"Message\" + Environment.NewLine +\n\t\t\t\t\"Expected: 2\" + Environment.NewLine +\n\t\t\t\t\"Actual:   1\";\n\n\t\t\tAssertActualExpectedException ex =\n\t\t\t\tnew AssertActualExpectedException(\"2\", 1, \"Message\");\n\n\t\t\tAssert.Equal(expectedMessage, ex.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "AssertExceptionTests.cs",
    "methods": [
      {
        "name": "PreservesUserMessage",
        "body": "{\n\t\t\tAssertException ex = new AssertException(\"UserMessage\");\n\n\t\t\tAssert.Equal(\"UserMessage\", ex.UserMessage);\n\t\t}"
      },
      {
        "name": "UserMessageIsTheMessage",
        "body": "{\n\t\t\tAssertException ex = new AssertException(\"UserMessage\");\n\n\t\t\tAssert.Equal(ex.UserMessage, ex.Message);\n\t\t}"
      },
      {
        "name": "DeveloperCanChooseWhichStackFrameItemsToExclude",
        "body": "{\n\t\t\tCustomException ex = Assert.Throws<CustomException>(() => { throw new CustomException(); });\n\n\t\t\tstring stackTrace = ex.StackTrace;\n\n\t\t\tAssert.Empty(stackTrace);  // Everything was filtered out in our exception\n\t\t\tAssert.Equal(2, ex.StackFrames.Count);\n\t\t\tAssert.Contains(\"Xunit1.AssertExceptionTests\", ex.StackFrames[0]);\n\t\t\tAssert.Contains(\"Xunit.Record.Exception\", ex.StackFrames[1]);\n\t\t}"
      },
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalException = new TestableAssertException(\"User Message\", \"Stack Trace\");\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tAssert.Equal(originalException.StackTrace, deserializedException.StackTrace);\n\t\t\tAssert.Equal(originalException.UserMessage, deserializedException.UserMessage);\n\t\t}"
      }
    ]
  },
  {
    "file": "DoesNotThrowExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalException = new TestableDoesNotThrowException(\"Stack Trace\");\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tAssert.Equal(originalException.StackTrace, deserializedException.StackTrace);\n\t\t}"
      }
    ]
  },
  {
    "file": "ExceptionRequirementTests.cs",
    "methods": []
  },
  {
    "file": "InRangeExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalException = new InRangeException(\"Actual\", \"Low\", \"High\");\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tAssert.Equal(originalException.Actual, deserializedException.Actual);\n\t\t\tAssert.Equal(originalException.Low, deserializedException.Low);\n\t\t\tAssert.Equal(originalException.High, deserializedException.High);\n\t\t}"
      }
    ]
  },
  {
    "file": "NotInRangeExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalException = new NotInRangeException(\"Actual\", \"Low\", \"High\");\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tAssert.Equal(originalException.Actual, deserializedException.Actual);\n\t\t\tAssert.Equal(originalException.Low, deserializedException.Low);\n\t\t\tAssert.Equal(originalException.High, deserializedException.High);\n\t\t}"
      }
    ]
  },
  {
    "file": "ThrowsExceptionTests.cs",
    "methods": [
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalException = new TestableThrowsException(\"Stack Trace\");\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tAssert.Equal(originalException.StackTrace, deserializedException.StackTrace);\n\t\t}"
      }
    ]
  },
  {
    "file": "TraceAssertExceptionTests.cs",
    "methods": [
      {
        "name": "TraceAssertFailureWithFullDetails",
        "body": "{\n\t\t\tTraceAssertException ex = Assert.Throws<TraceAssertException>(() => Trace.Assert(false, \"message\", \"detailed message\"));\n\n\t\t\tAssert.Equal(\"message\", ex.AssertMessage);\n\t\t\tAssert.Equal(\"detailed message\", ex.AssertDetailedMessage);\n\t\t\tAssert.Equal(\"Debug.Assert() Failure : message\" + Environment.NewLine + \"Detailed Message:\" + Environment.NewLine + \"detailed message\", ex.Message);\n\t\t}"
      },
      {
        "name": "TraceAssertFailureWithNoDetailedMessage",
        "body": "{\n\t\t\tTraceAssertException ex = Assert.Throws<TraceAssertException>(() => Trace.Assert(false, \"message\"));\n\n\t\t\tAssert.Equal(\"message\", ex.AssertMessage);\n\t\t\tAssert.Equal(\"\", ex.AssertDetailedMessage);\n\t\t\tAssert.Equal(\"Debug.Assert() Failure : message\", ex.Message);\n\t\t}"
      },
      {
        "name": "TraceAssertFailureWithNoMessage",
        "body": "{\n\t\t\t// Mono does \"non-standard\" things with the message when it's empty\n\t\t\tif (!EnvironmentHelper.IsMono)\n\t\t\t{\n\t\t\t\tTraceAssertException ex = Assert.Throws<TraceAssertException>(() => Trace.Assert(false));\n\n\t\t\t\tAssert.Equal(\"\", ex.AssertMessage);\n\n\t\t\t\tAssert.Equal(\"\", ex.AssertDetailedMessage);\n\t\t\t\tAssert.Equal(\"Debug.Assert() Failure\", ex.Message);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "SerializesCustomProperties",
        "body": "{\n\t\t\tvar originalException = new TraceAssertException(\"Assert Message\", \"Detailed Message\");\n\n\t\t\tvar deserializedException = SerializationUtility.SerializeAndDeserialize(originalException);\n\n\t\t\tAssert.Equal(originalException.AssertMessage, deserializedException.AssertMessage);\n\t\t\tAssert.Equal(originalException.AssertDetailedMessage, deserializedException.AssertDetailedMessage);\n\t\t}"
      }
    ]
  },
  {
    "file": "ExecutorCallbackTests.cs",
    "methods": [
      {
        "name": "IMessageSink",
        "body": "{\n\t\t\t\tIMessage msg = null;\n\t\t\t\tvar handler = new Mock<IMessageSink>();\n\t\t\t\thandler\n\t\t\t\t\t.Setup(h => h.SyncProcessMessage(It.IsAny<IMessage>()))\n\t\t\t\t\t.Callback<IMessage>(_msg => msg = _msg)\n\t\t\t\t\t.Returns((IMessage)null);\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\n\t\t\t\tcallback.Notify(\"This is the callback value\");\n\n\t\t\t\tAssert.Equal(\"This is the callback value\", msg.Properties[\"data\"]);\n\t\t\t}"
      },
      {
        "name": "ICallbackEventHandler",
        "body": "{\n\t\t\t\tvar handler = new Mock<ICallbackEventHandler>();\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\n\t\t\t\tcallback.Notify(\"This is the callback value\");\n\n\t\t\t\thandler.Verify(h => h.RaiseCallbackEvent(\"This is the callback value\"), Times.Once());\n\t\t\t}"
      },
      {
        "name": "NullCallbackDoesNotThrow",
        "body": "{\n\t\t\t\tvar callback = ExecutorCallback.Wrap(null);\n\n\t\t\t\tAssert.DoesNotThrow(() => callback.Notify(\"This is the callback value\"));\n\t\t\t}"
      },
      {
        "name": "IMessageSinkReturnsTrueByDefault",
        "body": "{\n\t\t\t\tvar handler = new Mock<IMessageSink>();\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\t\t\t\t// Don't call Notify here\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.True(result);\n\t\t\t}"
      },
      {
        "name": "IMessageSinkReturningTrue",
        "body": "{\n\t\t\t\tvar values = new Hashtable { { \"data\", \"true\" } };\n\t\t\t\tvar message = new Mock<IMessage>();\n\t\t\t\tmessage.Setup(m => m.Properties).Returns(values);\n\t\t\t\tvar handler = new Mock<IMessageSink>();\n\t\t\t\thandler\n\t\t\t\t\t.Setup(h => h.SyncProcessMessage(It.IsAny<IMessage>()))\n\t\t\t\t\t.Returns(message.Object);\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\t\t\t\t// Have to call Notify() because that's how we discover the intended ShouldContinue value\n\t\t\t\tcallback.Notify(null);\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.True(result);\n\t\t\t}"
      },
      {
        "name": "IMessageSinkReturningFalse",
        "body": "{\n\t\t\t\tvar values = new Hashtable { { \"data\", \"false\" } };\n\t\t\t\tvar message = new Mock<IMessage>();\n\t\t\t\tmessage.Setup(m => m.Properties).Returns(values);\n\t\t\t\tvar handler = new Mock<IMessageSink>();\n\t\t\t\thandler\n\t\t\t\t\t.Setup(h => h.SyncProcessMessage(It.IsAny<IMessage>()))\n\t\t\t\t\t.Returns(message.Object);\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\t\t\t\t// Have to call Notify() because that's how we discover the intended ShouldContinue value\n\t\t\t\tcallback.Notify(null);\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.False(result);\n\t\t\t}"
      },
      {
        "name": "ICallbackEventHandlerReturningTrue",
        "body": "{\n\t\t\t\tvar handler = new Mock<ICallbackEventHandler>();\n\t\t\t\thandler.Setup(h => h.GetCallbackResult()).Returns(\"true\");\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.True(result);\n\t\t\t}"
      },
      {
        "name": "ICallbackEventHandlerReturningFalse",
        "body": "{\n\t\t\t\tvar handler = new Mock<ICallbackEventHandler>();\n\t\t\t\thandler.Setup(h => h.GetCallbackResult()).Returns(\"false\");\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.False(result);\n\t\t\t}"
      },
      {
        "name": "ICallbackEventHandlerReturningNull",
        "body": "{\n\t\t\t\tvar handler = new Mock<ICallbackEventHandler>();\n\t\t\t\tvar callback = ExecutorCallback.Wrap(handler.Object);\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.True(result);\n\t\t\t}"
      },
      {
        "name": "NullCallbackAlwaysReturnsTrue",
        "body": "{\n\t\t\t\tvar callback = ExecutorCallback.Wrap(null);\n\n\t\t\t\tvar result = callback.ShouldContinue();\n\n\t\t\t\tAssert.True(result);\n\t\t\t}"
      },
      {
        "name": "UnsupportedCallbackTypeThrows",
        "body": "{\n\t\t\t\tExecutorCallback wrapper = ExecutorCallback.Wrap(42);\n\n\t\t\t\tvar ex = Record.Exception(() => wrapper.Notify(\"Notification\"));\n\n\t\t\t\tAssert.IsType<TargetException>(ex);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "AssemblyResultTests.cs",
    "methods": [
      {
        "name": "AssemblyResultCodeBase",
        "body": "{\n\t\t\tAssemblyResult assemblyResult = new AssemblyResult(filename);\n\n\t\t\tAssert.Equal(Path.GetDirectoryName(Path.GetFullPath(filename)), assemblyResult.Directory);\n\t\t}"
      },
      {
        "name": "AssemblyResultName",
        "body": "{\n\t\t\tAssemblyResult assemblyResult = new AssemblyResult(filename);\n\n\t\t\tAssert.Equal(Path.GetFullPath(filename), assemblyResult.Filename);\n\t\t}"
      },
      {
        "name": "AssemblyResultConfigFilename",
        "body": "{\n\t\t\tAssemblyResult assemblyResult = new AssemblyResult(filename, fullPathName);\n\n\t\t\tAssert.Equal(fullPathName, assemblyResult.ConfigFilename);\n\t\t}"
      },
      {
        "name": "ToXml",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tAssemblyResult assemblyResult = new AssemblyResult(filename, fullPathName);\n\n\t\t\tXmlNode resultNode = assemblyResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"assembly\", resultNode.Name);\n\t\t\tAssert.Equal(Path.GetFullPath(filename), resultNode.Attributes[\"name\"].Value);\n\t\t\tAssert.Equal(fullPathName, resultNode.Attributes[\"configFile\"].Value);\n\t\t\tAssert.NotNull(resultNode.Attributes[\"run-date\"]);\n\t\t\tAssert.NotNull(resultNode.Attributes[\"run-time\"]);\n\t\t\tAssert.Equal(\"0.000\", resultNode.Attributes[\"time\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"total\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"passed\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"failed\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"skipped\"].Value);\n\t\t\tAssert.Contains(\"xUnit.net\", resultNode.Attributes[\"test-framework\"].Value);\n\t\t\tstring expectedEnvironment = string.Format(\"{0}-bit .NET {1}\", IntPtr.Size * 8, Environment.Version);\n\t\t\tAssert.Equal(expectedEnvironment, resultNode.Attributes[\"environment\"].Value);\n\t\t}"
      },
      {
        "name": "ToXml_WithChildren",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tPassedResult passedResult = new PassedResult(\"foo\", \"bar\", null, null);\n\t\t\tpassedResult.ExecutionTime = 1.1;\n\t\t\tFailedResult failedResult = new FailedResult(\"foo\", \"bar\", null, null, \"extype\", \"message\", \"stack\");\n\t\t\tfailedResult.ExecutionTime = 2.2;\n\t\t\tSkipResult skipResult = new SkipResult(\"foo\", \"bar\", null, null, \"reason\");\n\t\t\tClassResult classResult = new ClassResult(typeof(object));\n\t\t\tclassResult.Add(passedResult);\n\t\t\tclassResult.Add(failedResult);\n\t\t\tclassResult.Add(skipResult);\n\t\t\tAssemblyResult assemblyResult = new AssemblyResult(filename);\n\t\t\tassemblyResult.Add(classResult);\n\n\t\t\tXmlNode resultNode = assemblyResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"3.300\", resultNode.Attributes[\"time\"].Value);\n\t\t\tAssert.Equal(\"3\", resultNode.Attributes[\"total\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"passed\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"failed\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"skipped\"].Value);\n\t\t\tAssert.Single(resultNode.SelectNodes(\"class\"));\n\t\t}"
      }
    ]
  },
  {
    "file": "ClassResultTests.cs",
    "methods": [
      {
        "name": "ConstructorGuardClauses",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(() => new ClassResult(null));\n\t\t}"
      },
      {
        "name": "ConstructWithStrings",
        "body": "{\n\t\t\tClassResult result = new ClassResult(\"name\", \"fullname\", \"namespace\");\n\n\t\t\tAssert.Equal(\"fullname\", result.FullyQualifiedName);\n\t\t\tAssert.Equal(\"name\", result.Name);\n\t\t\tAssert.Equal(\"namespace\", result.Namespace);\n\t\t}"
      },
      {
        "name": "ConstructWithType",
        "body": "{\n\t\t\tClassResult result = new ClassResult(typeof(object));\n\n\t\t\tAssert.Equal(typeof(object).FullName, result.FullyQualifiedName);\n\t\t\tAssert.Equal(typeof(object).Name, result.Name);\n\t\t\tAssert.Equal(typeof(object).Namespace, result.Namespace);\n\t\t}"
      },
      {
        "name": "SetAssertException",
        "body": "{\n\t\t\tClassResult result = new ClassResult(typeof(object));\n\t\t\tException thrownException;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthrow new EqualException(2, 3);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrownException = ex;\n\t\t\t\tresult.SetException(ex);\n\t\t\t}\n\n\t\t\tAssert.Equal(thrownException.GetType().FullName, result.ExceptionType);\n\t\t\tAssert.Equal(thrownException.Message, result.Message);\n\t\t\tAssert.Equal(thrownException.StackTrace, result.StackTrace);\n\t\t}"
      },
      {
        "name": "SetExceptionNull",
        "body": "{\n\t\t\tClassResult result = new ClassResult(typeof(object));\n\n\t\t\tresult.SetException(null);\n\n\t\t\tAssert.Null(result.ExceptionType);\n\t\t\tAssert.Null(result.Message);\n\t\t\tAssert.Null(result.StackTrace);\n\t\t}"
      },
      {
        "name": "SetNonAssertException",
        "body": "{\n\t\t\tClassResult result = new ClassResult(typeof(object));\n\t\t\tException thrownException;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthrow new Exception(\"message\");\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrownException = ex;\n\t\t\t\tresult.SetException(ex);\n\t\t\t}\n\n\t\t\tAssert.Equal(thrownException.GetType().FullName, result.ExceptionType);\n\t\t\tAssert.Equal(result.ExceptionType + \" : \" + thrownException.Message, result.Message);\n\t\t\tAssert.Equal(thrownException.StackTrace, result.StackTrace);\n\t\t}"
      },
      {
        "name": "SetNonAssertExceptionWithInnerException",
        "body": "{\n\t\t\tClassResult result = new ClassResult(typeof(object));\n\t\t\tException thrownException = null;\n\t\t\tException innerException = null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tthrow new InvalidOperationException();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tinnerException = ex;\n\t\t\t\t\tthrow new Exception(\"message\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrownException = ex;\n\t\t\t\tresult.SetException(ex);\n\t\t\t}\n\n\t\t\tstring expectedMessage = string.Format(\n\t\t\t\t\"{0} : {1}{2}---- {3} : {4}\",\n\t\t\t\tthrownException.GetType().FullName,\n\t\t\t\tthrownException.Message,\n\t\t\t\tEnvironment.NewLine,\n\t\t\t\tinnerException.GetType().FullName,\n\t\t\t\tinnerException.Message);\n\n\t\t\tAssert.Equal(expectedMessage, result.Message);\n\n\t\t\tstring expectedStackTrace =\n\t\t\t\tstring.Format(\n\t\t\t\t\t\"{0}{1}----- Inner Stack Trace -----{1}{2}\",\n\t\t\t\t\tthrownException.StackTrace,\n\t\t\t\t\tEnvironment.NewLine,\n\t\t\t\t\tinnerException.StackTrace);\n\n\t\t\tAssert.Equal(expectedStackTrace, result.StackTrace);\n\t\t}"
      },
      {
        "name": "ToXml",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tClassResult classResult = new ClassResult(typeof(object));\n\n\t\t\tXmlNode resultNode = classResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"class\", resultNode.Name);\n\t\t\tAssert.Equal(classResult.FullyQualifiedName, resultNode.Attributes[\"name\"].Value);\n\t\t\tAssert.Equal(\"0.000\", resultNode.Attributes[\"time\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"total\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"passed\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"failed\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"skipped\"].Value);\n\t\t}"
      },
      {
        "name": "ToXml_WithChildren",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tClassResult classResult = new ClassResult(typeof(object));\n\t\t\tPassedResult passedResult = new PassedResult(\"foo\", \"bar\", null, null);\n\t\t\tpassedResult.ExecutionTime = 1.1;\n\t\t\tFailedResult failedResult = new FailedResult(\"foo\", \"bar\", null, null, \"extype\", \"message\", \"stack\");\n\t\t\tfailedResult.ExecutionTime = 2.2;\n\t\t\tSkipResult skipResult = new SkipResult(\"foo\", \"bar\", null, null, \"reason\");\n\t\t\tclassResult.Add(passedResult);\n\t\t\tclassResult.Add(failedResult);\n\t\t\tclassResult.Add(skipResult);\n\n\t\t\tXmlNode resultNode = classResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"3.300\", resultNode.Attributes[\"time\"].Value);\n\t\t\tAssert.Equal(\"3\", resultNode.Attributes[\"total\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"passed\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"failed\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"skipped\"].Value);\n\t\t\tAssert.Equal(3, resultNode.SelectNodes(\"test\").Count);\n\t\t}"
      },
      {
        "name": "ToXml_WithClassFailure",
        "body": "{\n\t\t\tException ex;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthrow new InvalidOperationException(\"message\");\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tex = e;\n\t\t\t}\n\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tClassResult classResult = new ClassResult(typeof(object));\n\t\t\tclassResult.SetException(ex);\n\n\t\t\tXmlNode resultNode = classResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"class\", resultNode.Name);\n\t\t\tAssert.Equal(classResult.FullyQualifiedName, resultNode.Attributes[\"name\"].Value);\n\t\t\tAssert.Equal(\"0.000\", resultNode.Attributes[\"time\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"total\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"passed\"].Value);\n\t\t\tAssert.Equal(\"1\", resultNode.Attributes[\"failed\"].Value);\n\t\t\tAssert.Equal(\"0\", resultNode.Attributes[\"skipped\"].Value);\n\t\t\tXmlNode failureNode = resultNode.SelectSingleNode(\"failure\");\n\t\t\tAssert.Equal(ex.GetType().FullName, failureNode.Attributes[\"exception-type\"].Value);\n\t\t\tAssert.Equal(ExceptionUtility.GetMessage(ex), failureNode.SelectSingleNode(\"message\").InnerText);\n\t\t\tAssert.Equal(ExceptionUtility.GetStackTrace(ex), failureNode.SelectSingleNode(\"stack-trace\").InnerText);\n\t\t}"
      },
      {
        "name": "ToXmlTwiceDoesNotDoubleCounts",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tClassResult classResult = new ClassResult(typeof(object));\n\t\t\tPassedResult passedResult = new PassedResult(\"foo\", \"bar\", null, null);\n\t\t\tpassedResult.ExecutionTime = 1.1;\n\t\t\tFailedResult failedResult = new FailedResult(\"foo\", \"bar\", null, null, \"extype\", \"message\", \"stack\");\n\t\t\tfailedResult.ExecutionTime = 2.2;\n\t\t\tSkipResult skipResult = new SkipResult(\"foo\", \"bar\", null, null, \"reason\");\n\t\t\tclassResult.Add(passedResult);\n\t\t\tclassResult.Add(failedResult);\n\t\t\tclassResult.Add(skipResult);\n\n\t\t\tXmlNode resultNode1 = classResult.ToXml(parentNode);\n\t\t\tXmlNode resultNode2 = classResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(resultNode1.Attributes[\"time\"].Value, resultNode2.Attributes[\"time\"].Value);\n\t\t\tAssert.Equal(resultNode1.Attributes[\"total\"].Value, resultNode2.Attributes[\"total\"].Value);\n\t\t\tAssert.Equal(resultNode1.Attributes[\"passed\"].Value, resultNode2.Attributes[\"passed\"].Value);\n\t\t\tAssert.Equal(resultNode1.Attributes[\"failed\"].Value, resultNode2.Attributes[\"failed\"].Value);\n\t\t\tAssert.Equal(resultNode1.Attributes[\"skipped\"].Value, resultNode2.Attributes[\"skipped\"].Value);\n\t\t\tAssert.Equal(resultNode1.SelectNodes(\"test\").Count, resultNode2.SelectNodes(\"test\").Count);\n\t\t}"
      }
    ]
  },
  {
    "file": "CompositeResultsTests.cs",
    "methods": [
      {
        "name": "AddResult",
        "body": "{\n\t\t\tStubResult stubResult = new StubResult();\n\n\t\t\tStubCompositeResult compositeResult = new StubCompositeResult();\n\t\t\tcompositeResult.Add(stubResult);\n\n\t\t\tAssert.Single(compositeResult.Results);\n\t\t\tAssert.True(compositeResult.Results.Contains(stubResult));\n\t\t}"
      },
      {
        "name": "AddResultsMultiple",
        "body": "{\n\t\t\tStubResult stubResult1 = new StubResult();\n\t\t\tStubResult stubResult2 = new StubResult();\n\t\t\tStubResult stubResult3 = new StubResult();\n\n\t\t\tStubCompositeResult compositeResult = new StubCompositeResult();\n\t\t\tcompositeResult.Add(stubResult1);\n\t\t\tcompositeResult.Add(stubResult2);\n\t\t\tcompositeResult.Add(stubResult3);\n\n\t\t\tAssert.Equal(3, compositeResult.Results.Count);\n\t\t\tAssert.True(compositeResult.Results.Contains(stubResult1));\n\t\t\tAssert.True(compositeResult.Results.Contains(stubResult2));\n\t\t\tAssert.True(compositeResult.Results.Contains(stubResult3));\n\t\t}"
      },
      {
        "name": "ResultsShouldBeReadOnly",
        "body": "{\n\t\t\tStubCompositeResult result = new StubCompositeResult();\n\n\t\t\tAssert.True(result.Results.IsReadOnly);\n\t\t}"
      }
    ]
  },
  {
    "file": "FailedResultTests.cs",
    "methods": [
      {
        "name": "InitializeFailedResult",
        "body": "{\n\t\t\tType stubType = typeof(StubClass);\n\t\t\tMethodInfo method = stubType.GetMethod(\"StubMethod\");\n\t\t\tStubException stubException = new StubException(\"Message\", \"StackTrace\");\n\n\t\t\tFailedResult result = new FailedResult(Reflector.Wrap(method), stubException, null);\n\t\t\tresult.ExecutionTime = 1.2;\n\n\t\t\tAssert.Equal(\"StubMethod\", result.MethodName);\n\t\t\tAssert.Equal(stubType.FullName, result.TypeName);\n\t\t\tAssert.Equal(typeof(StubException).FullName + \" : Message\", result.Message);\n\t\t\tAssert.Equal(1.2, result.ExecutionTime);\n\t\t\tAssert.Equal(\"StackTrace\", result.StackTrace);\n\t\t}"
      },
      {
        "name": "InitializeFailedResultWithMultipleInnerExceptions",
        "body": "{\n\t\t\tType stubType = typeof(StubClass);\n\t\t\tMethodInfo method = stubType.GetMethod(\"StubMethod\");\n\t\t\tException thrownException = null;\n\t\t\tException innerException = null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tthrow new InvalidOperationException();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tinnerException = ex;\n\t\t\t\t\tthrow new Exception(\"message\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrownException = ex;\n\t\t\t}\n\n\t\t\tFailedResult result = new FailedResult(Reflector.Wrap(method), thrownException, null);\n\n\t\t\tresult.ExecutionTime = 1.2;\n\n\t\t\tstring expectedMessage = string.Format(\n\t\t\t\t\"{0} : {1}{2}---- {3} : {4}\",\n\t\t\t\tthrownException.GetType().FullName,\n\t\t\t\tthrownException.Message,\n\t\t\t\tEnvironment.NewLine,\n\t\t\t\tinnerException.GetType().FullName,\n\t\t\t\tinnerException.Message);\n\n\t\t\tAssert.Equal(expectedMessage, result.Message);\n\n\t\t\tstring expectedStackTrace =\n\t\t\t\tstring.Format(\n\t\t\t\t\t\"{0}{1}----- Inner Stack Trace -----{1}{2}\",\n\t\t\t\t\tthrownException.StackTrace,\n\t\t\t\t\tEnvironment.NewLine,\n\t\t\t\t\tinnerException.StackTrace);\n\n\t\t\tAssert.Equal(expectedStackTrace, result.StackTrace);\n\t\t}"
      },
      {
        "name": "ToXml",
        "body": "{\n\t\t\tException ex = new Exception();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tThrowAnException();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tex = e;\n\t\t\t}\n\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"StubMethod\");\n\t\t\tFailedResult failedResult = new FailedResult(Reflector.Wrap(method), ex, null);\n\t\t\tfailedResult.ExecutionTime = 1.2;\n\n\t\t\tXmlNode resultNode = failedResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"Fail\", resultNode.Attributes[\"result\"].Value);\n\t\t\tAssert.Equal(\"1.200\", resultNode.Attributes[\"time\"].Value);\n\t\t\tXmlNode failureXmlNode = resultNode.SelectSingleNode(\"failure\");\n\t\t\tAssert.NotNull(failureXmlNode);\n\t\t\tAssert.Equal(ex.GetType().FullName, failureXmlNode.Attributes[\"exception-type\"].Value);\n\t\t\tAssert.Equal(ex.GetType().FullName + \" : \" + ex.Message, failureXmlNode.SelectSingleNode(\"message\").InnerText);\n\t\t\tAssert.Equal(ex.StackTrace, failureXmlNode.SelectSingleNode(\"stack-trace\").InnerText);\n\t\t\tAssert.Null(resultNode.SelectSingleNode(\"reason\"));\n\t\t}"
      }
    ]
  },
  {
    "file": "MethodResultTests.cs",
    "methods": [
      {
        "name": "ConstructWithMethodInfo",
        "body": "{\n\t\t\tType stubType = typeof(StubClass);\n\t\t\tMethodInfo method = stubType.GetMethod(\"Method\");\n\n\t\t\tMethodResult result = new TestableMethodResult(Reflector.Wrap(method));\n\n\t\t\tAssert.Equal(\"Method\", result.MethodName);\n\t\t\tAssert.Equal(typeof(StubClass).FullName, result.TypeName);\n\t\t\tAssert.Equal(0.0, result.ExecutionTime);\n\t\t\tAssert.Equal(0, result.Traits.Count);\n\t\t}"
      },
      {
        "name": "ConstructWithMethodInfoWithProperties",
        "body": "{\n\t\t\tType stubType = typeof(StubClass);\n\t\t\tMethodInfo method = stubType.GetMethod(\"MethodWithTraits\");\n\n\t\t\tMethodResult result = new TestableMethodResult(Reflector.Wrap(method));\n\n\t\t\tAssert.Equal(2, result.Traits.Count);\n\t\t}"
      },
      {
        "name": "ToXml",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"Method\");\n\t\t\tTestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method));\n\n\t\t\tXmlNode resultNode = methodResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"test\", resultNode.Name);\n\t\t\tAssert.Equal(methodResult.TypeName, resultNode.Attributes[\"type\"].Value);\n\t\t\tAssert.Equal(methodResult.MethodName, resultNode.Attributes[\"method\"].Value);\n\t\t\tAssert.Equal(methodResult.TypeName + \".\" + methodResult.MethodName, resultNode.Attributes[\"name\"].Value);\n\t\t\tAssert.Null(resultNode.SelectSingleNode(\"traits\"));\n\t\t\tAssert.Null(resultNode.SelectSingleNode(\"output\"));\n\t\t}"
      },
      {
        "name": "ToXmlWithDisplayName",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"Method\");\n\t\t\tTestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method), \"Display Name\");\n\n\t\t\tXmlNode resultNode = methodResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"Display Name\", resultNode.Attributes[\"name\"].Value);\n\t\t}"
      },
      {
        "name": "ToXmlWithTraits",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"MethodWithTraits\");\n\t\t\tTestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method));\n\n\t\t\tXmlNode resultNode = methodResult.ToXml(parentNode);\n\n\t\t\tXmlNode traitsNode = resultNode.SelectSingleNode(\"traits\");\n\t\t\tAssert.NotNull(traitsNode);\n\t\t\tXmlNodeList traitNodes = traitsNode.SelectNodes(\"trait\");\n\t\t\tAssert.Equal(\"larry\", FindTrait(traitNodes, \"author\").Attributes[\"value\"].Value);\n\t\t\tAssert.Equal(\"PassedResults\", FindTrait(traitNodes, \"Class\").Attributes[\"value\"].Value);\n\t\t}"
      },
      {
        "name": "ToXmlWithOutput",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"Method\");\n\t\t\tTestableMethodResult methodResult = new TestableMethodResult(Reflector.Wrap(method), \"Display Name\");\n\t\t\tmethodResult.Output = \"This is my output!\";\n\n\t\t\tXmlNode resultNode = methodResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"This is my output!\", resultNode.SelectSingleNode(\"output\").InnerText);\n\t\t}"
      },
      {
        "name": "Method",
        "body": "{ }"
      },
      {
        "name": "MethodWithParams",
        "body": "{ }"
      },
      {
        "name": "MethodWithTraits",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "PassedResultTests.cs",
    "methods": [
      {
        "name": "ToXml",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"StubMethod\");\n\t\t\tPassedResult passedResult = new PassedResult(Reflector.Wrap(method), null);\n\t\t\tpassedResult.ExecutionTime = 1.2;\n\n\t\t\tXmlNode resultNode = passedResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"Pass\", resultNode.Attributes[\"result\"].Value);\n\t\t\tAssert.Equal(\"1.200\", resultNode.Attributes[\"time\"].Value);\n\t\t\tAssert.Null(resultNode.SelectSingleNode(\"failure\"));\n\t\t\tAssert.Null(resultNode.SelectSingleNode(\"reason\"));\n\t\t}"
      }
    ]
  },
  {
    "file": "SkipResultTests.cs",
    "methods": [
      {
        "name": "ToXml",
        "body": "{\n\t\t\tXmlDocument doc = new XmlDocument();\n\t\t\tdoc.LoadXml(\"<foo/>\");\n\t\t\tXmlNode parentNode = doc.ChildNodes[0];\n\t\t\tMethodInfo method = typeof(StubClass).GetMethod(\"StubMethod\");\n\t\t\tSkipResult skipResult = new SkipResult(Reflector.Wrap(method), null, \"the reason\");\n\n\t\t\tXmlNode resultNode = skipResult.ToXml(parentNode);\n\n\t\t\tAssert.Equal(\"Skip\", resultNode.Attributes[\"result\"].Value);\n\t\t\tAssert.Null(resultNode.Attributes[\"success\"]);\n\t\t\tAssert.Null(resultNode.Attributes[\"time\"]);\n\t\t\tAssert.Null(resultNode.SelectSingleNode(\"failure\"));\n\t\t\tAssert.Equal(\"the reason\", resultNode.SelectSingleNode(\"reason/message\").InnerText);\n\t\t}"
      }
    ]
  },
  {
    "file": "MethodUtilityTests.cs",
    "methods": [
      {
        "name": "ReturnsNullWithNoDisplayName",
        "body": "{\n\t\t\t\tstring methodName = \"WithoutDisplayName\";\n\t\t\t\tType testClassType = typeof(ClassWithDisplayName);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(methodName);\n\n\t\t\t\tvar result = MethodUtility.GetDisplayName(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Null(result);\n\t\t\t}"
      },
      {
        "name": "ReturnsDisplayNameFromFact",
        "body": "{\n\t\t\t\tstring methodName = \"WithDisplayName\";\n\t\t\t\tType testClassType = typeof(ClassWithDisplayName);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(methodName);\n\n\t\t\t\tvar result = MethodUtility.GetDisplayName(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Equal(\"My Display Name\", result);\n\t\t\t}"
      },
      {
        "name": "WithDisplayName",
        "body": "{ }"
      },
      {
        "name": "WithoutDisplayName",
        "body": "{ }"
      },
      {
        "name": "MultipleTraitsOnATestMethod",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"MultipleTestTraitsOnAMethod\");\n\n\t\t\t\tvar traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Equal(2, traits.Count);\n\t\t\t\tstring description = Assert.Single(traits[\"Description\"]);\n\t\t\t\tAssert.Equal(\"more than just the test method name\", description);\n\t\t\t\tstring author = Assert.Single(traits[\"Author\"]);\n\t\t\t\tAssert.Equal(\"James Newkirk\", author);\n\t\t\t}"
      },
      {
        "name": "NoTraits",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"MethodDoesNotHaveTestTraits\");\n\n\t\t\t\tvar traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Equal(0, traits.Count);\n\t\t\t}"
      },
      {
        "name": "SingleTraitOnATestMethod",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"SingleTraitOnAMethod\");\n\n\t\t\t\tvar traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Single(traits);\n\t\t\t\tstring description = Assert.Single(traits[\"Description\"]);\n\t\t\t\tAssert.Equal(\"more than just the test method name\", description);\n\t\t\t}"
      },
      {
        "name": "TraitsOnClass",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithClassTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestMethod\");\n\n\t\t\t\tvar traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Equal(2, traits.Count);\n\t\t\t\tstring description = Assert.Single(traits[\"Description\"]);\n\t\t\t\tAssert.Equal(\"more than just the test method name\", description);\n\t\t\t\tstring author = Assert.Single(traits[\"Author\"]);\n\t\t\t\tAssert.Equal(\"James Newkirk\", author);\n\t\t\t}"
      },
      {
        "name": "DuplicatedTraitsOnClassAndMethodAreNotDuplicated",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithClassTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestMethodWithTraits\");\n\n\t\t\t\tvar traits = MethodUtility.GetTraits(Reflector.Wrap(methodInfo));\n\n\t\t\t\tAssert.Equal(2, traits.Count);\n\t\t\t\tstring description = Assert.Single(traits[\"Description\"]);\n\t\t\t\tAssert.Equal(\"more than just the test method name\", description);\n\t\t\t\tstring author = Assert.Single(traits[\"Author\"]);\n\t\t\t\tAssert.Equal(\"James Newkirk\", author);\n\t\t\t}"
      },
      {
        "name": "CanDecorateTestMethodWithMultipleFactDerivedAttributes",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(Spy).GetMethod(\"TestMethod\");\n\n\t\t\t\tList<ITestCommand> commands = new List<ITestCommand>(MethodUtility.GetTestCommands(Reflector.Wrap(method)));\n\n\t\t\t\tAssert.Equal(2, commands.Count);\n\t\t\t}"
      },
      {
        "name": "MethodDoesNotHaveTraits",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"MethodDoesNotHaveTestTraits\");\n\n\t\t\t\tAssert.False(MethodUtility.HasTraits(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "MethodHasATrait",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"SingleTraitOnAMethod\");\n\n\t\t\t\tAssert.True(MethodUtility.HasTraits(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "ClassHasTrait",
        "body": "{\n\t\t\t\tType testClassType = typeof(ClassWithClassTraits);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestMethod\");\n\n\t\t\t\tAssert.True(MethodUtility.HasTraits(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestMethodWithNoTimeoutParameter",
        "body": "{\n\t\t\t\tType testClassType = typeof(TimeoutTestClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithNoTimeoutParameter\");\n\n\t\t\t\tAssert.False(MethodUtility.HasTimeout(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestMethodWithTimeoutParameter",
        "body": "{\n\t\t\t\tType testClassType = typeof(TimeoutTestClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithTimeoutParameter\");\n\n\t\t\t\tAssert.True(MethodUtility.HasTimeout(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TimeoutParameter",
        "body": "{\n\t\t\t\tType testClassType = typeof(TimeoutTestClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithTimeoutParameter\");\n\n\t\t\t\tlong timeout = MethodUtility.GetTimeoutParameter(Reflector.Wrap(methodInfo));\n\t\t\t\tAssert.Equal<long>(1000, timeout);\n\t\t\t}"
      },
      {
        "name": "TestAttributeWithNoTimeoutParameter",
        "body": "{ }"
      },
      {
        "name": "TestAttributeWithTimeoutParameter",
        "body": "{ }"
      },
      {
        "name": "SkipReasonParameter",
        "body": "{\n\t\t\t\tType testClassType = typeof(SkipTestClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithSkipReason\");\n\n\t\t\t\tstring skipReason = MethodUtility.GetSkipReason(Reflector.Wrap(methodInfo));\n\t\t\t\tAssert.Equal(\"reason\", skipReason);\n\t\t\t}"
      },
      {
        "name": "TestMethodDoesNotHaveSkipReasonParameter",
        "body": "{\n\t\t\t\tType testClassType = typeof(SkipTestClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithNoSkipReason\");\n\n\t\t\t\tAssert.False(MethodUtility.IsSkip(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestMethodHasSkipReasonParameter",
        "body": "{\n\t\t\t\tType testClassType = typeof(SkipTestClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"TestAttributeWithSkipReason\");\n\n\t\t\t\tAssert.True(MethodUtility.IsSkip(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestAttributeWithNoSkipReason",
        "body": "{ }"
      },
      {
        "name": "TestAttributeWithSkipReason",
        "body": "{ }"
      },
      {
        "name": "IsATest",
        "body": "{\n\t\t\t\tType testClassType = typeof(TestMethodClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"IsATestMethod\");\n\n\t\t\t\tAssert.True(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "MethodDoesNotHaveTestAttribute",
        "body": "{\n\t\t\t\tType testClassType = typeof(NoTestAttributeClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"NoTestAttribute\");\n\n\t\t\t\tAssert.False(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestMethodIsAbstract",
        "body": "{\n\t\t\t\tType testClassType = typeof(AbstractMethodClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"AbstractMethod\");\n\n\t\t\t\tAssert.False(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestMethodIsStatic",
        "body": "{\n\t\t\t\tType testClassType = typeof(StaticTestMethodClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"StaticTestMethod\");\n\n\t\t\t\tAssert.True(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "TestMethodsCanHaveNonVoidReturnType",
        "body": "{\n\t\t\t\tType testClassType = typeof(NonVoidReturnClass);\n\t\t\t\tMethodInfo methodInfo = testClassType.GetMethod(\"NonVoidTest\");\n\n\t\t\t\tAssert.True(MethodUtility.IsTest(Reflector.Wrap(methodInfo)));\n\t\t\t}"
      },
      {
        "name": "AbstractMethod",
        "body": "No body available"
      },
      {
        "name": "NonVoidTest",
        "body": "{\n\t\t\t\t\treturn null;\n\t\t\t\t}"
      },
      {
        "name": "StaticTestMethod",
        "body": "{ }"
      },
      {
        "name": "IsATestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "MultiValueDictionaryTests.cs",
    "methods": [
      {
        "name": "EmptyDictionary",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tAssert.Equal(0, dictionary.Keys.Count());\n\t\t}"
      },
      {
        "name": "RetrievingUnknownKeyThrows",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tAssert.Throws<KeyNotFoundException>(() => dictionary[\"foo\"]);\n\t\t}"
      },
      {
        "name": "AddSingleValue",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tdictionary.AddValue(\"Key\", \"Value\");\n\n\t\t\tAssert.Contains(\"Key\", dictionary.Keys);\n\t\t\tAssert.Contains(\"Value\", dictionary[\"Key\"]);\n\t\t}"
      },
      {
        "name": "AddTwoValuesForSameKey",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tdictionary.AddValue(\"Key\", \"Value1\");\n\t\t\tdictionary.AddValue(\"Key\", \"Value2\");\n\n\t\t\tAssert.Contains(\"Key\", dictionary.Keys);\n\t\t\tIEnumerable<string> values = dictionary[\"Key\"];\n\t\t\tAssert.Contains(\"Value1\", values);\n\t\t\tAssert.Contains(\"Value2\", values);\n\t\t}"
      },
      {
        "name": "AddSameValueForSameKeyDoesNotDuplicateValue",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tdictionary.AddValue(\"Key\", \"Value1\");\n\t\t\tdictionary.AddValue(\"Key\", \"Value1\");\n\n\t\t\tAssert.Contains(\"Key\", dictionary.Keys);\n\t\t\tIEnumerable<string> values = dictionary[\"Key\"];\n\t\t\tAssert.Single(values);\n\t\t\tAssert.Contains(\"Value1\", values);\n\t\t}"
      },
      {
        "name": "RemoveKey",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\t\t\tdictionary.AddValue(\"Key\", \"Value\");\n\n\t\t\tdictionary.Remove(\"Key\");\n\n\t\t\tAssert.DoesNotContain(\"Key\", dictionary.Keys);\n\t\t}"
      },
      {
        "name": "RemoveKeyForUnknownKeyDoesNotThrow",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tAssert.DoesNotThrow(() => dictionary.Remove(\"Key\"));\n\t\t}"
      },
      {
        "name": "RemoveValue",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\t\t\tdictionary.AddValue(\"Key\", \"Value1\");\n\t\t\tdictionary.AddValue(\"Key\", \"Value2\");\n\n\t\t\tdictionary.RemoveValue(\"Key\", \"Value1\");\n\n\t\t\tAssert.Contains(\"Key\", dictionary.Keys);\n\t\t\tIEnumerable<string> values = dictionary[\"Key\"];\n\t\t\tAssert.DoesNotContain(\"Value1\", values);\n\t\t\tAssert.Contains(\"Value2\", values);\n\t\t}"
      },
      {
        "name": "RemoveValueForUnknownKeyDoesNotThrow",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\n\t\t\tAssert.DoesNotThrow(() => dictionary.RemoveValue(\"Key\", \"Value1\"));\n\t\t}"
      },
      {
        "name": "RemoveValueForUnknownValueDoesNotThrow",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\t\t\tdictionary.AddValue(\"Key\", \"Value1\");\n\n\t\t\tAssert.DoesNotThrow(() => dictionary.RemoveValue(\"Key\", \"Value2\"));\n\t\t}"
      },
      {
        "name": "RemovingLastValueFromKeyRemovesKey",
        "body": "{\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\t\t\tdictionary.AddValue(\"Key\", \"Value1\");\n\n\t\t\tdictionary.RemoveValue(\"Key\", \"Value1\");\n\n\t\t\tAssert.DoesNotContain(\"Key\", dictionary.Keys);\n\t\t}"
      },
      {
        "name": "CanEnumerateKeysAndValuesWithDelegate",
        "body": "{\n\t\t\tstring result = \"\";\n\t\t\tvar dictionary = new Xunit.Sdk.MultiValueDictionary<string, string>();\n\t\t\tdictionary.AddValue(\"Key1\", \"Value1\");\n\t\t\tdictionary.AddValue(\"Key2\", \"Value2\");\n\t\t\tdictionary.AddValue(\"Key2\", \"Value1\");\n\t\t\tdictionary.AddValue(\"Key3\", \"Value7\");\n\n\t\t\tdictionary.ForEach((key, value) => result += key + \": \" + value + \"\\r\\n\");\n\n\t\t\tAssert.Equal(\n\t\t\t\t\"Key1: Value1\\r\\n\" +\n\t\t\t\t\"Key2: Value2\\r\\n\" +\n\t\t\t\t\"Key2: Value1\\r\\n\" +\n\t\t\t\t\"Key3: Value7\\r\\n\", result);\n\t\t}"
      }
    ]
  },
  {
    "file": "ReflectorTests.cs",
    "methods": [
      {
        "name": "CanFindPublicMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PublicMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "CanFindPublicStaticMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PublicStaticMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "CanFindPrivateMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PrivateMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "CanFindPrivateStaticMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PrivateStaticMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "NonExistantMethodReturnsNull",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"NonExistantMethod\");\n\n\t\t\t\tAssert.Null(result);\n\t\t\t}"
      },
      {
        "name": "ReturnsPublicAndPrivateStaticAndNonStaticMethods",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tList<IMethodInfo> methods = new List<IMethodInfo>(typeInfo.GetMethods());\n\n\t\t\t\tforeach (string name in new string[] { \"PrivateMethod\", \"PrivateStaticMethod\", \"PublicMethod\", \"PublicStaticMethod\" })\n\t\t\t\t\tAssert.NotNull(methods.Find(methodInfo => methodInfo.Name == name));\n\n\t\t\t\tAssert.Null(methods.Find(methodInfo => methodInfo.Name == \"Property\"));\n\t\t\t}"
      },
      {
        "name": "ThrowsException",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");\n\t\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\t\tTestMethodCommandClass obj = new TestMethodCommandClass();\n\n\t\t\t\tException ex = Record.Exception(() => wrappedMethod.Invoke(obj));\n\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      },
      {
        "name": "ThrowsTargetInvocationException",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsTargetInvocationException\");\n\t\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\t\tTestMethodCommandClass obj = new TestMethodCommandClass();\n\n\t\t\t\tException ex = Record.Exception(() => wrappedMethod.Invoke(obj));\n\n\t\t\t\tAssert.IsType<TargetInvocationException>(ex);\n\t\t\t}"
      },
      {
        "name": "TurnsTargetParameterCountExceptionIntoParameterCountMismatchException",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");\n\t\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\t\tTestMethodCommandClass obj = new TestMethodCommandClass();\n\n\t\t\t\tException ex = Record.Exception(() => wrappedMethod.Invoke(obj, \"Hello world\"));\n\n\t\t\t\tAssert.IsType<ParameterCountMismatchException>(ex);\n\t\t\t}"
      },
      {
        "name": "PrivateMethod",
        "body": "{ }"
      },
      {
        "name": "PrivateStaticMethod",
        "body": "{ }"
      },
      {
        "name": "PublicMethod",
        "body": "{ }"
      },
      {
        "name": "PublicStaticMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TypeUtilityTests.cs",
    "methods": [
      {
        "name": "ClassContains2MethodsWithTestAttribute",
        "body": "{\n\t\t\tList<IMethodInfo> testMethods =\n\t\t\t\tnew List<IMethodInfo>(TypeUtility.GetTestMethods(Reflector.Wrap(typeof(ClassWith2TestMethods))));\n\n\t\t\tAssert.Equal(2, testMethods.Count);\n\t\t}"
      },
      {
        "name": "ClassContainsNoMethodsWithTestAttribute",
        "body": "{\n\t\t\tList<IMethodInfo> testMethods =\n\t\t\t\tnew List<IMethodInfo>(TypeUtility.GetTestMethods(Reflector.Wrap(typeof(ClassWithNoTestMethods))));\n\n\t\t\tAssert.Equal(0, testMethods.Count);\n\t\t}"
      },
      {
        "name": "ClassContainsTestMethods",
        "body": "{\n\t\t\tAssert.True(TypeUtility.ContainsTestMethods(Reflector.Wrap(typeof(ClassWith2TestMethods))));\n\t\t}"
      },
      {
        "name": "ClassDoesNotContainTestMethods",
        "body": "{\n\t\t\tAssert.False(TypeUtility.ContainsTestMethods(Reflector.Wrap(typeof(ClassWithNoTestMethods))));\n\t\t}"
      },
      {
        "name": "ClassHasRunWithAttributeReturnsTypeThatDoesNotImplementsITestClassCommand",
        "body": "{\n\t\t\tType testClassType = typeof(CustomRunWithInvalidClass);\n\n\t\t\tAssert.Null(TypeUtility.GetRunWith(Reflector.Wrap(testClassType)));\n\t\t}"
      },
      {
        "name": "ClassHasRunWithAttributeReturnsTypeThatImplementsITestClassCommand",
        "body": "{\n\t\t\tType testClassType = typeof(CustomRunWithClass);\n\t\t\tType commandType = TypeUtility.GetRunWith(Reflector.Wrap(testClassType)).Type;\n\n\t\t\tAssert.True(TypeUtility.ImplementsITestClassCommand(Reflector.Wrap(commandType)));\n\t\t}"
      },
      {
        "name": "ClassHasRunWithAttributeWithITestClassCommand",
        "body": "{\n\t\t\tType testClassType = typeof(CustomRunWithClass);\n\t\t\tAssert.True(TypeUtility.HasRunWith(Reflector.Wrap(testClassType)));\n\t\t}"
      },
      {
        "name": "BaseClassCanHaveRunWithAttribute",
        "body": "{\n\t\t\tType testClassType = typeof(RunWithDerivedClass);\n\n\t\t\tType commandType = TypeUtility.GetRunWith(Reflector.Wrap(testClassType)).Type;\n\n\t\t\tAssert.NotNull(commandType);\n\t\t}"
      },
      {
        "name": "CanDetermineIfClassIsStatic",
        "body": "{\n\t\t\tAssert.False(TypeUtility.IsStatic(Reflector.Wrap(typeof(NonStaticClass))));\n\t\t\tAssert.True(TypeUtility.IsStatic(Reflector.Wrap(typeof(StaticClass))));\n\t\t}"
      },
      {
        "name": "Method1",
        "body": "{ }"
      },
      {
        "name": "Method2",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "SerializationTests.cs",
    "methods": [
      {
        "name": "CanSerializeAndDeserializeObjectsInATest",
        "body": "{\n\t\t\tBinaryFormatter bf = new BinaryFormatter();\n\n\t\t\tusing (Stream ms = new MemoryStream())\n\t\t\t{\n\t\t\t\tbf.Serialize(ms, new SerializableObject());\n\t\t\t\tms.Position = 0;\n\t\t\t\tobject o = bf.Deserialize(ms);\n\n\t\t\t\tAssert.IsType(typeof(SerializableObject), o);\n\t\t\t\tAssert.DoesNotThrow(delegate { SerializableObject o2 = (SerializableObject)o; });\n\t\t\t}\n\t\t}"
      }
    ]
  },
  {
    "file": "SingleTests.cs",
    "methods": [
      {
        "name": "NullCollectionThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(() => Assert.Single(null));\n\t\t\t}"
      },
      {
        "name": "EmptyCollectionThrows",
        "body": "{\n\t\t\t\tArrayList collection = new ArrayList();\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 0 elements instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "MultiItemCollectionThrows",
        "body": "{\n\t\t\t\tArrayList collection = new ArrayList { \"Hello\", \"World\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 2 elements instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "SingleItemCollectionDoesNotThrow",
        "body": "{\n\t\t\t\tArrayList collection = new ArrayList { \"Hello\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection));\n\n\t\t\t\tAssert.Null(ex);\n\t\t\t}"
      },
      {
        "name": "SingleItemCollectionReturnsTheItem",
        "body": "{\n\t\t\t\tArrayList collection = new ArrayList { \"Hello\" };\n\n\t\t\t\tobject result = Assert.Single(collection);\n\n\t\t\t\tAssert.Equal(\"Hello\", result);\n\t\t\t}"
      },
      {
        "name": "NullCollectionThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(() => Assert.Single(null, null));\n\t\t\t}"
      },
      {
        "name": "ObjectSingleMatch",
        "body": "{\n\t\t\t\tIEnumerable collection = new[] { \"Hello\", \"World!\" };\n\n\t\t\t\tAssert.Single(collection, \"Hello\");\n\t\t\t}"
      },
      {
        "name": "NullSingleMatch",
        "body": "{\n\t\t\t\tIEnumerable collection = new[] { \"Hello\", \"World!\", null };\n\n\t\t\t\tAssert.Single(collection, null);\n\t\t\t}"
      },
      {
        "name": "ObjectNoMatch",
        "body": "{\n\t\t\t\tIEnumerable collection = new[] { \"Hello\", \"World!\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection, \"foo\"));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 0 instances of 'foo' instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "PredicateTooManyMatches",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\", \"World!\", \"Hello\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection, \"Hello\"));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 2 instances of 'Hello' instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "NullCollectionThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(() => Assert.Single<object>(null));\n\t\t\t}"
      },
      {
        "name": "EmptyCollectionThrows",
        "body": "{\n\t\t\t\tobject[] collection = new object[0];\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 0 elements instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "MultiItemCollectionThrows",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\", \"World!\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 2 elements instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "SingleItemCollectionDoesNotThrow",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection));\n\n\t\t\t\tAssert.Null(ex);\n\t\t\t}"
      },
      {
        "name": "SingleItemCollectionReturnsTheItem",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\" };\n\n\t\t\t\tstring result = Assert.Single(collection);\n\n\t\t\t\tAssert.Equal(\"Hello\", result);\n\t\t\t}"
      },
      {
        "name": "NullCollectionThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(() => Assert.Single<object>(null, _ => true));\n\t\t\t}"
      },
      {
        "name": "NullPredicateThrows",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(() => Assert.Single<object>(new object[0], null));\n\t\t\t}"
      },
      {
        "name": "PredicateSingleMatch",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\", \"World!\" };\n\n\t\t\t\tstring result = Assert.Single(collection, item => item.StartsWith(\"H\"));\n\n\t\t\t\tAssert.Equal(\"Hello\", result);\n\t\t\t}"
      },
      {
        "name": "PredicateNoMatch",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\", \"World!\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection, item => false));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 0 elements instead of 1.\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "PredicateTooManyMatches",
        "body": "{\n\t\t\t\tstring[] collection = new[] { \"Hello\", \"World!\" };\n\n\t\t\t\tException ex = Record.Exception(() => Assert.Single(collection, item => true));\n\n\t\t\t\tAssert.IsType<SingleException>(ex);\n\t\t\t\tAssert.Equal(\"The collection contained 2 elements instead of 1.\", ex.Message);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "StubTestClassCommand.cs",
    "methods": []
  },
  {
    "file": "StubTestCommand.cs",
    "methods": []
  },
  {
    "file": "ThrowsTests.cs",
    "methods": [
      {
        "name": "DoesNotThrowException",
        "body": "{\n\t\t\t\tbool methodCalled = false;\n\n\t\t\t\tAssert.DoesNotThrow(() => methodCalled = true);\n\n\t\t\t\tAssert.True(methodCalled);\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws<ArgumentException>(delegate { });\n\t\t\t\t}\n\t\t\t\tcatch (AssertActualExpectedException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"(No exception was thrown)\", exception.Actual);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws<Exception>(delegate { throw new InvalidOperationException(); });\n\t\t\t\t}\n\t\t\t\tcatch (AssertException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "GotExpectedException",
        "body": "{\n\t\t\t\tArgumentException ex =\n\t\t\t\t\tAssert.Throws<ArgumentException>(delegate { throw new ArgumentException(); });\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws<ArgumentException>(() => accessor.SuccessfulProperty);\n\t\t\t\t}\n\t\t\t\tcatch (AssertActualExpectedException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"(No exception was thrown)\", exception.Actual);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws<Exception>(() => accessor.FailingProperty);\n\t\t\t\t}\n\t\t\t\tcatch (AssertException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "GotExpectedException",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\tInvalidOperationException ex =\n\t\t\t\t\tAssert.Throws<InvalidOperationException>(() => accessor.FailingProperty);\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws(typeof(ArgumentException), delegate { });\n\t\t\t\t}\n\t\t\t\tcatch (AssertActualExpectedException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"(No exception was thrown)\", exception.Actual);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws(typeof(Exception), delegate { throw new InvalidOperationException(); });\n\t\t\t\t}\n\t\t\t\tcatch (AssertException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "GotExpectedException",
        "body": "{\n\t\t\t\tException ex =\n\t\t\t\t\tAssert.Throws(typeof(ArgumentException), delegate { throw new ArgumentException(); });\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t\tAssert.IsType<ArgumentException>(ex);\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeDoesNotThrow",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws(typeof(ArgumentException), () => accessor.SuccessfulProperty);\n\t\t\t\t}\n\t\t\t\tcatch (AssertActualExpectedException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"(No exception was thrown)\", exception.Actual);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "ExpectExceptionButCodeThrowsDerivedException",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tAssert.Throws(typeof(Exception), () => accessor.FailingProperty);\n\t\t\t\t}\n\t\t\t\tcatch (AssertException exception)\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Assert.Throws() Failure\", exception.UserMessage);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "GotExpectedException",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\tException ex =\n\t\t\t\t\tAssert.Throws(typeof(InvalidOperationException), () => accessor.FailingProperty);\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "TrueTests.cs",
    "methods": [
      {
        "name": "AssertTrue",
        "body": "{\n\t\t\tAssert.True(true);\n\t\t}"
      },
      {
        "name": "AssertTrueThrowsExceptionWhenFalse",
        "body": "{\n\t\t\tTrueException exception = Assert.Throws<TrueException>(() => Assert.True(false));\n\n\t\t\tAssert.Equal(\"Assert.True() Failure\", exception.UserMessage);\n\t\t}"
      }
    ]
  },
  {
    "file": "AsyncAcceptanceTests.cs",
    "methods": [
      {
        "name": "Async40AcceptanceTest",
        "body": "{\n\t\t\tIEnumerable<MethodResult> results = RunClass(typeof(Async40AcceptanceTestClass));\n\n\t\t\tMethodResult result = Assert.Single(results);\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(typeof(TrueException).FullName, failedResult.ExceptionType);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\t\treturn Task.Factory.StartNew(() =>\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(1);\n\t\t\t\t})\n\t\t\t\t.ContinueWith(_ =>\n\t\t\t\t{\n\t\t\t\t\tAssert.True(false);\n\t\t\t\t});\n\t\t\t}"
      }
    ]
  },
  {
    "file": "CollectionAcceptanceTests.cs",
    "methods": [
      {
        "name": "TwoClasses_OneInExplicitCollection_OneInDefaultCollection",
        "body": "{\n\t\tvar results = Run(new[] { typeof(ClassInExplicitCollection), typeof(ClassInDefaultCollection) });\n\n\t\tvar defaultResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName.StartsWith(\"Test collection for \"));\n\t\tAssertMessageSequence(defaultResults, \"CollectionAcceptanceTests+ClassInDefaultCollection.Passing\");\n\n\t\tvar explicitResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName == \"Explicit Collection\");\n\t\tAssertMessageSequence(explicitResults, \"CollectionAcceptanceTests+ClassInExplicitCollection.Passing\");\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "FixtureAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestClassMustHaveSinglePublicConstructor",
        "body": "{\n\t\t\tvar messages = Run(typeof(ClassWithTooManyConstructors));\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCollectionStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestClassStarting>(message),\n\n\t\t\t\t// TestMethod1\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);\n\t\t\t\t\tAssert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());\n\t\t\t\t\tAssert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());\n\t\t\t\t},\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodFinished>(message),\n\n\t\t\t\t// TestMethod2\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);\n\t\t\t\t\tAssert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());\n\t\t\t\t\tAssert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());\n\t\t\t\t},\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodFinished>(message),\n\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestClassFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCollectionFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyFinished>(message)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());\n\t\t\tAssert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Collection(\n\t\t\t\tmsg.ExceptionTypes,\n\t\t\t\ttype => Assert.Equal(typeof(TestClassException).FullName, type),\n\t\t\t\ttype => Assert.Equal(typeof(DivideByZeroException).FullName, type)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureDisposeResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithDefaultParameter",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithDefaultCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithDefaultCtorArg.TheTest\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithOptionalParameter",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithOptionalCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithOptionalCtorArg.TheTest\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithParamsParameter",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithParamsArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithParamsArg.TheTest\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataShouldHaveBeenSetup",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ThrowingAsyncSetupShouldResultInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetup));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureAsyncDisposeResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotBeDecoratedWithICollectionFixture",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(TestClassWithCollectionFixture));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());\n\t\t\tAssert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", msg.Messages.Single());\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());\n\t\t\tAssert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsSameInstanceAcrossClasses",
        "body": "{\n\t\t\tRun<ITestPassed>(new[] { typeof(FixtureSaver1), typeof(FixtureSaver2) });\n\n\t\t\tAssert.Same(FixtureSaver1.Fixture, FixtureSaver2.Fixture);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnCollectionDecorationWorks",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy_ClassFixture));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnTestClassTakesPrecedenceOverClassFixtureOnCollection",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithCountedFixture));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureSetupAsyncResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetupAsync));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureAsyncDispose));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "CollectionFixtureAsyncSetupShouldOnlyRunOnce",
        "body": "{\n\t\t\tvar results = Run<ITestPassed>(new[] { typeof(Fixture1), typeof(Fixture2) });\n\t\t\tAssert.Equal(2, results.Count);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "Xunit2AcceptanceTests.cs",
    "methods": [
      {
        "name": "NoTests",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(NoTestsClass));\n\n\t\t\tAssert.Collection(results,\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);\n\t\t\t\t\tAssert.Equal(0, finished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, finished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, finished.TestsSkipped);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SinglePassingTest",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(SinglePassingTestClass));\n\n\t\t\tAssert.Collection(results,\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar collectionStarting = Assert.IsAssignableFrom<ITestCollectionStarting>(message);\n\t\t\t\t\tAssert.NotNull(collectionStarting.TestCollection);\n\t\t\t\t\t// TODO: There will need to be more tests here eventually...\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classStarting = Assert.IsAssignableFrom<ITestClassStarting>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", classStarting.TestClass.Class.Name);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testMethodStarting = Assert.IsAssignableFrom<ITestMethodStarting>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodStarting.TestClass.Class.Name);\n\t\t\t\t\tAssert.Equal(\"TestMethod\", testMethodStarting.TestMethod.Method.Name);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass.TestMethod\", testCaseStarting.TestCase.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestStarting>(message);\n\t\t\t\t\tAssert.Equal(starting.TestCase.DisplayName, starting.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classConstructionStarting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(message);\n\t\t\t\t\tAssert.Equal(classConstructionStarting.TestCase.DisplayName, classConstructionStarting.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classConstructionFinished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(message);\n\t\t\t\t\tAssert.Equal(classConstructionFinished.TestCase.DisplayName, classConstructionFinished.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testPassed = Assert.IsAssignableFrom<ITestPassed>(message);\n\t\t\t\t\tAssert.Equal(testPassed.TestCase.DisplayName, testPassed.Test.DisplayName);\n\t\t\t\t\tAssert.NotEqual(0M, testPassed.ExecutionTime);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testFinished = Assert.IsAssignableFrom<ITestFinished>(message);\n\t\t\t\t\tAssert.Equal(testFinished.TestCase.DisplayName, testFinished.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(message);\n\t\t\t\t\tAssert.Equal(1, testCaseFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, testCaseFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, testCaseFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, testCaseFinished.ExecutionTime);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testMethodFinished = Assert.IsAssignableFrom<ITestMethodFinished>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodFinished.TestClass.Class.Name);\n\t\t\t\t\tAssert.Equal(\"TestMethod\", testMethodFinished.TestMethod.Method.Name);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classFinished = Assert.IsAssignableFrom<ITestClassFinished>(message);\n\t\t\t\t\tAssert.Equal(1, classFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, classFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, classFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, classFinished.ExecutionTime);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar collectionFinished = Assert.IsAssignableFrom<ITestCollectionFinished>(message);\n\t\t\t\t\tAssert.NotNull(collectionFinished.TestCollection);\n\t\t\t\t\tAssert.Equal(1, collectionFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, collectionFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, collectionFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, collectionFinished.ExecutionTime);\n\t\t\t\t\t// TODO: There will need to be more tests here eventually...\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar assemblyFinished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);\n\t\t\t\t\tAssert.Equal(1, assemblyFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, assemblyFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, assemblyFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, assemblyFinished.ExecutionTime);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SingleSkippedTest",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(SingleSkippedTestClass));\n\n\t\t\tvar skippedMessage = Assert.Single(results.OfType<ITestSkipped>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SingleSkippedTestClass.TestMethod\", skippedMessage.Test.DisplayName);\n\t\t\tAssert.Equal(\"This is a skipped test\", skippedMessage.Reason);\n\n\t\t\tvar classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());\n\t\t\tAssert.Equal(1, classFinishedMessage.TestsSkipped);\n\n\t\t\tvar collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());\n\t\t\tAssert.Equal(1, collectionFinishedMessage.TestsSkipped);\n\t\t}"
      },
      {
        "name": "TimedOutTest",
        "body": "{\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar results = Run(typeof(ClassUnderTest));\n\t\t\tstopwatch.Stop();\n\n\t\t\tvar passedMessage = Assert.Single(results.OfType<ITestPassed>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.ShortRunningTest\", passedMessage.Test.DisplayName);\n\n\t\t\tvar failedMessage = Assert.Single(results.OfType<ITestFailed>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.LongRunningTest\", failedMessage.Test.DisplayName);\n\t\t\tAssert.Equal(\"Test execution timed out after 10 milliseconds\", failedMessage.Messages.Single());\n\n\t\t\tAssert.True(stopwatch.ElapsedMilliseconds < 10000, \"Elapsed time should be less than 10 seconds\");\n\t\t}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "TestWithUnstartedTaskThrows",
        "body": "{\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar results = Run(typeof(ClassUnderTest));\n\t\t\tstopwatch.Stop();\n\n\t\t\tvar failedMessage = Assert.Single(results.OfType<ITestFailed>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+NonStartedTasks+ClassUnderTest.NonStartedTask\", failedMessage.Test.DisplayName);\n\t\t\tAssert.Equal(\"Test method returned a non-started Task (tasks must be started before being returned)\", failedMessage.Messages.Single());\n\t\t}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "SingleFailingTest",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(SingleFailingTestClass));\n\n\t\t\tvar failedMessage = Assert.Single(results.OfType<ITestFailed>());\n\t\t\tAssert.Equal(typeof(TrueException).FullName, failedMessage.ExceptionTypes.Single());\n\n\t\t\tvar classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());\n\t\t\tAssert.Equal(1, classFinishedMessage.TestsFailed);\n\n\t\t\tvar collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());\n\t\t\tAssert.Equal(1, collectionFinishedMessage.TestsFailed);\n\t\t}"
      },
      {
        "name": "TestFailureResultsFromThrowingCtorInTestClass",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassUnderTest_CtorFailure));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TestFailureResultsFromThrowingDisposeInTestClass",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassUnderTest_DisposeFailure));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "CompositeTestFailureResultsFromFailingTestsPlusThrowingDisposeInTestClass",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassUnderTest_FailingTestAndDisposeFailure));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tvar combinedMessage = Xunit.ExceptionUtility.CombineMessages(msg);\n\t\t\tAssert.StartsWith(\"System.AggregateException : \", combinedMessage);\n\t\t\tAssert.Contains(\n\t\t\t\t\"---- Assert.Equal() Failure: Values differ\" + Environment.NewLine +\n\t\t\t\t\"Expected: 2\" + Environment.NewLine +\n\t\t\t\t\"Actual:   3\" + Environment.NewLine +\n\t\t\t\t\"---- System.DivideByZeroException : \",\n\t\t\t\tcombinedMessage);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{\n\t\t\t\tAssert.Equal(2, 3);\n\t\t\t}"
      },
      {
        "name": "TestsCanBeInStaticClasses",
        "body": "{\n\t\t\tvar testMessages = Run<ITestResultMessage>(typeof(StaticClassUnderTest));\n\n\t\t\tvar testMessage = Assert.Single(testMessages);\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+StaticClassSupport+StaticClassUnderTest.Passing\", testMessage.Test.DisplayName);\n\t\t\tAssert.IsAssignableFrom<ITestPassed>(testMessage);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "EachTestMethodHasIndividualExceptionMessage",
        "body": "{\n\t\t\tvar testMessages = Run<ITestFailed>(typeof(ClassUnderTest));\n\n\t\t\tvar equalFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.EqualFailure\");\n\t\t\tAssert.Contains(\"Assert.Equal() Failure\", equalFailure.Messages.Single());\n\n\t\t\tvar notNullFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.NotNullFailure\");\n\t\t\tAssert.Contains(\"Assert.NotNull() Failure\", notNullFailure.Messages.Single());\n\t\t}"
      },
      {
        "name": "EqualFailure",
        "body": "{\n\t\t\t\tAssert.Equal(42, 40);\n\t\t\t}"
      },
      {
        "name": "NotNullFailure",
        "body": "{\n\t\t\t\tAssert.NotNull(null);\n\t\t\t}"
      },
      {
        "name": "OverrideOfOrderingAtCollectionLevel",
        "body": "{\n\t\t\tvar testMessages = Run<ITestPassed>(typeof(TestClassUsingCollection));\n\n\t\t\tAssert.Collection(testMessages,\n\t\t\t\tmessage => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "OverrideOfOrderingAtClassLevel",
        "body": "{\n\t\t\tvar testMessages = Run<ITestPassed>(typeof(TestClassWithoutCollection));\n\n\t\t\tAssert.Collection(testMessages,\n\t\t\t\tmessage => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "NonParallelCollectionsRunLast",
        "body": "{\n\t\t\tvar testMessages = Run<ITestPassed>(new[] {\n\t\t\t\ttypeof(TestClassNonParallelCollection),\n\t\t\t\ttypeof(TestClassParallelCollection)\n\t\t\t});\n\n\t\t\tAssert.Collection(testMessages,\n\t\t\t\tmessage => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"IShouldBeLast1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"IShouldBeLast2\", message.TestCase.TestMethod.Method.Name)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast1",
        "body": "{ }"
      },
      {
        "name": "CanUseCustomFactAttribute",
        "body": "{\n\t\t\tvar msgs = Run<ITestPassed>(typeof(ClassWithCustomFact));\n\n\t\t\tvar msg = Assert.Single(msgs);\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomFact.Passing\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "CanUseCustomFactWithArrayParameters",
        "body": "{\n\t\t\tvar msgs = Run<ITestPassed>(typeof(ClassWithCustomArrayFact));\n\n\t\t\tvar msg = Assert.Single(msgs);\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomArrayFact.Passing\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "CannotMixMultipleFactDerivedAttributes",
        "body": "{\n\t\t\tvar msgs = Run<ITestFailed>(typeof(ClassWithMultipleFacts)).ToList();\n\n\t\t\tAssert.Collection(msgs,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing\", msg.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"System.InvalidOperationException\", msg.ExceptionTypes.Single());\n\t\t\t\t\tAssert.Equal(\"Test method 'Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing' has multiple [Fact]-derived attributes\", msg.Messages.Single());\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "SendOutputMessages",
        "body": "{\n\t\t\tvar msgs = Run(typeof(ClassUnderTest));\n\n\t\t\tvar idxOfTestPassed = msgs.FindIndex(msg => msg is ITestPassed);\n\t\t\tAssert.True(idxOfTestPassed >= 0, \"Test should have passed\");\n\n\t\t\tvar idxOfFirstTestOutput = msgs.FindIndex(msg => msg is ITestOutput);\n\t\t\tAssert.True(idxOfFirstTestOutput >= 0, \"Test should have output\");\n\t\t\tAssert.True(idxOfFirstTestOutput < idxOfTestPassed, \"Test output messages should precede test result\");\n\n\t\t\tAssert.Collection(msgs.OfType<ITestOutput>(),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);\n\t\t\t\t\tAssert.Equal(\"This is output in the constructor\" + Environment.NewLine, outputMessage.Output);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);\n\t\t\t\t\tAssert.Equal(\"This is test output\" + Environment.NewLine, outputMessage.Output);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);\n\t\t\t\t\tAssert.Equal(\"This is output in Dispose\" + Environment.NewLine, outputMessage.Output);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\t\toutput.WriteLine(\"This is test output\");\n\t\t\t}"
      },
      {
        "name": "AsyncLifetimeAcceptanceTest",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithAsyncLifetime));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{\n\t\t\t\toutput.WriteLine(\"Run Test\");\n\t\t\t}"
      },
      {
        "name": "ThrowingConstructor",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingCtor));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\");\n\t\t}"
      },
      {
        "name": "ThrowingInitializeAsync",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingInitializeAsync));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "ThrowingDisposeAsync",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingDisposeAsync));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "FailingTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_FailingTest));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\tAssert.True(false);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\tAssert.True(false);\n\t\t}"
      }
    ]
  },
  {
    "file": "TraitHelperTests.cs",
    "methods": [
      {
        "name": "MethodWithNoTraits_ReturnsEmptyList",
        "body": "{\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"NoTraits\");\n\n\t\tvar traits = TraitHelper.GetTraits(method);\n\n\t\tAssert.Empty(traits);\n\t}"
      },
      {
        "name": "MethodWithTraitAttribute_ReturnsTrait",
        "body": "{\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"Trait\");\n\n\t\tvar traits = TraitHelper.GetTraits(method);\n\n\t\tvar value = Assert.Single(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase));\n\t\tAssert.Equal(\"foo = bar\", value);\n\t}"
      },
      {
        "name": "MethodWithCustomTraitAttribute_ReturnsTraitValues",
        "body": "{\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"CustomTrait\");\n\n\t\tvar traits = TraitHelper.GetTraits(method);\n\n\t\tAssert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),\n\t\t\tvalue => Assert.Equal(\"Baz = 2112\", value),\n\t\t\tvalue => Assert.Equal(\"Foo = Biff\", value)\n\t\t);\n\t}"
      },
      {
        "name": "CombinesMultipleTraitSources",
        "body": "{\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"MultipleTraits\");\n\n\t\tvar traits = TraitHelper.GetTraits(method);\n\n\t\tAssert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),\n\t\t\tvalue => Assert.Equal(\"Baz = 2112\", value),\n\t\t\tvalue => Assert.Equal(\"foo = bar\", value),\n\t\t\tvalue => Assert.Equal(\"Foo = Biff\", value),\n\t\t\tvalue => Assert.Equal(\"Hello = World\", value)\n\t\t);\n\t}"
      },
      {
        "name": "MethodWithInheritedCustomTraitAttribute_ReturnsTraitValues",
        "body": "{\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"InheritedTrait\");\n\n\t\tvar traits = TraitHelper.GetTraits(method);\n\n\t\tAssert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),\n\t\t\tvalue => Assert.Equal(\"Baz = 2112\", value),\n\t\t\tvalue => Assert.Equal(\"Foo = Biff\", value)\n\t\t);\n\t}"
      },
      {
        "name": "CombinesInheritedMultipleTraitSources",
        "body": "{\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"InheritedMultipleTraits\");\n\n\t\tvar traits = TraitHelper.GetTraits(method);\n\n\t\tAssert.Collection(traits.Select(kvp => $\"{kvp.Key} = {kvp.Value}\").OrderBy(_ => _, StringComparer.OrdinalIgnoreCase),\n\t\t\tvalue => Assert.Equal(\"Baz = 2112\", value),\n\t\t\tvalue => Assert.Equal(\"foo = bar\", value),\n\t\t\tvalue => Assert.Equal(\"Foo = Biff\", value),\n\t\t\tvalue => Assert.Equal(\"Hello = World\", value)\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "ReflectionAbstractionExtensionsTests.cs",
    "methods": [
      {
        "name": "WhenUsingReflectionMethodInfo_ReturnsExistingMethodInfo",
        "body": "{\n\t\t\tvar methodInfo = Mocks.ReflectionMethodInfo<ToRuntimeMethod>(\"WhenUsingReflectionMethodInfo_ReturnsExistingMethodInfo\");\n\n\t\t\tvar result = methodInfo.ToRuntimeMethod();\n\n\t\t\tAssert.NotNull(result);\n\t\t\tAssert.Same(methodInfo.MethodInfo, result);\n\t\t}"
      },
      {
        "name": "WhenUsingNonReflectionMethodInfo_MethodExists_ReturnsMethodInfo",
        "body": "{\n\t\t\tvar typeInfo = Mocks.TypeInfo(\"ReflectionAbstractionExtensionsTests+ToRuntimeMethod\", assemblyFileName: \"xunit.v2.tests.dll\");\n\t\t\tvar methodInfo = Mocks.MethodInfo(\"WhenUsingNonReflectionMethodInfo_MethodExists_ReturnsMethodInfo\", isStatic: true, type: typeInfo);\n\n\t\t\tvar result = methodInfo.ToRuntimeMethod();\n\n\t\t\tAssert.NotNull(result);\n\t\t\tAssert.Same(typeof(ToRuntimeMethod).GetMethod(\"WhenUsingNonReflectionMethodInfo_MethodExists_ReturnsMethodInfo\"), result);\n\t\t}"
      },
      {
        "name": "WhenUsingNonReflectionMethodInfo_MethodDoesNotExist_ReturnsNull",
        "body": "{\n\t\t\tvar typeInfo = Mocks.TypeInfo(\"ReflectionAbstractionExtensionsTests+ToRuntimeMethod\", assemblyFileName: \"xunit.v2.tests.dll\");\n\t\t\tvar methodInfo = Mocks.MethodInfo(\"UnknownMethod\", isStatic: true, type: typeInfo);\n\n\t\t\tvar result = methodInfo.ToRuntimeMethod();\n\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "WhenUsingReflectionTypeInfo_ReturnsExistingType",
        "body": "{\n\t\t\tvar typeInfo = Mocks.ReflectionTypeInfo<ToRuntimeType>();\n\n\t\t\tvar result = typeInfo.ToRuntimeType();\n\n\t\t\tAssert.NotNull(result);\n\t\t\tAssert.Same(typeInfo.Type, result);\n\t\t}"
      },
      {
        "name": "WhenUsingNonReflectionTypeInfo_TypeExists_ReturnsType",
        "body": "{\n\t\t\tvar typeInfo = Mocks.TypeInfo(\"ReflectionAbstractionExtensionsTests+ToRuntimeType\", assemblyFileName: \"xunit.v2.tests.dll\");\n\n\t\t\tvar result = typeInfo.ToRuntimeType();\n\n\t\t\tAssert.NotNull(result);\n\t\t\tAssert.Same(typeof(ToRuntimeType), result);\n\t\t}"
      },
      {
        "name": "WhenUsingNonReflectionTypeInfo_TypeDoesNotExist_ReturnsNull",
        "body": "{\n\t\t\tvar typeInfo = Mocks.TypeInfo(\"UnknownType\", assemblyFileName: \"xunit.v2.tests.dll\");\n\n\t\t\tvar result = typeInfo.ToRuntimeType();\n\n\t\t\tAssert.Null(result);\n\t\t}"
      }
    ]
  },
  {
    "file": "ResolveGenericMethodTests.cs",
    "methods": []
  },
  {
    "file": "DefaultTestCaseOrdererTests.cs",
    "methods": [
      {
        "name": "OrderIsStable",
        "body": "{\n\t\tvar orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());\n\n\t\tvar result1 = orderer.OrderTestCases(TestCases);\n\t\tvar result2 = orderer.OrderTestCases(TestCases);\n\t\tvar result3 = orderer.OrderTestCases(TestCases);\n\n\t\tAssert.Equal(result1, result2);\n\t\tAssert.Equal(result2, result3);\n\t}"
      },
      {
        "name": "OrderIsUnpredictable",
        "body": "{\n\t\tvar orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());\n\n\t\tvar result = orderer.OrderTestCases(TestCases);\n\n\t\tAssert.NotEqual(TestCases, result);\n\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test4",
        "body": "{ }"
      },
      {
        "name": "Test5",
        "body": "{ }"
      },
      {
        "name": "Test6",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ExtensibilityPointFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultTestCollectionFactoryIsCollectionPerClass",
        "body": "{\n\t\t\tvar assembly = Mocks.TestAssembly();\n\n\t\t\tvar result = ExtensibilityPointFactory.GetXunitTestCollectionFactory(spy, (IAttributeInfo)null, assembly);\n\n\t\t\tAssert.IsType<CollectionPerClassTestCollectionFactory>(result);\n\t\t}"
      },
      {
        "name": "UserCanChooseCustomCollectionFactory",
        "body": "{\n\t\t\tvar factoryType = typeof(MyTestCollectionFactory);\n\t\t\tvar attr = Mocks.CollectionBehaviorAttribute(factoryType.FullName, factoryType.Assembly.FullName);\n\t\t\tvar assembly = Mocks.TestAssembly();\n\n\t\t\tvar result = ExtensibilityPointFactory.GetXunitTestCollectionFactory(spy, attr, assembly);\n\n\t\t\tvar myFactory = Assert.IsType<MyTestCollectionFactory>(result);\n\t\t\tAssert.Same(assembly, myFactory.Assembly);\n\t\t}"
      }
    ]
  },
  {
    "file": "CollectionPerAssemblyTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "ReturnsDefaultTestCollectionForUndecoratedTestClass",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\");\n\t\tvar type2 = Mocks.TypeInfo(\"type2\");\n\t\tvar assemblyFileName = Path.DirectorySeparatorChar == '/' ? \"/foo/bar.dll\" : @\"C:\\Foo\\bar.dll\";\n\t\tvar assembly = Mocks.TestAssembly(assemblyFileName);\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"Test collection for bar.dll\", result1.DisplayName);\n\t}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{\n\t\tvar attr = Mocks.CollectionAttribute(\"My Collection\");\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"My Collection\", result1.DisplayName);\n\t}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.NotSame(result1, result2);\n\t\tAssert.Equal(\"Collection 1\", result1.DisplayName);\n\t\tAssert.Equal(\"Collection 2\", result2.DisplayName);\n\t}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result = factory.Get(testType);\n\n\t\tAssert.Same(collectionDefinitionType, result.CollectionDefinition);\n\t}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar spy = SpyMessageSink.Create(messages: messages);\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, spy);\n\n\t\tfactory.Get(testType);\n\n\t\tvar msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));\n\t\tAssert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);\n\t}"
      }
    ]
  },
  {
    "file": "CollectionPerClassTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultCollectionBehaviorIsCollectionPerClass",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"FullyQualified.Type.Number1\");\n\t\tvar type2 = Mocks.TypeInfo(\"FullyQualified.Type.Number2\");\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.NotSame(result1, result2);\n\t\tAssert.Equal(\"Test collection for FullyQualified.Type.Number1\", result1.DisplayName);\n\t\tAssert.Equal(\"Test collection for FullyQualified.Type.Number2\", result2.DisplayName);\n\t\tAssert.Null(result1.CollectionDefinition);\n\t\tAssert.Null(result2.CollectionDefinition);\n\t}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{\n\t\tvar attr = Mocks.CollectionAttribute(\"My Collection\");\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"My Collection\", result1.DisplayName);\n\t}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.NotSame(result1, result2);\n\t\tAssert.Equal(\"Collection 1\", result1.DisplayName);\n\t\tAssert.Equal(\"Collection 2\", result2.DisplayName);\n\t}"
      },
      {
        "name": "ExplicitlySpecifyingACollectionWithTheSameNameAsAnImplicitWorks",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\");\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Test collection for type1\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"Test collection for type1\", result1.DisplayName);\n\t}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result = factory.Get(testType);\n\n\t\tAssert.Same(collectionDefinitionType, result.CollectionDefinition);\n\t}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar spy = SpyMessageSink.Create(messages: messages);\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, spy);\n\n\t\tfactory.Get(testType);\n\n\t\tvar msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));\n\t\tAssert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);\n\t}"
      }
    ]
  },
  {
    "file": "FactDiscovererTests.cs",
    "methods": [
      {
        "name": "FactWithoutParameters_ReturnsTestCaseThatRunsFact",
        "body": "{\n\t\tvar discoverer = TestableFactDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithNoParameters\");\n\n\t\tvar testCases = discoverer.Discover(options, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tawait testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);\n\t\tAssert.Single(messageBus.Messages.OfType<ITestPassed>());\n\t}"
      },
      {
        "name": "FactWithParameters_ReturnsTestCaseWhichThrows",
        "body": "{\n\t\tvar discoverer = TestableFactDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithParameters\");\n\n\t\tvar testCases = discoverer.Discover(options, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tawait testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Equal(\"[Fact] methods are not allowed to have parameters. Did you mean to use [Theory]?\", failed.Messages.Single());\n\t}"
      },
      {
        "name": "GenericFact_ReturnsTestCaseWhichThrows",
        "body": "{\n\t\tvar discoverer = TestableFactDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"GenericFact\");\n\n\t\tvar testCases = discoverer.Discover(options, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tawait testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Equal(\"[Fact] methods are not allowed to be generic.\", failed.Messages.Single());\n\t}"
      },
      {
        "name": "FactWithNoParameters",
        "body": "{ }"
      },
      {
        "name": "FactWithParameters",
        "body": "{ }"
      },
      {
        "name": "GenericFact",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ExecutionErrorTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar testCase = Mocks.ExecutionErrorTestCase(\"This is my error message\");\n\t\tvar runner = new ExecutionErrorTestCaseRunner(testCase, messageBus, aggregator, tokenSource);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(0m, result.Time);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);\n\t\t\t\tAssert.Same(testCase, testCaseStarting.TestCase);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);\n\t\t\t\tAssert.Same(testCase, testStarting.TestCase);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, failed.TestCollection);\n\t\t\t\tAssert.Same(testCase, failed.TestCase);\n\t\t\t\tAssert.Equal(0m, failed.ExecutionTime);\n\t\t\t\tAssert.Empty(failed.Output);\n\t\t\t\tvar exceptionType = Assert.Single(failed.ExceptionTypes);\n\t\t\t\tAssert.Equal(\"System.InvalidOperationException\", exceptionType);\n\t\t\t\tvar type = Assert.Single(failed.Messages);\n\t\t\t\tAssert.Equal(\"This is my error message\", type);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);\n\t\t\t\tAssert.Same(testCase, testFinished.TestCase);\n\t\t\t\tAssert.Equal(0m, testFinished.ExecutionTime);\n\t\t\t\tAssert.Empty(testFinished.Output);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);\n\t\t\t\tAssert.Same(testCase, testCaseFinished.TestCase);\n\t\t\t\tAssert.Equal(0m, testCaseFinished.ExecutionTime);\n\t\t\t\tAssert.Equal(1, testCaseFinished.TestsRun);\n\t\t\t\tAssert.Equal(1, testCaseFinished.TestsFailed);\n\t\t\t\tAssert.Equal(0, testCaseFinished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "TestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "DefaultMessageBus",
        "body": "{\n\t\t\tvar runner = TestableTestAssemblyRunner.Create();\n\n\t\t\tvar messageBus = runner.CreateMessageBus_Public();\n\n\t\t\tAssert.IsType<MessageBus>(messageBus);\n\t\t}"
      },
      {
        "name": "SyncMessageBusOption",
        "body": "{\n\t\t\tvar executionOptions = TestFrameworkOptions.ForExecution();\n\t\t\texecutionOptions.SetSynchronousMessageReporting(true);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(executionOptions: executionOptions);\n\n\t\t\tvar messageBus = runner.CreateMessageBus_Public();\n\n\t\t\tAssert.IsType<SynchronousMessageBus>(messageBus);\n\t\t}"
      },
      {
        "name": "Messages",
        "body": "{\n\t\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = SpyMessageSink.Create(messages: messages);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink, summary);\n\t\t\tvar thisAssembly = Assembly.GetExecutingAssembly();\n\t\t\tvar thisAppDomain = AppDomain.CurrentDomain;\n\n\t\t\tvar result = await runner.RunAsync();\n\n\t\t\tAssert.Equal(4, result.Total);\n\t\t\tAssert.Equal(2, result.Failed);\n\t\t\tAssert.Equal(1, result.Skipped);\n\t\t\tAssert.NotEqual(21.12m, result.Time);  // Uses clock time, not result time\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestAssemblyStarting>(msg);\n#if NETFRAMEWORK\n\t\t\t\t\tAssert.Equal(thisAssembly.GetLocalCodeBase(), starting.TestAssembly.Assembly.AssemblyPath);\n\t\t\t\t\tAssert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, starting.TestAssembly.ConfigFileName);\n#endif\n\t\t\t\t\tAssert.InRange(starting.StartTime, DateTime.Now.AddMinutes(-15), DateTime.Now);\n\t\t\t\t\tAssert.Equal(\"The test framework environment\", starting.TestEnvironment);\n\t\t\t\t\tAssert.Equal(\"The test framework display name\", starting.TestFrameworkDisplayName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(msg);\n\t\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t\t\tAssert.Equal(result.Time, finished.ExecutionTime);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailureInQueueOfTestAssemblyStarting_DoesNotQueueTestAssemblyFinished_DoesNotRunTestCollections",
        "body": "{\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = Substitute.For<IMessageSink>();\n\t\t\tmessageSink.OnMessage(null)\n\t\t\t\t\t   .ReturnsForAnyArgs(callInfo =>\n\t\t\t\t\t   {\n\t\t\t\t\t\t   var msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\t\t\t   messages.Add(msg);\n\n\t\t\t\t\t\t   if (msg is ITestAssemblyStarting)\n\t\t\t\t\t\t\t   throw new InvalidOperationException();\n\n\t\t\t\t\t\t   return true;\n\t\t\t\t\t   });\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\n\t\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\t\tvar starting = Assert.Single(messages);\n\t\t\tAssert.IsAssignableFrom<ITestAssemblyStarting>(starting);\n\t\t\tAssert.Empty(runner.CollectionsRun);\n\t\t}"
      },
      {
        "name": "FailureInAfterTestAssemblyStarting_GivesErroredAggregatorToTestCollectionRunner_NoCleanupFailureMessage",
        "body": "{\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = SpyMessageSink.Create(messages: messages);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\t\t\tvar ex = new DivideByZeroException();\n\t\t\trunner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Same(ex, runner.RunTestCollectionAsync_AggregatorResult);\n\t\t\tAssert.Empty(messages.OfType<ITestAssemblyCleanupFailure>());\n\t\t}"
      },
      {
        "name": "FailureInBeforeTestAssemblyFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestAssemblyStarting",
        "body": "{\n\t\t\tvar thisAssembly = Assembly.GetExecutingAssembly();\n\t\t\tvar thisAppDomain = AppDomain.CurrentDomain;\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = SpyMessageSink.Create(messages: messages);\n\t\t\tvar testCases = new[] { Mocks.TestCase() };\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink, testCases: testCases);\n\t\t\tvar startingException = new DivideByZeroException();\n\t\t\tvar finishedException = new InvalidOperationException();\n\t\t\trunner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\t\trunner.BeforeTestAssemblyFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar cleanupFailure = Assert.Single(messages.OfType<ITestAssemblyCleanupFailure>());\n#if NETFRAMEWORK\n\t\t\tAssert.Equal(thisAssembly.GetLocalCodeBase(), cleanupFailure.TestAssembly.Assembly.AssemblyPath);\n\t\t\tAssert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, cleanupFailure.TestAssembly.ConfigFileName);\n#endif\n\t\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "Cancellation_TestAssemblyStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{\n\t\t\tvar messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyStarting));\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.False(runner.AfterTestAssemblyStarting_Called);\n\t\t\tAssert.False(runner.BeforeTestAssemblyFinished_Called);\n\t\t}"
      },
      {
        "name": "Cancellation_TestAssemblyFinished_CallsCallExtensibilityCallbacks",
        "body": "{\n\t\t\tvar messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyFinished));\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.True(runner.AfterTestAssemblyStarting_Called);\n\t\t\tAssert.True(runner.BeforeTestAssemblyFinished_Called);\n\t\t}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{\n\t\t\tvar collection1 = Mocks.TestCollection(displayName: \"1\");\n\t\t\tvar testCase1a = Mocks.TestCase(collection1);\n\t\t\tvar testCase1b = Mocks.TestCase(collection1);\n\t\t\tvar collection2 = Mocks.TestCollection(displayName: \"2\");\n\t\t\tvar testCase2a = Mocks.TestCase(collection2);\n\t\t\tvar testCase2b = Mocks.TestCase(collection2);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1a, testCase2a, testCase2b, testCase1b });\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(runner.CollectionsRun.OrderBy(c => c.Item1.DisplayName),\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Same(collection1, tuple.Item1);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(testCase1a, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(testCase1b, testCase)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Same(collection2, tuple.Item1);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(testCase2a, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(testCase2b, testCase)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningCollections",
        "body": "{\n\t\t\tvar collection1 = Mocks.TestCollection();\n\t\t\tvar testCase1 = Mocks.TestCase(collection1);\n\t\t\tvar collection2 = Mocks.TestCollection();\n\t\t\tvar testCase2 = Mocks.TestCase(collection2);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1, testCase2 }, cancelInRunTestCollectionAsync: true);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Single(runner.CollectionsRun);\n\t\t}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{\n\t\t\tvar runner = TestableTestAssemblyRunner.Create();\n\n\t\t\tAssert.IsType<DefaultTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{\n\t\t\tvar runner = TestableTestAssemblyRunner.Create();\n\n\t\t\tAssert.IsType<DefaultTestCollectionOrderer>(runner.TestCollectionOrderer);\n\t\t}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar collection1 = Mocks.TestCollection(displayName: \"AAA\");\n\t\t\tvar testCase1 = Mocks.TestCase(collection1);\n\t\t\tvar collection2 = Mocks.TestCollection(displayName: \"ZZZZ\");\n\t\t\tvar testCase2 = Mocks.TestCase(collection2);\n\t\t\tvar collection3 = Mocks.TestCollection(displayName: \"MM\");\n\t\t\tvar testCase3 = Mocks.TestCase(collection3);\n\t\t\tvar testCases = new[] { testCase1, testCase2, testCase3 };\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(testCases: testCases, executionMessageSink: executionSink);\n\t\t\trunner.TestCollectionOrderer = new ThrowingOrderer();\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Test collection orderer 'TestAssemblyRunnerTests+TestCollectionOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.CollectionsRun);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus, result: summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Same(result, summary);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testCaseStarting.TestCase);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testCaseFinished.TestCase);\n\t\t\t\tAssert.Equal(21.12m, testCaseFinished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, testCaseFinished.TestsRun);\n\t\t\t\tAssert.Equal(2, testCaseFinished.TestsFailed);\n\t\t\t\tAssert.Equal(1, testCaseFinished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestCaseStarting_DoesNotQueueTestCaseFinished_DoesNotRunTests",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestCaseStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestCaseStarting>(starting);\n\t\tAssert.False(runner.RunTestAsync_Called);\n\t}"
      },
      {
        "name": "RunTestAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestCaseStarting_GivesErroredAggregatorToTestRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestCaseFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCaseStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus, testCase);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCaseCleanupFailure>());\n\t\tAssert.Same(testCase, cleanupFailure.TestCase);\n\t\tAssert.Equal(new[] { testCase }, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestCaseStarting_DoesNotCallExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCaseStarting));\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.False(runner.AfterTestCaseStarting_Called);\n\t\tAssert.False(runner.BeforeTestCaseFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCaseFinished_CallsExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCaseFinished));\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.AfterTestCaseStarting_Called);\n\t\tAssert.True(runner.BeforeTestCaseFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCaseCleanupFailure));\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\t\trunner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      }
    ]
  },
  {
    "file": "TestClassRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableTestClassRunner.Create(messageBus, new[] { testCase }, result: summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(result.Total, summary.Total);\n\t\tAssert.Equal(result.Failed, summary.Failed);\n\t\tAssert.Equal(result.Skipped, summary.Skipped);\n\t\tAssert.Equal(result.Time, summary.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestClassStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Equal(\"TestClassRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestClassFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Equal(\"TestClassRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);\n\t\t\t\tAssert.Equal(21.12m, finished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestClassStarting_DoesNotQueueTestClassFinished_DoesNotRunTestMethods",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus.QueueMessage(null)\n\t\t\t\t  .ReturnsForAnyArgs(callInfo =>\n\t\t\t\t  {\n\t\t\t\t\t  var msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\t\t  messages.Add(msg);\n\n\t\t\t\t\t  if (msg is ITestClassStarting)\n\t\t\t\t\t\t  throw new InvalidOperationException();\n\n\t\t\t\t\t  return true;\n\t\t\t\t  });\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestClassStarting>(starting);\n\t\tAssert.Empty(runner.MethodsRun);\n\t}"
      },
      {
        "name": "RunTestMethodAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestClassRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestClassStarting_GivesErroredAggregatorToTestMethodRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestClassFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestClassStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };\n\t\tvar runner = TestableTestClassRunner.Create(messageBus, testCases);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestClassCleanupFailure>());\n\t\tAssert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);\n\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestClassStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestClassStarting));\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestClassStarting_Called);\n\t\tAssert.False(runner.BeforeTestClassFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestClassFinished_CallsExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestClassFinished));\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.True(runner.AfterTestClassStarting_Called);\n\t\tAssert.True(runner.BeforeTestClassFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestClassCleanupFailure));\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\t\trunner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      },
      {
        "name": "TestsAreGroupedByMethod",
        "body": "{\n\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, other2, passing2 });\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.MethodsRun,\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Passing\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(passing1, testCase),\n\t\t\t\t\ttestCase => Assert.Same(passing2, testCase)\n\t\t\t\t);\n\t\t\t},\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Other\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(other1, testCase),\n\t\t\t\t\ttestCase => Assert.Same(other2, testCase)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{\n\t\tvar passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { passing, other }, cancelInRunTestMethodAsync: true);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tuple = Assert.Single(runner.MethodsRun);\n\t\tAssert.Equal(\"Passing\", tuple.Item1.Name);\n\t}"
      },
      {
        "name": "TestsOrdererIsUsedToDetermineRunOrder",
        "body": "{\n\t\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, passing2, other2 }, orderer: new MockTestCaseOrderer(reverse: true));\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(runner.MethodsRun,\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Other\", tuple.Item1.Name);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(other2, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(other1, testCase)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Passing\", tuple.Item1.Name);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(passing2, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(passing1, testCase)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar runner = TestableTestClassRunner.Create(messageBus, [passing1, other1, passing2, other2], new ThrowingOrderer());\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar errorMessage = Assert.Single(messageBus.Messages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Test case orderer 'TestClassRunnerTests+TestCaseOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.MethodsRun);\n\t\t}"
      },
      {
        "name": "TestClassMustHaveParameterlessConstructor",
        "body": "{\n\t\tvar test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { test });\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"A test class must have a parameterless constructor.\", tcex.Message);\n\t}"
      },
      {
        "name": "ConstructorWithMissingArguments",
        "body": "{\n\t\tvar test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");\n\t\tvar constructor = typeof(ClassWithConstructor).GetConstructors().Single();\n\t\tvar args = new object[] { \"Hello, world!\" };\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"The following constructor parameters did not have matching arguments: Int32 x, Decimal z\", tcex.Message);\n\t}"
      },
      {
        "name": "ConstructorWithMatchingArguments",
        "body": "{\n\t\tvar test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");\n\t\tvar constructor = typeof(ClassWithConstructor).GetConstructors().Single();\n\t\tvar args = new object[] { \"Hello, world!\", 21.12m, 42, DateTime.Now };\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tuple = Assert.Single(runner.MethodsRun);\n\t\tAssert.Collection(tuple.Item3,\n\t\t\targ => Assert.Equal(42, arg),\n\t\t\targ => Assert.Equal(\"Hello, world!\", arg),\n\t\t\targ => Assert.Equal(21.12m, arg)\n\t\t);\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus, new[] { testCase }, summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(result.Total, summary.Total);\n\t\tAssert.Equal(result.Failed, summary.Failed);\n\t\tAssert.Equal(result.Skipped, summary.Skipped);\n\t\tAssert.Equal(result.Time, summary.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestCollectionStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestCollectionFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Equal(21.12m, finished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestCollectionStarting_DoesNotQueueTestCollectionFinished_DoesNotRunTestClasses",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestCollectionStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestCollectionStarting>(starting);\n\t\tAssert.Empty(runner.ClassesRun);\n\t}"
      },
      {
        "name": "RunTestClassAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestCollectionStarting_GivesErroredAggregatorToTestClassRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestCollectionFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCollectionStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus, testCases);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());\n\t\tAssert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);\n\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestCollectionStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionStarting));\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestCollectionStarting_Called);\n\t\tAssert.False(runner.BeforeTestCollectionFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCollectionFinished_CallsExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionFinished));\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.True(runner.AfterTestCollectionStarting_Called);\n\t\tAssert.True(runner.BeforeTestCollectionFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCollectionCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionCleanupFailure));\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\t\trunner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{\n\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");\n\t\tvar other2 = Mocks.TestCase<ClassUnderTest2>(\"Other\");\n\t\tvar runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2, other2, other1 });\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.ClassesRun,\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(passing1, testCase),\n\t\t\t\t\ttestCase => Assert.Same(other1, testCase)\n\t\t\t\t);\n\t\t\t},\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"TestCollectionRunnerTests+ClassUnderTest2\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(passing2, testCase),\n\t\t\t\t\ttestCase => Assert.Same(other2, testCase)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningClasses",
        "body": "{\n\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");\n\t\tvar runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2 }, cancelInRunTestClassAsync: true);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tuple = Assert.Single(runner.ClassesRun);\n\t\tAssert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestInvokerTests.cs",
    "methods": [
      {
        "name": "Messages_StaticTestMethod",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"StaticPassing\", messageBus);\n\n\t\tawait invoker.RunAsync();\n\n\t\tAssert.Empty(messageBus.Messages);\n\t\tAssert.True(invoker.BeforeTestMethodInvoked_Called);\n\t\tAssert.True(invoker.AfterTestMethodInvoked_Called);\n\t}"
      },
      {
        "name": "Messages_NonStaticTestMethod_NoDispose",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, \"Display Name\");\n\n\t\tawait invoker.RunAsync();\n\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, starting.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", starting.Test.DisplayName);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, finished.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", finished.Test.DisplayName);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "Messages_NonStaticTestMethod_WithDispose",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<DisposableClass>(\"Passing\", messageBus, \"Display Name\");\n\n\t\tawait invoker.RunAsync();\n\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, starting.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", starting.Test.DisplayName);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, finished.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", finished.Test.DisplayName);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus);\n\n\t\tvar result = await invoker.RunAsync();\n\n\t\tAssert.NotEqual(0m, result);\n\t\tAssert.Null(invoker.Aggregator.ToException());\n\t}"
      },
      {
        "name": "Failing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);\n\n\t\tvar result = await invoker.RunAsync();\n\n\t\tAssert.NotEqual(0m, result);\n\t\tAssert.IsType<TrueException>(invoker.Aggregator.ToException());\n\t}"
      },
      {
        "name": "TooManyParameterValues",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, testMethodArguments: new object[] { 42 });\n\n\t\tawait invoker.RunAsync();\n\n\t\tvar ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());\n\t\tAssert.Equal(\"The test method expected 0 parameter values, but 1 parameter value was provided.\", ex.Message);\n\t}"
      },
      {
        "name": "NotEnoughParameterValues",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"FactWithParameter\", messageBus);\n\n\t\tawait invoker.RunAsync();\n\n\t\tvar ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());\n\t\tAssert.Equal(\"The test method expected 1 parameter value, but 0 parameter values were provided.\", ex.Message);\n\t}"
      },
      {
        "name": "CancellationRequested_DoesNotInvokeTestMethod",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);\n\t\tinvoker.TokenSource.Cancel();\n\n\t\tvar result = await invoker.RunAsync();\n\n\t\tAssert.Equal(0m, result);\n\t\tAssert.Null(invoker.Aggregator.ToException());\n\t\tAssert.False(invoker.BeforeTestMethodInvoked_Called);\n\t\tAssert.False(invoker.AfterTestMethodInvoked_Called);\n\t}"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "{\n\t\t\tAssert.True(false);\n\t\t}"
      },
      {
        "name": "FactWithParameter",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestMethodRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus, new[] { testCase }, result: summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(result.Total, summary.Total);\n\t\tAssert.Equal(result.Failed, summary.Failed);\n\t\tAssert.Equal(result.Skipped, summary.Skipped);\n\t\tAssert.Equal(result.Time, summary.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestMethodStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);\n\t\t\t\tAssert.Equal(\"Passing\", starting.TestMethod.Method.Name);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestMethodFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);\n\t\t\t\tAssert.Equal(\"Passing\", finished.TestMethod.Method.Name);\n\t\t\t\tAssert.Equal(21.12m, finished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestMethodStarting_DoesNotQueueTestMethodFinished_DoesNotRunTestCases",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestMethodStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestMethodStarting>(starting);\n\t\tAssert.Empty(runner.TestCasesRun);\n\t}"
      },
      {
        "name": "RunTestCaseAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestMethodStarting_GivesErroredAggregatorToTestCaseRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestMethodFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestMethodStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus, testCases);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestMethodCleanupFailure>());\n\t\tAssert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);\n\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestMethodStarting_DoesNotCallExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestMethodStarting));\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestMethodStarting_Called);\n\t\tAssert.False(runner.BeforeTestMethodFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestMethodFinished_CallsExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestMethodFinished));\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.True(runner.AfterTestMethodStarting_Called);\n\t\tAssert.True(runner.BeforeTestMethodFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestMethodCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestMethodCleanupFailure));\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\t\trunner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{\n\t\tvar passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar runner = TestableTestMethodRunner.Create(testCases: new[] { passing, other }, cancelInRunTestCaseAsync: true);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar testCase = Assert.Single(runner.TestCasesRun);\n\t\tAssert.Same(passing, testCase);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(21.12m, result.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testStarting.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", testStarting.Test.DisplayName);\n\t\t\t},\n\t\t\tmsg => { },  // Pass/fail/skip, will be tested elsewhere\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testFinished.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", testFinished.Test.DisplayName);\n\t\t\t\tAssert.Equal(21.12m, testFinished.ExecutionTime);\n\t\t\t\tAssert.Empty(testFinished.Output);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\t// Direct run summary\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(0, result.Failed);\n\t\tAssert.Equal(0, result.Skipped);\n\t\tAssert.Equal(21.12m, result.Time);\n\t\t// Pass message\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, passed.TestCollection);\n\t\tAssert.Same(runner.TestCase, passed.TestCase);\n\t\tAssert.Equal(\"Display Name\", passed.Test.DisplayName);\n\t\tAssert.Equal(21.12m, passed.ExecutionTime);\n\t\tAssert.Empty(passed.Output);\n\t}"
      },
      {
        "name": "Failing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m, lambda: () => Assert.True(false));\n\n\t\tvar result = await runner.RunAsync();\n\n\t\t// Direct run summary\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(1, result.Failed);\n\t\tAssert.Equal(0, result.Skipped);\n\t\tAssert.Equal(21.12m, result.Time);\n\t\t// Fail message\n\t\tvar failed = messageBus.Messages.OfType<ITestFailed>().Single();\n\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);\n\t\tAssert.Same(runner.TestCase, failed.TestCase);\n\t\tAssert.Equal(\"Display Name\", failed.Test.DisplayName);\n\t\tAssert.Equal(21.12m, failed.ExecutionTime);\n\t\tAssert.Empty(failed.Output);\n\t\tAssert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Skipping",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", skipReason: \"Please don't run me\", runTime: 21.12m, lambda: () => Assert.True(false));\n\n\t\tvar result = await runner.RunAsync();\n\n\t\t// Direct run summary\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(0, result.Failed);\n\t\tAssert.Equal(1, result.Skipped);\n\t\tAssert.Equal(0m, result.Time);\n\t\t// Skip message\n\t\tvar failed = messageBus.Messages.OfType<ITestSkipped>().Single();\n\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);\n\t\tAssert.Same(runner.TestCase, failed.TestCase);\n\t\tAssert.Equal(\"Display Name\", failed.Test.DisplayName);\n\t\tAssert.Equal(0m, failed.ExecutionTime);\n\t\tAssert.Empty(failed.Output);\n\t\tAssert.Equal(\"Please don't run me\", failed.Reason);\n\t}"
      },
      {
        "name": "Output",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, output: \"This is my text output\");\n\n\t\tawait runner.RunAsync();\n\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Equal(\"This is my text output\", passed.Output);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestStarting_DoesNotQueueTestFinished_DoesNotInvokeTest",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestStarting>(starting);\n\t\tAssert.False(runner.InvokeTestAsync_Called);\n\t}"
      },
      {
        "name": "WithPreSeededException_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestStarting_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");\n\t\tvar runner = TestableTestRunner.Create(messageBus, testCase);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCleanupFailure>());\n\t\tAssert.Same(testCase, cleanupFailure.TestCase);\n\t\tAssert.Equal(new[] { testCase }, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestStarting_DoesNotCallExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestStarting));\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestStarting_Called);\n\t\tAssert.False(runner.BeforeTestFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCleanupFailure));\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\t\trunner.BeforeTestFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "IsXunit",
        "body": "{\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create();\n\n\t\t\tvar result = runner.GetTestFrameworkDisplayName();\n\n\t\t\tAssert.StartsWith(\"xUnit.net \", result);\n\t\t}"
      },
      {
        "name": "Default",
        "body": "{\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create();\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith($\"[collection-per-class, parallel ({Environment.ProcessorCount} threads)]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_NonParallel",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, non-parallel]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_MaxThreads",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: 3);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_Unlimited",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: -1);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (unlimited threads)]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_CustomCollectionFactory",
        "body": "{\n\t\t\tvar factoryType = typeof(MyTestCollectionFactory);\n\t\t\tvar attr = Mocks.CollectionBehaviorAttribute(factoryType.FullName, factoryType.Assembly.FullName, disableTestParallelization: true);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attr });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[My Factory, non-parallel]\", result);\n\t\t}"
      },
      {
        "name": "TestOptions_NonParallel",
        "body": "{\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetDisableParallelization(true);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, non-parallel]\", result);\n\t\t}"
      },
      {
        "name": "TestOptions_MaxThreads",
        "body": "{\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetMaxParallelThreads(3);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);\n\t\t}"
      },
      {
        "name": "TestOptions_MaxThreads_Aggressive",
        "body": "{\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetMaxParallelThreads(3);\n\t\t\toptions.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads/aggressive)]\", result);\n\t\t}"
      },
      {
        "name": "TestOptionsOverrideAttribute",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true, maxParallelThreads: 127);\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetDisableParallelization(false);\n\t\t\toptions.SetMaxParallelThreads(3);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);\n\t\t}"
      },
      {
        "name": "Parallel_SingleThread_Aggressive",
        "body": "{\n\t\t\tvar passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetMaxParallelThreads(1);\n\t\t\toptions.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();\n\t\t\tAssert.Equal(threadIDs[0], threadIDs[1]);\n\t\t}"
      },
      {
        "name": "NonParallel",
        "body": "{\n\t\t\tvar passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetDisableParallelization(true);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();\n\t\t\tAssert.Equal(threadIDs[0], threadIDs[1]);\n\t\t}"
      },
      {
        "name": "CanSetTestCaseOrdererInAssemblyAttribute",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCaseOrdererAttribute<MyTestCaseOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\trunner.Initialize();\n\n\t\t\tAssert.IsType<MyTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCaseOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test case orderer\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar ordererAttribute = Mocks.TestCaseOrdererAttribute<MyCtorThrowingTestCaseOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Assembly-level test case orderer 'XunitTestAssemblyRunnerTests+TestCaseOrderer+MyCtorThrowingTestCaseOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "CanSetTestCollectionOrdererInAssemblyAttribute",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyTestCollectionOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\trunner.Initialize();\n\n\t\t\tAssert.IsType<MyTestCollectionOrderer>(runner.TestCollectionOrderer);\n\t\t}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCollectionOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test collection orderer\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyCtorThrowingTestCollectionOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Assembly-level test collection orderer 'XunitTestAssemblyRunnerTests+TestCollectionOrderer+MyCtorThrowingTestCollectionOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ Thread.Sleep(0); }"
      },
      {
        "name": "Other",
        "body": "{ Thread.Sleep(0); }"
      }
    ]
  },
  {
    "file": "XunitTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "BeforeAfterTestAttributesComeFromTestCollectionAndTestClassAndTestMethod",
        "body": "{\n\t\tvar collection = Mocks.TestCollection(definition: Reflector.Wrap(typeof(BeforeAfterCollection)));\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\", collection);\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tvar aggregator = new ExceptionAggregator();\n\t\tvar tokenSource = new CancellationTokenSource();\n\n\t\tvar runner = new XunitTestCaseRunner(testCase, \"Display Name\", \"Skip Reason\", new object[0], new object[0], messageBus, aggregator, tokenSource);\n\n\t\tAssert.Collection(runner.BeforeAfterAttributes,\n\t\t\tattr => Assert.IsType<BeforeAfterOnCollection>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnClass>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnMethod>(attr)\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestClassRunnerTests.cs",
    "methods": [
      {
        "name": "ClassCannotBeDecoratedWithICollectionFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithCollectionFixture>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", runner.RunTestMethodAsync_AggregatorResult.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotHaveMoreThanOneConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithTwoConstructors>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"A test class may only define a single public constructor.\", runner.RunTestMethodAsync_AggregatorResult.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHavePublicAndPrivateConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithMixedConstructors>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHaveStaticConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithStaticConstructor>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CreatesFixturesFromClassAndCollection",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\", collection);\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.ClassFixtureMappings.OrderBy(mapping => mapping.Key.Name),\n\t\t\tmapping => Assert.IsType<FixtureUnderTest>(mapping.Value),\n\t\t\tmapping => Assert.IsType<object>(mapping.Value)\n\t\t);\n\t}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureUnderTest>().Single();\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassForFixtureAsyncLifetimeAndDisposableUnderTest>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tvar runnerSessionTask = runner.RunAsync();\n\n\t\tawait Task.Delay(500);\n\n\t\tvar fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();\n\n\t\tAssert.True(fixtureUnderTest.DisposeAsyncCalled);\n\t\tAssert.False(fixtureUnderTest.Disposed);\n\n\t\tfixtureUnderTest.DisposeAsyncSignaler.SetResult(true);\n\n\t\tawait runnerSessionTask;\n\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "MultiplePublicConstructorsOnClassFixture_ReturnsError",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithMultiCtorClassFixture>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UnresolvedConstructorParameterOnClassFixture_ReturnsError",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);\n\t}"
      },
      {
        "name": "CanInjectCollectionFixtureIntoClassFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");\n\t\tvar collectionFixture = new DependentCollectionFixture();\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase, collectionFixture);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t\tvar classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithCollectionFixtureDependency>().Single();\n\t\tAssert.Same(collectionFixture, classFixture.CollectionFixture);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CanInjectMessageSinkIntoClassFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t\tvar classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithMessageSinkDependency>().Single();\n\t\tAssert.NotNull(classFixture.MessageSink);\n\t\tAssert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);\n\t}"
      },
      {
        "name": "CanLogSinkMessageFromClassFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\tAssert.Equal(\"ClassFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{\n\t\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{\n\t\t\tvar testCase = Mocks.XunitTestCase<TestClassWithUnknownTestCaseOrderer>(\"Passing\");\n\t\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for class-level test case orderer on test class 'XunitTestClassRunnerTests+TestCaseOrderer+TestClassWithUnknownTestCaseOrderer'\", diagnosticMessage.Message);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "PassesFixtureValuesToConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase, 42, \"Hello, world!\", 21.12m);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar args = Assert.Single(runner.ConstructorArguments);\n\t\tAssert.Collection(args,\n\t\t\targ => Assert.IsType<FixtureUnderTest>(arg),\n\t\t\targ => Assert.Equal(\"Hello, world!\", arg),\n\t\t\targ => Assert.Equal(21.12m, arg)\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "CreatesFixtures",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.CollectionFixtureMappings.OrderBy(mapping => mapping.Key.Name),\n\t\t\tmapping => Assert.IsType<FixtureUnderTest>(mapping.Value),\n\t\t\tmapping => Assert.IsType<object>(mapping.Value)\n\t\t);\n\t}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureUnderTest>().Single();\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionForFixtureAsyncLifetimeAndDisposableUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tvar runnerSessionTask = runner.RunAsync();\n\n\t\tawait Task.Delay(500);\n\n\t\tvar fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();\n\n\t\tAssert.True(fixtureUnderTest.DisposeAsyncCalled);\n\t\tAssert.False(fixtureUnderTest.Disposed);\n\n\t\tfixtureUnderTest.DisposeAsyncSignaler.SetResult(true);\n\n\t\tawait runnerSessionTask;\n\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "MultiplePublicConstructorsOnCollectionFixture_ReturnsError",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionsWithMultiCtorCollectionFixture)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);\n\t}"
      },
      {
        "name": "UnresolvedConstructorParameterOnCollectionFixture_ReturnsError",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithDependency)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);\n\t}"
      },
      {
        "name": "CanInjectMessageSinkIntoCollectionFixture",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestClassAsync_AggregatorResult);\n\t\tvar classFixture = runner.CollectionFixtureMappings.Values.OfType<CollectionFixtureWithMessageSinkDependency>().Single();\n\t\tAssert.NotNull(classFixture.MessageSink);\n\t\tAssert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);\n\t}"
      },
      {
        "name": "CanLogSinkMessageFromCollectionFixture",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\tAssert.Equal(\"CollectionFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);\n\t}"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{\n\t\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);\n\t\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{\n\t\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithUnknownTestCaseOrderer)), \"TestCollectionDisplayName\");\n\t\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);\n\t\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for collection-level test case orderer on test collection 'TestCollectionDisplayName'\", diagnosticMessage.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "XunitTestInvokerTests.cs",
    "methods": [
      {
        "name": "Success",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest();\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute });\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Null(invoker.Aggregator.ToException());\n\t\t\tAssert.Collection(messageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),  // From TestInvoker\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),  // From TestInvoker\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar beforeStarting = Assert.IsAssignableFrom<IBeforeTestStarting>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeStarting.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, beforeStarting.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", beforeStarting.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", beforeStarting.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar beforeFinished = Assert.IsAssignableFrom<IBeforeTestFinished>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeFinished.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, beforeFinished.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", beforeFinished.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", beforeFinished.AttributeName);\n\t\t\t\t},\n\t\t\t\t// Test method is invoked here; no directly observable message (tested below)\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar afterStarting = Assert.IsAssignableFrom<IAfterTestStarting>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterStarting.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, afterStarting.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", afterStarting.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", afterStarting.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar afterFinished = Assert.IsAssignableFrom<IAfterTestFinished>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterFinished.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, afterFinished.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", afterFinished.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", afterFinished.AttributeName);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailedBefore",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest { ThrowInBefore = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.IsType<SpyBeforeAfterTest.BeforeException>(invoker.Aggregator.ToException());\n\t\t\tAssert.Collection(messageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailedAfter",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest { ThrowInAfter = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tvar aggEx = Assert.IsType<AggregateException>(invoker.Aggregator.ToException());\n\t\t\tAssert.Collection(aggEx.InnerExceptions,\n\t\t\t\tex => Assert.IsType<TrueException>(ex),\n\t\t\t\tex => Assert.IsType<SpyBeforeAfterTest.AfterException>(ex)\n\t\t\t);\n\t\t\tAssert.Collection(messageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IAfterTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IAfterTestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Successful",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingBefore_First",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInBefore = true };\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"Before #1\", msg);\n\t\t}"
      },
      {
        "name": "FailingBefore_Second",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInBefore = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\t// No cleanup for #2, since it threw\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingAfter_First",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInAfter = true };\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingAfter_Second",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInAfter = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingTest",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => { messages.Add(\"Test method invocation\"); Assert.True(false); }\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTheoryTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "EnumeratesDataAtRuntimeAndExecutesOneTestForEachDataRow",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableXunitTheoryTestCaseRunner.Create<ClassUnderTest>(\"TestWithData\", messageBus, \"Display Name\");\n\n\t\tvar summary = await runner.RunAsync();\n\n\t\tAssert.NotEqual(0m, summary.Time);\n\t\tAssert.Equal(2, summary.Total);\n\t\tAssert.Equal(1, summary.Failed);\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Equal(\"Display Name(x: 42, y: 'a', z: \\\"Hello\\\")\", passed.Test.DisplayName);\n\t\tvar failed = messageBus.Messages.OfType<ITestFailed>().Single();\n\t\tAssert.Equal(\"Display Name(x: 0, y: null, z: \\\"World!\\\")\", failed.Test.DisplayName);\n\t}"
      },
      {
        "name": "DisposesArguments",
        "body": "{\n\t\tClassUnderTest.DataWasDisposed = false;\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableXunitTheoryTestCaseRunner.Create<ClassUnderTest>(\"TestWithDisposableData\", messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(ClassUnderTest.DataWasDisposed);\n\t}"
      },
      {
        "name": "OnlySkipsDataRowsWithSkipReason",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableXunitTheoryTestCaseRunner.Create<ClassUnderTest>(\"TestWithSomeDataSkipped\", messageBus, \"Display Name\");\n\n\t\tvar summary = await runner.RunAsync();\n\n\t\tAssert.NotEqual(0m, summary.Time);\n\t\tAssert.Equal(4, summary.Total);\n\t\tAssert.Equal(2, summary.Skipped);\n\t\tAssert.Equal(1, summary.Failed);\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Equal($\"Display Name(x: 1, y: 'b', z: \\\"not skipped\\\")\", passed.Test.DisplayName);\n\t\tvar failed = messageBus.Messages.OfType<ITestFailed>().Single();\n\t\tAssert.Equal(\"Display Name(x: 0, y: 'c', z: \\\"also not skipped\\\")\", failed.Test.DisplayName);\n\n\t\tAssert.Contains(messageBus.Messages.OfType<ITestSkipped>(), skipped => skipped.Test.DisplayName == $\"Display Name(x: 42, y: 'a', z: \\\"Hello\\\")\");\n\t\tAssert.Contains(messageBus.Messages.OfType<ITestSkipped>(), skipped => skipped.Test.DisplayName == \"Display Name(x: 0, y: null, z: \\\"World!\\\")\");\n\t}"
      },
      {
        "name": "ThrowingToString",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableXunitTheoryTestCaseRunner.Create<ClassWithThrowingToString>(\"Test\", messageBus, \"Display Name\");\n\n\t\tvar summary = await runner.RunAsync();\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Equal(\"Display Name(c: TargetInvocationException was thrown formatting an object of type \\\"XunitTheoryTestCaseRunnerTests+ClassWithThrowingToString\\\")\", passed.Test.DisplayName);\n\t}"
      },
      {
        "name": "ThrowingEnumerator",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableXunitTheoryTestCaseRunner.Create<ClassWithThrowingEnumerator>(\"Test\", messageBus, \"Display Name\");\n\n\t\tvar summary = await runner.RunAsync();\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Equal(\"Display Name(c: [ClassWithThrowingEnumerator { }])\", passed.Test.DisplayName);\n\t}"
      }
    ]
  },
  {
    "file": "TestMethodTestCaseTests.cs",
    "methods": [
      {
        "name": "DefaultBehavior",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(\"MockType\", \"MockMethod\");\n\n\t\tvar testCase = new TestableTestMethodTestCase(testMethod);\n\n\t\tAssert.Equal(\"MockType.MockMethod\", testCase.DisplayName);\n\t\tAssert.Null(testCase.SkipReason);\n\t\tAssert.Empty(testCase.Traits);\n\t}"
      },
      {
        "name": "DisposesArguments",
        "body": "{\n\t\tvar disposable1 = Substitute.For<IDisposable>();\n\t\tvar disposable2 = Substitute.For<IDisposable>();\n\t\tvar testMethod = Mocks.TestMethod();\n\t\tvar testCase = new TestableTestMethodTestCase(testMethod, new[] { disposable1, disposable2 });\n\n\t\ttestCase.Dispose();\n\n\t\tdisposable1.Received(1).Dispose();\n\t\tdisposable2.Received(1).Dispose();\n\t}"
      },
      {
        "name": "CorrectNumberOfTestArguments",
        "body": "{\n\t\t\tvar param1 = Mocks.ParameterInfo(\"p1\");\n\t\t\tvar param2 = Mocks.ParameterInfo(\"p2\");\n\t\t\tvar param3 = Mocks.ParameterInfo(\"p3\");\n\t\t\tvar testMethod = Mocks.TestMethod(parameters: new[] { param1, param2, param3 });\n\t\t\tvar arguments = new object[] { 42, \"Hello, world!\", 'A' };\n\n\t\t\tvar testCase = new TestableTestMethodTestCase(testMethod, arguments);\n\n\t\t\tAssert.Equal($\"{testMethod.TestClass.Class.Name}.{testMethod.Method.Name}(p1: 42, p2: \\\"Hello, world!\\\", p3: 'A')\", testCase.DisplayName);\n\t\t}"
      },
      {
        "name": "NotEnoughTestArguments",
        "body": "{\n\t\t\tvar param = Mocks.ParameterInfo(\"p1\");\n\t\t\tvar testMethod = Mocks.TestMethod(parameters: new[] { param });\n\n\t\t\tvar testCase = new TestableTestMethodTestCase(testMethod, new object[0]);\n\n\t\t\tAssert.Equal($\"{testMethod.TestClass.Class.Name}.{testMethod.Method.Name}(p1: ???)\", testCase.DisplayName);\n\t\t}"
      },
      {
        "name": "UniqueID_NoArguments",
        "body": "{\n\t\t\tvar value = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\").UniqueID;\n\n\t\t\tAssert.NotEmpty(value);\n\t\t}"
      },
      {
        "name": "UniqueID_Arguments",
        "body": "{\n\t\t\tvar value42 = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\", new object[] { 42 }).UniqueID;\n\t\t\tvar valueHelloWorld = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\", new object[] { \"Hello, world!\" }).UniqueID;\n\t\t\tvar valueNull = TestableTestMethodTestCase.Create<ClassUnderTest>(\"TestMethod\", new object[] { (string)null }).UniqueID;\n\n\t\t\tAssert.NotEmpty(value42);\n\t\t\tAssert.NotEqual(value42, valueHelloWorld);\n\t\t\tAssert.NotEqual(value42, valueNull);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TheoryDiscovererTests.cs",
    "methods": [
      {
        "name": "NoDataAttributes",
        "body": "{\n\t\tvar failures = Run<ITestFailed>(typeof(NoDataAttributesClass));\n\n\t\tvar failure = Assert.Single(failures);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"No data found for TheoryDiscovererTests+NoDataAttributesClass.TheoryMethod\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "NullMemberData_ThrowsInvalidOperationException",
        "body": "{\n\t\tvar results = Run<ITestFailed>(typeof(NullDataClass));\n\n\t\tvar failure = Assert.Single(results);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Test data returned null for TheoryDiscovererTests+NullDataClass.NullMemberData. Make sure it is statically initialized before this test method is called.\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "EmptyTheoryData",
        "body": "{\n\t\tvar failures = Run<ITestFailed>(typeof(EmptyTheoryDataClass));\n\n\t\tvar failure = Assert.Single(failures);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"No data found for TheoryDiscovererTests+EmptyTheoryDataClass.TheoryMethod\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToTrue_YieldsTestCasePerDataRow",
        "body": "{\n\t\tdiscoveryOptions.SetPreEnumerateTheories(true);\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();\n\n\t\tAssert.Equal(2, testCases.Count);\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 42)\");\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 2112)\");\n\t}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToFalse_YieldsSingleTheoryTestCase",
        "body": "{\n\t\tdiscoveryOptions.SetPreEnumerateTheories(false);\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+MultipleDataClass.TheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "DiscoverOptions_PreEnumerateTheoriesSetToTrueWithSkipOnData_YieldsSkippedTestCasePerDataRow",
        "body": "{\n\t\tdiscoveryOptions.SetPreEnumerateTheories(true);\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MultipleDataClassSkipped), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();\n\n\t\tAssert.Equal(2, testCases.Count);\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 42)\" && testCase.SkipReason == \"Skip this attribute\");\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 2112)\" && testCase.SkipReason == \"Skip this attribute\");\n\n\t}"
      },
      {
        "name": "ThrowingData",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ThrowingDataClass), \"TheoryWithMisbehavingData\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData\", theoryTestCase.DisplayName);\n\t\tvar message = Assert.Single(discoverer.DiagnosticMessages);\n\t\tvar diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);\n\t\tAssert.StartsWith($\"Exception thrown during theory discovery on 'TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData'; falling back to single test case.{Environment.NewLine}System.DivideByZeroException:\", diagnostic.Message);\n\t}"
      },
      {
        "name": "DataDiscovererReturningNullYieldsSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar theoryAttribute = Mocks.TheoryAttribute();\n\t\tvar dataAttribute = Mocks.DataAttribute();\n\t\tvar testMethod = Mocks.TestMethod(\"MockTheoryType\", \"MockTheoryMethod\", methodAttributes: new[] { theoryAttribute, dataAttribute });\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, theoryAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"MockTheoryType.MockTheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "NonSerializableDataYieldsSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(NonSerializableDataClass), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod\", theoryTestCase.DisplayName);\n\t\tvar message = Assert.Single(discoverer.DiagnosticMessages);\n\t\tvar diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);\n\t\tAssert.Equal(\"Non-serializable data ('System.Object[]') found for 'TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod'; falling back to single test case.\", diagnostic.Message);\n\t}"
      },
      {
        "name": "NoSuchDataDiscoverer_ThrowsInvalidOperationException",
        "body": "{\n\t\tvar results = Run<ITestFailed>(typeof(NoSuchDataDiscovererClass));\n\n\t\tvar failure = Assert.Single(results);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NoSuchDataDiscovererAttribute on TheoryDiscovererTests+NoSuchDataDiscovererClass.Test does not exist.\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "NotADataDiscoverer_ThrowsInvalidOperationException",
        "body": "{\n\t\tvar results = Run<ITestFailed>(typeof(NotADataDiscovererClass));\n\n\t\tvar failure = Assert.Single(results);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NotADataDiscovererAttribute on TheoryDiscovererTests+NotADataDiscovererClass.Test does not implement IDataDiscoverer.\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "NonDiscoveryEnumeratedDataYieldsSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(NonDiscoveryEnumeratedData), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+NonDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "MixedDiscoveryEnumerationDataYieldSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MixedDiscoveryEnumeratedData), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+MixedDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "SkippedTheoryWithNoData",
        "body": "{\n\t\tvar skips = Run<ITestSkipped>(typeof(SkippedWithNoData));\n\n\t\tvar skip = Assert.Single(skips);\n\t\tAssert.Equal(\"TheoryDiscovererTests+SkippedWithNoData.TestMethod\", skip.Test.DisplayName);\n\t\tAssert.Equal(\"I have no data\", skip.Reason);\n\t}"
      },
      {
        "name": "SkippedTheoryWithData",
        "body": "{\n\t\tvar skips = Run<ITestSkipped>(typeof(SkippedWithData));\n\n\t\tvar skip = Assert.Single(skips);\n\t\tAssert.Equal(\"TheoryDiscovererTests+SkippedWithData.TestMethod\", skip.Test.DisplayName);\n\t\tAssert.Equal(\"I have data\", skip.Reason);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestCaseTests.cs",
    "methods": [
      {
        "name": "DefaultBehavior",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(\"MockType\", \"MockMethod\");\n\n\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\tAssert.Equal(\"MockType.MockMethod\", testCase.DisplayName);\n\t\tAssert.Null(testCase.SkipReason);\n\t\tAssert.Empty(testCase.Traits);\n\t}"
      },
      {
        "name": "SkipReason",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(skip: \"Skip Reason\");\n\n\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\tAssert.Equal(\"Skip Reason\", testCase.SkipReason);\n\t}"
      },
      {
        "name": "Timeout",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(timeout: 42);\n\n\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\tAssert.Equal(42, testCase.Timeout);\n\t}"
      },
      {
        "name": "TraitsOnTestMethod",
        "body": "{\n\t\t\tvar trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");\n\t\t\tvar trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");\n\t\t\tvar testMethod = Mocks.TestMethod(methodAttributes: new[] { trait1, trait2 });\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));\n\t\t\tAssert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));\n\t\t}"
      },
      {
        "name": "TraitsOnTestClass",
        "body": "{\n\t\t\tvar trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");\n\t\t\tvar trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");\n\t\t\tvar testMethod = Mocks.TestMethod(classAttributes: new[] { trait1, trait2 });\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));\n\t\t\tAssert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));\n\t\t}"
      },
      {
        "name": "CustomTrait",
        "body": "{\n\t\t\tvar passingTests = Run<ITestPassed>(typeof(ClassWithCustomTraitTest));\n\n\t\t\tvar passingTest = Assert.Single(passingTests);\n\t\t\tif (passingTest != null)\n\t\t\t\tAssert.Collection(\n\t\t\t\t\tpassingTest.TestCase.Traits.OrderBy(x => x.Key),\n\t\t\t\t\tnamedTrait =>\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(\"Assembly\", namedTrait.Key);\n\t\t\t\t\t\tvar value = Assert.Single(namedTrait.Value);\n\t\t\t\t\t\tAssert.Equal(\"Trait\", value);\n\t\t\t\t\t},\n\t\t\t\t\tnamedTrait =>\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(\"Author\", namedTrait.Key);\n\t\t\t\t\t\tvar value = Assert.Single(namedTrait.Value);\n\t\t\t\t\t\tAssert.Equal(\"Some Schmoe\", value);\n\t\t\t\t\t},\n\t\t\t\t\tnamedTrait =>\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(\"Bug\", namedTrait.Key);\n\t\t\t\t\t\tvar value = Assert.Single(namedTrait.Value);\n\t\t\t\t\t\tAssert.Equal(\"2112\", value);\n\t\t\t\t\t});\n\t\t}"
      },
      {
        "name": "CustomTraitWithoutDiscoverer",
        "body": "{\n\t\t\tvar trait = Mocks.TraitAttribute<BadTraitAttribute>();\n\t\t\tvar testMethod = Mocks.TestMethod(classAttributes: new[] { trait });\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar spy = SpyMessageSink.Create(messages: messages);\n\n\t\t\tvar testCase = new XunitTestCase(spy, TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Empty(testCase.Traits);\n\t\t\tvar diagnosticMessages = messages.OfType<IDiagnosticMessage>();\n\t\t\tvar diagnosticMessage = Assert.Single(diagnosticMessages);\n\t\t\tAssert.Equal($\"Trait attribute on '{testCase.DisplayName}' did not have [TraitDiscoverer]\", diagnosticMessage.Message);\n\t\t}"
      },
      {
        "name": "BugFix",
        "body": "{ }"
      },
      {
        "name": "CustomDisplayName",
        "body": "{\n\t\t\tvar testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\");\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Equal(\"Custom Display Name\", testCase.DisplayName);\n\t\t}"
      },
      {
        "name": "CustomDisplayNameWithArguments",
        "body": "{\n\t\t\tvar param1 = Mocks.ParameterInfo(\"p1\");\n\t\t\tvar param2 = Mocks.ParameterInfo(\"p2\");\n\t\t\tvar param3 = Mocks.ParameterInfo(\"p3\");\n\t\t\tvar testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\", parameters: new[] { param1, param2, param3 });\n\t\t\tvar arguments = new object[] { 42, \"Hello, world!\", 'A' };\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod, arguments);\n\n\t\t\tAssert.Equal(\"Custom Display Name(p1: 42, p2: \\\"Hello, world!\\\", p3: 'A')\", testCase.DisplayName);\n\t\t}"
      }
    ]
  },
  {
    "file": "XunitTestFrameworkDiscovererTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar assembly = Substitute.For<IAssemblyInfo>();\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tvar diagnosticMessageSink = SpyMessageSink.Create();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"assemblyInfo\", () => new XunitTestFrameworkDiscoverer(null, sourceProvider, diagnosticMessageSink));\n\t\t\tAssert.Throws<ArgumentNullException>(\"sourceProvider\", () => new XunitTestFrameworkDiscoverer(assembly, null, diagnosticMessageSink));\n\t\t\tAssert.Throws<ArgumentNullException>(\"diagnosticMessageSink\", () => new XunitTestFrameworkDiscoverer(assembly, sourceProvider, null));\n\t\t}"
      },
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: TestFrameworkOptions.ForDiscovery()));\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: Substitute.For<IMessageSink>(), discoveryOptions: null));\n\t\t}"
      },
      {
        "name": "AssemblyWithNoTypes_ReturnsNoTestCases",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\n\t\t\tframework.Find();\n\n\t\t\tAssert.Empty(framework.TestCases);\n\t\t}"
      },
      {
        "name": "RequestsOnlyPublicTypesFromAssembly",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(collectionFactory: Substitute.For<IXunitTestCollectionFactory>());\n\n\t\t\tframework.Find();\n\n\t\t\tframework.Assembly.Received(1).GetTypes(includePrivateTypes: false);\n\t\t}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{\n\t\t\tvar abstractClassTypeInfo = Reflector.Wrap(typeof(AbstractClass));\n\t\t\tvar assembly = Mocks.AssemblyInfo(types: new[] { abstractClassTypeInfo });\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);\n\t\t\tframework.FindTestsForClass(null).ReturnsForAnyArgs(true);\n\n\t\t\tframework.Find();\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(0).FindTestsForClass(Arg.Any<ITestClass>(), Arg.Any<bool>());\n\t\t}"
      },
      {
        "name": "CallsFindImplWhenTypesAreFoundInAssembly",
        "body": "{\n\t\t\tvar objectTypeInfo = Reflector.Wrap(typeof(object));\n\t\t\tvar intTypeInfo = Reflector.Wrap(typeof(int));\n\t\t\tvar assembly = Mocks.AssemblyInfo(types: new[] { objectTypeInfo, intTypeInfo });\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);\n\t\t\tframework.FindTestsForClass(null).ReturnsForAnyArgs(true);\n\n\t\t\tframework.Find();\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == objectTypeInfo), false);\n\t\t\tframework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == intTypeInfo), false);\n\t\t}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tvar typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));\n\t\t\tvar mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);\n\n\t\t\tframework.Find();\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tsourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());\n\t\t}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tsourceProvider\n\t\t\t\t.GetSourceInformation(null)\n\t\t\t\t.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });\n\t\t\tvar typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));\n\t\t\tvar mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);\n\n\t\t\tframework.Find(includeSourceInformation: true);\n\n\t\t\tAssert.Collection(framework.TestCases,\n\t\t\t\ttestCase =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);\n\t\t\t\t\tAssert.Equal(\"Source File\", testCase.SourceInformation.FileName);\n\t\t\t\t\tAssert.Equal(42, testCase.SourceInformation.LineNumber);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar typeName = typeof(object).FullName;\n\t\t\tvar sink = Substitute.For<IMessageSink>();\n\t\t\tvar options = TestFrameworkOptions.ForDiscovery();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"typeName\", () => framework.Find(typeName: null, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));\n\t\t\tAssert.Throws<ArgumentException>(\"typeName\", () => framework.Find(typeName: \"\", includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: options));\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: null));\n\t\t}"
      },
      {
        "name": "RequestsPublicAndPrivateMethodsFromType",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar type = Substitute.For<ITypeInfo>();\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(type);\n\n\t\t\tframework.Find(\"abc\");\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\ttype.Received(1).GetMethods(includePrivateMethods: true);\n\t\t}"
      },
      {
        "name": "CallsFindImplWhenMethodsAreFoundOnType",
        "body": "{\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();\n\t\t\tvar type = Substitute.For<ITypeInfo>();\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(type);\n\n\t\t\tframework.Find(\"abc\");\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), false);\n\t\t}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();\n\t\t\tvar type = Substitute.For<ITypeInfo>();\n\t\t\ttype.IsAbstract.Returns(true);\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(type);\n\n\t\t\tframework.Find(\"abc\");\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(0).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), Arg.Any<bool>());\n\t\t}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);\n\n\t\t\tframework.Find(\"abc\");\n\n\t\t\tsourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());\n\t\t}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tsourceProvider\n\t\t\t\t.GetSourceInformation(null)\n\t\t\t\t.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);\n\t\t\tvar typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(typeInfo);\n\n\t\t\tframework.Find(\"abc\", includeSourceInformation: true);\n\n\t\t\tAssert.Collection(framework.TestCases,\n\t\t\t\ttestCase =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);\n\t\t\t\t\tAssert.Equal(\"Source File\", testCase.SourceInformation.FileName);\n\t\t\t\t\tAssert.Equal(42, testCase.SourceInformation.LineNumber);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ClassWithNoTests_ReturnsNoTestCases",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithNoTests)));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.False(framework.Sink.Finished.WaitOne(0));\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithFact_ReturnsOneTestCaseOfTypeXunitTestCase",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithOneFact)));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tvar testCase = Assert.Single(framework.Sink.TestCases);\n\t\t\tAssert.IsType<XunitTestCase>(testCase);\n\t\t}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithMixOfFactsAndNonTests_ReturnsTestCasesOnlyForFacts",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithMixOfFactsAndNonFacts)));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(2, framework.Sink.TestCases.Count);\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod1\");\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod2\");\n\t\t}"
      },
      {
        "name": "AssemblyWithTheoryWithInlineData_ReturnsOneTestCasePerDataRecord",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = Mocks.TestClass(typeof(TheoryWithInlineData));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(2, framework.Sink.TestCases.Count);\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: \\\"Hello world\\\")\");\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: 42)\");\n\t\t}"
      },
      {
        "name": "AssemblyWithTheoryWithPropertyData_ReturnsOneTestCasePerDataRecord",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = Mocks.TestClass(typeof(TheoryWithPropertyData));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(2, framework.Sink.TestCases.Count);\n\t\t\tAssert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 42)\");\n\t\t\tAssert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 2112)\");\n\t\t}"
      },
      {
        "name": "AssemblyWithMultiLevelHierarchyWithFactOverridenInNonImmediateDerivedClass_ReturnsOneTestCase",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = Mocks.TestClass(typeof(Child));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(1, framework.Sink.TestCases.Count);\n\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+FindImpl+Child.FactOverridenInNonImmediateDerivedClass\", framework.Sink.TestCases[0].DisplayName);\n\t\t}"
      },
      {
        "name": "FactOverridenInNonImmediateDerivedClass",
        "body": "{\n\t\t\t\tAssert.True(true);\n\t\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefaultTestCollection",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar type = Reflector.Wrap(typeof(ClassWithNoCollection));\n\n\t\t\tvar testClass = framework.CreateTestClass(type);\n\n\t\t\tAssert.NotNull(testClass.TestCollection);\n\t\t\tAssert.Equal(\"Test collection for XunitTestFrameworkDiscovererTests+CreateTestClass+ClassWithNoCollection\", testClass.TestCollection.DisplayName);\n\t\t\tAssert.Null(testClass.TestCollection.CollectionDefinition);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "UndeclaredTestCollection",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar type = Reflector.Wrap(typeof(ClassWithUndeclaredCollection));\n\n\t\t\tvar testClass = framework.CreateTestClass(type);\n\n\t\t\tAssert.NotNull(testClass.TestCollection);\n\t\t\tAssert.Equal(\"This a collection without declaration\", testClass.TestCollection.DisplayName);\n\t\t\tAssert.Null(testClass.TestCollection.CollectionDefinition);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefinedTestCollection",
        "body": "{\n\t\t\tvar type = Reflector.Wrap(typeof(ClassWithDefinedCollection));\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(type.Assembly);\n\n\t\t\tvar testClass = framework.CreateTestClass(type);\n\n\t\t\tAssert.NotNull(testClass.TestCollection);\n\t\t\tAssert.Equal(\"This a defined collection\", testClass.TestCollection.DisplayName);\n\t\t\tAssert.NotNull(testClass.TestCollection.CollectionDefinition);\n\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+CreateTestClass+DeclaredCollection\", testClass.TestCollection.CollectionDefinition.Name);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "ATestNotToBeRun",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "MessageBusTests.cs",
    "methods": [
      {
        "name": "QueuedMessageShowUpInMessageSink",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar sink = SpyMessageSink.Create(messages: messages);\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg2 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg3 = Substitute.For<IMessageSinkMessage>();\n\n\t\tusing (var bus = new MessageBus(sink))\n\t\t{\n\t\t\tbus.QueueMessage(msg1);\n\t\t\tbus.QueueMessage(msg2);\n\t\t\tbus.QueueMessage(msg3);\n\t\t}\n\n\t\tAssert.Collection(messages,\n\t\t\tmessage => Assert.Same(msg1, message),\n\t\t\tmessage => Assert.Same(msg2, message),\n\t\t\tmessage => Assert.Same(msg3, message)\n\t\t);\n\t}"
      },
      {
        "name": "TryingToQueueMessageAfterDisposingThrows",
        "body": "{\n\t\tvar bus = new MessageBus(SpyMessageSink.Create());\n\t\tbus.Dispose();\n\n\t\tvar exception = Record.Exception(\n\t\t\t() => bus.QueueMessage(Substitute.For<IMessageSinkMessage>())\n\t\t);\n\n\t\tAssert.IsType<ObjectDisposedException>(exception);\n\t}"
      },
      {
        "name": "WhenSinkThrowsMessagesContinueToBeDelivered",
        "body": "{\n\t\tvar sink = Substitute.For<IMessageSink>();\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg2 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg3 = Substitute.For<IMessageSinkMessage>();\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tsink.OnMessage(Arg.Any<IMessageSinkMessage>())\n\t\t\t.Returns(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = (IMessageSinkMessage)callInfo[0];\n\t\t\t\tif (msg == msg2)\n\t\t\t\t\tthrow new DivideByZeroException(\"whee!\");\n\t\t\t\telse\n\t\t\t\t\tmessages.Add(msg);\n\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\tusing (var bus = new MessageBus(sink))\n\t\t{\n\t\t\tbus.QueueMessage(msg1);\n\t\t\tbus.QueueMessage(msg2);\n\t\t\tbus.QueueMessage(msg3);\n\t\t}\n\n\t\tAssert.Collection(messages,\n\t\t\tmessage => Assert.Same(message, msg1),\n\t\t\tmessage =>\n\t\t\t{\n\t\t\t\tvar errorMessage = Assert.IsAssignableFrom<IErrorMessage>(message);\n\t\t\t\tAssert.Equal(\"System.DivideByZeroException\", errorMessage.ExceptionTypes.Single());\n\t\t\t\tAssert.Equal(\"whee!\", errorMessage.Messages.Single());\n\t\t\t},\n\t\t\tmessage => Assert.Same(message, msg3)\n\t\t);\n\t}"
      },
      {
        "name": "QueueReturnsTrueForFailIfStopOnFailFalse",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar sink = SpyMessageSink.Create(messages: messages);\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg2 = Substitute.For<ITestFailed>();\n\t\tvar msg3 = Substitute.For<IMessageSinkMessage>();\n\n\t\tusing (var bus = new MessageBus(sink))\n\t\t{\n\t\t\tAssert.True(bus.QueueMessage(msg1));\n\t\t\tAssert.True(bus.QueueMessage(msg2));\n\t\t\tAssert.True(bus.QueueMessage(msg3));\n\t\t}\n\n\t\tAssert.Collection(messages,\n\t\t\tmessage => Assert.Same(msg1, message),\n\t\t\tmessage => Assert.Same(msg2, message),\n\t\t\tmessage => Assert.Same(msg3, message)\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "ReflectionAttributeInfoTests.cs",
    "methods": [
      {
        "name": "Throws",
        "body": "{\n\t\t\t\tvar attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithAttribute)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));\n\t\t\t\tvar attributeInfo = new ReflectionAttributeInfo(attributeData);\n\n\t\t\t\tvar ex = Record.Exception(() => attributeInfo.GetNamedArgument<int>(\"IntValue\"));\n\n\t\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\t\tAssert.StartsWith(\"Could not find property or field named 'IntValue' on instance of 'ReflectionAttributeInfoTests+GetNamedArgument+NamedValueDoesNotExist+AttributeUnderTest'\", argEx.Message);\n\t\t\t\tAssert.Equal(\"argumentName\", argEx.ParamName);\n\t\t\t}"
      },
      {
        "name": "ReturnsValue",
        "body": "{\n\t\t\t\tvar attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));\n\t\t\t\tvar attributeInfo = new ReflectionAttributeInfo(attributeData);\n\n\t\t\t\tvar result = attributeInfo.GetNamedArgument<int>(\"IntValue\");\n\n\t\t\t\tAssert.Equal(42, result);\n\t\t\t}"
      },
      {
        "name": "ReturnsDefaultValueWhenValueIsNotSet",
        "body": "{\n\t\t\t\tvar attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithoutAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));\n\t\t\t\tvar attributeInfo = new ReflectionAttributeInfo(attributeData);\n\n\t\t\t\tvar result = attributeInfo.GetNamedArgument<int>(\"IntValue\");\n\n\t\t\t\tAssert.Equal(0, result);\n\t\t\t}"
      },
      {
        "name": "ReturnsValue",
        "body": "{\n\t\t\t\tvar attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));\n\t\t\t\tvar attributeInfo = new ReflectionAttributeInfo(attributeData);\n\n\t\t\t\tvar result = attributeInfo.GetNamedArgument<int>(\"IntValue\");\n\n\t\t\t\tAssert.Equal(42, result);\n\t\t\t}"
      },
      {
        "name": "ReturnsDefaultValueWhenValueIsNotSet",
        "body": "{\n\t\t\t\tvar attributeData = CustomAttributeData.GetCustomAttributes(typeof(ClassWithoutAttributeValue)).Single(cad => cad.AttributeType == typeof(AttributeUnderTest));\n\t\t\t\tvar attributeInfo = new ReflectionAttributeInfo(attributeData);\n\n\t\t\t\tvar result = attributeInfo.GetNamedArgument<int>(\"IntValue\");\n\n\t\t\t\tAssert.Equal(0, result);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "ReflectorTests.cs",
    "methods": [
      {
        "name": "CanFindPublicMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PublicMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "CanFindPublicStaticMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PublicStaticMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "CanFindPrivateMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PrivateMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "CanFindPrivateStaticMethod",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"PrivateStaticMethod\");\n\n\t\t\t\tAssert.NotNull(result);\n\t\t\t}"
      },
      {
        "name": "NonExistantMethodReturnsNull",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tIMethodInfo result = typeInfo.GetMethod(\"NonExistantMethod\");\n\n\t\t\t\tAssert.Null(result);\n\t\t\t}"
      },
      {
        "name": "ReturnsPublicAndPrivateStaticAndNonStaticMethods",
        "body": "{\n\t\t\t\tITypeInfo typeInfo = Reflector.Wrap(typeof(TestClass));\n\n\t\t\t\tList<IMethodInfo> methods = new List<IMethodInfo>(typeInfo.GetMethods());\n\n\t\t\t\tforeach (string name in new string[] { \"PrivateMethod\", \"PrivateStaticMethod\", \"PublicMethod\", \"PublicStaticMethod\" })\n\t\t\t\t\tAssert.NotNull(methods.Find(methodInfo => methodInfo.Name == name));\n\n\t\t\t\tAssert.Null(methods.Find(methodInfo => methodInfo.Name == \"Property\"));\n\t\t\t}"
      },
      {
        "name": "ThrowsException",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");\n\t\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\t\tTestMethodCommandClass obj = new TestMethodCommandClass();\n\n\t\t\t\tException ex = Record.Exception(() => wrappedMethod.Invoke(obj));\n\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      },
      {
        "name": "ThrowsTargetInvocationException",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsTargetInvocationException\");\n\t\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\t\tTestMethodCommandClass obj = new TestMethodCommandClass();\n\n\t\t\t\tException ex = Record.Exception(() => wrappedMethod.Invoke(obj));\n\n\t\t\t\tAssert.IsType<TargetInvocationException>(ex);\n\t\t\t}"
      },
      {
        "name": "TurnsTargetParameterCountExceptionIntoParameterCountMismatchException",
        "body": "{\n\t\t\t\tMethodInfo method = typeof(TestMethodCommandClass).GetMethod(\"ThrowsException\");\n\t\t\t\tIMethodInfo wrappedMethod = Reflector.Wrap(method);\n\t\t\t\tTestMethodCommandClass obj = new TestMethodCommandClass();\n\n\t\t\t\tException ex = Record.Exception(() => wrappedMethod.Invoke(obj, \"Hello world\"));\n\n\t\t\t\tAssert.IsType<ParameterCountMismatchException>(ex);\n\t\t\t}"
      },
      {
        "name": "PrivateMethod",
        "body": "{ }"
      },
      {
        "name": "PrivateStaticMethod",
        "body": "{ }"
      },
      {
        "name": "PublicMethod",
        "body": "{ }"
      },
      {
        "name": "PublicStaticMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "SynchronousMessageBusTests.cs",
    "methods": [
      {
        "name": "MessagesAreDispatchedImmediatelyFromBus",
        "body": "{\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar dispatchedMessages = new List<IMessageSinkMessage>();\n\t\tusing (var bus = new SynchronousMessageBus(SpyMessageSink.Create(messages: dispatchedMessages), stopOnFail: false))\n\t\t{\n\t\t\tAssert.True(bus.QueueMessage(msg1));\n\t\t}\n\n\t\tvar message = Assert.Single(dispatchedMessages);\n\t\tAssert.Same(msg1, message);\n\t}"
      },
      {
        "name": "BusShouldReportShutdownWhenMessageSinkReturnsFalse",
        "body": "{\n\t\tusing (var bus = new SynchronousMessageBus(SpyMessageSink.Create(returnResult: false), stopOnFail: false))\n\t\t{\n\t\t\tAssert.False(bus.QueueMessage(Substitute.For<IMessageSinkMessage>()));\n\t\t}\n\t}"
      }
    ]
  },
  {
    "file": "TestCaseBulkDeserializerTests.cs",
    "methods": [
      {
        "name": "XunitFactWithColonsGetsEscaped",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(\"TESTS:TESTS\", \"a:b\");\n\t\tvar testCase = new XunitTestCase(null, Xunit.Sdk.TestMethodDisplay.ClassAndMethod, Xunit.Sdk.TestMethodDisplayOptions.None, testMethod);\n\n\t\tvar serializedTestCase = discoverer.Serialize(testCase);\n\n\t\tAssert.StartsWith(\":F:TESTS::TESTS:a::b:1:0:\", serializedTestCase);\n\t}"
      },
      {
        "name": "CanDeserializeGeneralizedSerialization",
        "body": "{\n\t\tvar discoverySink = new SpyMessageSink<IDiscoveryCompleteMessage>();\n\t\tdiscoverer.Find(\"TestCaseBulkDeserializerTests+TestClass\", false, discoverySink, TestFrameworkOptions.ForDiscovery());\n\t\tdiscoverySink.Finished.WaitOne();\n\t\tvar serializedTestCases =\n\t\t\tdiscoverySink\n\t\t\t\t.Messages\n\t\t\t\t.OfType<ITestCaseDiscoveryMessage>()\n\t\t\t\t.Where(m => m.TestCase.TestMethod.Method.Name == \"TheoryMethod\")\n\t\t\t\t.Select(m => discoverer.Serialize(m.TestCase))\n\t\t\t\t.ToList();\n\n\t\tvar results = default(List<KeyValuePair<string, ITestCase>>);\n\t\tAction<List<KeyValuePair<string, ITestCase>>> callback = r => results = r;\n\n\t\tnew TestCaseBulkDeserializer(discoverer, executor, serializedTestCases, callback);\n\n\t\tvar kvp = Assert.Single(results);\n\t\tAssert.Equal(kvp.Value.UniqueID, kvp.Key);\n\t\tAssert.Equal(\"TestCaseBulkDeserializerTests+TestClass\", kvp.Value.TestMethod.TestClass.Class.Name);\n\t\tAssert.Equal(\"TheoryMethod\", kvp.Value.TestMethod.Method.Name);\n\t\tAssert.Equal(\"TestCaseBulkDeserializerTests+TestClass.TheoryMethod(x: 42)\", kvp.Value.DisplayName);\n\t}"
      },
      {
        "name": "FactMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestCaseDescriptorFactoryTests.cs",
    "methods": [
      {
        "name": "EmptyTestCase",
        "body": "{\n\t\t\tvar testCase = Substitute.For<ITestCase>();\n\n\t\t\tnew TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);\n\n\t\t\tvar result = Assert.Single(callbackResults);\n\t\t\tAssert.Equal(\"C \\nM \\nU \\nD \\nS Serialization of test case ID ''\\n\", result);\n\t\t}"
      },
      {
        "name": "NoDiscovererMeansNoSerialization",
        "body": "{\n\t\t\tvar testCase = Substitute.For<ITestCase>();\n\n\t\t\tnew TestCaseDescriptorFactory(null, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);\n\n\t\t\tvar result = Assert.Single(callbackResults);\n\t\t\tAssert.Equal(\"C \\nM \\nU \\nD \\n\", result);\n\t\t}"
      },
      {
        "name": "PopulatedTestCase",
        "body": "{\n\t\t\tvar sourceInfo = Substitute.For<ISourceInformation>();\n\t\t\tsourceInfo.FileName.Returns(@\"C:\\Foo\\Bar.dll\");\n\t\t\tsourceInfo.LineNumber.Returns(123456);\n\n\t\t\tvar traits = new Dictionary<string, List<string>>\n\t\t\t{\n\t\t\t\t{ \"Name \\n 1\", new List<string> { \"Value 1a\", \"Value \\n 1b\" } },\n\t\t\t\t{ \"Name 2\", new List<string> { \"Value 2\" } }\n\t\t\t};\n\n\t\t\tvar testCase = Mocks.TestCase<MockDiscovery>(\"PopulatedTestCase\", \"Display \\n Name\", \"Skip \\n Reason\", \"ABCDEF0123456789\");\n\t\t\ttestCase.SourceInformation.Returns(sourceInfo);\n\t\t\ttestCase.Traits.Returns(traits);\n\n\t\t\tnew TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);\n\n\t\t\tvar result = Assert.Single(callbackResults);\n\t\t\tAssert.Equal(\n\t\t\t\t\"C TestCaseDescriptorFactoryTests+MockDiscovery\\n\" +\n\t\t\t\t\"M PopulatedTestCase\\n\" +\n\t\t\t\t\"U ABCDEF0123456789\\n\" +\n\t\t\t\t\"D Display \\\\n Name\\n\" +\n\t\t\t\t\"S Serialization of test case ID 'ABCDEF0123456789'\\n\" +\n\t\t\t\t\"R Skip \\\\n Reason\\n\" +\n\t\t\t\t\"F C:\\\\Foo\\\\Bar.dll\\n\" +\n\t\t\t\t\"L 123456\\n\" +\n\t\t\t\t\"T Name \\\\n 1\\nValue 1a\\n\" +\n\t\t\t\t\"T Name \\\\n 1\\nValue \\\\n 1b\\n\" +\n\t\t\t\t\"T Name 2\\nValue 2\\n\",\n\t\t\t\tresult);\n\t\t}"
      },
      {
        "name": "XunitFactHasSpecialSerialization",
        "body": "{\n\t\t\tvar testCase = testCases.Single(tc => tc.TestMethod.Method.Name == \"FactMethod\");\n\n\t\t\tnew TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);\n\n\t\t\tvar result = Assert.Single(callbackResults);\n\t\t\tvar serialization = Assert.Single(result.Split('\\n').Where(line => line.StartsWith(\"S \")));\n\t\t\tAssert.Equal($\"S :F:TestCaseDescriptorFactoryTests+TestClass:FactMethod:1:0:{testCase.TestMethod.TestClass.TestCollection.UniqueID.ToString(\"N\")}\", serialization);\n\t\t}"
      },
      {
        "name": "XunitTheoryDoesNotHaveSpecialSerialization",
        "body": "{\n\t\t\tvar testCase = testCases.Single(tc => tc.TestMethod.Method.Name == \"TheoryMethod\");\n\n\t\t\tnew TestCaseDescriptorFactory(discoverer, new List<ITestCase> { testCase }, (Action<List<string>>)Callback);\n\n\t\t\tvar result = Assert.Single(callbackResults);\n\t\t\tvar serialization = Assert.Single(result.Split('\\n').Where(line => line.StartsWith(\"S \")));\n\t\t\tAssert.False(serialization.StartsWith(\"S :FACT\"));\n\t\t}"
      },
      {
        "name": "FactMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestFrameworkProxyTests.cs",
    "methods": [
      {
        "name": "NoAttribute",
        "body": "{\n\t\tvar assembly = Mocks.AssemblyInfo();\n\n\t\tvar proxy = new TestFrameworkProxy(assembly, null, diagnosticSpy);\n\n\t\tAssert.IsType<XunitTestFramework>(proxy.InnerTestFramework);\n\t\tAssert.Empty(diagnosticMessages);\n\t}"
      },
      {
        "name": "Attribute_NoDiscoverer",
        "body": "{\n\t\tvar attribute = Mocks.TestFrameworkAttribute(typeof(AttributeWithoutDiscoverer));\n\t\tvar assembly = Mocks.AssemblyInfo(attributes: new[] { attribute });\n\n\t\tvar proxy = new TestFrameworkProxy(assembly, null, diagnosticSpy);\n\n\t\tAssert.IsType<XunitTestFramework>(proxy.InnerTestFramework);\n\t\tAssertSingleDiagnosticMessage(\"Assembly-level test framework attribute was not decorated with [TestFrameworkDiscoverer]\");\n\t}"
      },
      {
        "name": "Attribute_WithDiscoverer_NoMessageSink",
        "body": "{\n\t\tvar attribute = Mocks.TestFrameworkAttribute(typeof(AttributeWithDiscoverer));\n\t\tvar assembly = Mocks.AssemblyInfo(attributes: new[] { attribute });\n\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\n\t\tvar proxy = new TestFrameworkProxy(assembly, sourceProvider, diagnosticSpy);\n\n\t\tvar testFramework = Assert.IsType<MyTestFramework>(proxy.InnerTestFramework);\n\t\tAssert.Same(sourceProvider, testFramework.SourceInformationProvider);\n\t\tAssert.Empty(diagnosticMessages);\n\t}"
      },
      {
        "name": "Attribute_WithDiscoverer_WithMessageSink",
        "body": "{\n\t\tvar attribute = Mocks.TestFrameworkAttribute(typeof(AttributeWithDiscovererWithMessageSink));\n\t\tvar assembly = Mocks.AssemblyInfo(attributes: new[] { attribute });\n\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\n\t\tvar proxy = new TestFrameworkProxy(assembly, sourceProvider, diagnosticSpy);\n\n\t\tvar testFramework = Assert.IsType<MyTestFrameworkWithMessageSink>(proxy.InnerTestFramework);\n\t\tvar wrapper = Assert.IsType<TestFrameworkProxy.MessageSinkWrapper>(testFramework.MessageSink);\n\t\tAssert.Same(diagnosticSpy, wrapper.InnerSink);\n\t\tAssert.Same(sourceProvider, testFramework.SourceInformationProvider);\n\t\tAssert.Empty(diagnosticMessages);\n\t}"
      }
    ]
  },
  {
    "file": "TestOutputHelperTests.cs",
    "methods": []
  },
  {
    "file": "AcceptanceTestV2.cs",
    "methods": []
  },
  {
    "file": "AcceptanceTestAssembly.cs",
    "methods": []
  },
  {
    "file": "CSharpAcceptanceTestAssembly.cs",
    "methods": []
  },
  {
    "file": "CSharpAcceptanceTestV2Assembly.cs",
    "methods": []
  },
  {
    "file": "CulturedXunitTestCase.cs",
    "methods": []
  },
  {
    "file": "SpyBeforeAfterTest.cs",
    "methods": []
  },
  {
    "file": "MockTestCaseOrderer.cs",
    "methods": []
  },
  {
    "file": "XmlTestExecutionVisitorTests.cs",
    "methods": [
      {
        "name": "ReturnsFalseWhenCancellationThunkIsTrue",
        "body": "{\n\t\t\tvar visitor = new XmlTestExecutionVisitor(null, () => true);\n\n\t\t\tvar result = visitor.OnMessage(testMessage);\n\n\t\t\tAssert.False(result);\n\t\t}"
      },
      {
        "name": "ReturnsTrueWhenCancellationThunkIsFalse",
        "body": "{\n\t\t\tvar visitor = new XmlTestExecutionVisitor(null, () => false);\n\n\t\t\tvar result = visitor.OnMessage(testMessage);\n\n\t\t\tAssert.True(result);\n\t\t}"
      },
      {
        "name": "AddsStatisticsToRunningTotal",
        "body": "{\n\t\t\tvar assemblyFinished = Substitute.For<ITestAssemblyFinished>();\n\t\t\tassemblyFinished.TestsRun.Returns(2112);\n\t\t\tassemblyFinished.TestsFailed.Returns(42);\n\t\t\tassemblyFinished.TestsSkipped.Returns(6);\n\t\t\tassemblyFinished.ExecutionTime.Returns(123.4567M);\n\n\t\t\tvar visitor = new XmlTestExecutionVisitor(null, () => false) { Total = 10, Failed = 10, Skipped = 10, Time = 10M };\n\n\t\t\tvisitor.OnMessage(assemblyFinished);\n\n\t\t\tAssert.Equal(2122, visitor.Total);\n\t\t\tAssert.Equal(52, visitor.Failed);\n\t\t\tAssert.Equal(16, visitor.Skipped);\n\t\t\tAssert.Equal(133.4567M, visitor.Time);\n\t\t}"
      },
      {
        "name": "AddsAssemblyStartingInformationToXml",
        "body": "{\n\t\t\tvar assemblyStarting = Substitute.For<ITestAssemblyStarting>();\n\t\t\tassemblyStarting.TestAssembly.Assembly.AssemblyPath.Returns(\"assembly\");\n\t\t\tassemblyStarting.TestAssembly.ConfigFileName.Returns(\"config\");\n\t\t\tassemblyStarting.StartTime.Returns(new DateTime(2013, 7, 6, 16, 24, 32));\n\t\t\tassemblyStarting.TestEnvironment.Returns(\"256-bit MentalFloss\");\n\t\t\tassemblyStarting.TestFrameworkDisplayName.Returns(\"xUnit.net v14.42\");\n\n\t\t\tvar assemblyElement = new XElement(\"assembly\");\n\t\t\tvar visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);\n\n\t\t\tvisitor.OnMessage(assemblyStarting);\n\n\t\t\tAssert.Equal(\"assembly\", assemblyElement.Attribute(\"name\").Value);\n\t\t\tAssert.Equal(\"256-bit MentalFloss\", assemblyElement.Attribute(\"environment\").Value);\n\t\t\tAssert.Equal(\"xUnit.net v14.42\", assemblyElement.Attribute(\"test-framework\").Value);\n\t\t\tAssert.Equal(\"config\", assemblyElement.Attribute(\"config-file\").Value);\n\t\t\tAssert.Equal(\"2013-07-06\", assemblyElement.Attribute(\"run-date\").Value);\n\t\t\tAssert.Equal(\"16:24:32\", assemblyElement.Attribute(\"run-time\").Value);\n\t\t}"
      },
      {
        "name": "AssemblyStartingDoesNotIncludeNullConfigFile",
        "body": "{\n\t\t\tvar assemblyStarting = Substitute.For<ITestAssemblyStarting>();\n\t\t\tassemblyStarting.TestAssembly.ConfigFileName.Returns((string)null);\n\n\t\t\tvar assemblyElement = new XElement(\"assembly\");\n\t\t\tvar visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);\n\n\t\t\tvisitor.OnMessage(assemblyStarting);\n\n\t\t\tAssert.Null(assemblyElement.Attribute(\"config-file\"));\n\t\t}"
      },
      {
        "name": "NullStackTraceInFailedTestResultsInEmptyStackTraceXmlElement",
        "body": "{\n\t\t\tvar assemblyFinished = Substitute.For<ITestAssemblyFinished>();\n\t\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"TestMethod\");\n\t\t\tvar testFailed = Substitute.For<ITestFailed>();\n\t\t\ttestFailed.TestCase.Returns(testCase);\n\t\t\ttestFailed.ExceptionTypes.Returns(new[] { \"ExceptionType\" });\n\t\t\ttestFailed.Messages.Returns(new[] { \"Exception Message\" });\n\t\t\ttestFailed.StackTraces.Returns(new[] { (string)null });\n\t\t\ttestFailed.ExceptionParentIndices.Returns(new[] { -1 });\n\n\t\t\tvar assemblyElement = new XElement(\"assembly\");\n\t\t\tvar visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);\n\n\t\t\tvisitor.OnMessage(testFailed);\n\t\t\tvisitor.OnMessage(assemblyFinished);\n\n\t\t\tvar testElement = Assert.Single(assemblyElement.Elements(\"collection\").Single().Elements(\"test\"));\n\t\t\tvar failureElement = Assert.Single(testElement.Elements(\"failure\"));\n\t\t\tAssert.Empty(failureElement.Elements(\"stack-trace\").Single().Value);\n\t\t}"
      },
      {
        "name": "TestElementSourceInfoIsPlacedInXmlWhenPresent",
        "body": "{\n\t\t\tvar assemblyFinished = Substitute.For<ITestAssemblyFinished>();\n\t\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"TestMethod\");\n\t\t\ttestCase.SourceInformation.Returns(new SourceInformation { FileName = \"source file\", LineNumber = 42 });\n\t\t\tvar testPassed = Substitute.For<ITestPassed>();\n\t\t\ttestPassed.TestCase.Returns(testCase);\n\n\t\t\tvar assemblyElement = new XElement(\"assembly\");\n\t\t\tvar visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);\n\n\t\t\tvisitor.OnMessage(testPassed);\n\t\t\tvisitor.OnMessage(assemblyFinished);\n\n\t\t\tvar testElement = Assert.Single(assemblyElement.Elements(\"collection\").Single().Elements(\"test\"));\n\t\t\tAssert.Equal(\"source file\", testElement.Attribute(\"source-file\").Value);\n\t\t\tAssert.Equal(\"42\", testElement.Attribute(\"source-line\").Value);\n\t\t}"
      },
      {
        "name": "TestElementTraisArePlacedInXmlWhenPresent",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, List<string>>\n\t\t\t{\n\t\t\t\t{ \"name1\", new List<string> { \"value1\" }},\n\t\t\t\t{ \"name2\", new List<string> { \"value2\" }}\n\t\t\t};\n\t\t\tvar assemblyFinished = Substitute.For<ITestAssemblyFinished>();\n\t\t\tvar passingTestCase = Mocks.TestCase<ClassUnderTest>(\"TestMethod\");\n\t\t\tpassingTestCase.Traits.Returns(traits);\n\t\t\tvar testPassed = Substitute.For<ITestPassed>();\n\t\t\ttestPassed.TestCase.Returns(passingTestCase);\n\n\t\t\tvar assemblyElement = new XElement(\"assembly\");\n\t\t\tvar visitor = new XmlTestExecutionVisitor(assemblyElement, () => false);\n\n\t\t\tvisitor.OnMessage(testPassed);\n\t\t\tvisitor.OnMessage(assemblyFinished);\n\n\t\t\tvar traitsElements = assemblyElement.Elements(\"collection\").Single().Elements(\"test\").Single().Elements(\"traits\").Single().Elements(\"trait\");\n\t\t\tvar name1Element = Assert.Single(traitsElements, e => e.Attribute(\"name\").Value == \"name1\");\n\t\t\tAssert.Equal(\"value1\", name1Element.Attribute(\"value\").Value);\n\t\t\tvar name2Element = Assert.Single(traitsElements, e => e.Attribute(\"name\").Value == \"name2\");\n\t\t\tAssert.Equal(\"value2\", name2Element.Attribute(\"value\").Value);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "BooleanAssertsTests.cs",
    "methods": [
      {
        "name": "AssertFalse",
        "body": "{\n\t\t\tAssert.False(false);\n\t\t}"
      },
      {
        "name": "ThrowsExceptionWhenTrue",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.False(true));\n\n\t\t\tAssert.IsType<FalseException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.False() Failure\" + Environment.NewLine +\n\t\t\t\t\"Expected: False\" + Environment.NewLine +\n\t\t\t\t\"Actual:   True\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ThrowsExceptionWhenNull",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.False(null));\n\n\t\t\tAssert.IsType<FalseException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.False() Failure\" + Environment.NewLine +\n\t\t\t\t\"Expected: False\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "UserSuppliedMessage",
        "body": "{\n#pragma warning disable xUnit2020 // Do not use always-failing boolean assertions\n\t\t\tvar ex = Record.Exception(() => Assert.False(true, \"Custom User Message\"));\n#pragma warning restore xUnit2020 // Do not use always-failing boolean assertions\n\n\t\t\tAssert.NotNull(ex);\n\t\t\tAssert.Equal(\"Custom User Message\", ex.Message);\n\t\t}"
      },
      {
        "name": "AssertTrue",
        "body": "{\n\t\t\tAssert.True(true);\n\t\t}"
      },
      {
        "name": "ThrowsExceptionWhenFalse",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.True(false));\n\n\t\t\tAssert.IsType<TrueException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.True() Failure\" + Environment.NewLine +\n\t\t\t\t\"Expected: True\" + Environment.NewLine +\n\t\t\t\t\"Actual:   False\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ThrowsExceptionWhenNull",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.True(null));\n\n\t\t\tAssert.IsType<TrueException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.True() Failure\" + Environment.NewLine +\n\t\t\t\t\"Expected: True\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "UserSuppliedMessage",
        "body": "{\n#pragma warning disable xUnit2020 // Do not use always-failing boolean assertions\n\t\t\tvar ex = Record.Exception(() => Assert.True(false, \"Custom User Message\"));\n#pragma warning restore xUnit2020 // Do not use always-failing boolean assertions\n\n\t\t\tAssert.NotNull(ex);\n\t\t\tAssert.Equal(\"Custom User Message\", ex.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "DictionaryAssertsTests.cs",
    "methods": [
      {
        "name": "KeyInDictionary",
        "body": "{\n\t\t\tvar dictionary = new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase)\n\t\t\t{\n\t\t\t\t[\"forty-two\"] = 42\n\t\t\t};\n\n\t\t\tAssert.Equal(42, Assert.Contains(\"FORTY-two\", dictionary));\n\t\t\tAssert.Equal(42, Assert.Contains(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary)));\n\t\t\tAssert.Equal(42, Assert.Contains(\"FORTY-two\", (IDictionary<string, int>)dictionary));\n\t\t\tAssert.Equal(42, Assert.Contains(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary));\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tAssert.Equal(42, Assert.Contains(\"FORTY-two\", dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));\n\t\t\tAssert.Equal(42, Assert.Contains(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));\n#endif\n\t\t}"
      },
      {
        "name": "KeyNotInDictionary",
        "body": "{\n\t\t\tvar dictionary = new Dictionary<string, int>()\n\t\t\t{\n\t\t\t\t[\"eleventeen\"] = 110\n\t\t\t};\n\n\t\t\tvoid assertFailure(Action action)\n\t\t\t{\n\t\t\t\tvar ex = Record.Exception(action);\n\n\t\t\t\tAssert.IsType<ContainsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Contains() Failure: Key not found in dictionary\" + Environment.NewLine +\n\t\t\t\t\t\"Keys:      [\\\"eleventeen\\\"]\" + Environment.NewLine +\n\t\t\t\t\t\"Not found: \\\"FORTY-two\\\"\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", dictionary));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary)));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", (IDictionary<string, int>)dictionary));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary));\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", dictionary.ToImmutableDictionary()));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary()));\n#endif\n\t\t}"
      },
      {
        "name": "KeyNotInDictionary",
        "body": "{\n\t\t\tvar dictionary = new Dictionary<string, int>()\n\t\t\t{\n\t\t\t\t[\"eleventeen\"] = 110\n\t\t\t};\n\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", dictionary);\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary));\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", (IDictionary<string, int>)dictionary);\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary);\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", dictionary.ToImmutableDictionary());\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary());\n#endif\n\t\t}"
      },
      {
        "name": "KeyInDictionary",
        "body": "{\n\t\t\tvar dictionary = new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase)\n\t\t\t{\n\t\t\t\t[\"forty-two\"] = 42\n\t\t\t};\n\n\t\t\tvoid assertFailure(Action action)\n\t\t\t{\n\t\t\t\tvar ex = Record.Exception(action);\n\n\t\t\t\tAssert.IsType<DoesNotContainException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.DoesNotContain() Failure: Key found in dictionary\" + Environment.NewLine +\n\t\t\t\t\t\"Keys:  [\\\"forty-two\\\"]\" + Environment.NewLine +\n\t\t\t\t\t\"Found: \\\"FORTY-two\\\"\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", dictionary));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", new ReadOnlyDictionary<string, int>(dictionary)));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IDictionary<string, int>)dictionary));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IReadOnlyDictionary<string, int>)dictionary));\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IImmutableDictionary<string, int>)dictionary.ToImmutableDictionary(StringComparer.InvariantCultureIgnoreCase)));\n#endif\n\t\t}"
      }
    ]
  },
  {
    "file": "EventAssertsTests.cs",
    "methods": [
      {
        "name": "NoEventRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.Raises<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => { }\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NoEventRaised_NoData",
        "body": "{\n\t\t\tvar obj = new RaisingClass_Action();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.Raises(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => { }\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\"Assert.Raises() Failure: No event was raised\", ex.Message);\n\t\t}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = Assert.Raises<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Null(evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "RaisingClass_ActionOfT",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.Raises<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t$\"Actual:   typeof({typeof(DerivedObject).FullName})\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NoEventRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.Raises<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => { }\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = Assert.Raises<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "DerivedTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.Raises<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t$\"Actual:   typeof({typeof(DerivedObject).FullName})\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "CustomRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_CustomEventHandler();\n\t\t\tvar eventObj = new object();\n\t\t\tAssert.RaisedEvent<object>? raisedEvent = null;\n\t\t\tvoid handler(object? s, object args) => raisedEvent = new Assert.RaisedEvent<object>(s, args);\n\n\t\t\tvar evt = Assert.Raises(\n\t\t\t\t() => raisedEvent,\n\t\t\t\t() => obj.Completed += handler,\n\t\t\t\t() => obj.Completed -= handler,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "NoEventRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.RaisesAny<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => { }\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = Assert.RaisesAny<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Null(evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "DerivedTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar evt = Assert.RaisesAny<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Null(evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "NoEventRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.RaisesAny<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => { }\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NoEventRaised_NonGeneric",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandler();\n\n\t\t\tvar ex = Record.Exception(\n\t\t\t\t() => Assert.RaisesAny(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => { }\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.EventArgs)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ExactTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = Assert.RaisesAny<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "ExactTypeRaised_NonGeneric",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandler();\n\t\t\tvar eventObj = new EventArgs();\n\n\t\t\tvar evt = Assert.RaisesAny(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "DerivedTypeRaised",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar evt = Assert.RaisesAny<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "DerivedTypeRaised_NonGeneric",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandler();\n\t\t\tvar eventObj = new DerivedEventArgs();\n\n\t\t\tvar evt = Assert.RaisesAny(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n\t\t\t\t() => obj.RaiseWithArgs(eventObj)\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAnyAsync<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => Task.FromResult(0)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = await Assert.RaisesAnyAsync<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Null(evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar evt = await Assert.RaisesAnyAsync<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Null(evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAnyAsync<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => Task.FromResult(0)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandler();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAnyAsync(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => Task.FromResult(0)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.RaisesAny() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.EventArgs)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = await Assert.RaisesAnyAsync<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandler();\n\t\t\tvar eventObj = new EventArgs();\n\n\t\t\tvar evt = await Assert.RaisesAnyAsync(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar evt = await Assert.RaisesAnyAsync<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandler();\n\t\t\tvar eventObj = new DerivedEventArgs();\n\n\t\t\tvar evt = await Assert.RaisesAnyAsync(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAsync<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => Task.FromResult(0)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_Action();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAsync(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => Task.CompletedTask\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\"Assert.Raises() Failure: No event was raised\", ex.Message);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = await Assert.RaisesAsync<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Null(evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_ActionOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAsync<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t$\"Actual:   typeof({typeof(DerivedObject).FullName})\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAsync<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n\t\t\t\t\t() => Task.FromResult(0)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: No event was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   No event was raised\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new object();\n\n\t\t\tvar evt = await Assert.RaisesAsync<object>(\n\t\t\t\th => obj.Completed += h,\n\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t);\n\n\t\t\tAssert.NotNull(evt);\n\t\t\tAssert.Equal(obj, evt.Sender);\n\t\t\tAssert.Equal(eventObj, evt.Arguments);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new RaisingClass_EventHandlerOfT();\n\t\t\tvar eventObj = new DerivedObject();\n\n\t\t\tvar ex = await Record.ExceptionAsync(\n\t\t\t\t() => Assert.RaisesAsync<object>(\n\t\t\t\t\th => obj.Completed += h,\n\t\t\t\t\th => obj.Completed -= h,\n#if XUNIT_V2\n\t\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj))\n#else\n\t\t\t\t\t() => Task.Run(() => obj.RaiseWithArgs(eventObj), TestContext.Current.CancellationToken)\n#endif\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tAssert.IsType<RaisesException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Raises() Failure: Wrong event type was raised\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t$\"Actual:   typeof({typeof(DerivedObject).FullName})\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "ExceptionAssertsTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\t\tvoid testCode() { }\n\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"exceptionType\", () => Assert.Throws(null!, testCode));\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws(typeof(Exception), default(Action)!));\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() { }\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() => throw new ArgumentException();\n\n\t\t\t\tAssert.Throws(typeof(ArgumentException), testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new ArgumentNullException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\t\tobject testCode() => 42;\n\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"exceptionType\", () => Assert.Throws(null!, testCode));\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws(typeof(Exception), default(Func<object>)!));\n\t\t\t}"
      },
      {
        "name": "ProtectsAgainstAccidentalTask",
        "body": "{\n\t\t\t\tstatic object testCode() => Task.FromResult(42);\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(Exception), testCode));\n\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t\tAssert.Equal(\"You must call Assert.ThrowsAsync when testing async code\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => 42;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => throw new ArgumentException();\n\n\t\t\t\tAssert.Throws(typeof(ArgumentException), testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new ArgumentNullException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws(typeof(ArgumentException), testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Action)!));\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() { }\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() => throw new ArgumentException();\n\n\t\t\t\tAssert.Throws<ArgumentException>(testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new ArgumentNullException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Func<object>)!));\n\t\t\t}"
      },
      {
        "name": "ProtectsAgainstAccidentalTask",
        "body": "{\n\t\t\t\tstatic object testCode() => Task.FromResult(42);\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<Exception>(testCode));\n\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t\tAssert.Equal(\"You must call Assert.ThrowsAsync when testing async code\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => 42;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => throw new ArgumentException();\n\n\t\t\t\tAssert.Throws<ArgumentException>(testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new ArgumentNullException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Action)!));\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() { }\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() => throw new ArgumentException(\"Hello world\", \"paramName\");\n\n\t\t\t\tAssert.Throws<ArgumentException>(\"paramName\", testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectParameterName",
        "body": "{\n\t\t\t\tvoid testCode() => throw new ArgumentException(\"Hello world\", \"paramName1\");\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName2\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Incorrect parameter name\" + Environment.NewLine +\n\t\t\t\t\t\"Exception: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Expected:  \\\"paramName2\\\"\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:    \\\"paramName1\\\"\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new ArgumentNullException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.Throws<ArgumentException>(default(Func<object>)!));\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => 42;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => throw new ArgumentException(\"Hello world\", \"paramName\");\n\n\t\t\t\tAssert.Throws<ArgumentException>(\"paramName\", testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectParameterName",
        "body": "{\n\t\t\t\tobject testCode() => throw new ArgumentException(\"Hello world\", \"paramName1\");\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName2\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Incorrect parameter name\" + Environment.NewLine +\n\t\t\t\t\t\"Exception: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Expected:  \\\"paramName2\\\"\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:    \\\"paramName1\\\"\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new ArgumentNullException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.Throws<ArgumentException>(\"paramName\", testCode));\n\n\t\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAny<ArgumentException>(default(Action)!));\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() { }\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsAnyException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.ThrowsAny() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() => throw new ArgumentException();\n\n\t\t\t\tAssert.ThrowsAny<ArgumentException>(testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tvoid testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsAnyException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.ThrowsAny() Failure: Exception type was not compatible\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tvoid testCode() => throw new ArgumentNullException();\n\n\t\t\t\tAssert.ThrowsAny<ArgumentException>(testCode);\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAny<ArgumentException>(default(Func<object>)!));\n\t\t\t}"
      },
      {
        "name": "ProtectsAgainstAccidentalTask",
        "body": "{\n\t\t\t\tstatic object testCode() => Task.FromResult(42);\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.ThrowsAny<Exception>(testCode));\n\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t\tAssert.Equal(\"You must call Assert.ThrowsAnyAsync when testing async code\", ex.Message);\n\t\t\t}"
      },
      {
        "name": "NoExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => 42;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsAnyException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.ThrowsAny() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Null(ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "CorrectExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => throw new ArgumentException();\n\n\t\t\t\tAssert.ThrowsAny<ArgumentException>(testCode);\n\t\t\t}"
      },
      {
        "name": "IncorrectExceptionThrown",
        "body": "{\n\t\t\t\tvar thrown = new DivideByZeroException();\n\t\t\t\tobject testCode() => throw thrown;\n\n\t\t\t\tvar ex = Record.Exception(() => Assert.ThrowsAny<ArgumentException>(testCode));\n\n\t\t\t\tAssert.IsType<ThrowsAnyException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.ThrowsAny() Failure: Exception type was not compatible\" + Environment.NewLine +\n\t\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t\t}"
      },
      {
        "name": "DerivedExceptionThrown",
        "body": "{\n\t\t\t\tobject testCode() => throw new ArgumentNullException();\n\n\t\t\t\tAssert.ThrowsAny<ArgumentException>(testCode);\n\t\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAnyAsync<ArgumentException>(default(Func<Task>)!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => Task.FromResult(42);\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAnyAsync<ArgumentException>(testCode));\n\n\t\t\tAssert.IsType<ThrowsAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ThrowsAny() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Null(ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => throw new ArgumentException();\n\n\t\t\tawait Assert.ThrowsAnyAsync<ArgumentException>(testCode);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar thrown = new DivideByZeroException();\n\t\t\tTask testCode() => throw thrown;\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAnyAsync<ArgumentException>(testCode));\n\n\t\t\tAssert.IsType<ThrowsAnyException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ThrowsAny() Failure: Exception type was not compatible\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => throw new ArgumentNullException();\n\n\t\t\tawait Assert.ThrowsAnyAsync<ArgumentException>(testCode);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAsync<ArgumentException>(default(Func<Task>)!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => Task.FromResult(42);\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Null(ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => throw new ArgumentException();\n\n\t\t\tawait Assert.ThrowsAsync<ArgumentException>(testCode);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar thrown = new DivideByZeroException();\n\t\t\tTask testCode() => throw thrown;\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar thrown = new ArgumentNullException();\n\t\t\tTask testCode() => throw thrown;\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.ThrowsAsync<ArgumentException>(\"paramName\", default(Func<Task>)!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => Task.FromResult(42);\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: No exception was thrown\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Null(ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => throw new ArgumentException(\"Hello world\", \"paramName\");\n\n\t\t\tawait Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tTask testCode() => throw new ArgumentException(\"Hello world\", \"paramName1\");\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName2\", testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: Incorrect parameter name\" + Environment.NewLine +\n\t\t\t\t\"Exception: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\"Expected:  \\\"paramName2\\\"\" + Environment.NewLine +\n\t\t\t\t\"Actual:    \\\"paramName1\\\"\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar thrown = new DivideByZeroException();\n\t\t\tTask testCode() => throw thrown;\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.DivideByZeroException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar thrown = new ArgumentNullException();\n\t\t\tTask testCode() => throw thrown;\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.ThrowsAsync<ArgumentException>(\"paramName\", testCode));\n\n\t\t\tAssert.IsType<ThrowsException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Throws() Failure: Exception type was not an exact match\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.ArgumentException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.ArgumentNullException)\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t\tAssert.Same(thrown, ex.InnerException);\n\t\t}"
      }
    ]
  },
  {
    "file": "FailAssertsTests.cs",
    "methods": [
      {
        "name": "WithoutMessage",
        "body": "{\n\t\tvar ex = Record.Exception(() => Assert.Fail());\n\n\t\tAssert.IsType<FailException>(ex);\n\t\tAssert.Equal(\"Assert.Fail() Failure\", ex.Message);\n\t}"
      },
      {
        "name": "WithMessage",
        "body": "{\n\t\tvar ex = Record.Exception(() => Assert.Fail(\"This is a user message\"));\n\n\t\tAssert.IsType<FailException>(ex);\n\t\tAssert.Equal(\"This is a user message\", ex.Message);\n\t}"
      }
    ]
  },
  {
    "file": "IdentityAssertsTests.cs",
    "methods": [
      {
        "name": "Identical",
        "body": "{\n\t\t\tvar actual = new object();\n\n\t\t\tvar ex = Record.Exception(() => Assert.NotSame(actual, actual));\n\n\t\t\tAssert.IsType<NotSameException>(ex);\n\t\t\tAssert.Equal(\"Assert.NotSame() Failure: Values are the same instance\", ex.Message);\n\t\t}"
      },
      {
        "name": "NotIdentical",
        "body": "{\n\t\t\tAssert.NotSame(\"bob\", \"jim\");\n\t\t}"
      },
      {
        "name": "Identical",
        "body": "{\n\t\t\tvar actual = new object();\n\n\t\t\tAssert.Same(actual, actual);\n\t\t}"
      },
      {
        "name": "NotIdentical",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.Same(\"bob\", \"jim\"));\n\n\t\t\tAssert.IsType<SameException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Same() Failure: Values are not the same instance\" + Environment.NewLine +\n\t\t\t\t\"Expected: \\\"bob\\\"\" + Environment.NewLine +\n\t\t\t\t\"Actual:   \\\"jim\\\"\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "EqualValueTypeValuesAreNotSameBecauseOfBoxing",
        "body": "{\n#pragma warning disable xUnit2005 // Do not use identity check on value type\n\t\t\tAssert.Throws<SameException>(() => Assert.Same(0, 0));\n#pragma warning restore xUnit2005 // Do not use identity check on value type\n\t\t}"
      }
    ]
  },
  {
    "file": "MultipleAssertsTests.cs",
    "methods": [
      {
        "name": "NoActions_DoesNotThrow",
        "body": "{\n\t\tAssert.Multiple();\n\t}"
      },
      {
        "name": "SingleAssert_Success_DoesNotThrow",
        "body": "{\n\t\tAssert.Multiple(\n\t\t\t() => Assert.True(true)\n\t\t);\n\t}"
      },
      {
        "name": "SingleAssert_Fails_ThrowsFailingAssert",
        "body": "{\n\t\tvar ex = Record.Exception(() =>\n\t\t\tAssert.Multiple(\n\t\t\t\t() => Assert.True(false)\n\t\t\t)\n\t\t);\n\n\t\tAssert.IsType<TrueException>(ex);\n\t}"
      },
      {
        "name": "MultipleAssert_Success_DoesNotThrow",
        "body": "{\n\t\tAssert.Multiple(\n\t\t\t() => Assert.True(true),\n\t\t\t() => Assert.False(false)\n\t\t);\n\t}"
      },
      {
        "name": "MultipleAssert_SingleFailure_ThrowsFailingAssert",
        "body": "{\n\t\tvar ex = Record.Exception(() =>\n\t\t\tAssert.Multiple(\n\t\t\t\t() => Assert.True(true),\n\t\t\t\t() => Assert.False(true)\n\t\t\t)\n\t\t);\n\n\t\tAssert.IsType<FalseException>(ex);\n\t}"
      },
      {
        "name": "MultipleAssert_MultipleFailures_ThrowsMultipleException",
        "body": "{\n\t\tvar ex = Record.Exception(() =>\n\t\t\tAssert.Multiple(\n\t\t\t\t() => Assert.True(false),\n\t\t\t\t() => Assert.False(true)\n\t\t\t)\n\t\t);\n\n\t\tvar multiEx = Assert.IsType<MultipleException>(ex);\n\t\tAssert.Equal(\n\t\t\t\"Assert.Multiple() Failure: Multiple failures were encountered\",\n\t\t\tex.Message\n\t\t);\n\t\tAssert.Collection(\n\t\t\tmultiEx.InnerExceptions,\n\t\t\tinnerEx => Assert.IsType<TrueException>(innerEx),\n\t\t\tinnerEx => Assert.IsType<FalseException>(innerEx)\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "NullAssertsTests.cs",
    "methods": [
      {
        "name": "Success_Reference",
        "body": "{\n\t\t\tAssert.NotNull(new object());\n\t\t}"
      },
      {
        "name": "Success_NullableStruct",
        "body": "{\n\t\t\tint? x = 42;\n\n\t\t\tvar result = Assert.NotNull(x);\n\n\t\t\tAssert.IsType<int>(result);\n\t\t\tAssert.Equal(42, result);\n\t\t}"
      },
      {
        "name": "Failure_Reference",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.NotNull(null));\n\n\t\t\tAssert.IsType<NotNullException>(ex);\n\t\t\tAssert.Equal(\"Assert.NotNull() Failure: Value is null\", ex.Message);\n\t\t}"
      },
      {
        "name": "Failure_NullableStruct",
        "body": "{\n\t\t\tint? value = null;\n\n\t\t\tvar ex = Record.Exception(() => Assert.NotNull(value));\n\n\t\t\tAssert.IsType<NotNullException>(ex);\n\t\t\tAssert.Equal(\"Assert.NotNull() Failure: Value of type 'Nullable<int>' does not have a value\", ex.Message);\n\t\t}"
      },
      {
        "name": "Success_Reference",
        "body": "{\n\t\t\tAssert.Null(null);\n\t\t}"
      },
      {
        "name": "Success_NullableStruct",
        "body": "{\n\t\t\tint? x = null;\n\n\t\t\tAssert.Null(x);\n\t\t}"
      },
      {
        "name": "Failure_Reference",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.Null(new object()));\n\n\t\t\tAssert.IsType<NullException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Null() Failure: Value is not null\" + Environment.NewLine +\n\t\t\t\t\"Expected: null\" + Environment.NewLine +\n\t\t\t\t\"Actual:   Object { }\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Failure_NullableStruct",
        "body": "{\n\t\t\tint? x = 42;\n\n\t\t\tvar ex = Record.Exception(() => Assert.Null(x));\n\n\t\t\tAssert.IsType<NullException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Null() Failure: Value of type 'Nullable<int>' has a value\" + Environment.NewLine +\n\t\t\t\t\"Expected: null\" + Environment.NewLine +\n\t\t\t\t\"Actual:   42\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "PropertyAssertsTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"object\", () => Assert.PropertyChanged(null!, \"propertyName\", delegate { }));\n\t\t\tAssert.Throws<ArgumentNullException>(\"testCode\", () => Assert.PropertyChanged(Substitute.For<INotifyPropertyChanged>(), \"propertyName\", (Action)null!));\n\t\t}"
      },
      {
        "name": "ExceptionThrownWhenPropertyNotChanged",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\n\t\t\tvar ex = Record.Exception(() => Assert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () => { }));\n\n\t\t\tAssert.IsType<PropertyChangedException>(ex);\n\t\t\tAssert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);\n\t\t}"
      },
      {
        "name": "ExceptionThrownWhenWrongPropertyChanged",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\n\t\t\tvar ex = Record.Exception(() => Assert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () => obj.Property2 = 42));\n\n\t\t\tAssert.IsType<PropertyChangedException>(ex);\n\t\t\tAssert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);\n\t\t}"
      },
      {
        "name": "NoExceptionThrownWhenPropertyChanged",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\n\t\t\tAssert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () => obj.Property1 = \"NewValue\");\n\t\t}"
      },
      {
        "name": "NoExceptionThrownWhenMultiplePropertyChangesIncludesCorrectProperty",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\n\t\t\tAssert.PropertyChanged(obj, nameof(NotifiedClass.Property1), () =>\n\t\t\t{\n\t\t\t\tobj.Property2 = 12;\n\t\t\t\tobj.Property1 = \"New Value\";\n\t\t\t\tobj.Property2 = 42;\n\t\t\t});\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"object\", () => Assert.PropertyChangedAsync(null!, \"propertyName\", () => Task.FromResult(0)));\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"testCode\", () => Assert.PropertyChangedAsync(Substitute.For<INotifyPropertyChanged>(), \"propertyName\", default(Func<Task>)!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), () => Task.FromResult(0)));\n\n\t\t\tAssert.IsType<PropertyChangedException>(ex);\n\t\t\tAssert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\t\t\tasync Task setter() => obj!.Property2 = 42;\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), setter));\n\n\t\t\tAssert.IsType<PropertyChangedException>(ex);\n\t\t\tAssert.Equal(\"Assert.PropertyChanged() failure: Property 'Property1' was not set\", ex.Message);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\t\t\tasync Task setter() => obj!.Property1 = \"NewValue\";\n\n\t\t\tawait Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), setter);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar obj = new NotifiedClass();\n\n\t\t\tasync Task setter()\n\t\t\t{\n\t\t\t\tobj.Property2 = 12;\n\t\t\t\tobj.Property1 = \"New Value\";\n\t\t\t\tobj.Property2 = 42;\n\t\t\t}\n\n\t\t\tawait Assert.PropertyChangedAsync(obj, nameof(NotifiedClass.Property1), setter);\n\t\t}"
      }
    ]
  },
  {
    "file": "RangeAssertsTests.cs",
    "methods": [
      {
        "name": "DoubleValueWithinRange",
        "body": "{\n\t\t\tAssert.InRange(1.0, .75, 1.25);\n\t\t}"
      },
      {
        "name": "IntNotWithinRangeWithZeroActual",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.InRange(0, 1, 2));\n\n\t\t\tAssert.IsType<InRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.InRange() Failure: Value not in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (1 - 2)\" + Environment.NewLine +\n\t\t\t\t\"Actual: 0\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IntNotWithinRangeWithZeroMinimum",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.InRange(2, 0, 1));\n\n\t\t\tAssert.IsType<InRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.InRange() Failure: Value not in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (0 - 1)\" + Environment.NewLine +\n\t\t\t\t\"Actual: 2\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IntValueWithinRange",
        "body": "{\n\t\t\tAssert.InRange(2, 1, 3);\n\t\t}"
      },
      {
        "name": "StringNotWithinRange",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.InRange(\"adam\", \"bob\", \"scott\"));\n\n\t\t\tAssert.IsType<InRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.InRange() Failure: Value not in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (\\\"bob\\\" - \\\"scott\\\")\" + Environment.NewLine +\n\t\t\t\t\"Actual: \\\"adam\\\"\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "StringValueWithinRange",
        "body": "{\n\t\t\tAssert.InRange(\"bob\", \"adam\", \"scott\");\n\t\t}"
      },
      {
        "name": "DoubleValueWithinRange",
        "body": "{\n\t\t\tAssert.InRange(400.0, .75, 1.25, new DoubleComparer(-1));\n\t\t}"
      },
      {
        "name": "DoubleNotWithinRange",
        "body": "{\n\t\t\tAssert.NotInRange(1.50, .75, 1.25);\n\t\t}"
      },
      {
        "name": "DoubleWithinRange",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.NotInRange(1.0, .75, 1.25));\n\n\t\t\tAssert.IsType<NotInRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (0.75 - 1.25)\" + Environment.NewLine +\n\t\t\t\t\"Actual: 1\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IntNotWithinRange",
        "body": "{\n\t\t\tAssert.NotInRange(1, 2, 3);\n\t\t}"
      },
      {
        "name": "IntWithinRange",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.NotInRange(2, 1, 3));\n\n\t\t\tAssert.IsType<NotInRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (1 - 3)\" + Environment.NewLine +\n\t\t\t\t\"Actual: 2\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "StringNotWithNotInRange",
        "body": "{\n\t\t\tAssert.NotInRange(\"adam\", \"bob\", \"scott\");\n\t\t}"
      },
      {
        "name": "StringWithNotInRange",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.NotInRange(\"bob\", \"adam\", \"scott\"));\n\n\t\t\tAssert.IsType<NotInRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (\\\"adam\\\" - \\\"scott\\\")\" + Environment.NewLine +\n\t\t\t\t\"Actual: \\\"bob\\\"\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "DoubleValueWithinRange",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.NotInRange(400.0, .75, 1.25, new DoubleComparer(-1)));\n\n\t\t\tAssert.IsType<NotInRangeException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.NotInRange() Failure: Value in range\" + Environment.NewLine +\n\t\t\t\t\"Range:  (0.75 - 1.25)\" + Environment.NewLine +\n\t\t\t\t\"Actual: 400\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "DoubleValueNotWithinRange",
        "body": "{\n\t\t\tAssert.NotInRange(1.0, .75, 1.25, new DoubleComparer(1));\n\t\t}"
      }
    ]
  },
  {
    "file": "ArgumentFormatterTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n#if XUNIT_V2\n\t\t\tvar task = Task.Run(() => { });\n#else\n\t\t\tvar task = Task.Run(() => { }, TestContext.Current.CancellationToken);\n#endif\n\t\t\tawait task;\n\n\t\t\tAssert.Equal(\"Task { Status = RanToCompletion }\", ArgumentFormatter.Format(task));\n\t\t}"
      },
      {
        "name": "TaskGenericValue",
        "body": "{\n\t\t\tvar taskCompletionSource = new TaskCompletionSource<int>();\n\t\t\ttaskCompletionSource.SetException(new DivideByZeroException());\n\n\t\t\tAssert.Equal(\"Task<int> { Status = Faulted }\", ArgumentFormatter.Format(taskCompletionSource.Task));\n\t\t}"
      },
      {
        "name": "GroupingIsRenderedAsCollectionsOfKeysLinkedToCollectionsOfValues",
        "body": "{\n\t\t\tvar grouping = Enumerable.Range(0, 10).GroupBy(i => i % 2 == 0).FirstOrDefault(g => g.Key == true);\n\n\t\t\tAssert.Equal(\"[True] = [0, 2, 4, 6, 8]\", ArgumentFormatter.Format(grouping));\n\t\t}"
      },
      {
        "name": "GroupingsAreRenderedAsCollectionsOfKeysLinkedToCollectionsOfValues",
        "body": "{\n\t\t\tvar grouping = Enumerable.Range(0, 10).GroupBy(i => i % 2 == 0);\n\n\t\t\tAssert.Equal(\"[[True] = [0, 2, 4, 6, 8], [False] = [1, 3, 5, 7, 9]]\", ArgumentFormatter.Format(grouping));\n\t\t}"
      },
      {
        "name": "WhenCustomTypeImplementsToString_UsesToString",
        "body": "{\n\t\t\tAssert.Equal(\"This is what you should show\", ArgumentFormatter.Format(new TypeWithToString()));\n\t\t}"
      },
      {
        "name": "ArgumentFormatterFormatTypeNameGenericTypeParameter",
        "body": "{\n\t\t\tvar genericTypeParameters = typeof(List<>).GetGenericArguments();\n\t\t\tvar parameterType = genericTypeParameters.First();\n\n\t\t\tAssert.Equal(\"typeof(T)\", ArgumentFormatter.Format(parameterType));\n\t\t}"
      },
      {
        "name": "ArgumentFormatterFormatTypeNameGenericTypeParameters",
        "body": "{\n\t\t\tvar genericTypeParameters = typeof(Dictionary<,>).GetGenericArguments();\n\t\t\tvar parameterTKey = genericTypeParameters.First();\n\n\t\t\tAssert.Equal(\"typeof(TKey)\", ArgumentFormatter.Format(parameterTKey));\n\n\t\t\tvar parameterTValue = genericTypeParameters.Last();\n\t\t\tAssert.Equal(\"typeof(TValue)\", ArgumentFormatter.Format(parameterTValue));\n\t\t}"
      }
    ]
  },
  {
    "file": "CollectionTrackerTests.cs",
    "methods": [
      {
        "name": "ExceededDepth",
        "body": "{\n\t\t\tvar tracker = new[] { 42, 2112 }.AsTracker();\n\n\t\t\tvar result = tracker.FormatIndexedMismatch(2600, out var pointerIndent, ArgumentFormatter.MAX_DEPTH);\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", result);\n\t\t\t//             - ^\n\t\t\tAssert.Equal(1, pointerIndent);\n\t\t}"
      },
      {
        "name": "SmallCollection_Start",
        "body": "{\n\t\t\tvar tracker = new[] { 42, 2112 }.AsTracker();\n\n\t\t\tvar result = tracker.FormatIndexedMismatch(0, out var pointerIndent);\n\n\t\t\tAssert.Equal(\"[42, 2112]\", result);\n\t\t\t//            -^\n\t\t\tAssert.Equal(1, pointerIndent);\n\t\t}"
      },
      {
        "name": "LargeCollection_Start",
        "body": "{\n\t\t\tvar tracker = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsTracker();\n\n\t\t\tvar result = tracker.FormatIndexedMismatch(1, out var pointerIndent);\n\n\t\t\tAssert.Equal($\"[1, 2, 3, 4, 5, {ArgumentFormatter.Ellipsis}]\", result);\n\t\t\t//             ----^\n\t\t\tAssert.Equal(4, pointerIndent);\n\t\t}"
      },
      {
        "name": "LargeCollection_Mid",
        "body": "{\n\t\t\tvar tracker = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsTracker();\n\n\t\t\tvar result = tracker.FormatIndexedMismatch(3, out var pointerIndent);\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}, 2, 3, 4, 5, 6, {ArgumentFormatter.Ellipsis}]\", result);\n\t\t\t//             - ---                        |----|--^\n\t\t\tAssert.Equal(12, pointerIndent);\n\t\t}"
      },
      {
        "name": "LargeCollection_End",
        "body": "{\n\t\t\tvar tracker = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsTracker();\n\n\t\t\tvar result = tracker.FormatIndexedMismatch(6, out var pointerIndent);\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}, 3, 4, 5, 6, 7]\", result);\n\t\t\t//             - ---                        |----|----|---^\n\t\t\tAssert.Equal(18, pointerIndent);\n\t\t}"
      },
      {
        "name": "ExceededDepth",
        "body": "{\n\t\t\tvar span = new[] { 42, 2112 }.AsSpan();\n\n\t\t\tvar result = CollectionTracker<int>.FormatIndexedMismatch(span, 2600, out var pointerIndent, ArgumentFormatter.MAX_DEPTH);\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", result);\n\t\t\t//             - ^\n\t\t\tAssert.Equal(1, pointerIndent);\n\t\t}"
      },
      {
        "name": "SmallCollection_Start",
        "body": "{\n\t\t\tvar span = new[] { 42, 2112 }.AsSpan();\n\n\t\t\tvar result = CollectionTracker<int>.FormatIndexedMismatch(span, 0, out var pointerIndent);\n\n\t\t\tAssert.Equal(\"[42, 2112]\", result);\n\t\t\t//            -^\n\t\t\tAssert.Equal(1, pointerIndent);\n\t\t}"
      },
      {
        "name": "LargeCollection_Start",
        "body": "{\n\t\t\tvar span = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsSpan();\n\n\t\t\tvar result = CollectionTracker<int>.FormatIndexedMismatch(span, 1, out var pointerIndent);\n\n\t\t\tAssert.Equal($\"[1, 2, 3, 4, 5, {ArgumentFormatter.Ellipsis}]\", result);\n\t\t\t//             ----^\n\t\t\tAssert.Equal(4, pointerIndent);\n\t\t}"
      },
      {
        "name": "LargeCollection_Mid",
        "body": "{\n\t\t\tvar span = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsSpan();\n\n\t\t\tvar result = CollectionTracker<int>.FormatIndexedMismatch(span, 3, out var pointerIndent);\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}, 2, 3, 4, 5, 6, {ArgumentFormatter.Ellipsis}]\", result);\n\t\t\t//             - ---                        |----|--^\n\t\t\tAssert.Equal(12, pointerIndent);\n\t\t}"
      },
      {
        "name": "LargeCollection_End",
        "body": "{\n\t\t\tvar span = new[] { 1, 2, 3, 4, 5, 6, 7 }.AsSpan();\n\n\t\t\tvar result = CollectionTracker<int>.FormatIndexedMismatch(span, 6, out var pointerIndent);\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}, 3, 4, 5, 6, 7]\", result);\n\t\t\t//             - ---                        |----|----|---^\n\t\t\tAssert.Equal(18, pointerIndent);\n\t\t}"
      },
      {
        "name": "Empty",
        "body": "{\n\t\t\tvar tracker = new object[0].AsTracker();\n\n\t\t\tAssert.Equal(\"[]\", tracker.FormatStart());\n\t\t}"
      },
      {
        "name": "ExceededDepth",
        "body": "{\n\t\t\tvar tracker = new object[0].AsTracker();\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", tracker.FormatStart(ArgumentFormatter.MAX_DEPTH));\n\t\t}"
      },
      {
        "name": "Empty",
        "body": "{\n\t\t\tIEnumerable<object> collection = new object[0];\n\n\t\t\tAssert.Equal(\"[]\", CollectionTracker<object>.FormatStart(collection));\n\t\t}"
      },
      {
        "name": "ExceededDepth",
        "body": "{\n\t\t\tIEnumerable<object> collection = new object[0];\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", CollectionTracker<object>.FormatStart(collection, ArgumentFormatter.MAX_DEPTH));\n\t\t}"
      },
      {
        "name": "Empty",
        "body": "{\n\t\t\tvar span = new object[0].AsSpan();\n\n\t\t\tAssert.Equal(\"[]\", CollectionTracker<object>.FormatStart(span));\n\t\t}"
      },
      {
        "name": "ExceededDepth",
        "body": "{\n\t\t\tvar span = new object[0].AsSpan();\n\n\t\t\tAssert.Equal($\"[{ArgumentFormatter.Ellipsis}]\", CollectionTracker<object>.FormatStart(span, ArgumentFormatter.MAX_DEPTH));\n\t\t}"
      }
    ]
  },
  {
    "file": "SetAssertsTests.cs",
    "methods": [
      {
        "name": "ValueInSet",
        "body": "{\n\t\t\tvar set = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"forty-two\" };\n\n\t\t\tAssert.Contains(\"FORTY-two\", set);\n\t\t\tAssert.Contains(\"FORTY-two\", (ISet<string>)set);\n\t\t\tAssert.Contains(\"FORTY-two\", set.ToSortedSet(StringComparer.OrdinalIgnoreCase));\n#if NET5_0_OR_GREATER\n\t\t\tAssert.Contains(\"FORTY-two\", (IReadOnlySet<string>)set);\n#endif\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tAssert.Contains(\"FORTY-two\", set.ToImmutableHashSet(StringComparer.OrdinalIgnoreCase));\n\t\t\tAssert.Contains(\"FORTY-two\", set.ToImmutableSortedSet(StringComparer.OrdinalIgnoreCase));\n#endif\n\t\t}"
      },
      {
        "name": "ValueNotInSet",
        "body": "{\n\t\t\tvar set = new HashSet<string>() { \"eleventeen\" };\n\n\t\t\tvoid assertFailure(Action action)\n\t\t\t{\n\t\t\t\tvar ex = Record.Exception(action);\n\n\t\t\t\tAssert.IsType<ContainsException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.Contains() Failure: Item not found in set\" + Environment.NewLine +\n\t\t\t\t\t\"Set:       [\\\"eleventeen\\\"]\" + Environment.NewLine +\n\t\t\t\t\t\"Not found: \\\"FORTY-two\\\"\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", set));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", (ISet<string>)set));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", set.ToSortedSet()));\n#if NET5_0_OR_GREATER\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", (IReadOnlySet<string>)set));\n#endif\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", set.ToImmutableHashSet()));\n\t\t\tassertFailure(() => Assert.Contains(\"FORTY-two\", set.ToImmutableSortedSet()));\n#endif\n\t\t}"
      },
      {
        "name": "ValueNotInSet",
        "body": "{\n\t\t\tvar set = new HashSet<string>() { \"eleventeen\" };\n\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", set);\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", (ISet<string>)set);\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", set.ToSortedSet());\n#if NET5_0_OR_GREATER\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", (IReadOnlySet<string>)set);\n#endif\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", set.ToImmutableHashSet());\n\t\t\tAssert.DoesNotContain(\"FORTY-two\", set.ToImmutableSortedSet());\n#endif\n\t\t}"
      },
      {
        "name": "ValueInSet",
        "body": "{\n\t\t\tvar set = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"forty-two\" };\n\n\t\t\tvoid assertFailure(Action action)\n\t\t\t{\n\t\t\t\tvar ex = Record.Exception(action);\n\n\t\t\t\tAssert.IsType<DoesNotContainException>(ex);\n\t\t\t\tAssert.Equal(\n\t\t\t\t\t\"Assert.DoesNotContain() Failure: Item found in set\" + Environment.NewLine +\n\t\t\t\t\t\"Set:   [\\\"forty-two\\\"]\" + Environment.NewLine +\n\t\t\t\t\t\"Found: \\\"FORTY-two\\\"\",\n\t\t\t\t\tex.Message\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (ISet<string>)set));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set.ToSortedSet(StringComparer.OrdinalIgnoreCase)));\n#if NET5_0_OR_GREATER\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", (IReadOnlySet<string>)set));\n#endif\n#if XUNIT_IMMUTABLE_COLLECTIONS\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set.ToImmutableHashSet(StringComparer.OrdinalIgnoreCase)));\n\t\t\tassertFailure(() => Assert.DoesNotContain(\"FORTY-two\", set.ToImmutableSortedSet(StringComparer.OrdinalIgnoreCase)));\n#endif\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"expectedSubset\", () => Assert.ProperSubset(null!, new HashSet<int>()));\n\t\t}"
      },
      {
        "name": "IsSubsetButNotProperSubset",
        "body": "{\n\t\t\tvar expectedSubset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3 };\n\n\t\t\tvar ex = Record.Exception(() => Assert.ProperSubset(expectedSubset, actual));\n\n\t\t\tAssert.IsType<ProperSubsetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ProperSubset() Failure: Value is not a proper subset\" + Environment.NewLine +\n\t\t\t\t\"Expected: [1, 2, 3]\" + Environment.NewLine +\n\t\t\t\t\"Actual:   [1, 2, 3]\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IsProperSubset",
        "body": "{\n\t\t\tvar expectedSubset = new HashSet<int> { 1, 2, 3, 4 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3 };\n\n\t\t\tAssert.ProperSubset(expectedSubset, actual);\n\t\t}"
      },
      {
        "name": "IsNotSubset",
        "body": "{\n\t\t\tvar expectedSubset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 7 };\n\n\t\t\tvar ex = Record.Exception(() => Assert.ProperSubset(expectedSubset, actual));\n\n\t\t\tAssert.IsType<ProperSubsetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ProperSubset() Failure: Value is not a proper subset\" + Environment.NewLine +\n\t\t\t\t\"Expected: [1, 2, 3]\" + Environment.NewLine +\n\t\t\t\t\"Actual:   [1, 2, 7]\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullActual",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.ProperSubset(new HashSet<int>(), null));\n\n\t\t\tAssert.IsType<ProperSubsetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ProperSubset() Failure: Value is not a proper subset\" + Environment.NewLine +\n\t\t\t\t\"Expected: []\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"expectedSuperset\", () => Assert.ProperSuperset(null!, new HashSet<int>()));\n\t\t}"
      },
      {
        "name": "IsSupersetButNotProperSuperset",
        "body": "{\n\t\t\tvar expectedSuperset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3 };\n\n\t\t\tvar ex = Record.Exception(() => Assert.ProperSuperset(expectedSuperset, actual));\n\n\t\t\tAssert.IsType<ProperSupersetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ProperSuperset() Failure: Value is not a proper superset\" + Environment.NewLine +\n\t\t\t\t\"Expected: [1, 2, 3]\" + Environment.NewLine +\n\t\t\t\t\"Actual:   [1, 2, 3]\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IsProperSuperset",
        "body": "{\n\t\t\tvar expectedSuperset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3, 4 };\n\n\t\t\tAssert.ProperSuperset(expectedSuperset, actual);\n\t\t}"
      },
      {
        "name": "IsNotSuperset",
        "body": "{\n\t\t\tvar expectedSuperset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 7 };\n\n\t\t\tvar ex = Record.Exception(() => Assert.ProperSuperset(expectedSuperset, actual));\n\n\t\t\tAssert.IsType<ProperSupersetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ProperSuperset() Failure: Value is not a proper superset\" + Environment.NewLine +\n\t\t\t\t\"Expected: [1, 2, 3]\" + Environment.NewLine +\n\t\t\t\t\"Actual:   [1, 2, 7]\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullActual",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.ProperSuperset(new HashSet<int>(), null));\n\n\t\t\tAssert.IsType<ProperSupersetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.ProperSuperset() Failure: Value is not a proper superset\" + Environment.NewLine +\n\t\t\t\t\"Expected: []\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"expectedSubset\", () => Assert.Subset(null!, new HashSet<int>()));\n\t\t}"
      },
      {
        "name": "IsSubset",
        "body": "{\n\t\t\tvar expectedSubset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3 };\n\n\t\t\tAssert.Subset(expectedSubset, actual);\n\t\t}"
      },
      {
        "name": "IsProperSubset",
        "body": "{\n\t\t\tvar expectedSubset = new HashSet<int> { 1, 2, 3, 4 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3 };\n\n\t\t\tAssert.Subset(expectedSubset, actual);\n\t\t}"
      },
      {
        "name": "IsNotSubset",
        "body": "{\n\t\t\tvar expectedSubset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 7 };\n\n\t\t\tvar ex = Record.Exception(() => Assert.Subset(expectedSubset, actual));\n\n\t\t\tAssert.IsType<SubsetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Subset() Failure: Value is not a subset\" + Environment.NewLine +\n\t\t\t\t\"Expected: [1, 2, 3]\" + Environment.NewLine +\n\t\t\t\t\"Actual:   [1, 2, 7]\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullActual",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.Subset(new HashSet<int>(), null));\n\n\t\t\tAssert.IsType<SubsetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Subset() Failure: Value is not a subset\" + Environment.NewLine +\n\t\t\t\t\"Expected: []\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"expectedSuperset\", () => Assert.Superset(null!, new HashSet<int>()));\n\t\t}"
      },
      {
        "name": "IsSuperset",
        "body": "{\n\t\t\tvar expectedSuperset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3 };\n\n\t\t\tAssert.Superset(expectedSuperset, actual);\n\t\t}"
      },
      {
        "name": "IsProperSuperset",
        "body": "{\n\t\t\tvar expectedSuperset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 3, 4 };\n\n\t\t\tAssert.Superset(expectedSuperset, actual);\n\t\t}"
      },
      {
        "name": "IsNotSuperset",
        "body": "{\n\t\t\tvar expectedSuperset = new HashSet<int> { 1, 2, 3 };\n\t\t\tvar actual = new HashSet<int> { 1, 2, 7 };\n\n\t\t\tvar ex = Assert.Throws<SupersetException>(() => Assert.Superset(expectedSuperset, actual));\n\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Superset() Failure: Value is not a superset\" + Environment.NewLine +\n\t\t\t\t\"Expected: [1, 2, 3]\" + Environment.NewLine +\n\t\t\t\t\"Actual:   [1, 2, 7]\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullActual",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => Assert.Superset(new HashSet<int>(), null));\n\n\t\t\tAssert.IsType<SupersetException>(ex);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.Superset() Failure: Value is not a superset\" + Environment.NewLine +\n\t\t\t\t\"Expected: []\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tex.Message\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "TypeAssertsTests.cs",
    "methods": [
      {
        "name": "NullObject",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsAssignableFrom<object>(null));\n\n\t\t\tAssert.IsType<IsAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsAssignableFrom() Failure: Value is null\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsAssignableFrom<InvalidCastException>(ex);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsAssignableFrom<Exception>(ex);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n\t\t\tAssert.IsAssignableFrom<IDisposable>(ex);\n\t\t}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Assert.IsAssignableFrom<InvalidCastException>(ex);\n\n\t\t\tAssert.Same(ex, result);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tvar result =\n\t\t\t\tRecord.Exception(\n\t\t\t\t\t() => Assert.IsAssignableFrom<InvalidCastException>(new InvalidOperationException())\n\t\t\t\t);\n\n\t\t\tAssert.IsType<IsAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsAssignableFrom() Failure: Value is an incompatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidOperationException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsAssignableFrom(typeof(object), null));\n\n\t\t\tAssert.IsType<IsAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsAssignableFrom() Failure: Value is null\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsAssignableFrom(typeof(InvalidCastException), ex);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsAssignableFrom(typeof(Exception), ex);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n\t\t\tAssert.IsAssignableFrom(typeof(IDisposable), ex);\n\t\t}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Assert.IsAssignableFrom<InvalidCastException>(ex);\n\n\t\t\tAssert.Same(ex, result);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tvar result =\n\t\t\t\tRecord.Exception(\n\t\t\t\t\t() => Assert.IsAssignableFrom(typeof(InvalidCastException), new InvalidOperationException())\n\t\t\t\t);\n\n\t\t\tAssert.IsType<IsAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsAssignableFrom() Failure: Value is an incompatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidOperationException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tAssert.IsNotAssignableFrom<object>(null);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotAssignableFrom<InvalidCastException>(ex));\n\n\t\t\tAssert.IsType<IsNotAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotAssignableFrom<Exception>(ex));\n\n\t\t\tAssert.IsType<IsNotAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.Exception)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotAssignableFrom<IDisposable>(ex));\n\n\t\t\tAssert.IsType<IsNotAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(TypeAssertsTests+DisposableClass)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tAssert.IsNotAssignableFrom<InvalidCastException>(new InvalidOperationException());\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tAssert.IsNotAssignableFrom(typeof(object), null);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotAssignableFrom(typeof(InvalidCastException), ex));\n\n\t\t\tAssert.IsType<IsNotAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotAssignableFrom(typeof(Exception), ex));\n\n\t\t\tAssert.IsType<IsNotAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.Exception)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotAssignableFrom(typeof(IDisposable), ex));\n\n\t\t\tAssert.IsType<IsNotAssignableFromException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotAssignableFrom() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(TypeAssertsTests+DisposableClass)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tAssert.IsNotAssignableFrom(typeof(InvalidCastException), new InvalidOperationException());\n\t\t}"
      },
      {
        "name": "UnmatchedType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsNotType<Exception>(ex);\n\t\t}"
      },
      {
        "name": "MatchedType",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType<InvalidCastException>(new InvalidCastException()));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is the exact type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tAssert.IsNotType<object>(null);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tAssert.IsNotType<object>(null, exactMatch: false);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType<InvalidCastException>(ex, exactMatch: false));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal<object>(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType<Exception>(ex, exactMatch: false));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal<object>(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.Exception)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n#pragma warning disable xUnit2018  // TODO: Temporary until xUnit2018 is updated for the new signatures\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType<IDisposable>(ex, exactMatch: false));\n#pragma warning restore xUnit2018\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal<object>(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(TypeAssertsTests+DisposableClass)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tAssert.IsNotType<InvalidCastException>(new InvalidOperationException(), exactMatch: false);\n\t\t}"
      },
      {
        "name": "UnmatchedType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsNotType(typeof(Exception), ex);\n\t\t}"
      },
      {
        "name": "MatchedType",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType(typeof(InvalidCastException), new InvalidCastException()));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is the exact type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tAssert.IsNotType(typeof(object), null);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tAssert.IsNotType(typeof(object), null, exactMatch: false);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType(typeof(InvalidCastException), ex, exactMatch: false));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType(typeof(Exception), ex, exactMatch: false));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.Exception)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidCastException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n\t\t\tvar result = Record.Exception(() => Assert.IsNotType(typeof(IDisposable), ex, exactMatch: false));\n\n\t\t\tAssert.IsType<IsNotTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsNotType() Failure: Value is a compatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.IDisposable)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(TypeAssertsTests+DisposableClass)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tAssert.IsNotType(typeof(InvalidCastException), new InvalidOperationException(), exactMatch: false);\n\t\t}"
      },
      {
        "name": "MatchingType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsType<InvalidCastException>(ex);\n\t\t}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Assert.IsType<InvalidCastException>(ex);\n\n\t\t\tAssert.Same(ex, result);\n\t\t}"
      },
      {
        "name": "UnmatchedType",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsType<InvalidCastException>(new InvalidOperationException()));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidOperationException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar dynamicAssembly = await CSharpDynamicAssembly.Create(\"namespace System.Xml { public class XmlException: Exception { } }\");\n\t\t\tvar assembly = Assembly.LoadFile(dynamicAssembly.FileName);\n\t\t\tvar dynamicXmlExceptionType = assembly.GetType(\"System.Xml.XmlException\");\n\t\t\tAssert.NotNull(dynamicXmlExceptionType);\n\t\t\tvar ex = Activator.CreateInstance(dynamicXmlExceptionType);\n\n\t\t\tvar result = Record.Exception(() => Assert.IsType<XmlException>(ex));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.Xml.XmlException) (from \" + typeof(XmlException).Assembly.FullName + \")\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.Xml.XmlException) (from \" + assembly.FullName + \")\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsType<object>(null));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsType<object>(null, exactMatch: false));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsType<InvalidCastException>(ex, exactMatch: false);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsType<Exception>(ex, exactMatch: false);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n#pragma warning disable xUnit2018  // TODO: Temporary until xUnit2018 is updated for the new signatures\n\t\t\tAssert.IsType<IDisposable>(ex, exactMatch: false);\n#pragma warning restore xUnit2018\n\t\t}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Assert.IsType<InvalidCastException>(ex, exactMatch: false);\n\n\t\t\tAssert.Same(ex, result);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tvar result =\n\t\t\t\tRecord.Exception(\n\t\t\t\t\t() => Assert.IsType<InvalidCastException>(new InvalidOperationException(), exactMatch: false)\n\t\t\t\t);\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is an incompatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidOperationException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "MatchingType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsType(typeof(InvalidCastException), ex);\n\t\t}"
      },
      {
        "name": "UnmatchedTypeThrows",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsType(typeof(InvalidCastException), new InvalidOperationException()));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidOperationException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar dynamicAssembly = await CSharpDynamicAssembly.Create(\"namespace System.Xml { public class XmlException: Exception { } }\");\n\t\t\tvar assembly = Assembly.LoadFile(dynamicAssembly.FileName);\n\t\t\tvar dynamicXmlExceptionType = assembly.GetType(\"System.Xml.XmlException\");\n\t\t\tAssert.NotNull(dynamicXmlExceptionType);\n\t\t\tvar ex = Activator.CreateInstance(dynamicXmlExceptionType);\n\n\t\t\tvar result = Record.Exception(() => Assert.IsType(typeof(XmlException), ex));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is not the exact type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.Xml.XmlException) (from \" + typeof(XmlException).Assembly.FullName + \")\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.Xml.XmlException) (from \" + assembly.FullName + \")\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObjectThrows",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsType(typeof(object), null));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NullObject",
        "body": "{\n\t\t\tvar result = Record.Exception(() => Assert.IsType(typeof(object), null, exactMatch: false));\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is null\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(object)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   null\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SameType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsType(typeof(InvalidCastException), ex, exactMatch: false);\n\t\t}"
      },
      {
        "name": "BaseType",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tAssert.IsType(typeof(Exception), ex, exactMatch: false);\n\t\t}"
      },
      {
        "name": "Interface",
        "body": "{\n\t\t\tvar ex = new DisposableClass();\n\n\t\t\tAssert.IsType(typeof(IDisposable), ex, exactMatch: false);\n\t\t}"
      },
      {
        "name": "ReturnsCastObject",
        "body": "{\n\t\t\tvar ex = new InvalidCastException();\n\n\t\t\tvar result = Assert.IsType<InvalidCastException>(ex, exactMatch: false);\n\n\t\t\tAssert.Same(ex, result);\n\t\t}"
      },
      {
        "name": "IncompatibleType",
        "body": "{\n\t\t\tvar result =\n\t\t\t\tRecord.Exception(\n\t\t\t\t\t() => Assert.IsType(typeof(InvalidCastException), new InvalidOperationException(), exactMatch: false)\n\t\t\t\t);\n\n\t\t\tAssert.IsType<IsTypeException>(result);\n\t\t\tAssert.Equal(\n\t\t\t\t\"Assert.IsType() Failure: Value is an incompatible type\" + Environment.NewLine +\n\t\t\t\t\"Expected: typeof(System.InvalidCastException)\" + Environment.NewLine +\n\t\t\t\t\"Actual:   typeof(System.InvalidOperationException)\",\n\t\t\t\tresult.Message\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "IAssemblyMetadataExtensionsTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"assemblyMetadata\", () => IAssemblyMetadataExtensions.SimpleAssemblyName(null!));\n\n\t\t\tvar metadata = Substitute.For<IAssemblyMetadata, InterfaceProxy<IAssemblyMetadata>>();\n\t\t\tmetadata.AssemblyName.Returns(default(string));\n\t\t\tAssert.Throws<ArgumentNullException>(\"assemblyMetadata.AssemblyName\", () => IAssemblyMetadataExtensions.SimpleAssemblyName(metadata));\n\t\t}"
      },
      {
        "name": "ReturnsSimpleName",
        "body": "{\n\t\t\tvar metadata = Mocks.AssemblyMetadata(\"mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\");\n\n\t\t\tvar result = IAssemblyMetadataExtensions.SimpleAssemblyName(metadata);\n\n\t\t\tAssert.Equal(\"mscorlib\", result);\n\t\t}"
      }
    ]
  },
  {
    "file": "ReflectionExtensionsTests.cs",
    "methods": [
      {
        "name": "GetDefaultValue",
        "body": "{\n\t\tAssert.Null(typeof(object).GetDefaultValue());\n\t\tAssert.Equal(0, typeof(int).GetDefaultValue());\n\t}"
      },
      {
        "name": "ForAssembly",
        "body": "{\n\t\t\tvar attrs = typeof(ReflectionExtensionsTests).Assembly.GetMatchingCustomAttributes(typeof(IAttributeUnderTest));\n\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest);\n#if !NETFRAMEWORK\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest<int>);\n#endif\n\t\t}"
      },
      {
        "name": "ForAttribute",
        "body": "{\n\t\t\tvar attrs = new AttributeWithAttribute().GetMatchingCustomAttributes(typeof(IAttributeUnderTest));\n\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest);\n#if !NETFRAMEWORK\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest<int>);\n#endif\n\t\t}"
      },
      {
        "name": "ForMethod",
        "body": "{\n\t\t\tvar attrs = typeof(GetMatchingCustomAttributes).GetMethod(nameof(MethodWithAttribute), BindingFlags.NonPublic | BindingFlags.Static)?.GetMatchingCustomAttributes(typeof(IAttributeUnderTest)) ?? [];\n\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest);\n#if !NETFRAMEWORK\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest<int>);\n#endif\n\t\t}"
      },
      {
        "name": "ForParameter",
        "body": "{\n\t\t\tvar method = typeof(GetMatchingCustomAttributes).GetMethod(nameof(MethodWithParameter), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\t\t\tvar attrs = method.GetParameters()[0].GetMatchingCustomAttributes(typeof(IAttributeUnderTest));\n\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest);\n#if !NETFRAMEWORK\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest<int>);\n#endif\n\t\t}"
      },
      {
        "name": "ForType",
        "body": "{\n\t\t\tvar attrs = typeof(ClassWithAttribute).GetMatchingCustomAttributes(typeof(IAttributeUnderTest));\n\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest);\n#if !NETFRAMEWORK\n\t\t\tAssert.Contains(attrs, attr => attr is AttributeUnderTest<int>);\n#endif\n\t\t}"
      },
      {
        "name": "Implements",
        "body": "{\n\t\tAssert.True(typeof(string).Implements(typeof(IEnumerable<char>)));\n\t\tAssert.True(typeof(IEnumerable<>).Implements(typeof(IEnumerable)));\n\t\tAssert.True(typeof(IEnumerable<int>).Implements(typeof(IEnumerable)));\n\n\t\tAssert.False(typeof(object).Implements(typeof(IEnumerable)));\n\t\tAssert.False(typeof(IAsyncDisposable).Implements(typeof(IDisposable)));\n\t}"
      },
      {
        "name": "IsFromLocalAssembly",
        "body": "{\n\t\tAssert.True(typeof(MyEnum).IsFromLocalAssembly());\n#if NETFRAMEWORK\n\t\tif (!EnvironmentHelper.IsMono)\n\t\t\tAssert.False(typeof(System.Xml.ConformanceLevel).IsFromLocalAssembly());\n#endif\n\t}"
      },
      {
        "name": "IsNullable",
        "body": "{\n\t\tAssert.True(typeof(object).IsNullable());\n\t\tAssert.True(typeof(string).IsNullable());\n\t\tAssert.True(typeof(IXunitSerializable).IsNullable());\n\t\tAssert.True(typeof(char?).IsNullable());\n\t\tAssert.False(typeof(char).IsNullable());\n\t}"
      },
      {
        "name": "IsNullableEnum",
        "body": "{\n\t\tAssert.True(typeof(MyEnum?).IsNullableEnum());\n\t\tAssert.False(typeof(MyEnum).IsNullableEnum());\n\t\tAssert.False(typeof(char?).IsNullableEnum());\n\t}"
      },
      {
        "name": "NoArguments",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithNoArgs), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\n\t\t\tvar result = method.ResolveMethodArguments([]);\n\n\t\t\tAssert.Empty(result);\n\t\t}"
      },
      {
        "name": "TooFewArguments",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithTwoArgs), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\t\t\tvar args = new[] { new object() };\n\n\t\t\tvar result = method.ResolveMethodArguments(args);\n\n\t\t\tAssert.Same(args, result);\n\t\t}"
      },
      {
        "name": "MethodWithDefaultValue_UsesDefaultValue",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithDefaultValue), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\n\t\t\tvar results = method.ResolveMethodArguments([]);\n\n\t\t\tvar result = Assert.Single(results);\n\t\t\tAssert.Equal(42, result);\n\t\t}"
      },
      {
        "name": "MethodWithParams_NoValuesProvided",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\n\t\t\tvar results = method.ResolveMethodArguments([]);\n\n\t\t\tvar result = Assert.Single(results);\n\t\t\tvar resultArray = Assert.IsType<int[]>(result);\n\t\t\tAssert.Empty(resultArray);\n\t\t}"
      },
      {
        "name": "MethodWithParams_NullProvided",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\n\t\t\tvar results = method.ResolveMethodArguments([null]);\n\n\t\t\tvar result = Assert.Single(results);\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "MethodWithParams_DirectArrayProvided",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\t\t\tvar valueArray = new[] { 42, 2112 };\n\n\t\t\tvar results = method.ResolveMethodArguments([valueArray]);\n\n\t\t\tvar result = Assert.Single(results);\n\t\t\tAssert.Same(valueArray, result);\n\t\t}"
      },
      {
        "name": "MethodWithParams_MultipleValuesProvided",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\n\t\t\tvar results = method.ResolveMethodArguments([42, 2112]);\n\n\t\t\tvar result = Assert.Single(results);\n\t\t\tvar resultArray = Assert.IsType<int[]>(result);\n\t\t\tAssert.Equal(new[] { 42, 2112 }, resultArray);\n\t\t}"
      },
      {
        "name": "MethodWithParams_WrongType",
        "body": "{\n\t\t\tvar method = typeof(ResolveMethodArguments).GetMethod(nameof(MethodWithParams), BindingFlags.NonPublic | BindingFlags.Static);\n\t\t\tAssert.NotNull(method);\n\n\t\t\tvar ex = Record.Exception(() => method.ResolveMethodArguments([42, \"Hello\"]));\n\n\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\tAssert.Equal(\"The arguments for this test method did not match the parameters: [42, \\\"Hello\\\"]\", ex.Message);\n\t\t}"
      },
      {
        "name": "SafeName",
        "body": "{\n\t\tAssert.Equal(\"System.Object\", typeof(object).SafeName());\n\n\t\tvar genericMethod = typeof(ReflectionExtensionsTests).GetMethod(nameof(GenericMethod), BindingFlags.NonPublic | BindingFlags.Static);\n\t\tAssert.NotNull(genericMethod);\n\t\tvar genericArgumentType = genericMethod.GetGenericArguments()[0];\n\n\t\tAssert.Equal(\"T\", genericArgumentType.SafeName());\n\t}"
      },
      {
        "name": "ToCommaSeparatedList",
        "body": "{\n\t\tAssert.Equal(\"'System.Object', 'System.Int32'\", new[] { typeof(object), typeof(int) }.ToCommaSeparatedList());\n\t}"
      },
      {
        "name": "ToDisplayName",
        "body": "{\n\t\tAssert.Equal(\"Object\", typeof(object).ToDisplayName());\n\t\tAssert.Equal(\"Dictionary<String, List<Int32>>\", typeof(Dictionary<string, List<int>>).ToDisplayName());\n\t}"
      },
      {
        "name": "ToSimpleName",
        "body": "{\n\t\t// Without namespace\n\t\tAssert.Equal(\"ReflectionExtensionsTests\", typeof(ReflectionExtensionsTests).ToSimpleName());\n\t\tAssert.Equal(\"ReflectionExtensionsTests+ResolveMethodArguments\", typeof(ResolveMethodArguments).ToSimpleName());\n\n\t\t// With namespace\n\t\tAssert.Equal(\"ParentClass\", typeof(NS1.ParentClass).ToSimpleName());\n\t\tAssert.Equal(\"ParentClass+ChildClass\", typeof(NS1.ParentClass.ChildClass).ToSimpleName());\n\t}"
      },
      {
        "name": "UnwrapNullable",
        "body": "{\n\t\tAssert.Equal(typeof(object), typeof(object).UnwrapNullable());\n\t\tAssert.Equal(typeof(int), typeof(int).UnwrapNullable());\n\t\tAssert.Equal(typeof(int), typeof(int?).UnwrapNullable());\n\t}"
      }
    ]
  },
  {
    "file": "AssemblyExtensionsTests.cs",
    "methods": [
      {
        "name": "NullAssembly_ReturnsNull",
        "body": "{\n\t\t\tvar result = AssemblyExtensions.GetLocalCodeBase(null);\n\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "NullCodeBase_ReturnsNull",
        "body": "{\n\t\t\tvar result = AssemblyExtensions.GetLocalCodeBase(null, '/');\n\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "UnsupportedCodeBaseFormat_Throws",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => AssemblyExtensions.GetLocalCodeBase(\"http://host/path\", '/'));\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"codeBase\", argEx.ParamName);\n\t\t\tAssert.StartsWith(\"Codebase 'http://host/path' is unsupported; must start with 'file://'.\", argEx.Message);\n\t\t}"
      },
      {
        "name": "UnsupportedDirectorySeparator_Throws",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => AssemblyExtensions.GetLocalCodeBase(\"file:///path\", 'a'));\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"directorySeparator\", argEx.ParamName);\n\t\t\tAssert.StartsWith(\"Unknown directory separator 'a'; must be one of '/' or '\\\\'.\", argEx.Message);\n\t\t}"
      },
      {
        "name": "PosixSystem_LocalPath",
        "body": "{\n\t\t\tvar result = AssemblyExtensions.GetLocalCodeBase(\"file:///path/to/file.dll\", '/');\n\n\t\t\tAssert.Equal(\"/path/to/file.dll\", result);\n\t\t}"
      },
      {
        "name": "PosixSystem_UNCPath_Throws",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => AssemblyExtensions.GetLocalCodeBase(\"file://server/path\", '/'));\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"codeBase\", argEx.ParamName);\n\t\t\tAssert.StartsWith(\"UNC-style codebase 'file://server/path' is not supported on POSIX-style file systems.\", argEx.Message);\n\t\t}"
      },
      {
        "name": "WindowsSystem_LocalPath",
        "body": "{\n\t\t\tvar result = AssemblyExtensions.GetLocalCodeBase(\"file:///C:/path/to/file.dll\", '\\\\');\n\n\t\t\tAssert.Equal(@\"C:\\path\\to\\file.dll\", result);\n\t\t}"
      },
      {
        "name": "WindowsSystem_UNCPath",
        "body": "{\n\t\t\tvar result = AssemblyExtensions.GetLocalCodeBase(\"file://server/path/to/file.dll\", '\\\\');\n\n\t\t\tAssert.Equal(@\"\\\\server\\path\\to\\file.dll\", result);\n\t\t}"
      },
      {
        "name": "GetTargetFramework",
        "body": "{\n#if NET472\n\t\tvar expected = \".NETFramework,Version=v4.7.2\";\n#elif NET6_0\n\t\tvar expected = \".NETCoreApp,Version=v6.0\";\n#else\n#error Unknown target framework\n#endif\n\n\t\tvar result = AssemblyExtensions.GetTargetFramework(typeof(AssemblyExtensionsTests).Assembly);\n\n\t\tAssert.Equal(expected, result);\n\t}"
      }
    ]
  },
  {
    "file": "ObjectExtensionsTests.cs",
    "methods": [
      {
        "name": "NullValue",
        "body": "{\n\t\t\tvar result = ObjectExtensions.AsValueTask(null);\n\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "NonTaskValue",
        "body": "{\n\t\t\tvar result = ObjectExtensions.AsValueTask(42);\n\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar task = new ValueTask<int>(42);\n\n\t\t\tvar result = ObjectExtensions.AsValueTask(task);\n\n\t\t\tAssert.True(result.HasValue);\n\t\t\tAssert.Equal(42, await result.Value);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar task = Task.FromResult(42);\n\n\t\t\tvar result = ObjectExtensions.AsValueTask(task);\n\n\t\t\tAssert.True(result.HasValue);\n\t\t\tAssert.Equal(42, await result.Value);\n\t\t}"
      }
    ]
  },
  {
    "file": "JsonArraySerializerTests.cs",
    "methods": []
  },
  {
    "file": "JsonDeserializerTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\tAssert.Throws<ArgumentNullException>(\"json\", () => JsonDeserializer.TryDeserialize(null!, out var _));\n\t}"
      }
    ]
  },
  {
    "file": "JsonObjectSerializerTests.cs",
    "methods": []
  },
  {
    "file": "SerializationHelperTests.cs",
    "methods": [
      {
        "name": "GuardClauseForNullSerializedValue",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => TestableSerializationHelper.Instance.Deserialize(null!));\n\n\t\t\tvar argnEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"serializedValue\", argnEx.ParamName);\n\t\t}"
      },
      {
        "name": "ArraysCanBeNull",
        "body": "{\n\t\t\tvar result = TestableSerializationHelper.Instance.Deserialize(\"[]\");\n\n\t\t\tAssert.Null(result);\n\t\t}"
      },
      {
        "name": "CanSerializeRuntimeType",
        "body": "{\n\t\t\t// Type is abstract; RuntimeType is what you get at runtime and since it's\n\t\t\t// internal, we can't just call typeof() to get one\n\t\t\tvar type = 42.GetType().GetType();\n\n\t\t\tAssert.True(TestableSerializationHelper.Instance.IsSerializable(null, type));\n\t\t}"
      },
      {
        "name": "CannotSerializeGenericArgumentType",
        "body": "{\n\t\t\tvar value = typeof(ClassWithGenericMethod).GetMethod(nameof(ClassWithGenericMethod.GenericMethod))!.GetGenericArguments()[0];\n\t\t\tvar type = value.GetType();\n\n\t\t\tAssert.False(TestableSerializationHelper.Instance.IsSerializable(value, type));\n\t\t}"
      },
      {
        "name": "CannotSerializeGenericArgumentTypeInsideArray",
        "body": "{\n\t\t\tType[] value =\n\t\t\t[\n\t\t\t\t// Okay\n\t\t\t\ttypeof(Type),\n\t\t\t\t// Not okay\n\t\t\t\ttypeof(ClassWithGenericMethod).GetMethod(nameof(ClassWithGenericMethod.GenericMethod))!.GetGenericArguments()[0],\n\t\t\t];\n\t\t\tvar type = value.GetType();\n\n\t\t\tAssert.False(TestableSerializationHelper.Instance.IsSerializable(value, type));\n\t\t}"
      }
    ]
  },
  {
    "file": "XunitSerializationInfoTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => new XunitSerializationInfo(SerializationHelper.Instance, default(IXunitSerializable)!));\n\n\t\t\tvar argnEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"object\", argnEx.ParamName);\n\t\t}"
      },
      {
        "name": "InitializedWithSerializedValue",
        "body": "{\n\t\t\tvar info = new XunitSerializationInfo(SerializationHelper.Instance, $\"ch:1:97\\nst:0:{ToBase64(\"Hello world\")}\\ndec:12:21.12\");\n\n\t\t\tAssert.Equal('a', info.GetValue<char>(\"ch\"));\n\t\t\tAssert.Equal(\"Hello world\", info.GetValue<string>(\"st\"));\n\t\t\tAssert.Equal(21.12m, info.GetValue<decimal>(\"dec\"));\n\t\t}"
      },
      {
        "name": "EntryMissingDataThrowsDuringConstructor",
        "body": "{\n\t\t\tvar serialization = \"ch:1:97\\nst\\ndec:12:21.12\";\n\n\t\t\tvar ex = Record.Exception(() => new XunitSerializationInfo(SerializationHelper.Instance, serialization));\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"serializedValue\", argEx.ParamName);\n\t\t\tAssert.StartsWith($\"Serialized piece 'st' is malformed. Full serialization:{Environment.NewLine}{serialization}\", argEx.Message);\n\t\t}"
      },
      {
        "name": "GuardClauseForNonSerializableData",
        "body": "{\n\t\t\tvar info = new XunitSerializationInfo(SerializationHelper.Instance);\n\n\t\t\tvar ex = Record.Exception(() => info.AddValue(\"v\", new MyClass()));\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"value\", argEx.ParamName);\n\t\t\tAssert.StartsWith(\"Cannot serialize a value of type 'XunitSerializationInfoTests+MyClass': unsupported type for serialization\", argEx.Message);\n\t\t}"
      },
      {
        "name": "EmptyInfo",
        "body": "{\n\t\t\tvar info = new XunitSerializationInfo(SerializationHelper.Instance);\n\n\t\t\tvar result = info.ToSerializedString();\n\n\t\t\tAssert.Empty(result);\n\t\t}"
      }
    ]
  },
  {
    "file": "DisposalTrackerTests.cs",
    "methods": [
      {
        "name": "AddThrows",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => classUnderTest.Add(new object()));\n\n\t\t\tAssert.NotNull(ex);\n\t\t\tAssert.IsType<ObjectDisposedException>(ex);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tAssert.Equal(1, classToDispose.DisposeCount);  // Already disposed in InitializeAsync\n\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tAssert.Equal(1, classToDispose.DisposeCount);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar classUnderTest = new DisposalTracker();\n\t\t\tvar obj = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tclassUnderTest.Add(obj);\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => classUnderTest.DisposeAsync());\n\n\t\t\tAssert.Null(ex);\n\t\t\tobj.Received().Dispose();\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar classUnderTest = new DisposalTracker();\n\t\t\tvar obj1 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tclassUnderTest.Add(obj1);\n\t\t\tvar thrown = new DivideByZeroException();\n\t\t\tvar obj2 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tobj2.When(x => x.Dispose()).Throw(thrown);\n\t\t\tclassUnderTest.Add(obj2);\n\t\t\tvar obj3 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tclassUnderTest.Add(obj3);\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => classUnderTest.DisposeAsync());\n\n\t\t\tAssert.Same(thrown, ex);\n\t\t\tobj1.Received().Dispose();\n\t\t\tobj2.Received().Dispose();\n\t\t\tobj3.Received().Dispose();\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar classUnderTest = new DisposalTracker();\n\t\t\tvar obj1 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tobj1.When(x => x.Dispose()).Throw<DivideByZeroException>();\n\t\t\tclassUnderTest.Add(obj1);\n\t\t\tvar obj2 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tobj2.When(x => x.Dispose()).Throw<InvalidOperationException>();\n\t\t\tclassUnderTest.Add(obj2);\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => classUnderTest.DisposeAsync());\n\n\t\t\tvar aggEx = Assert.IsType<AggregateException>(ex);\n\t\t\tAssert.Collection(\n\t\t\t\taggEx.InnerExceptions,\n\t\t\t\tex => Assert.IsType<InvalidOperationException>(ex),\n\t\t\t\tex => Assert.IsType<DivideByZeroException>(ex)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar obj1 = new TrackingAsyncDisposable(\"1\", messages);\n\t\t\tclassUnderTest.Add(obj1);\n\t\t\tvar obj2 = new TrackingAsyncDisposable(\"2\", messages);\n\t\t\tclassUnderTest.Add(obj2);\n\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessages,\n\t\t\t\tmsg => Assert.Equal(\"2: DisposeAsync\", msg),\n\t\t\t\tmsg => Assert.Equal(\"1: DisposeAsync\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar obj1 = new TrackingDisposable(\"1\", messages);\n\t\t\tclassUnderTest.Add(obj1);\n\t\t\tvar obj2 = new TrackingDisposable(\"2\", messages);\n\t\t\tclassUnderTest.Add(obj2);\n\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessages,\n\t\t\t\tmsg => Assert.Equal(\"2: Dispose\", msg),\n\t\t\t\tmsg => Assert.Equal(\"1: Dispose\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar obj1 = new TrackingDisposable(\"1\", messages);\n\t\t\tclassUnderTest.Add(obj1);\n\t\t\tvar obj2 = new TrackingAsyncDisposable(\"2\", messages);\n\t\t\tclassUnderTest.Add(obj2);\n\t\t\tvar obj3 = new TrackingDisposable(\"3\", messages);\n\t\t\tclassUnderTest.Add(obj3);\n\t\t\tvar obj4 = new TrackingAsyncDisposable(\"4\", messages);\n\t\t\tclassUnderTest.Add(obj4);\n\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessages,\n\t\t\t\tmsg => Assert.Equal(\"4: DisposeAsync\", msg),\n\t\t\t\tmsg => Assert.Equal(\"3: Dispose\", msg),\n\t\t\t\tmsg => Assert.Equal(\"2: DisposeAsync\", msg),\n\t\t\t\tmsg => Assert.Equal(\"1: Dispose\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TrackedObjectsReturnsReverseOrder",
        "body": "{\n\t\t\tvar obj1 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tclassUnderTest.Add(obj1);\n\t\t\tvar obj2 = Substitute.For<IAsyncDisposable, InterfaceProxy<IAsyncDisposable>>();\n\t\t\tclassUnderTest.Add(obj2);\n\t\t\tvar obj3 = Substitute.For<IDisposable, InterfaceProxy<IDisposable>>();\n\t\t\tclassUnderTest.Add(obj3);\n\t\t\tvar obj4 = Substitute.For<IAsyncDisposable, InterfaceProxy<IAsyncDisposable>>();\n\t\t\tclassUnderTest.Add(obj4);\n\n\t\t\tvar trackedObjects = classUnderTest.TrackedObjects;\n\n\t\t\tAssert.Collection(\n\t\t\t\ttrackedObjects,\n\t\t\t\tobj => Assert.Same(obj4, obj),\n\t\t\t\tobj => Assert.Same(obj3, obj),\n\t\t\t\tobj => Assert.Same(obj2, obj),\n\t\t\t\tobj => Assert.Same(obj1, obj)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => classUnderTest.AddAction(null!));\n\n\t\t\tAssert.NotNull(ex);\n\t\t\tvar argEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"cleanupAction\", argEx.ParamName);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tAssert.True(disposed);\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => classUnderTest.AddAsyncAction(null!));\n\n\t\t\tAssert.NotNull(ex);\n\t\t\tvar argEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"cleanupAction\", argEx.ParamName);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tAssert.True(disposed);\n\t\t}"
      },
      {
        "name": "ClearRemovesAllObjects",
        "body": "{\n\t\t\tAssert.NotEmpty(classUnderTest.TrackedObjects);\n\n\t\t\tclassUnderTest.Clear();\n\n\t\t\tAssert.Empty(classUnderTest.TrackedObjects);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\t_ = expected.Received().DisposeAsync();\n\t\t}"
      },
      {
        "name": "ClearRemovesAllObjects",
        "body": "{\n\t\t\tAssert.NotEmpty(classUnderTest.TrackedObjects);\n\n\t\t\tclassUnderTest.Clear();\n\n\t\t\tAssert.Empty(classUnderTest.TrackedObjects);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\texpected.Received().Dispose();\n\t\t}"
      },
      {
        "name": "ClearRemovesAllObjects",
        "body": "{\n\t\t\tAssert.NotEmpty(classUnderTest.TrackedObjects);\n\n\t\t\tclassUnderTest.Clear();\n\n\t\t\tAssert.Empty(classUnderTest.TrackedObjects);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait classUnderTest.DisposeAsync();\n\n\t\t\tvar op = Assert.Single(expected.Operations);\n\t\t\tAssert.Equal(\"DisposeAsync\", op);\n\t\t}"
      }
    ]
  },
  {
    "file": "TypeHelperTests.cs",
    "methods": []
  },
  {
    "file": "UniqueIDGeneratorTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\n\t\t\tvar ex = Record.Exception(() => generator.Add(null!));\n\n\t\t\tvar anex = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"value\", anex.ParamName);\n\t\t}"
      },
      {
        "name": "NoData",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\n\t\t\tvar result = generator.Compute();\n\n\t\t\tAssert.Equal(\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\", result);\n\t\t}"
      },
      {
        "name": "SingleString",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\t\t\tgenerator.Add(\"Hello, world!\");\n\n\t\t\tvar result = generator.Compute();\n\n\t\t\tAssert.Equal(\"5450bb49d375ba935c1fe9c4dc48775d7d343fb97f22f07f8950f34a75a2708f\", result);\n\t\t}"
      },
      {
        "name": "CannotAddAfterCompute",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\t\t\tgenerator.Compute();\n\n\t\t\tvar ex = Record.Exception(() => generator.Add(\"Hello, world!\"));\n\n\t\t\tAssert.IsType<ObjectDisposedException>(ex);\n\t\t\tAssert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);\n\t\t}"
      },
      {
        "name": "CannotComputeTwice",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\t\t\tgenerator.Compute();\n\n\t\t\tvar ex = Record.Exception(() => generator.Compute());\n\n\t\t\tAssert.IsType<ObjectDisposedException>(ex);\n\t\t\tAssert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);\n\t\t}"
      },
      {
        "name": "CannotAddAfterDipose",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\t\t\tgenerator.Dispose();\n\n\t\t\tvar ex = Record.Exception(() => generator.Add(\"Hello, world!\"));\n\n\t\t\tAssert.IsType<ObjectDisposedException>(ex);\n\t\t\tAssert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);\n\t\t}"
      },
      {
        "name": "CannotComputeAfterDispose",
        "body": "{\n\t\t\tusing var generator = new UniqueIDGenerator();\n\t\t\tgenerator.Dispose();\n\n\t\t\tvar ex = Record.Exception(() => generator.Compute());\n\n\t\t\tAssert.IsType<ObjectDisposedException>(ex);\n\t\t\tAssert.StartsWith(\"Cannot use UniqueIDGenerator after you have called Compute or Dispose\", ex.Message);\n\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => UniqueIDGenerator.ForAssembly(null!, \"config-path\"));\n\n\t\t\tvar argnEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"assemblyPath\", argnEx.ParamName);\n\t\t}"
      }
    ]
  },
  {
    "file": "ITestAssemblyMessage.cs",
    "methods": []
  },
  {
    "file": "ITestCaseMessage.cs",
    "methods": []
  },
  {
    "file": "ITestClassMessage.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionMessage.cs",
    "methods": []
  },
  {
    "file": "ITestMessage.cs",
    "methods": []
  },
  {
    "file": "ITestMethodMessage.cs",
    "methods": []
  },
  {
    "file": "ITestResultMessage.cs",
    "methods": []
  },
  {
    "file": "IAfterTestFinished.cs",
    "methods": []
  },
  {
    "file": "IAfterTestStarting.cs",
    "methods": []
  },
  {
    "file": "IBeforeTestFinished.cs",
    "methods": []
  },
  {
    "file": "IBeforeTestStarting.cs",
    "methods": []
  },
  {
    "file": "ITestAssemblyCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "ITestAssemblyFinished.cs",
    "methods": []
  },
  {
    "file": "ITestAssemblyStarting.cs",
    "methods": []
  },
  {
    "file": "ITestCaseCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "ITestCaseDiscovered.cs",
    "methods": []
  },
  {
    "file": "ITestCaseFinished.cs",
    "methods": []
  },
  {
    "file": "ITestCaseStarting.cs",
    "methods": []
  },
  {
    "file": "ITestClassCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "ITestClassConstructionFinished.cs",
    "methods": []
  },
  {
    "file": "ITestClassConstructionStarting.cs",
    "methods": []
  },
  {
    "file": "ITestClassDisposeFinished.cs",
    "methods": []
  },
  {
    "file": "ITestClassDisposeStarting.cs",
    "methods": []
  },
  {
    "file": "ITestClassFinished.cs",
    "methods": []
  },
  {
    "file": "ITestClassStarting.cs",
    "methods": []
  },
  {
    "file": "ITestCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionFinished.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionStarting.cs",
    "methods": []
  },
  {
    "file": "ITestFailed.cs",
    "methods": []
  },
  {
    "file": "ITestFinished.cs",
    "methods": []
  },
  {
    "file": "ITestMethodCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "ITestMethodFinished.cs",
    "methods": []
  },
  {
    "file": "ITestMethodStarting.cs",
    "methods": []
  },
  {
    "file": "ITestNotRun.cs",
    "methods": []
  },
  {
    "file": "ITestOutput.cs",
    "methods": []
  },
  {
    "file": "ITestPassed.cs",
    "methods": []
  },
  {
    "file": "ITestSkipped.cs",
    "methods": []
  },
  {
    "file": "ITestStarting.cs",
    "methods": []
  },
  {
    "file": "ITestCaseMetadata.cs",
    "methods": []
  },
  {
    "file": "ITestClassMetadata.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionMetadata.cs",
    "methods": []
  },
  {
    "file": "ITestMetadata.cs",
    "methods": []
  },
  {
    "file": "ITestMethodMetadata.cs",
    "methods": []
  },
  {
    "file": "ITest.cs",
    "methods": []
  },
  {
    "file": "ITestAssembly.cs",
    "methods": []
  },
  {
    "file": "ITestCase.cs",
    "methods": []
  },
  {
    "file": "ITestClass.cs",
    "methods": []
  },
  {
    "file": "ITestCollection.cs",
    "methods": []
  },
  {
    "file": "ITestMethod.cs",
    "methods": []
  },
  {
    "file": "ITestFrameworkDiscoveryOptions.cs",
    "methods": []
  },
  {
    "file": "ITestFrameworkExecutionOptions.cs",
    "methods": []
  },
  {
    "file": "ITestFrameworkOptions.cs",
    "methods": []
  },
  {
    "file": "TestOptionsNames.cs",
    "methods": []
  },
  {
    "file": "TestAttachment.cs",
    "methods": []
  },
  {
    "file": "TestAttachmentType.cs",
    "methods": []
  },
  {
    "file": "TestMethodDisplay.cs",
    "methods": []
  },
  {
    "file": "TestMethodDisplayOptions.cs",
    "methods": []
  },
  {
    "file": "AsyncAcceptanceTests.cs",
    "methods": [
      {
        "name": "Async40AcceptanceTest",
        "body": "{\n\t\t\tIEnumerable<MethodResult> results = RunClass(typeof(Async40AcceptanceTestClass));\n\n\t\t\tMethodResult result = Assert.Single(results);\n\t\t\tFailedResult failedResult = Assert.IsType<FailedResult>(result);\n\t\t\tAssert.Equal(typeof(TrueException).FullName, failedResult.ExceptionType);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\t\treturn Task.Factory.StartNew(() =>\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(1);\n\t\t\t\t})\n\t\t\t\t.ContinueWith(_ =>\n\t\t\t\t{\n\t\t\t\t\tAssert.True(false);\n\t\t\t\t});\n\t\t\t}"
      }
    ]
  },
  {
    "file": "CollectionAcceptanceTests.cs",
    "methods": [
      {
        "name": "TwoClasses_OneInExplicitCollection_OneInDefaultCollection",
        "body": "{\n\t\tvar results = Run(new[] { typeof(ClassInExplicitCollection), typeof(ClassInDefaultCollection) });\n\n\t\tvar defaultResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName.StartsWith(\"Test collection for \"));\n\t\tAssertMessageSequence(defaultResults, \"CollectionAcceptanceTests+ClassInDefaultCollection.Passing\");\n\n\t\tvar explicitResults = results.OfType<ITestCollectionMessage>().Where(message => message.TestCollection.DisplayName == \"Explicit Collection\");\n\t\tAssertMessageSequence(explicitResults, \"CollectionAcceptanceTests+ClassInExplicitCollection.Passing\");\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "DynamicSkipAcceptanceTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"reason\", () => Assert.Skip(null!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar results = await RunAsync(typeof(ClassUnderTest));\n\n\t\t\tvar skipResult = Assert.Single(results.OfType<ITestSkipped>());\n\t\t\tAssert.Equal(\"This test was skipped\", skipResult.Reason);\n\t\t}"
      },
      {
        "name": "Unconditional",
        "body": "{\n\t\t\t\tAssert.Skip(\"This test was skipped\");\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"reason\", () => Assert.SkipUnless(true, null!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar results = await RunAsync(typeof(ClassUnderTest));\n\n\t\t\tvar skipResult = Assert.Single(results.OfType<ITestSkipped>());\n\t\t\tvar skipMethodStarting = Assert.Single(results.OfType<ITestMethodStarting>(), s => s.TestMethodUniqueID == skipResult.TestMethodUniqueID);\n\t\t\tAssert.Equal(\"Skipped\", skipMethodStarting.MethodName);\n\t\t\tAssert.Equal(\"This test was skipped\", skipResult.Reason);\n\t\t\tvar passResult = Assert.Single(results.OfType<ITestPassed>());\n\t\t\tvar passMethodStarting = results.OfType<ITestMethodStarting>().Where(ts => ts.TestMethodUniqueID == passResult.TestMethodUniqueID).Single();\n\t\t\tAssert.Equal(\"Passed\", passMethodStarting.MethodName);\n\t\t}"
      },
      {
        "name": "Skipped",
        "body": "{\n\t\t\t\tAssert.SkipUnless(false, \"This test was skipped\");\n\t\t\t}"
      },
      {
        "name": "Passed",
        "body": "{\n\t\t\t\tAssert.SkipUnless(true, \"This test is not skipped\");\n\t\t\t}"
      },
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tAssert.Throws<ArgumentNullException>(\"reason\", () => Assert.SkipWhen(true, null!));\n\t\t}"
      },
      {
        "name": "Task",
        "body": "{\n\t\t\tvar results = await RunAsync(typeof(ClassUnderTest));\n\n\t\t\tvar skipResult = Assert.Single(results.OfType<ITestSkipped>());\n\t\t\tvar skipMethodStarting = Assert.Single(results.OfType<ITestMethodStarting>(), s => s.TestMethodUniqueID == skipResult.TestMethodUniqueID);\n\t\t\tAssert.Equal(\"Skipped\", skipMethodStarting.MethodName);\n\t\t\tAssert.Equal(\"This test was skipped\", skipResult.Reason);\n\t\t\tvar passResult = Assert.Single(results.OfType<ITestPassed>());\n\t\t\tvar passMethodStarting = results.OfType<ITestMethodStarting>().Where(ts => ts.TestMethodUniqueID == passResult.TestMethodUniqueID).Single();\n\t\t\tAssert.Equal(\"Passed\", passMethodStarting.MethodName);\n\t\t}"
      },
      {
        "name": "Skipped",
        "body": "{\n\t\t\t\tAssert.SkipWhen(true, \"This test was skipped\");\n\t\t\t}"
      },
      {
        "name": "Passed",
        "body": "{\n\t\t\t\tAssert.SkipWhen(false, \"This test is not skipped\");\n\t\t\t}"
      }
    ]
  },
  {
    "file": "FixtureAcceptanceTests.cs",
    "methods": [
      {
        "name": "TestClassMustHaveSinglePublicConstructor",
        "body": "{\n\t\t\tvar messages = Run(typeof(ClassWithTooManyConstructors));\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCollectionStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestClassStarting>(message),\n\n\t\t\t\t// TestMethod1\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);\n\t\t\t\t\tAssert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());\n\t\t\t\t\tAssert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());\n\t\t\t\t},\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodFinished>(message),\n\n\t\t\t\t// TestMethod2\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseStarting>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar failedMessage = Assert.IsAssignableFrom<ITestFailed>(message);\n\t\t\t\t\tAssert.Equal(typeof(TestClassException).FullName, failedMessage.ExceptionTypes.Single());\n\t\t\t\t\tAssert.Equal(\"A test class may only define a single public constructor.\", failedMessage.Messages.Single());\n\t\t\t\t},\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCaseFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestMethodFinished>(message),\n\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestClassFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestCollectionFinished>(message),\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyFinished>(message)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());\n\t\t\tAssert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Collection(\n\t\t\t\tmsg.ExceptionTypes,\n\t\t\t\ttype => Assert.Equal(typeof(TestClassException).FullName, type),\n\t\t\t\ttype => Assert.Equal(typeof(DivideByZeroException).FullName, type)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureDisposeResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithDefaultParameter",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithDefaultCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithDefaultCtorArg.TheTest\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithOptionalParameter",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithOptionalCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithOptionalCtorArg.TheTest\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithParamsParameter",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithParamsArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"FixtureAcceptanceTests+ClassFixture+ClassWithParamsArg.TheTest\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataShouldHaveBeenSetup",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ThrowingAsyncSetupShouldResultInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetup));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureAsyncDisposeResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotBeDecoratedWithICollectionFixture",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(TestClassWithCollectionFixture));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());\n\t\t\tAssert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", msg.Messages.Single());\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestClassWithExtraArgumentToConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithExtraCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());\n\t\t\tAssert.Equal(\"The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2\", msg.Messages.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithMissingArgumentToConstructorIsAcceptable",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithMissingCtorArg));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingFixtureConstructorResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureCtor));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsPassedToConstructor",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "FixtureDataIsSameInstanceAcrossClasses",
        "body": "{\n\t\t\tRun<ITestPassed>(new[] { typeof(FixtureSaver1), typeof(FixtureSaver2) });\n\n\t\t\tAssert.Same(FixtureSaver1.Fixture, FixtureSaver2.Fixture);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnCollectionDecorationWorks",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(FixtureSpy_ClassFixture));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "ClassFixtureOnTestClassTakesPrecedenceOverClassFixtureOnCollection",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithCountedFixture));\n\n\t\t\tAssert.Single(messages);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureSetupAsyncResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithThrowingFixtureSetupAsync));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest",
        "body": "{\n\t\t\tvar messages = Run<ITestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureAsyncDispose));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "CollectionFixtureAsyncSetupShouldOnlyRunOnce",
        "body": "{\n\t\t\tvar results = Run<ITestPassed>(new[] { typeof(Fixture1), typeof(Fixture2) });\n\t\t\tAssert.Equal(2, results.Count);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "AcceptanceTestV3.cs",
    "methods": []
  },
  {
    "file": "ITestResultWithDisplayName.cs",
    "methods": []
  },
  {
    "file": "TestFailedWithDisplayName.cs",
    "methods": []
  },
  {
    "file": "TestNotRunWithDisplayName.cs",
    "methods": []
  },
  {
    "file": "TestPassedWithDisplayName.cs",
    "methods": []
  },
  {
    "file": "TestSkippedWithDisplayName.cs",
    "methods": []
  },
  {
    "file": "ExceptionAggregatorTests.cs",
    "methods": [
      {
        "name": "EmptyByDefault",
        "body": "{\n\t\tvar aggregator = new ExceptionAggregator();\n\n\t\tAssert.False(aggregator.HasExceptions);\n\t}"
      },
      {
        "name": "CanAddOneAggregatorToAnother",
        "body": "{\n\t\tvar aggregator1 = new ExceptionAggregator();\n\t\taggregator1.Add(new DivideByZeroException());\n\t\tvar aggregator2 = new ExceptionAggregator();\n\t\taggregator2.Add(new InvalidOperationException());\n\n\t\taggregator2.Aggregate(aggregator1);\n\n\t\tvar result = aggregator2.ToException();\n\t\tvar aggEx = Assert.IsType<AggregateException>(result);\n\t\tAssert.Collection(\n\t\t\taggEx.InnerExceptions,\n\t\t\tex => Assert.IsType<InvalidOperationException>(ex),\n\t\t\tex => Assert.IsType<DivideByZeroException>(ex)\n\t\t);\n\t}"
      },
      {
        "name": "CapturesException",
        "body": "{\n\t\tvar aggregator = new ExceptionAggregator();\n\n\t\taggregator.Run(() => throw new DivideByZeroException());\n\n\t\tvar result = aggregator.ToException();\n\t\tAssert.IsType<DivideByZeroException>(result);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar aggregator = new ExceptionAggregator();\n\n\t\tawait aggregator.RunAsync(async () =>\n\t\t{\n\t\t\tawait Task.Yield();\n\t\t\tthrow new DivideByZeroException();\n\t\t});\n\n\t\tvar result = aggregator.ToException();\n\t\tAssert.IsType<DivideByZeroException>(result);\n\t}"
      }
    ]
  },
  {
    "file": "CollectionPerAssemblyTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "ReturnsDefaultTestCollectionForUndecoratedTestClass",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\");\n\t\tvar type2 = Mocks.TypeInfo(\"type2\");\n\t\tvar assemblyFileName = Path.DirectorySeparatorChar == '/' ? \"/foo/bar.dll\" : @\"C:\\Foo\\bar.dll\";\n\t\tvar assembly = Mocks.TestAssembly(assemblyFileName);\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"Test collection for bar.dll\", result1.DisplayName);\n\t}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{\n\t\tvar attr = Mocks.CollectionAttribute(\"My Collection\");\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"My Collection\", result1.DisplayName);\n\t}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.NotSame(result1, result2);\n\t\tAssert.Equal(\"Collection 1\", result1.DisplayName);\n\t\tAssert.Equal(\"Collection 2\", result2.DisplayName);\n\t}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result = factory.Get(testType);\n\n\t\tAssert.Same(collectionDefinitionType, result.CollectionDefinition);\n\t}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar spy = SpyMessageSink.Create(messages: messages);\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });\n\t\tvar factory = new CollectionPerAssemblyTestCollectionFactory(assembly, spy);\n\n\t\tfactory.Get(testType);\n\n\t\tvar msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));\n\t\tAssert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);\n\t}"
      }
    ]
  },
  {
    "file": "CollectionPerClassTestCollectionFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultCollectionBehaviorIsCollectionPerClass",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"FullyQualified.Type.Number1\");\n\t\tvar type2 = Mocks.TypeInfo(\"FullyQualified.Type.Number2\");\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.NotSame(result1, result2);\n\t\tAssert.Equal(\"Test collection for FullyQualified.Type.Number1\", result1.DisplayName);\n\t\tAssert.Equal(\"Test collection for FullyQualified.Type.Number2\", result2.DisplayName);\n\t\tAssert.Null(result1.CollectionDefinition);\n\t\tAssert.Null(result2.CollectionDefinition);\n\t}"
      },
      {
        "name": "ClassesDecoratedWithSameCollectionNameAreInSameTestCollection",
        "body": "{\n\t\tvar attr = Mocks.CollectionAttribute(\"My Collection\");\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { attr });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { attr });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"My Collection\", result1.DisplayName);\n\t}"
      },
      {
        "name": "ClassesWithDifferentCollectionNamesHaveDifferentCollectionObjects",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 1\") });\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Collection 2\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.NotSame(result1, result2);\n\t\tAssert.Equal(\"Collection 1\", result1.DisplayName);\n\t\tAssert.Equal(\"Collection 2\", result2.DisplayName);\n\t}"
      },
      {
        "name": "ExplicitlySpecifyingACollectionWithTheSameNameAsAnImplicitWorks",
        "body": "{\n\t\tvar type1 = Mocks.TypeInfo(\"type1\");\n\t\tvar type2 = Mocks.TypeInfo(\"type2\", attributes: new[] { Mocks.CollectionAttribute(\"Test collection for type1\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\");\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result1 = factory.Get(type1);\n\t\tvar result2 = factory.Get(type2);\n\n\t\tAssert.Same(result1, result2);\n\t\tAssert.Equal(\"Test collection for type1\", result1.DisplayName);\n\t}"
      },
      {
        "name": "UsingTestCollectionDefinitionSetsTypeInfo",
        "body": "{\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinitionType = Mocks.TypeInfo(\"collectionDefinition\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinitionType });\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, SpyMessageSink.Create());\n\n\t\tvar result = factory.Get(testType);\n\n\t\tAssert.Same(collectionDefinitionType, result.CollectionDefinition);\n\t}"
      },
      {
        "name": "MultiplyDeclaredCollectionsRaisesEnvironmentalWarning",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar spy = SpyMessageSink.Create(messages: messages);\n\t\tvar testType = Mocks.TypeInfo(\"type\", attributes: new[] { Mocks.CollectionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition1 = Mocks.TypeInfo(\"collectionDefinition1\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar collectionDefinition2 = Mocks.TypeInfo(\"collectionDefinition2\", attributes: new[] { Mocks.CollectionDefinitionAttribute(\"This is a test collection\") });\n\t\tvar assembly = Mocks.TestAssembly(@\"C:\\Foo\\bar.dll\", types: new[] { collectionDefinition1, collectionDefinition2 });\n\t\tvar factory = new CollectionPerClassTestCollectionFactory(assembly, spy);\n\n\t\tfactory.Get(testType);\n\n\t\tvar msg = Assert.Single(messages.OfType<IDiagnosticMessage>().Select(m => m.Message));\n\t\tAssert.Equal(\"Multiple test collections declared with name 'This is a test collection': collectionDefinition1, collectionDefinition2\", msg);\n\t}"
      }
    ]
  },
  {
    "file": "DefaultTestCaseOrdererTests.cs",
    "methods": [
      {
        "name": "OrderIsStable",
        "body": "{\n\t\tvar orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());\n\n\t\tvar result1 = orderer.OrderTestCases(TestCases);\n\t\tvar result2 = orderer.OrderTestCases(TestCases);\n\t\tvar result3 = orderer.OrderTestCases(TestCases);\n\n\t\tAssert.Equal(result1, result2);\n\t\tAssert.Equal(result2, result3);\n\t}"
      },
      {
        "name": "OrderIsUnpredictable",
        "body": "{\n\t\tvar orderer = new DefaultTestCaseOrderer(SpyMessageSink.Create());\n\n\t\tvar result = orderer.OrderTestCases(TestCases);\n\n\t\tAssert.NotEqual(TestCases, result);\n\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test4",
        "body": "{ }"
      },
      {
        "name": "Test5",
        "body": "{ }"
      },
      {
        "name": "Test6",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "DefaultTestCollectionOrdererTests.cs",
    "methods": [
      {
        "name": "OrderIsStable",
        "body": "{\n\t\tvar orderer = DefaultTestCollectionOrderer.Instance;\n\n\t\tvar result1 = orderer.OrderTestCollections(TestCollections);\n\t\tvar result2 = orderer.OrderTestCollections(TestCollections);\n\t\tvar result3 = orderer.OrderTestCollections(TestCollections);\n\n\t\tAssert.Equal(result1, result2);\n\t\tAssert.Equal(result2, result3);\n\t}"
      },
      {
        "name": "OrderIsUnpredictable",
        "body": "{\n\t\tvar orderer = DefaultTestCollectionOrderer.Instance;\n\n\t\tvar result = orderer.OrderTestCollections(TestCollections);\n\n\t\t// If this test fails, rearrange the test collection list above\n\t\tAssert.NotEqual(TestCollections, result);\n\t}"
      }
    ]
  },
  {
    "file": "FactDiscovererTests.cs",
    "methods": [
      {
        "name": "FactWithoutParameters_ReturnsTestCaseThatRunsFact",
        "body": "{\n\t\tvar discoverer = TestableFactDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithNoParameters\");\n\n\t\tvar testCases = discoverer.Discover(options, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tawait testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);\n\t\tAssert.Single(messageBus.Messages.OfType<ITestPassed>());\n\t}"
      },
      {
        "name": "FactWithParameters_ReturnsTestCaseWhichThrows",
        "body": "{\n\t\tvar discoverer = TestableFactDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"FactWithParameters\");\n\n\t\tvar testCases = discoverer.Discover(options, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tawait testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Equal(\"[Fact] methods are not allowed to have parameters. Did you mean to use [Theory]?\", failed.Messages.Single());\n\t}"
      },
      {
        "name": "GenericFact_ReturnsTestCaseWhichThrows",
        "body": "{\n\t\tvar discoverer = TestableFactDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ClassUnderTest), \"GenericFact\");\n\n\t\tvar testCases = discoverer.Discover(options, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tawait testCase.RunAsync(SpyMessageSink.Create(), messageBus, new object[0], aggregator, cancellationTokenSource);\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Equal(\"[Fact] methods are not allowed to be generic.\", failed.Messages.Single());\n\t}"
      },
      {
        "name": "FactWithNoParameters",
        "body": "{ }"
      },
      {
        "name": "FactWithParameters",
        "body": "{ }"
      },
      {
        "name": "GenericFact",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "InProcessFrontControllerTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tvar testFramework = Mocks.TestFramework();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"testFramework\", () => new InProcessFrontController(null!, thisAssembly, null));\n\t\t\tAssert.Throws<ArgumentNullException>(\"testAssembly\", () => new InProcessFrontController(testFramework, null!, null));\n\t\t}"
      },
      {
        "name": "PropertiesReturnValuesFromDiscoverer",
        "body": "{\n\t\t\tvar frontController = TestableInProcessFrontController.Create();\n\n\t\t\tAssert.Equal(TestData.DefaultTestFrameworkDisplayName, frontController.TestFrameworkDisplayName);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar frontController = TestableInProcessFrontController.Create();\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar filter = (ITestCase testCase) => true;\n\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"options\", () => frontController.Find(null, null!, filter).AsTask());\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"filter\", () => frontController.Find(null, options, null!).AsTask());\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar frontController = TestableInProcessFrontController.Create(configFilePath: \"/path/to/config.json\");\n\t\t\tvar messageSink = SpyMessageSink.Capture();\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar filter = (ITestCase testCase) => true;\n\n\t\t\tawait frontController.Find(messageSink, options, filter);\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageSink.Messages,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<IDiscoveryStarting>(msg);\n#if BUILD_X86\n\t\t\t\t\tAssert.StartsWith(\"xunit.v3.core.x86.tests\", starting.AssemblyName);\n\t\t\t\t\tAssert.Equal(\"xunit.v3.core.x86.tests\", Path.GetFileNameWithoutExtension(starting.AssemblyPath));\n#else\n\t\t\t\t\tAssert.StartsWith(\"xunit.v3.core.tests\", starting.AssemblyName);\n\t\t\t\t\tAssert.Equal(\"xunit.v3.core.tests\", Path.GetFileNameWithoutExtension(starting.AssemblyPath));\n#endif\n\t\t\t\t\tAssert.Equal(frontController.TestAssemblyUniqueID, starting.AssemblyUniqueID);\n\t\t\t\t\tAssert.Equal(\"/path/to/config.json\", starting.ConfigFilePath);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar complete = Assert.IsAssignableFrom<IDiscoveryComplete>(msg);\n\t\t\t\t\tAssert.Equal(frontController.TestAssemblyUniqueID, complete.AssemblyUniqueID);\n\t\t\t\t\tAssert.Equal(0, complete.TestCasesToRun);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar frontController = TestableInProcessFrontController.Create();\n\t\t\tvar messageSink = SpyMessageSink.Capture();\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar validTestCase = Mocks.XunitTestCase<Find>(nameof(ReportsDiscoveredTestCasesAndCountsTestCasesWhichPassFilter));\n\t\t\tvar invalidTestCase = Mocks.XunitTestCase<Find>(nameof(SendsStartingAndCompleteMessages));\n\t\t\tvar filter = (ITestCase testCase) => testCase == validTestCase;\n\t\t\tvar callbackCalls = new List<(ITestCase testCase, bool passedFilter)>();\n\t\t\tfrontController\n\t\t\t\t.Discoverer\n\t\t\t\t.WhenForAnyArgs(d => d.Find(null!, null!))\n\t\t\t\t.Do(callInfo =>\n\t\t\t\t{\n\t\t\t\t\tvar callback = callInfo.Arg<Func<ITestCase, ValueTask<bool>>>();\n#pragma warning disable xUnit1031  // Test methods must not use blocking task operations\n\t\t\t\t\tcallback(validTestCase).GetAwaiter().GetResult();\n\t\t\t\t\tcallback(invalidTestCase).GetAwaiter().GetResult();\n#pragma warning restore xUnit1031  // Test methods must not use blocking task operations\n\t\t\t\t});\n\t\t\tValueTask<bool> frontControllerCallback(\n\t\t\t\tITestCase testCase,\n\t\t\t\tbool passedFilter)\n\t\t\t{\n\t\t\t\tcallbackCalls.Add((testCase, passedFilter));\n\t\t\t\treturn new(true);\n\t\t\t}\n\n\t\t\tawait frontController.Find(messageSink, options, filter, discoveryCallback: frontControllerCallback);\n\n\t\t\tvar complete = Assert.Single(messageSink.Messages.OfType<IDiscoveryComplete>());\n\t\t\tAssert.Equal(1, complete.TestCasesToRun);\n\t\t\tAssert.Collection(\n\t\t\t\tcallbackCalls,\n\t\t\t\tcallback =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Same(validTestCase, callback.testCase);\n\t\t\t\t\tAssert.True(callback.passedFilter);\n\t\t\t\t},\n\t\t\t\tcallback =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Same(invalidTestCase, callback.testCase);\n\t\t\t\t\tAssert.False(callback.passedFilter);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar frontController = TestableInProcessFrontController.Create();\n\t\t\tvar messageSink = SpyMessageSink.Capture();\n\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\t\t\tvar filter = (ITestCase testCase) => true;\n\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"messageSink\", () => frontController.FindAndRun(null!, discoveryOptions, executionOptions, filter).AsTask());\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"discoveryOptions\", () => frontController.FindAndRun(messageSink, null!, executionOptions, filter).AsTask());\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"executionOptions\", () => frontController.FindAndRun(messageSink, discoveryOptions, null!, filter).AsTask());\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"filter\", () => frontController.FindAndRun(messageSink, discoveryOptions, executionOptions, null!).AsTask());\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar frontController = TestableInProcessFrontController.Create();\n\t\t\tvar messageSink = SpyMessageSink.Capture();\n\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\t\t\tvar validTestCase = Mocks.XunitTestCase<FindAndRun>(nameof(RunsTestCasesWhichPassFilter));\n\t\t\tvar invalidTestCase = Mocks.XunitTestCase<Find>(nameof(GuardClauses));\n\t\t\tvar filter = (ITestCase testCase) => testCase == validTestCase;\n\t\t\tvar executedTestCases = default(IReadOnlyCollection<ITestCase>?);\n\t\t\tfrontController\n\t\t\t\t.Discoverer\n\t\t\t\t.WhenForAnyArgs(d => d.Find(null!, null!))\n\t\t\t\t.Do(callInfo =>\n\t\t\t\t{\n\t\t\t\t\tvar callback = callInfo.Arg<Func<ITestCase, ValueTask<bool>>>();\n#pragma warning disable xUnit1031  // Test methods must not use blocking task operations\n\t\t\t\t\tcallback(validTestCase).GetAwaiter().GetResult();\n\t\t\t\t\tcallback(invalidTestCase).GetAwaiter().GetResult();\n#pragma warning restore xUnit1031  // Test methods must not use blocking task operations\n\t\t\t\t});\n\t\t\tfrontController\n\t\t\t\t.Executor\n\t\t\t\t.WhenForAnyArgs(e => e.RunTestCases(null!, null!, null!))\n\t\t\t\t.Do(callInfo => executedTestCases = callInfo.Arg<IReadOnlyCollection<ITestCase>>());\n\n\t\t\tawait frontController.FindAndRun(messageSink, discoveryOptions, executionOptions, filter);\n\n\t\t\tAssert.NotNull(executedTestCases);\n\t\t\tvar runTestCase = Assert.Single(executedTestCases);\n\t\t\tAssert.Same(validTestCase, runTestCase);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestCollectionFactoryBaseTests.cs",
    "methods": [
      {
        "name": "AcquiresBeforeAfterTestAttributesFromCollectionDefinition_AndMergesThemWithTheAssemblyAttributes",
        "body": "{\n\t\tvar testAssembly = Mocks.XunitTestAssembly(beforeAfterTestAttributes: [new BeforeAfterTestAttribute1()]);\n\t\tvar factory = new TestableTestCollectionFactory(testAssembly);\n\n\t\tvar testCollection = factory.Get(typeof(TestClassForBeforeAfterAttribute));\n\n\t\tAssert.Collection(\n\t\t\ttestCollection.BeforeAfterTestAttributes.OrderBy(a => a.GetType().Name),\n\t\t\ta => Assert.Equal(\"BeforeAfterTestAttribute1\", a.GetType().Name),\n\t\t\ta => Assert.Equal(\"BeforeAfterTestAttribute2\", a.GetType().Name)\n\t\t);\n\t}"
      },
      {
        "name": "AcquiresFixtureTypesFromCollectionDefinition",
        "body": "{\n\t\tvar testAssembly = Mocks.XunitTestAssembly();\n\t\tvar factory = new TestableTestCollectionFactory(testAssembly);\n\n\t\tvar testCollection = factory.Get(typeof(TestClassForFixtures));\n\n\t\tvar collectionFixtureType = Assert.Single(testCollection.CollectionFixtureTypes);\n\t\tAssert.Equal(typeof(object), collectionFixtureType);\n\t\tvar classFixtureType = Assert.Single(testCollection.ClassFixtureTypes);\n\t\tAssert.Equal(typeof(string), classFixtureType);\n\t}"
      },
      {
        "name": "ReadsCollectionDefinitionAttributeForParallelization",
        "body": "{\n\t\t// Decorated definitions are read and cached by the test assembly\n\t\tvar definitions = new Dictionary<string, (Type, CollectionDefinitionAttribute)>\n\t\t{\n\t\t\t[\"foo\"] = (typeof(TestCollectionWithoutParallelization), new CollectionDefinitionAttribute { DisableParallelization = true })\n\t\t};\n\t\tvar testAssembly = Mocks.XunitTestAssembly(collectionDefinitions: definitions);\n\t\tvar factory = new TestableTestCollectionFactory(testAssembly);\n\n\t\tvar testCollection = factory.Get(typeof(TestClassForParallelization));\n\n\t\tAssert.True(testCollection.DisableParallelization);\n\t}"
      }
    ]
  },
  {
    "file": "TestFrameworkDiscovererTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar framework = TestableTestFrameworkDiscoverer.Create();\n\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"callback\", () => framework.Find(callback: null!, discoveryOptions: TestData.TestFrameworkDiscoveryOptions()).AsTask());\n\t\t\tawait Assert.ThrowsAsync<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(callback: _ => new(true), discoveryOptions: null!).AsTask());\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar spy = SpyMessageSink.Capture();\n\t\t\tTestContext.CurrentInternal.DiagnosticMessageSink = spy;\n\n\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\t\t\tdiscoverer.FindTestsForType_Exception = new DivideByZeroException();\n\n\t\t\tawait discoverer.Find();\n\n\t\t\tvar message = Assert.Single(spy.Messages.OfType<IDiagnosticMessage>());\n\t\t\tAssert.StartsWith($\"Exception during discovery:{Environment.NewLine}System.DivideByZeroException: Attempted to divide by zero.\", message.Message);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\n\t\t\tawait discoverer.Find();\n\n\t\t\tvar context = discoverer.FindTestsForType_Context;\n\t\t\tAssert.NotNull(context);\n\t\t\tAssert.Equal(TestEngineStatus.Discovering, context.TestAssemblyStatus);\n\t\t\tAssert.Equal(TestPipelineStage.Discovery, context.PipelineStage);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create(typeof(object), typeof(int));\n\n\t\t\t\tawait discoverer.Find();\n\n\t\t\t\tAssert.Collection(\n\t\t\t\t\tdiscoverer.FindTestsForType_TestClasses.Select(c => c.TestClassName).OrderBy(x => x),\n\t\t\t\t\ttypeName => Assert.Equal(typeof(int).FullName, typeName),    // System.Int32\n\t\t\t\t\ttypeName => Assert.Equal(typeof(object).FullName, typeName)  // System.Object\n\t\t\t\t);\n\t\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create(typeof(AbstractClass));\n\n\t\t\t\tawait discoverer.Find();\n\n\t\t\t\tAssert.Empty(discoverer.FindTestsForType_TestClasses);\n\t\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\n\t\t\t\tawait discoverer.Find(types: [typeof(object)]);\n\n\t\t\t\tvar testClass = Assert.Single(discoverer.FindTestsForType_TestClasses);\n\t\t\t\tAssert.Equal(typeof(object).FullName, testClass.TestClassName);\n\t\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\n\t\t\t\tawait discoverer.Find(types: [typeof(AbstractClass)]);\n\n\t\t\t\tAssert.Empty(discoverer.FindTestsForType_TestClasses);\n\t\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tCultureInfo.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\t\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions(culture: null);\n\n\t\t\t\tawait discoverer.Find(discoveryOptions);\n\n\t\t\t\tAssert.NotNull(discoverer.FindTestsForType_CurrentCulture);\n\t\t\t\tAssert.Equal(\"en-US\", discoverer.FindTestsForType_CurrentCulture.Name);\n\t\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tCultureInfo.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\t\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions(culture: string.Empty);\n\n\t\t\t\tawait discoverer.Find(discoveryOptions);\n\n\t\t\t\tAssert.NotNull(discoverer.FindTestsForType_CurrentCulture);\n\t\t\t\tAssert.Equal(string.Empty, discoverer.FindTestsForType_CurrentCulture.Name);\n\t\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\t\tCultureInfo.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");\n\t\t\t\tvar discoverer = TestableTestFrameworkDiscoverer.Create();\n\t\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions(culture: \"en-GB\");\n\n\t\t\t\tawait discoverer.Find(discoveryOptions);\n\n\t\t\t\tAssert.NotNull(discoverer.FindTestsForType_CurrentCulture);\n\t\t\t\tAssert.Equal(\"en-GB\", discoverer.FindTestsForType_CurrentCulture.Name);\n\t\t\t}"
      },
      {
        "name": "ATestNotToBeRun",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestOutputHelperTests.cs",
    "methods": []
  },
  {
    "file": "TheoryDiscovererTests.cs",
    "methods": [
      {
        "name": "NoDataAttributes",
        "body": "{\n\t\tvar failures = Run<ITestFailed>(typeof(NoDataAttributesClass));\n\n\t\tvar failure = Assert.Single(failures);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"No data found for TheoryDiscovererTests+NoDataAttributesClass.TheoryMethod\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "NullMemberData_ThrowsInvalidOperationException",
        "body": "{\n\t\tvar results = Run<ITestFailed>(typeof(NullDataClass));\n\n\t\tvar failure = Assert.Single(results);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Test data returned null for TheoryDiscovererTests+NullDataClass.NullMemberData. Make sure it is statically initialized before this test method is called.\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "EmptyTheoryData",
        "body": "{\n\t\tvar failures = Run<ITestFailed>(typeof(EmptyTheoryDataClass));\n\n\t\tvar failure = Assert.Single(failures);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"No data found for TheoryDiscovererTests+EmptyTheoryDataClass.TheoryMethod\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToTrue_YieldsTestCasePerDataRow",
        "body": "{\n\t\tdiscoveryOptions.SetPreEnumerateTheories(true);\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();\n\n\t\tAssert.Equal(2, testCases.Count);\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 42)\");\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClass.TheoryMethod(x: 2112)\");\n\t}"
      },
      {
        "name": "DiscoveryOptions_PreEnumerateTheoriesSetToFalse_YieldsSingleTheoryTestCase",
        "body": "{\n\t\tdiscoveryOptions.SetPreEnumerateTheories(false);\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MultipleDataClass), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+MultipleDataClass.TheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "DiscoverOptions_PreEnumerateTheoriesSetToTrueWithSkipOnData_YieldsSkippedTestCasePerDataRow",
        "body": "{\n\t\tdiscoveryOptions.SetPreEnumerateTheories(true);\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MultipleDataClassSkipped), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute).ToList();\n\n\t\tAssert.Equal(2, testCases.Count);\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 42)\" && testCase.SkipReason == \"Skip this attribute\");\n\t\tAssert.Single(testCases, testCase => testCase.DisplayName == \"TheoryDiscovererTests+MultipleDataClassSkipped.TheoryMethod(x: 2112)\" && testCase.SkipReason == \"Skip this attribute\");\n\n\t}"
      },
      {
        "name": "ThrowingData",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(ThrowingDataClass), \"TheoryWithMisbehavingData\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData\", theoryTestCase.DisplayName);\n\t\tvar message = Assert.Single(discoverer.DiagnosticMessages);\n\t\tvar diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);\n\t\tAssert.StartsWith($\"Exception thrown during theory discovery on 'TheoryDiscovererTests+ThrowingDataClass.TheoryWithMisbehavingData'; falling back to single test case.{Environment.NewLine}System.DivideByZeroException:\", diagnostic.Message);\n\t}"
      },
      {
        "name": "DataDiscovererReturningNullYieldsSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar theoryAttribute = Mocks.TheoryAttribute();\n\t\tvar dataAttribute = Mocks.DataAttribute();\n\t\tvar testMethod = Mocks.TestMethod(\"MockTheoryType\", \"MockTheoryMethod\", methodAttributes: new[] { theoryAttribute, dataAttribute });\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, theoryAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"MockTheoryType.MockTheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "NonSerializableDataYieldsSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(NonSerializableDataClass), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod\", theoryTestCase.DisplayName);\n\t\tvar message = Assert.Single(discoverer.DiagnosticMessages);\n\t\tvar diagnostic = Assert.IsAssignableFrom<IDiagnosticMessage>(message);\n\t\tAssert.Equal(\"Non-serializable data ('System.Object[]') found for 'TheoryDiscovererTests+NonSerializableDataClass.TheoryMethod'; falling back to single test case.\", diagnostic.Message);\n\t}"
      },
      {
        "name": "NoSuchDataDiscoverer_ThrowsInvalidOperationException",
        "body": "{\n\t\tvar results = Run<ITestFailed>(typeof(NoSuchDataDiscovererClass));\n\n\t\tvar failure = Assert.Single(results);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NoSuchDataDiscovererAttribute on TheoryDiscovererTests+NoSuchDataDiscovererClass.Test does not exist.\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "NotADataDiscoverer_ThrowsInvalidOperationException",
        "body": "{\n\t\tvar results = Run<ITestFailed>(typeof(NotADataDiscovererClass));\n\n\t\tvar failure = Assert.Single(results);\n\t\tAssert.Equal(\"System.InvalidOperationException\", failure.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Data discoverer specified for TheoryDiscovererTests+NotADataDiscovererAttribute on TheoryDiscovererTests+NotADataDiscovererClass.Test does not implement IDataDiscoverer.\", failure.Messages.Single());\n\t}"
      },
      {
        "name": "NonDiscoveryEnumeratedDataYieldsSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(NonDiscoveryEnumeratedData), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+NonDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "MixedDiscoveryEnumerationDataYieldSingleTheoryTestCase",
        "body": "{\n\t\tvar discoverer = TestableTheoryDiscoverer.Create();\n\t\tvar testMethod = Mocks.TestMethod(typeof(MixedDiscoveryEnumeratedData), \"TheoryMethod\");\n\t\tvar factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();\n\n\t\tvar testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);\n\n\t\tvar testCase = Assert.Single(testCases);\n\t\tvar theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);\n\t\tAssert.Equal(\"TheoryDiscovererTests+MixedDiscoveryEnumeratedData.TheoryMethod\", theoryTestCase.DisplayName);\n\t}"
      },
      {
        "name": "SkippedTheoryWithNoData",
        "body": "{\n\t\tvar skips = Run<ITestSkipped>(typeof(SkippedWithNoData));\n\n\t\tvar skip = Assert.Single(skips);\n\t\tAssert.Equal(\"TheoryDiscovererTests+SkippedWithNoData.TestMethod\", skip.Test.DisplayName);\n\t\tAssert.Equal(\"I have no data\", skip.Reason);\n\t}"
      },
      {
        "name": "SkippedTheoryWithData",
        "body": "{\n\t\tvar skips = Run<ITestSkipped>(typeof(SkippedWithData));\n\n\t\tvar skip = Assert.Single(skips);\n\t\tAssert.Equal(\"TheoryDiscovererTests+SkippedWithData.TestMethod\", skip.Test.DisplayName);\n\t\tAssert.Equal(\"I have data\", skip.Reason);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestFrameworkDiscovererTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar assembly = Substitute.For<IAssemblyInfo>();\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tvar diagnosticMessageSink = SpyMessageSink.Create();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"assemblyInfo\", () => new XunitTestFrameworkDiscoverer(null, sourceProvider, diagnosticMessageSink));\n\t\t\tAssert.Throws<ArgumentNullException>(\"sourceProvider\", () => new XunitTestFrameworkDiscoverer(assembly, null, diagnosticMessageSink));\n\t\t\tAssert.Throws<ArgumentNullException>(\"diagnosticMessageSink\", () => new XunitTestFrameworkDiscoverer(assembly, sourceProvider, null));\n\t\t}"
      },
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: TestFrameworkOptions.ForDiscovery()));\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(includeSourceInformation: false, discoveryMessageSink: Substitute.For<IMessageSink>(), discoveryOptions: null));\n\t\t}"
      },
      {
        "name": "AssemblyWithNoTypes_ReturnsNoTestCases",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\n\t\t\tframework.Find();\n\n\t\t\tAssert.Empty(framework.TestCases);\n\t\t}"
      },
      {
        "name": "RequestsOnlyPublicTypesFromAssembly",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(collectionFactory: Substitute.For<IXunitTestCollectionFactory>());\n\n\t\t\tframework.Find();\n\n\t\t\tframework.Assembly.Received(1).GetTypes(includePrivateTypes: false);\n\t\t}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{\n\t\t\tvar abstractClassTypeInfo = Reflector.Wrap(typeof(AbstractClass));\n\t\t\tvar assembly = Mocks.AssemblyInfo(types: new[] { abstractClassTypeInfo });\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);\n\t\t\tframework.FindTestsForClass(null).ReturnsForAnyArgs(true);\n\n\t\t\tframework.Find();\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(0).FindTestsForClass(Arg.Any<ITestClass>(), Arg.Any<bool>());\n\t\t}"
      },
      {
        "name": "CallsFindImplWhenTypesAreFoundInAssembly",
        "body": "{\n\t\t\tvar objectTypeInfo = Reflector.Wrap(typeof(object));\n\t\t\tvar intTypeInfo = Reflector.Wrap(typeof(int));\n\t\t\tvar assembly = Mocks.AssemblyInfo(types: new[] { objectTypeInfo, intTypeInfo });\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>(assembly);\n\t\t\tframework.FindTestsForClass(null).ReturnsForAnyArgs(true);\n\n\t\t\tframework.Find();\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == objectTypeInfo), false);\n\t\t\tframework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == intTypeInfo), false);\n\t\t}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tvar typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));\n\t\t\tvar mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);\n\n\t\t\tframework.Find();\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tsourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());\n\t\t}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tsourceProvider\n\t\t\t\t.GetSourceInformation(null)\n\t\t\t\t.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });\n\t\t\tvar typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));\n\t\t\tvar mockAssembly = Mocks.AssemblyInfo(types: new[] { typeInfo });\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(mockAssembly, sourceProvider);\n\n\t\t\tframework.Find(includeSourceInformation: true);\n\n\t\t\tAssert.Collection(framework.TestCases,\n\t\t\t\ttestCase =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);\n\t\t\t\t\tAssert.Equal(\"Source File\", testCase.SourceInformation.FileName);\n\t\t\t\t\tAssert.Equal(42, testCase.SourceInformation.LineNumber);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "GuardClauses",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar typeName = typeof(object).FullName;\n\t\t\tvar sink = Substitute.For<IMessageSink>();\n\t\t\tvar options = TestFrameworkOptions.ForDiscovery();\n\n\t\t\tAssert.Throws<ArgumentNullException>(\"typeName\", () => framework.Find(typeName: null, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));\n\t\t\tAssert.Throws<ArgumentException>(\"typeName\", () => framework.Find(typeName: \"\", includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: options));\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryMessageSink\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: null, discoveryOptions: options));\n\t\t\tAssert.Throws<ArgumentNullException>(\"discoveryOptions\", () => framework.Find(typeName, includeSourceInformation: false, discoveryMessageSink: sink, discoveryOptions: null));\n\t\t}"
      },
      {
        "name": "RequestsPublicAndPrivateMethodsFromType",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar type = Substitute.For<ITypeInfo>();\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(type);\n\n\t\t\tframework.Find(\"abc\");\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\ttype.Received(1).GetMethods(includePrivateMethods: true);\n\t\t}"
      },
      {
        "name": "CallsFindImplWhenMethodsAreFoundOnType",
        "body": "{\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();\n\t\t\tvar type = Substitute.For<ITypeInfo>();\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(type);\n\n\t\t\tframework.Find(\"abc\");\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(1).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), false);\n\t\t}"
      },
      {
        "name": "ExcludesAbstractTypesFromDiscovery",
        "body": "{\n\t\t\tvar framework = Substitute.For<TestableXunitTestFrameworkDiscoverer>();\n\t\t\tvar type = Substitute.For<ITypeInfo>();\n\t\t\ttype.IsAbstract.Returns(true);\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(type);\n\n\t\t\tframework.Find(\"abc\");\n\t\t\tframework.Sink.Finished.WaitOne();\n\n\t\t\tframework.Received(0).FindTestsForClass(Arg.Is<ITestClass>(testClass => testClass.Class == type), Arg.Any<bool>());\n\t\t}"
      },
      {
        "name": "DoesNotCallSourceProviderWhenNotAskedFor",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);\n\n\t\t\tframework.Find(\"abc\");\n\n\t\t\tsourceProvider.Received(0).GetSourceInformation(Arg.Any<ITestCase>());\n\t\t}"
      },
      {
        "name": "CallsSourceProviderWhenTypesAreFoundInAssembly",
        "body": "{\n\t\t\tvar sourceProvider = Substitute.For<ISourceInformationProvider>();\n\t\t\tsourceProvider\n\t\t\t\t.GetSourceInformation(null)\n\t\t\t\t.ReturnsForAnyArgs(new Xunit.SourceInformation { FileName = \"Source File\", LineNumber = 42 });\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(sourceProvider: sourceProvider);\n\t\t\tvar typeInfo = Reflector.Wrap(typeof(ClassWithSingleTest));\n\t\t\tframework.Assembly.GetType(\"abc\").Returns(typeInfo);\n\n\t\t\tframework.Find(\"abc\", includeSourceInformation: true);\n\n\t\t\tAssert.Collection(framework.TestCases,\n\t\t\t\ttestCase =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+ClassWithSingleTest.TestMethod\", testCase.DisplayName);\n\t\t\t\t\tAssert.Equal(\"Source File\", testCase.SourceInformation.FileName);\n\t\t\t\t\tAssert.Equal(42, testCase.SourceInformation.LineNumber);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ClassWithNoTests_ReturnsNoTestCases",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithNoTests)));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.False(framework.Sink.Finished.WaitOne(0));\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithFact_ReturnsOneTestCaseOfTypeXunitTestCase",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithOneFact)));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tvar testCase = Assert.Single(framework.Sink.TestCases);\n\t\t\tAssert.IsType<XunitTestCase>(testCase);\n\t\t}"
      },
      {
        "name": "TestMethod1",
        "body": "{ }"
      },
      {
        "name": "TestMethod2",
        "body": "{ }"
      },
      {
        "name": "AssemblyWithMixOfFactsAndNonTests_ReturnsTestCasesOnlyForFacts",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = new TestClass(Mocks.TestCollection(), Reflector.Wrap(typeof(ClassWithMixOfFactsAndNonFacts)));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(2, framework.Sink.TestCases.Count);\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod1\");\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+ClassWithMixOfFactsAndNonFacts.TestMethod2\");\n\t\t}"
      },
      {
        "name": "AssemblyWithTheoryWithInlineData_ReturnsOneTestCasePerDataRecord",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = Mocks.TestClass(typeof(TheoryWithInlineData));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(2, framework.Sink.TestCases.Count);\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: \\\"Hello world\\\")\");\n\t\t\tAssert.Single(framework.Sink.TestCases, t => t.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithInlineData.TheoryMethod(value: 42)\");\n\t\t}"
      },
      {
        "name": "AssemblyWithTheoryWithPropertyData_ReturnsOneTestCasePerDataRecord",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = Mocks.TestClass(typeof(TheoryWithPropertyData));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(2, framework.Sink.TestCases.Count);\n\t\t\tAssert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 42)\");\n\t\t\tAssert.Single(framework.Sink.TestCases, testCase => testCase.DisplayName == \"XunitTestFrameworkDiscovererTests+FindImpl+TheoryWithPropertyData.TheoryMethod(value: 2112)\");\n\t\t}"
      },
      {
        "name": "AssemblyWithMultiLevelHierarchyWithFactOverridenInNonImmediateDerivedClass_ReturnsOneTestCase",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar testClass = Mocks.TestClass(typeof(Child));\n\n\t\t\tframework.FindTestsForClass(testClass);\n\n\t\t\tAssert.Equal(1, framework.Sink.TestCases.Count);\n\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+FindImpl+Child.FactOverridenInNonImmediateDerivedClass\", framework.Sink.TestCases[0].DisplayName);\n\t\t}"
      },
      {
        "name": "FactOverridenInNonImmediateDerivedClass",
        "body": "{\n\t\t\t\tAssert.True(true);\n\t\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefaultTestCollection",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar type = Reflector.Wrap(typeof(ClassWithNoCollection));\n\n\t\t\tvar testClass = framework.CreateTestClass(type);\n\n\t\t\tAssert.NotNull(testClass.TestCollection);\n\t\t\tAssert.Equal(\"Test collection for XunitTestFrameworkDiscovererTests+CreateTestClass+ClassWithNoCollection\", testClass.TestCollection.DisplayName);\n\t\t\tAssert.Null(testClass.TestCollection.CollectionDefinition);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "UndeclaredTestCollection",
        "body": "{\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create();\n\t\t\tvar type = Reflector.Wrap(typeof(ClassWithUndeclaredCollection));\n\n\t\t\tvar testClass = framework.CreateTestClass(type);\n\n\t\t\tAssert.NotNull(testClass.TestCollection);\n\t\t\tAssert.Equal(\"This a collection without declaration\", testClass.TestCollection.DisplayName);\n\t\t\tAssert.Null(testClass.TestCollection.CollectionDefinition);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "DefinedTestCollection",
        "body": "{\n\t\t\tvar type = Reflector.Wrap(typeof(ClassWithDefinedCollection));\n\t\t\tvar framework = TestableXunitTestFrameworkDiscoverer.Create(type.Assembly);\n\n\t\t\tvar testClass = framework.CreateTestClass(type);\n\n\t\t\tAssert.NotNull(testClass.TestCollection);\n\t\t\tAssert.Equal(\"This a defined collection\", testClass.TestCollection.DisplayName);\n\t\t\tAssert.NotNull(testClass.TestCollection.CollectionDefinition);\n\t\t\tAssert.Equal(\"XunitTestFrameworkDiscovererTests+CreateTestClass+DeclaredCollection\", testClass.TestCollection.CollectionDefinition.Name);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "ATestNotToBeRun",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestFrameworkTests.cs",
    "methods": [
      {
        "name": "Defaults",
        "body": "{\n\t\t\tvar framework = new XunitTestFramework();\n\n\t\t\tAssert.Matches(@\"xUnit.net v3 \\d+\\.\\d+\\.\\d+(-pre\\.\\d+(-dev)?(\\+[0-9a-f]+)?)?\", framework.TestFrameworkDisplayName);\n\t\t}"
      }
    ]
  },
  {
    "file": "ConsoleCaptureTestOutputWriterTests.cs",
    "methods": [
      {
        "name": "CapturesConsoleOut",
        "body": "{\n\t\tConsole.WriteLine(\"This is a line of text from Console.WriteLine\");\n\n\t\tAssert.Equal(\"This is a line of text from Console.WriteLine\" + Environment.NewLine, testOutputHelper.Output);\n\t}"
      },
      {
        "name": "CapturesConsoleError",
        "body": "{\n\t\tConsole.Error.WriteLine(\"This is a line of text from Console.Error.WriteLine\");\n\n\t\tAssert.Equal(\"This is a line of text from Console.Error.WriteLine\" + Environment.NewLine, testOutputHelper.Output);\n\t}"
      },
      {
        "name": "OutputIsInterleaved",
        "body": "{\n\t\tConsole.WriteLine(\"This is a line of text from Console.WriteLine\");\n\t\ttestOutputHelper.WriteLine(\"This is a line of text from the output helper\");\n\t\tConsole.Error.WriteLine(\"This is a line of text from Console.Error.WriteLine\");\n\n\t\tAssert.Equal(\n\t\t\t\"This is a line of text from Console.WriteLine\" + Environment.NewLine +\n\t\t\t\"This is a line of text from the output helper\" + Environment.NewLine +\n\t\t\t\"This is a line of text from Console.Error.WriteLine\" + Environment.NewLine,\n\t\t\ttestOutputHelper.Output\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "MessageBusTests.cs",
    "methods": [
      {
        "name": "QueuedMessageShowUpInMessageSink",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar sink = SpyMessageSink.Create(messages: messages);\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg2 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg3 = Substitute.For<IMessageSinkMessage>();\n\n\t\tusing (var bus = new MessageBus(sink))\n\t\t{\n\t\t\tbus.QueueMessage(msg1);\n\t\t\tbus.QueueMessage(msg2);\n\t\t\tbus.QueueMessage(msg3);\n\t\t}\n\n\t\tAssert.Collection(messages,\n\t\t\tmessage => Assert.Same(msg1, message),\n\t\t\tmessage => Assert.Same(msg2, message),\n\t\t\tmessage => Assert.Same(msg3, message)\n\t\t);\n\t}"
      },
      {
        "name": "TryingToQueueMessageAfterDisposingThrows",
        "body": "{\n\t\tvar bus = new MessageBus(SpyMessageSink.Create());\n\t\tbus.Dispose();\n\n\t\tvar exception = Record.Exception(\n\t\t\t() => bus.QueueMessage(Substitute.For<IMessageSinkMessage>())\n\t\t);\n\n\t\tAssert.IsType<ObjectDisposedException>(exception);\n\t}"
      },
      {
        "name": "WhenSinkThrowsMessagesContinueToBeDelivered",
        "body": "{\n\t\tvar sink = Substitute.For<IMessageSink>();\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg2 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg3 = Substitute.For<IMessageSinkMessage>();\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tsink.OnMessage(Arg.Any<IMessageSinkMessage>())\n\t\t\t.Returns(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = (IMessageSinkMessage)callInfo[0];\n\t\t\t\tif (msg == msg2)\n\t\t\t\t\tthrow new DivideByZeroException(\"whee!\");\n\t\t\t\telse\n\t\t\t\t\tmessages.Add(msg);\n\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\tusing (var bus = new MessageBus(sink))\n\t\t{\n\t\t\tbus.QueueMessage(msg1);\n\t\t\tbus.QueueMessage(msg2);\n\t\t\tbus.QueueMessage(msg3);\n\t\t}\n\n\t\tAssert.Collection(messages,\n\t\t\tmessage => Assert.Same(message, msg1),\n\t\t\tmessage =>\n\t\t\t{\n\t\t\t\tvar errorMessage = Assert.IsAssignableFrom<IErrorMessage>(message);\n\t\t\t\tAssert.Equal(\"System.DivideByZeroException\", errorMessage.ExceptionTypes.Single());\n\t\t\t\tAssert.Equal(\"whee!\", errorMessage.Messages.Single());\n\t\t\t},\n\t\t\tmessage => Assert.Same(message, msg3)\n\t\t);\n\t}"
      },
      {
        "name": "QueueReturnsTrueForFailIfStopOnFailFalse",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar sink = SpyMessageSink.Create(messages: messages);\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar msg2 = Substitute.For<ITestFailed>();\n\t\tvar msg3 = Substitute.For<IMessageSinkMessage>();\n\n\t\tusing (var bus = new MessageBus(sink))\n\t\t{\n\t\t\tAssert.True(bus.QueueMessage(msg1));\n\t\t\tAssert.True(bus.QueueMessage(msg2));\n\t\t\tAssert.True(bus.QueueMessage(msg3));\n\t\t}\n\n\t\tAssert.Collection(messages,\n\t\t\tmessage => Assert.Same(msg1, message),\n\t\t\tmessage => Assert.Same(msg2, message),\n\t\t\tmessage => Assert.Same(msg3, message)\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "SynchronousMessageBusTests.cs",
    "methods": [
      {
        "name": "MessagesAreDispatchedImmediatelyFromBus",
        "body": "{\n\t\tvar msg1 = Substitute.For<IMessageSinkMessage>();\n\t\tvar dispatchedMessages = new List<IMessageSinkMessage>();\n\t\tusing (var bus = new SynchronousMessageBus(SpyMessageSink.Create(messages: dispatchedMessages), stopOnFail: false))\n\t\t{\n\t\t\tAssert.True(bus.QueueMessage(msg1));\n\t\t}\n\n\t\tvar message = Assert.Single(dispatchedMessages);\n\t\tAssert.Same(msg1, message);\n\t}"
      },
      {
        "name": "BusShouldReportShutdownWhenMessageSinkReturnsFalse",
        "body": "{\n\t\tusing (var bus = new SynchronousMessageBus(SpyMessageSink.Create(returnResult: false), stopOnFail: false))\n\t\t{\n\t\t\tAssert.False(bus.QueueMessage(Substitute.For<IMessageSinkMessage>()));\n\t\t}\n\t}"
      }
    ]
  },
  {
    "file": "TraceCaptureTestOutputWriterTests.cs",
    "methods": [
      {
        "name": "CapturesTrace",
        "body": "{\n\t\tTrace.WriteLine(\"This is a line of text from Trace.WriteLine\");\n\n\t\tAssert.Equal(\"This is a line of text from Trace.WriteLine\" + Environment.NewLine, testOutputHelper.Output);\n\t}"
      },
      {
        "name": "CapturesDebug",
        "body": "{\n\t\tDebug.WriteLine(\"This is a line of text from Debug.WriteLine\");\n\n#if DEBUG\n\t\tAssert.Equal(\"This is a line of text from Debug.WriteLine\" + Environment.NewLine, testOutputHelper.Output);\n#else\n\t\tAssert.Empty(testOutputHelper.Output);\n#endif\n\t}"
      },
      {
        "name": "OutputIsInterleaved",
        "body": "{\n\t\tTrace.WriteLine(\"This is a line of text from Trace.WriteLine\");\n\t\ttestOutputHelper.WriteLine(\"This is a line of text from the output helper\");\n\t\tDebug.WriteLine(\"This is a line of text from Debug.WriteLine\");\n\n\t\tAssert.Equal(\n\t\t\t\"This is a line of text from Trace.WriteLine\" + Environment.NewLine +\n\t\t\t\"This is a line of text from the output helper\" + Environment.NewLine +\n#if DEBUG\n\t\t\t\"This is a line of text from Debug.WriteLine\" + Environment.NewLine,\n#else\n\t\t\t\"\",\n#endif\n\t\t\ttestOutputHelper.Output\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "MatrixTheoryDataTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\tvar nonEmptyData = new[] { new object() };\n\n\t\tAssert.Throws<ArgumentNullException>(\"dimension1\", () => new MatrixTheoryData<object?, object?>(null!, nonEmptyData));\n\t\tAssert.Throws<ArgumentNullException>(\"dimension2\", () => new MatrixTheoryData<object?, object?>(nonEmptyData, null!));\n\n\t\tvar emptyData = Array.Empty<object>();\n\n\t\tAssert.Throws<ArgumentException>(\"dimension1\", () => new MatrixTheoryData<object?, object?>(emptyData, nonEmptyData));\n\t\tAssert.Throws<ArgumentException>(\"dimension2\", () => new MatrixTheoryData<object?, object?>(nonEmptyData, emptyData));\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar messages = await RunAsync(typeof(SampleUsage));\n\n\t\tAssert.Collection(\n\t\t\tmessages.OfType<ITestPassed>().Select(passed => messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == passed.TestUniqueID).TestDisplayName).OrderBy(x => x),\n\t\t\tdisplayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"Hello\\\", y: 5)\", displayName),\n\t\t\tdisplayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"world!\\\", y: 6)\", displayName)\n\t\t);\n\t\tAssert.Collection(\n\t\t\tmessages.OfType<ITestFailed>().Select(failed => messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID).TestDisplayName).OrderBy(x => x),\n\t\t\tdisplayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"Hello\\\", y: 42)\", displayName),\n\t\t\tdisplayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"Hello\\\", y: 6)\", displayName),\n\t\t\tdisplayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"world!\\\", y: 42)\", displayName),\n\t\t\tdisplayName => Assert.Equal(\"MatrixTheoryDataTests+SampleUsage.MyTestMethod(x: \\\"world!\\\", y: 5)\", displayName)\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "MessageSinkMessageTests.cs",
    "methods": [
      {
        "name": "WithoutJsonTypeID_Throws",
        "body": "{\n\t\tvar msg = new DerivedMessageSinkMessage();\n\n\t\tvar ex = Record.Exception(() => msg.ToJson());\n\n\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\tAssert.Equal($\"Message sink message type '{typeof(DerivedMessageSinkMessage).SafeName()}' is missing its [JsonTypeID] decoration\", ex.Message);\n\t}"
      },
      {
        "name": "SerializationExcludesNullValuesAndEmptyTraits",
        "body": "{\n\t\tvar startTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));\n\t\tvar msg = new TestAssemblyStarting\n\t\t{\n\t\t\tAssemblyUniqueID = \"asm-id\",\n\t\t\tAssemblyName = \"asm-name\",\n\t\t\tAssemblyPath = \"asm-path\",\n\t\t\tConfigFilePath = null,\n\t\t\tSeed = null,\n\t\t\tStartTime = startTime,\n\t\t\tTargetFramework = null,\n\t\t\tTestEnvironment = \"test-env\",\n\t\t\tTestFrameworkDisplayName = \"test-framework\",\n\t\t\tTraits = TestData.EmptyTraits,\n\t\t};\n\n\t\tvar json = msg.ToJson();\n\n\t\tAssert.NotNull(json);\n\t\tvar expected =\n@\"{\n    \"\"$type\"\":                    \"\"test-assembly-starting\"\",\n    \"\"AssemblyUniqueID\"\":         \"\"asm-id\"\",\n    \"\"AssemblyName\"\":             \"\"asm-name\"\",\n    \"\"AssemblyPath\"\":             \"\"asm-path\"\",\n    \"\"StartTime\"\":                \"\"2020-09-26T13:55:27.2120000-07:00\"\",\n    \"\"TestEnvironment\"\":          \"\"test-env\"\",\n    \"\"TestFrameworkDisplayName\"\": \"\"test-framework\"\"\n}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");\n\t\tAssert.Equal(expected, json);\n\t}"
      },
      {
        "name": "SerializesEnumsAsStringsAndExcludesEmptyOutput",
        "body": "{\n\t\tvar finishTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));\n\t\tvar msg = new TestFailed\n\t\t{\n\t\t\tAssemblyUniqueID = \"asm-id\",\n\t\t\tCause = FailureCause.Assertion,\n\t\t\tExceptionParentIndices = [-1],\n\t\t\tExceptionTypes = [\"exception-type\"],\n\t\t\tExecutionTime = 123.45m,\n\t\t\tFinishTime = finishTime,\n\t\t\tMessages = [\"exception-message\"],\n\t\t\tOutput = \"\",\n\t\t\tStackTraces = [null],\n\t\t\tTestCaseUniqueID = \"test-case-id\",\n\t\t\tTestClassUniqueID = null,\n\t\t\tTestCollectionUniqueID = \"test-collection-id\",\n\t\t\tTestMethodUniqueID = null,\n\t\t\tTestUniqueID = \"test-id\",\n\t\t\tWarnings = null,\n\t\t};\n\n\t\tvar json = msg.ToJson();\n\n\t\tAssert.NotNull(json);\n\t\tvar expected =\n@\"{\n    \"\"$type\"\":                  \"\"test-failed\"\",\n    \"\"AssemblyUniqueID\"\":       \"\"asm-id\"\",\n    \"\"TestCollectionUniqueID\"\": \"\"test-collection-id\"\",\n    \"\"TestCaseUniqueID\"\":       \"\"test-case-id\"\",\n    \"\"TestUniqueID\"\":           \"\"test-id\"\",\n    \"\"ExecutionTime\"\":          123.45,\n    \"\"FinishTime\"\":             \"\"2020-09-26T13:55:27.2120000-07:00\"\",\n    \"\"Cause\"\":                  \"\"Assertion\"\",\n    \"\"ExceptionParentIndices\"\": [-1],\n    \"\"ExceptionTypes\"\":         [\"\"exception-type\"\"],\n    \"\"Messages\"\":               [\"\"exception-message\"\"],\n    \"\"StackTraces\"\":            [null]\n}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");\n\t\tAssert.Equal(expected, json);\n\t}"
      },
      {
        "name": "ValidatesAllDerivedTypesAreSupported",
        "body": "{\n\t\tvar excludedTypes = new HashSet<Type> {\n\t\t\ttypeof(MessageSinkMessage),\n\t\t\ttypeof(DerivedMessageSinkMessage),\n\t\t};\n\t\tvar derivedTypes =\n\t\t\ttypeof(MessageSinkMessage)\n\t\t\t\t.Assembly\n\t\t\t\t.GetTypes()\n\t\t\t\t.Where(t => !t.IsAbstract && !excludedTypes.Contains(t) && typeof(IMessageSinkMessage).IsAssignableFrom(t))\n\t\t\t\t.ToList();\n\t\tvar missingTypes =\n\t\t\tderivedTypes\n\t\t\t\t.Where(t => t.GetCustomAttribute<JsonTypeIDAttribute>() is null)\n\t\t\t\t.ToList();\n\n\t\tif (missingTypes.Count > 0)\n\t\t\tthrow new XunitException($\"The following message classes are missing [JsonTypeID]:{Environment.NewLine}{string.Join(Environment.NewLine, missingTypes.Select(t => $\"  - {t.SafeName()}\").OrderBy(t => t))}\");\n\t}"
      }
    ]
  },
  {
    "file": "TestFailedTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => new TestFailed\n\t\t\t{\n\t\t\t\tCause = (FailureCause)2112,\n\n\t\t\t\tAssemblyUniqueID = \"\",\n\t\t\t\tExceptionParentIndices = [],\n\t\t\t\tExceptionTypes = [],\n\t\t\t\tExecutionTime = 0,\n\t\t\t\tFinishTime = DateTimeOffset.UtcNow,\n\t\t\t\tMessages = [],\n\t\t\t\tOutput = \"\",\n\t\t\t\tStackTraces = [],\n\t\t\t\tTestCaseUniqueID = \"\",\n\t\t\t\tTestClassUniqueID = \"\",\n\t\t\t\tTestCollectionUniqueID = \"\",\n\t\t\t\tTestMethodUniqueID = \"\",\n\t\t\t\tTestUniqueID = \"\",\n\t\t\t\tWarnings = [],\n\t\t\t});\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"Cause\", argEx.ParamName);\n\t\t\tAssert.StartsWith($\"Enum value 2112 not in valid set: [Assertion, Exception, Other, Timeout]\", argEx.Message);\n\t\t}"
      },
      {
        "name": "NonAssertionException",
        "body": "{\n\t\t\tvar ex = new DivideByZeroException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Exception, failed.Cause);\n\t\t}"
      },
      {
        "name": "BuiltInAssertionException",
        "body": "{\n\t\t\tvar ex = EqualException.ForMismatchedValues(42, 2112);\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Assertion, failed.Cause);\n\t\t}"
      },
      {
        "name": "CustomAssertionException",
        "body": "{\n\t\t\tvar ex = new MyAssertionException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Assertion, failed.Cause);\n\t\t}"
      },
      {
        "name": "BuiltInTimeoutException",
        "body": "{\n\t\t\tvar ex = TestTimeoutException.ForTimedOutTest(2112);\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Timeout, failed.Cause);\n\t\t}"
      },
      {
        "name": "CustomTimeoutException",
        "body": "{\n\t\t\tvar ex = new MyTimeoutException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Timeout, failed.Cause);\n\t\t}"
      },
      {
        "name": "TimeoutExceptionTrumpsAssertionException",
        "body": "{\n\t\t\tvar ex = new MyMultiException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Timeout, failed.Cause);\n\t\t}"
      }
    ]
  },
  {
    "file": "XunitTestAssemblyTests.cs",
    "methods": [
      {
        "name": "AssemblyFixtureTypes",
        "body": "{\n\t\tvar fixtures = testAssembly.AssemblyFixtureTypes;\n\n\t\tvar fixture = Assert.Single(fixtures);\n\t\tAssert.Equal(\"SomeNamespace.SomeFixtureClass\", fixture.FullName);\n\t}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{\n\t\tvar attributes = testAssembly.BeforeAfterTestAttributes;\n\n\t\tvar attribute = Assert.Single(attributes);\n\t\tAssert.Equal(\"SomeNamespace.BeforeAfterTest1Attribute\", attribute.GetType().FullName);\n\t}"
      },
      {
        "name": "CollectionBehavior",
        "body": "{\n\t\tvar behavior = testAssembly.CollectionBehavior;\n\n\t\tAssert.NotNull(behavior);\n\t\tAssert.True(behavior.DisableTestParallelization);\n\t\tAssert.Equal(42, behavior.MaxParallelThreads);\n\t}"
      },
      {
        "name": "CollectionDefinitions",
        "body": "{\n\t\tvar definitions = testAssembly.CollectionDefinitions;\n\n\t\tAssert.Collection(\n\t\t\tdefinitions.OrderBy(d => d.Key),\n\t\t\tdefinition =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Foo\", definition.Key);\n\t\t\t\tAssert.Equal(\"SomeNamespace.NamedCollectionDefinition\", definition.Value.Type.FullName);\n\t\t\t},\n\t\t\tdefinition =>\n\t\t\t{\n\t\t\t\t// The ID is based on the assembly ID, which is based on the assembly name. Since we rebuild every time\n\t\t\t\t// and get a random assembly name every time, this ID will change every time. This is the same reason we\n\t\t\t\t// don't check the unique ID of the test assembly itself.\n\t\t\t\tAssert.Matches(\"Test collection for SomeNamespace.UnnamedCollectionDefinition \\\\(id: [0-9a-f]{64}\\\\)\", definition.Key);\n\t\t\t\tAssert.Equal(\"SomeNamespace.UnnamedCollectionDefinition\", definition.Value.Type.FullName);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "TargetFramework",
        "body": "{\n\t\tAssert.Equal(\".NETFramework,Version=v4.7.2\", testAssembly.TargetFramework);\n\t}"
      },
      {
        "name": "TestCaseOrderer",
        "body": "{\n\t\tvar orderer = testAssembly.TestCaseOrderer;\n\n\t\tAssert.NotNull(orderer);\n\t\tAssert.Equal(\"SomeNamespace.MyTestCaseOrderer\", orderer.GetType().FullName);\n\t}"
      },
      {
        "name": "TestCollectionOrderer",
        "body": "{\n\t\tvar orderer = testAssembly.TestCollectionOrderer;\n\n\t\tAssert.NotNull(orderer);\n\t\tAssert.Equal(\"SomeNamespace.MyTestCollectionOrderer\", orderer.GetType().FullName);\n\t}"
      },
      {
        "name": "Traits",
        "body": "{\n\t\tvar traits = testAssembly.Traits;\n\n\t\tvar trait = Assert.Single(traits);\n\t\tAssert.Equal(\"Hello\", trait.Key);\n\t\tvar value = Assert.Single(trait.Value);\n\t\tAssert.Equal(\"World\", value);\n\t}"
      },
      {
        "name": "Version",
        "body": "{\n\t\tvar version = testAssembly.Version;\n\n\t\tAssert.Equal(new Version(1, 2, 3, 4), version);\n\t}"
      },
      {
        "name": "Serialization",
        "body": "{\n\t\tvar serialized = SerializationHelper.Instance.Serialize(testAssembly);\n\t\tvar deserialized = SerializationHelper.Instance.Deserialize(serialized);\n\n\t\tAssert.IsType<XunitTestAssembly>(deserialized);\n\t\tAssert.Equivalent(testAssembly, deserialized);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestCaseTests.cs",
    "methods": [
      {
        "name": "DefaultBehavior",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(\"MockType\", \"MockMethod\");\n\n\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\tAssert.Equal(\"MockType.MockMethod\", testCase.DisplayName);\n\t\tAssert.Null(testCase.SkipReason);\n\t\tAssert.Empty(testCase.Traits);\n\t}"
      },
      {
        "name": "SkipReason",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(skip: \"Skip Reason\");\n\n\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\tAssert.Equal(\"Skip Reason\", testCase.SkipReason);\n\t}"
      },
      {
        "name": "Timeout",
        "body": "{\n\t\tvar testMethod = Mocks.TestMethod(timeout: 42);\n\n\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\tAssert.Equal(42, testCase.Timeout);\n\t}"
      },
      {
        "name": "TraitsOnTestMethod",
        "body": "{\n\t\t\tvar trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");\n\t\t\tvar trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");\n\t\t\tvar testMethod = Mocks.TestMethod(methodAttributes: new[] { trait1, trait2 });\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));\n\t\t\tAssert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));\n\t\t}"
      },
      {
        "name": "TraitsOnTestClass",
        "body": "{\n\t\t\tvar trait1 = Mocks.TraitAttribute(\"Trait1\", \"Value1\");\n\t\t\tvar trait2 = Mocks.TraitAttribute(\"Trait2\", \"Value2\");\n\t\t\tvar testMethod = Mocks.TestMethod(classAttributes: new[] { trait1, trait2 });\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Equal(\"Value1\", Assert.Single(testCase.Traits[\"Trait1\"]));\n\t\t\tAssert.Equal(\"Value2\", Assert.Single(testCase.Traits[\"Trait2\"]));\n\t\t}"
      },
      {
        "name": "CustomTrait",
        "body": "{\n\t\t\tvar passingTests = Run<ITestPassed>(typeof(ClassWithCustomTraitTest));\n\n\t\t\tvar passingTest = Assert.Single(passingTests);\n\t\t\tif (passingTest != null)\n\t\t\t\tAssert.Collection(\n\t\t\t\t\tpassingTest.TestCase.Traits.OrderBy(x => x.Key),\n\t\t\t\t\tnamedTrait =>\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(\"Assembly\", namedTrait.Key);\n\t\t\t\t\t\tvar value = Assert.Single(namedTrait.Value);\n\t\t\t\t\t\tAssert.Equal(\"Trait\", value);\n\t\t\t\t\t},\n\t\t\t\t\tnamedTrait =>\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(\"Author\", namedTrait.Key);\n\t\t\t\t\t\tvar value = Assert.Single(namedTrait.Value);\n\t\t\t\t\t\tAssert.Equal(\"Some Schmoe\", value);\n\t\t\t\t\t},\n\t\t\t\t\tnamedTrait =>\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(\"Bug\", namedTrait.Key);\n\t\t\t\t\t\tvar value = Assert.Single(namedTrait.Value);\n\t\t\t\t\t\tAssert.Equal(\"2112\", value);\n\t\t\t\t\t});\n\t\t}"
      },
      {
        "name": "CustomTraitWithoutDiscoverer",
        "body": "{\n\t\t\tvar trait = Mocks.TraitAttribute<BadTraitAttribute>();\n\t\t\tvar testMethod = Mocks.TestMethod(classAttributes: new[] { trait });\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar spy = SpyMessageSink.Create(messages: messages);\n\n\t\t\tvar testCase = new XunitTestCase(spy, TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Empty(testCase.Traits);\n\t\t\tvar diagnosticMessages = messages.OfType<IDiagnosticMessage>();\n\t\t\tvar diagnosticMessage = Assert.Single(diagnosticMessages);\n\t\t\tAssert.Equal($\"Trait attribute on '{testCase.DisplayName}' did not have [TraitDiscoverer]\", diagnosticMessage.Message);\n\t\t}"
      },
      {
        "name": "BugFix",
        "body": "{ }"
      },
      {
        "name": "CustomDisplayName",
        "body": "{\n\t\t\tvar testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\");\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod);\n\n\t\t\tAssert.Equal(\"Custom Display Name\", testCase.DisplayName);\n\t\t}"
      },
      {
        "name": "CustomDisplayNameWithArguments",
        "body": "{\n\t\t\tvar param1 = Mocks.ParameterInfo(\"p1\");\n\t\t\tvar param2 = Mocks.ParameterInfo(\"p2\");\n\t\t\tvar param3 = Mocks.ParameterInfo(\"p3\");\n\t\t\tvar testMethod = Mocks.TestMethod(displayName: \"Custom Display Name\", parameters: new[] { param1, param2, param3 });\n\t\t\tvar arguments = new object[] { 42, \"Hello, world!\", 'A' };\n\n\t\t\tvar testCase = new XunitTestCase(SpyMessageSink.Create(), TestMethodDisplay.ClassAndMethod, TestMethodDisplayOptions.None, testMethod, arguments);\n\n\t\t\tAssert.Equal(\"Custom Display Name(p1: 42, p2: \\\"Hello, world!\\\", p3: 'A')\", testCase.DisplayName);\n\t\t}"
      }
    ]
  },
  {
    "file": "XunitTestClassTests.cs",
    "methods": [
      {
        "name": "Metadata",
        "body": "{\n\t\tAssert.Equal(typeof(ClassUnderTest), testClass.Class);\n\t\tAssert.Equal(\"SomeNamespace.ClassUnderTest\", testClass.TestClassName);\n\t\tAssert.Equal(\"SomeNamespace\", testClass.TestClassNamespace);\n\t\tAssert.Equal(\"ClassUnderTest\", testClass.TestClassSimpleName);\n\t}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{\n\t\tvar result = testClass.BeforeAfterTestAttributes;\n\n\t\tAssert.Collection(\n\t\t\tresult.OrderBy(a => a.GetType().Name),\n\t\t\tattr => Assert.IsType<BeforeAfterOnAssembly>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnClass>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnCollection>(attr)\n\t\t);\n\t}"
      },
      {
        "name": "ClassFixtureTypes",
        "body": "{\n\t\tvar fixtures = testClass.ClassFixtureTypes;\n\n\t\tvar fixture = Assert.Single(fixtures);\n\t\tAssert.Equal(typeof(MyClassFixture), fixture);\n\t}"
      },
      {
        "name": "Constructors",
        "body": "{\n\t\tvar constructors = testClass.Constructors;\n\n\t\tAssert.NotNull(constructors);\n\t\tAssert.Collection(\n\t\t\tconstructors.OrderBy(c => c.GetParameters().Length),\n\t\t\tconstructor => Assert.Empty(constructor.GetParameters()),\n\t\t\tconstructor => Assert.Single(constructor.GetParameters())\n\t\t);\n\t}"
      },
      {
        "name": "Methods",
        "body": "{\n\t\tvar methods = testClass.Methods;\n\n\t\tstatic string displayName(MethodInfo method)\n\t\t{\n\t\t\tvar parameterTexts =\n\t\t\t\tmethod\n\t\t\t\t\t.GetParameters()\n\t\t\t\t\t.Select(p => $\"{p.ParameterType.FullName} {p.Name}\");\n\n\t\t\treturn $\"{method.DeclaringType?.FullName}.{method.Name}({string.Join(\", \", parameterTexts)})\";\n\t\t}\n\n\t\tAssert.Collection(\n\t\t\tmethods.Where(m => m.DeclaringType != typeof(object)).Select(displayName).OrderBy(x => x),\n\t\t\tmethod => Assert.Equal(\"SomeNamespace.BaseClass.BaseMethod()\", method),\n\t\t\tmethod => Assert.Equal(\"SomeNamespace.BaseClass.BaseStaticMethod()\", method),\n\t\t\tmethod => Assert.Equal(\"SomeNamespace.ClassUnderTest.InternalMethod()\", method),\n\t\t\tmethod => Assert.Equal(\"SomeNamespace.ClassUnderTest.PrivateMethod()\", method),\n\t\t\tmethod => Assert.Equal(\"SomeNamespace.ClassUnderTest.ProtectedMethod()\", method),\n\t\t\tmethod => Assert.Equal(\"SomeNamespace.ClassUnderTest.PublicMethod()\", method)\n\t\t);\n\t}"
      },
      {
        "name": "TestCaseOrderer",
        "body": "{\n\t\tvar orderer = testClass.TestCaseOrderer;\n\n\t\tAssert.IsType<SomeNamespace.MyTestCaseOrderer>(orderer);\n\t}"
      },
      {
        "name": "Traits",
        "body": "{\n\t\tvar traits = testClass.Traits;\n\n\t\tvar trait = Assert.Single(traits);\n\t\tAssert.Equal(\"Hello\", trait.Key);\n\t\tvar value = Assert.Single(trait.Value);\n\t\tAssert.Equal(\"World\", value);\n\t}"
      },
      {
        "name": "Serialization",
        "body": "{\n\t\t// We can't use the XunitTestClass backed by mocks because they don't serialize, so we'll create\n\t\t// one here that's backed by an actual XunitTestAssembly object.\n\t\tvar testCollection = TestData.XunitTestCollection<ClassUnderTest>();\n\t\tvar testClass = new XunitTestClass(typeof(ClassUnderTest), testCollection);\n\n\t\tvar serialized = SerializationHelper.Instance.Serialize(testClass);\n\t\tvar deserialized = SerializationHelper.Instance.Deserialize(serialized);\n\n\t\tAssert.IsType<XunitTestClass>(deserialized);\n\t\tAssert.Equivalent(testClass, deserialized);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestCollectionTests.cs",
    "methods": [
      {
        "name": "Metadata",
        "body": "{\n\t\tAssert.Equal(typeof(MyCollection), testCollection.CollectionDefinition);\n\t\tAssert.Equal(\"XunitTestCollectionTests+MyCollection\", testCollection.TestCollectionClassName);\n\t\tAssert.Equal(\"display name\", testCollection.TestCollectionDisplayName);\n\t}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{\n\t\tvar result = testCollection.BeforeAfterTestAttributes;\n\n\t\tAssert.Collection(\n\t\t\tresult.OrderBy(a => a.GetType().Name),\n\t\t\tattr => Assert.IsType<BeforeAfterOnAssembly>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnCollection>(attr)\n\t\t);\n\t}"
      },
      {
        "name": "ClassFixtureTypes",
        "body": "{\n\t\tvar fixtures = testCollection.ClassFixtureTypes;\n\n\t\tvar fixture = Assert.Single(fixtures);\n\t\tAssert.Equal(typeof(MyClassFixture), fixture);\n\t}"
      },
      {
        "name": "CollectionFixtureTypes",
        "body": "{\n\t\tvar fixtures = testCollection.CollectionFixtureTypes;\n\n\t\tvar fixture = Assert.Single(fixtures);\n\t\tAssert.Equal(typeof(MyCollectionFixture), fixture);\n\t}"
      },
      {
        "name": "DisableParallelization",
        "body": "{\n\t\tvar disableParallelization = testCollection.DisableParallelization;\n\n\t\tAssert.True(disableParallelization);\n\t}"
      },
      {
        "name": "TestCaseOrderer",
        "body": "{\n\t\tvar orderer = testCollection.TestCaseOrderer;\n\n\t\tAssert.IsType<MyTestCaseOrderer>(orderer);\n\t}"
      },
      {
        "name": "Serialization",
        "body": "{\n\t\t// We can't use the XunitTestCollection backed by mocks because they don't serialize, so we'll create\n\t\t// one here that's backed by an actual XunitTestAssembly object.\n\t\tvar testAssembly = TestData.XunitTestAssembly<ClassUnderTest>();\n\t\tvar testCollection = new XunitTestCollection(testAssembly, typeof(MyCollection), true, \"display name\");\n\n\t\tvar serialized = SerializationHelper.Instance.Serialize(testCollection);\n\t\tvar deserialized = SerializationHelper.Instance.Deserialize(serialized);\n\n\t\tAssert.IsType<XunitTestCollection>(deserialized);\n\t\tAssert.Equivalent(testCollection, deserialized);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestMethodTests.cs",
    "methods": [
      {
        "name": "Metadata",
        "body": "{\n\t\tAssert.Equal(nameof(ClassUnderTest.Passing), testMethod.MethodName);\n\t}"
      },
      {
        "name": "BeforeAfterTestAttributes",
        "body": "{\n\t\tvar result = testMethod.BeforeAfterTestAttributes;\n\n\t\tAssert.Collection(\n\t\t\tresult.OrderBy(a => a.GetType().Name),\n\t\t\tattr => Assert.IsType<BeforeAfterOnAssembly>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnClass>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnCollection>(attr),\n\t\t\tattr => Assert.IsType<BeforeAfterOnMethod>(attr)\n\t\t);\n\t}"
      },
      {
        "name": "DataAttributes",
        "body": "{\n\t\tvar attributes = testMethod.DataAttributes;\n\n\t\tvar attribute = Assert.Single(attributes);\n\t\tAssert.IsType<InlineDataAttribute>(attribute);\n\t}"
      },
      {
        "name": "FactAttributes",
        "body": "{\n\t\tvar attributes = testMethod.FactAttributes;\n\n\t\tAssert.Collection(\n\t\t\tattributes.OrderBy(x => x.GetType().Name),\n\t\t\tattribute => Assert.IsType<FactAttribute>(attribute),\n\t\t\tattribute => Assert.IsType<TheoryAttribute>(attribute)\n\t\t);\n\t}"
      },
      {
        "name": "Parameters",
        "body": "{\n\t\tvar parameters = testMethod.Parameters;\n\n\t\tAssert.Collection(\n\t\t\tparameters,\n\t\t\tparameter => Assert.Equal(\"x\", parameter.Name),\n\t\t\tparameter => Assert.Equal(\"y\", parameter.Name)\n\t\t);\n\t}"
      },
      {
        "name": "Traits",
        "body": "{\n\t\tvar traits = testMethod.Traits;\n\n\t\tvar trait = Assert.Single(traits);\n\t\tAssert.Equal(\"Hello\", trait.Key);\n\t\tvar value = Assert.Single(trait.Value);\n\t\tAssert.Equal(\"World\", value);\n\t}"
      },
      {
        "name": "Serialization",
        "body": "{\n\t\t// We can't use the XunitTestMethod backed by mocks because they don't serialize, so we'll create\n\t\t// one here that's backed by an actual XunitTestAssembly object.\n\t\tvar testClass = TestData.XunitTestClass<ClassUnderTest>();\n\t\tvar method = typeof(ClassUnderTest).GetMethod(\"Passing\") ?? throw new InvalidOperationException(\"Could not find test method\");\n\t\tvar testMethod = new XunitTestMethod(testClass, method, []);\n\n\t\tvar serialized = SerializationHelper.Instance.Serialize(testMethod);\n\t\tvar deserialized = SerializationHelper.Instance.Deserialize(serialized);\n\n\t\tAssert.IsType<XunitTestMethod>(deserialized);\n\t\tAssert.Equivalent(testMethod, deserialized);\n\t}"
      },
      {
        "name": "CanSerializeClosedGenericTestMethod",
        "body": "{\n\t\tvar methodInfo = typeof(ClassUnderTest).GetMethod(nameof(ClassUnderTest.TheoryWithTypeArgument))!;\n\t\tvar closedMethodInfo = methodInfo.MakeGenericMethod(typeof(string));\n\t\tvar testClass = TestData.XunitTestClass<ClassUnderTest>();\n\t\tvar testMethod = new XunitTestMethod(testClass, closedMethodInfo, [\"data\"]);\n\n\t\tvar serialized = SerializationHelper.Instance.Serialize(testMethod);\n\t\tvar deserialized = SerializationHelper.Instance.Deserialize(serialized);\n\n\t\tAssert.IsType<XunitTestMethod>(deserialized);\n\t\tAssert.Equivalent(testMethod, deserialized);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "RecordTests.cs",
    "methods": [
      {
        "name": "Exception",
        "body": "{\n\t\t\t\tException ex = Record.Exception(delegate { throw new InvalidOperationException(); });\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      },
      {
        "name": "NoException",
        "body": "{\n\t\t\t\tException ex = Record.Exception(delegate { });\n\n\t\t\t\tAssert.Null(ex);\n\t\t\t}"
      },
      {
        "name": "Exception",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\tException ex = Record.Exception(() => accessor.FailingProperty);\n\n\t\t\t\tAssert.NotNull(ex);\n\t\t\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\t\t}"
      },
      {
        "name": "NoException",
        "body": "{\n\t\t\t\tStubAccessor accessor = new StubAccessor();\n\n\t\t\t\tException ex = Record.Exception(() => accessor.SuccessfulProperty);\n\n\t\t\t\tAssert.Null(ex);\n\t\t\t}"
      }
    ]
  },
  {
    "file": "ExecutionErrorTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar testCase = Mocks.ExecutionErrorTestCase(\"This is my error message\");\n\t\tvar runner = new ExecutionErrorTestCaseRunner(testCase, messageBus, aggregator, tokenSource);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(0m, result.Time);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);\n\t\t\t\tAssert.Same(testCase, testCaseStarting.TestCase);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);\n\t\t\t\tAssert.Same(testCase, testStarting.TestCase);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, failed.TestCollection);\n\t\t\t\tAssert.Same(testCase, failed.TestCase);\n\t\t\t\tAssert.Equal(0m, failed.ExecutionTime);\n\t\t\t\tAssert.Empty(failed.Output);\n\t\t\t\tvar exceptionType = Assert.Single(failed.ExceptionTypes);\n\t\t\t\tAssert.Equal(\"System.InvalidOperationException\", exceptionType);\n\t\t\t\tvar type = Assert.Single(failed.Messages);\n\t\t\t\tAssert.Equal(\"This is my error message\", type);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);\n\t\t\t\tAssert.Same(testCase, testFinished.TestCase);\n\t\t\t\tAssert.Equal(0m, testFinished.ExecutionTime);\n\t\t\t\tAssert.Empty(testFinished.Output);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);\n\t\t\t\tAssert.Same(testCase, testCaseFinished.TestCase);\n\t\t\t\tAssert.Equal(0m, testCaseFinished.ExecutionTime);\n\t\t\t\tAssert.Equal(1, testCaseFinished.TestsRun);\n\t\t\t\tAssert.Equal(1, testCaseFinished.TestsFailed);\n\t\t\t\tAssert.Equal(0, testCaseFinished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "TestAssemblyRunnerContextTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait using var ctxt = TestableTestAssemblyRunnerContext.Create();\n\n\t\t\tvar ex = Record.Exception(() => ctxt.MessageBus);\n\n\t\t\tvar upex = Assert.IsType<UnsetPropertyException>(ex);\n\t\t\tAssert.Equal(nameof(TestableTestAssemblyRunnerContext.MessageBus), upex.PropertyName);\n\t\t\tAssert.Equal(typeof(TestableTestAssemblyRunnerContext).FullName, upex.TypeName);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tawait using var ctxt = TestableTestAssemblyRunnerContext.Create();\n\t\t\tawait ctxt.InitializeAsync();\n\n\t\t\tvar result = ctxt.MessageBus;\n\n\t\t\tAssert.IsType<MessageBus>(result);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\t\t\texecutionOptions.SetSynchronousMessageReporting(true);\n\t\t\tawait using var ctxt = TestableTestAssemblyRunnerContext.Create(executionOptions);\n\t\t\tawait ctxt.InitializeAsync();\n\n\t\t\tvar result = ctxt.MessageBus;\n\n\t\t\tAssert.IsType<SynchronousMessageBus>(result);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "DefaultMessageBus",
        "body": "{\n\t\t\tvar runner = TestableTestAssemblyRunner.Create();\n\n\t\t\tvar messageBus = runner.CreateMessageBus_Public();\n\n\t\t\tAssert.IsType<MessageBus>(messageBus);\n\t\t}"
      },
      {
        "name": "SyncMessageBusOption",
        "body": "{\n\t\t\tvar executionOptions = TestFrameworkOptions.ForExecution();\n\t\t\texecutionOptions.SetSynchronousMessageReporting(true);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(executionOptions: executionOptions);\n\n\t\t\tvar messageBus = runner.CreateMessageBus_Public();\n\n\t\t\tAssert.IsType<SynchronousMessageBus>(messageBus);\n\t\t}"
      },
      {
        "name": "Messages",
        "body": "{\n\t\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = SpyMessageSink.Create(messages: messages);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink, summary);\n\t\t\tvar thisAssembly = Assembly.GetExecutingAssembly();\n\t\t\tvar thisAppDomain = AppDomain.CurrentDomain;\n\n\t\t\tvar result = await runner.RunAsync();\n\n\t\t\tAssert.Equal(4, result.Total);\n\t\t\tAssert.Equal(2, result.Failed);\n\t\t\tAssert.Equal(1, result.Skipped);\n\t\t\tAssert.NotEqual(21.12m, result.Time);  // Uses clock time, not result time\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestAssemblyStarting>(msg);\n#if NETFRAMEWORK\n\t\t\t\t\tAssert.Equal(thisAssembly.GetLocalCodeBase(), starting.TestAssembly.Assembly.AssemblyPath);\n\t\t\t\t\tAssert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, starting.TestAssembly.ConfigFileName);\n#endif\n\t\t\t\t\tAssert.InRange(starting.StartTime, DateTime.Now.AddMinutes(-15), DateTime.Now);\n\t\t\t\t\tAssert.Equal(\"The test framework environment\", starting.TestEnvironment);\n\t\t\t\t\tAssert.Equal(\"The test framework display name\", starting.TestFrameworkDisplayName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(msg);\n\t\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t\t\tAssert.Equal(result.Time, finished.ExecutionTime);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailureInQueueOfTestAssemblyStarting_DoesNotQueueTestAssemblyFinished_DoesNotRunTestCollections",
        "body": "{\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = Substitute.For<IMessageSink>();\n\t\t\tmessageSink.OnMessage(null)\n\t\t\t\t\t   .ReturnsForAnyArgs(callInfo =>\n\t\t\t\t\t   {\n\t\t\t\t\t\t   var msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\t\t\t   messages.Add(msg);\n\n\t\t\t\t\t\t   if (msg is ITestAssemblyStarting)\n\t\t\t\t\t\t\t   throw new InvalidOperationException();\n\n\t\t\t\t\t\t   return true;\n\t\t\t\t\t   });\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\n\t\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\t\tvar starting = Assert.Single(messages);\n\t\t\tAssert.IsAssignableFrom<ITestAssemblyStarting>(starting);\n\t\t\tAssert.Empty(runner.CollectionsRun);\n\t\t}"
      },
      {
        "name": "FailureInAfterTestAssemblyStarting_GivesErroredAggregatorToTestCollectionRunner_NoCleanupFailureMessage",
        "body": "{\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = SpyMessageSink.Create(messages: messages);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\t\t\tvar ex = new DivideByZeroException();\n\t\t\trunner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Same(ex, runner.RunTestCollectionAsync_AggregatorResult);\n\t\t\tAssert.Empty(messages.OfType<ITestAssemblyCleanupFailure>());\n\t\t}"
      },
      {
        "name": "FailureInBeforeTestAssemblyFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestAssemblyStarting",
        "body": "{\n\t\t\tvar thisAssembly = Assembly.GetExecutingAssembly();\n\t\t\tvar thisAppDomain = AppDomain.CurrentDomain;\n\t\t\tvar messages = new List<IMessageSinkMessage>();\n\t\t\tvar messageSink = SpyMessageSink.Create(messages: messages);\n\t\t\tvar testCases = new[] { Mocks.TestCase() };\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink, testCases: testCases);\n\t\t\tvar startingException = new DivideByZeroException();\n\t\t\tvar finishedException = new InvalidOperationException();\n\t\t\trunner.AfterTestAssemblyStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\t\trunner.BeforeTestAssemblyFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar cleanupFailure = Assert.Single(messages.OfType<ITestAssemblyCleanupFailure>());\n#if NETFRAMEWORK\n\t\t\tAssert.Equal(thisAssembly.GetLocalCodeBase(), cleanupFailure.TestAssembly.Assembly.AssemblyPath);\n\t\t\tAssert.Equal(thisAppDomain.SetupInformation.ConfigurationFile, cleanupFailure.TestAssembly.ConfigFileName);\n#endif\n\t\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "Cancellation_TestAssemblyStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{\n\t\t\tvar messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyStarting));\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.False(runner.AfterTestAssemblyStarting_Called);\n\t\t\tAssert.False(runner.BeforeTestAssemblyFinished_Called);\n\t\t}"
      },
      {
        "name": "Cancellation_TestAssemblyFinished_CallsCallExtensibilityCallbacks",
        "body": "{\n\t\t\tvar messageSink = SpyMessageSink.Create(msg => !(msg is ITestAssemblyFinished));\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(messageSink);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.True(runner.AfterTestAssemblyStarting_Called);\n\t\t\tAssert.True(runner.BeforeTestAssemblyFinished_Called);\n\t\t}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{\n\t\t\tvar collection1 = Mocks.TestCollection(displayName: \"1\");\n\t\t\tvar testCase1a = Mocks.TestCase(collection1);\n\t\t\tvar testCase1b = Mocks.TestCase(collection1);\n\t\t\tvar collection2 = Mocks.TestCollection(displayName: \"2\");\n\t\t\tvar testCase2a = Mocks.TestCase(collection2);\n\t\t\tvar testCase2b = Mocks.TestCase(collection2);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1a, testCase2a, testCase2b, testCase1b });\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(runner.CollectionsRun.OrderBy(c => c.Item1.DisplayName),\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Same(collection1, tuple.Item1);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(testCase1a, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(testCase1b, testCase)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Same(collection2, tuple.Item1);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(testCase2a, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(testCase2b, testCase)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningCollections",
        "body": "{\n\t\t\tvar collection1 = Mocks.TestCollection();\n\t\t\tvar testCase1 = Mocks.TestCase(collection1);\n\t\t\tvar collection2 = Mocks.TestCollection();\n\t\t\tvar testCase2 = Mocks.TestCase(collection2);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(testCases: new[] { testCase1, testCase2 }, cancelInRunTestCollectionAsync: true);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Single(runner.CollectionsRun);\n\t\t}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{\n\t\t\tvar runner = TestableTestAssemblyRunner.Create();\n\n\t\t\tAssert.IsType<DefaultTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "DefaultTestCaseOrderer",
        "body": "{\n\t\t\tvar runner = TestableTestAssemblyRunner.Create();\n\n\t\t\tAssert.IsType<DefaultTestCollectionOrderer>(runner.TestCollectionOrderer);\n\t\t}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar collection1 = Mocks.TestCollection(displayName: \"AAA\");\n\t\t\tvar testCase1 = Mocks.TestCase(collection1);\n\t\t\tvar collection2 = Mocks.TestCollection(displayName: \"ZZZZ\");\n\t\t\tvar testCase2 = Mocks.TestCase(collection2);\n\t\t\tvar collection3 = Mocks.TestCollection(displayName: \"MM\");\n\t\t\tvar testCase3 = Mocks.TestCase(collection3);\n\t\t\tvar testCases = new[] { testCase1, testCase2, testCase3 };\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableTestAssemblyRunner.Create(testCases: testCases, executionMessageSink: executionSink);\n\t\t\trunner.TestCollectionOrderer = new ThrowingOrderer();\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Test collection orderer 'TestAssemblyRunnerTests+TestCollectionOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.CollectionsRun);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus, result: summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Same(result, summary);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseStarting.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testCaseStarting.TestCase);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testCaseFinished.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testCaseFinished.TestCase);\n\t\t\t\tAssert.Equal(21.12m, testCaseFinished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, testCaseFinished.TestsRun);\n\t\t\t\tAssert.Equal(2, testCaseFinished.TestsFailed);\n\t\t\t\tAssert.Equal(1, testCaseFinished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestCaseStarting_DoesNotQueueTestCaseFinished_DoesNotRunTests",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestCaseStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestCaseStarting>(starting);\n\t\tAssert.False(runner.RunTestAsync_Called);\n\t}"
      },
      {
        "name": "RunTestAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestCaseStarting_GivesErroredAggregatorToTestRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCaseCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestCaseFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCaseStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus, testCase);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestCaseStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCaseCleanupFailure>());\n\t\tAssert.Same(testCase, cleanupFailure.TestCase);\n\t\tAssert.Equal(new[] { testCase }, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestCaseStarting_DoesNotCallExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCaseStarting));\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.False(runner.AfterTestCaseStarting_Called);\n\t\tAssert.False(runner.BeforeTestCaseFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCaseFinished_CallsExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCaseFinished));\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.AfterTestCaseStarting_Called);\n\t\tAssert.True(runner.BeforeTestCaseFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCaseCleanupFailure));\n\t\tvar runner = TestableTestCaseRunner.Create(messageBus);\n\t\trunner.BeforeTestCaseFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      }
    ]
  },
  {
    "file": "TestClassRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableTestClassRunner.Create(messageBus, new[] { testCase }, result: summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(result.Total, summary.Total);\n\t\tAssert.Equal(result.Failed, summary.Failed);\n\t\tAssert.Equal(result.Skipped, summary.Skipped);\n\t\tAssert.Equal(result.Time, summary.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestClassStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Equal(\"TestClassRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestClassFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Equal(\"TestClassRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);\n\t\t\t\tAssert.Equal(21.12m, finished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestClassStarting_DoesNotQueueTestClassFinished_DoesNotRunTestMethods",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus.QueueMessage(null)\n\t\t\t\t  .ReturnsForAnyArgs(callInfo =>\n\t\t\t\t  {\n\t\t\t\t\t  var msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\t\t  messages.Add(msg);\n\n\t\t\t\t\t  if (msg is ITestClassStarting)\n\t\t\t\t\t\t  throw new InvalidOperationException();\n\n\t\t\t\t\t  return true;\n\t\t\t\t  });\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestClassStarting>(starting);\n\t\tAssert.Empty(runner.MethodsRun);\n\t}"
      },
      {
        "name": "RunTestMethodAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestClassRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestClassStarting_GivesErroredAggregatorToTestMethodRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestClassCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestClassFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestClassStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };\n\t\tvar runner = TestableTestClassRunner.Create(messageBus, testCases);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestClassStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestClassCleanupFailure>());\n\t\tAssert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);\n\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestClassStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestClassStarting));\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestClassStarting_Called);\n\t\tAssert.False(runner.BeforeTestClassFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestClassFinished_CallsExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestClassFinished));\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.True(runner.AfterTestClassStarting_Called);\n\t\tAssert.True(runner.BeforeTestClassFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestClassCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestClassCleanupFailure));\n\t\tvar runner = TestableTestClassRunner.Create(messageBus);\n\t\trunner.BeforeTestClassFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      },
      {
        "name": "TestsAreGroupedByMethod",
        "body": "{\n\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, other2, passing2 });\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.MethodsRun,\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Passing\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(passing1, testCase),\n\t\t\t\t\ttestCase => Assert.Same(passing2, testCase)\n\t\t\t\t);\n\t\t\t},\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"Other\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(other1, testCase),\n\t\t\t\t\ttestCase => Assert.Same(other2, testCase)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{\n\t\tvar passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { passing, other }, cancelInRunTestMethodAsync: true);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tuple = Assert.Single(runner.MethodsRun);\n\t\tAssert.Equal(\"Passing\", tuple.Item1.Name);\n\t}"
      },
      {
        "name": "TestsOrdererIsUsedToDetermineRunOrder",
        "body": "{\n\t\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { passing1, other1, passing2, other2 }, orderer: new MockTestCaseOrderer(reverse: true));\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(runner.MethodsRun,\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Other\", tuple.Item1.Name);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(other2, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(other1, testCase)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\ttuple =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Passing\", tuple.Item1.Name);\n\t\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\t\ttestCase => Assert.Same(passing2, testCase),\n\t\t\t\t\t\ttestCase => Assert.Same(passing1, testCase)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ThrowsWhileOrdering_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar passing2 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar other2 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar runner = TestableTestClassRunner.Create(messageBus, [passing1, other1, passing2, other2], new ThrowingOrderer());\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar errorMessage = Assert.Single(messageBus.Messages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Test case orderer 'TestClassRunnerTests+TestCaseOrderer+ThrowingOrderer' threw 'System.DivideByZeroException' during ordering: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.MethodsRun);\n\t\t}"
      },
      {
        "name": "TestClassMustHaveParameterlessConstructor",
        "body": "{\n\t\tvar test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { test });\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"A test class must have a parameterless constructor.\", tcex.Message);\n\t}"
      },
      {
        "name": "ConstructorWithMissingArguments",
        "body": "{\n\t\tvar test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");\n\t\tvar constructor = typeof(ClassWithConstructor).GetConstructors().Single();\n\t\tvar args = new object[] { \"Hello, world!\" };\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tcex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"The following constructor parameters did not have matching arguments: Int32 x, Decimal z\", tcex.Message);\n\t}"
      },
      {
        "name": "ConstructorWithMatchingArguments",
        "body": "{\n\t\tvar test = Mocks.TestCase<ClassWithConstructor>(\"Passing\");\n\t\tvar constructor = typeof(ClassWithConstructor).GetConstructors().Single();\n\t\tvar args = new object[] { \"Hello, world!\", 21.12m, 42, DateTime.Now };\n\t\tvar runner = TestableTestClassRunner.Create(testCases: new[] { test }, constructor: constructor, availableArguments: args);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tuple = Assert.Single(runner.MethodsRun);\n\t\tAssert.Collection(tuple.Item3,\n\t\t\targ => Assert.Equal(42, arg),\n\t\t\targ => Assert.Equal(\"Hello, world!\", arg),\n\t\t\targ => Assert.Equal(21.12m, arg)\n\t\t);\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus, new[] { testCase }, summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(result.Total, summary.Total);\n\t\tAssert.Equal(result.Failed, summary.Failed);\n\t\tAssert.Equal(result.Skipped, summary.Skipped);\n\t\tAssert.Equal(result.Time, summary.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestCollectionStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestCollectionFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Equal(21.12m, finished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestCollectionStarting_DoesNotQueueTestCollectionFinished_DoesNotRunTestClasses",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestCollectionStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestCollectionStarting>(starting);\n\t\tAssert.Empty(runner.ClassesRun);\n\t}"
      },
      {
        "name": "RunTestClassAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestCollectionStarting_GivesErroredAggregatorToTestClassRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestCollectionFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestCollectionStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus, testCases);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestCollectionStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCollectionCleanupFailure>());\n\t\tAssert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);\n\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestCollectionStarting_DoesNotCallExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionStarting));\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestCollectionStarting_Called);\n\t\tAssert.False(runner.BeforeTestCollectionFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCollectionFinished_CallsExtensibilityCallbacks",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionFinished));\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.True(runner.AfterTestCollectionStarting_Called);\n\t\tAssert.True(runner.BeforeTestCollectionFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCollectionCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCollectionCleanupFailure));\n\t\tvar runner = TestableTestCollectionRunner.Create(messageBus);\n\t\trunner.BeforeTestCollectionFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      },
      {
        "name": "TestsAreGroupedByCollection",
        "body": "{\n\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other1 = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");\n\t\tvar other2 = Mocks.TestCase<ClassUnderTest2>(\"Other\");\n\t\tvar runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2, other2, other1 });\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.ClassesRun,\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(passing1, testCase),\n\t\t\t\t\ttestCase => Assert.Same(other1, testCase)\n\t\t\t\t);\n\t\t\t},\n\t\t\ttuple =>\n\t\t\t{\n\t\t\t\tAssert.Equal(\"TestCollectionRunnerTests+ClassUnderTest2\", tuple.Item1.Name);\n\t\t\t\tAssert.Collection(tuple.Item2,\n\t\t\t\t\ttestCase => Assert.Same(passing2, testCase),\n\t\t\t\t\ttestCase => Assert.Same(other2, testCase)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningClasses",
        "body": "{\n\t\tvar passing1 = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar passing2 = Mocks.TestCase<ClassUnderTest2>(\"Passing\");\n\t\tvar runner = TestableTestCollectionRunner.Create(testCases: new[] { passing1, passing2 }, cancelInRunTestClassAsync: true);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar tuple = Assert.Single(runner.ClassesRun);\n\t\tAssert.Equal(\"TestCollectionRunnerTests+ClassUnderTest\", tuple.Item1.Name);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestInvokerTests.cs",
    "methods": [
      {
        "name": "Messages_StaticTestMethod",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"StaticPassing\", messageBus);\n\n\t\tawait invoker.RunAsync();\n\n\t\tAssert.Empty(messageBus.Messages);\n\t\tAssert.True(invoker.BeforeTestMethodInvoked_Called);\n\t\tAssert.True(invoker.AfterTestMethodInvoked_Called);\n\t}"
      },
      {
        "name": "Messages_NonStaticTestMethod_NoDispose",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, \"Display Name\");\n\n\t\tawait invoker.RunAsync();\n\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, starting.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", starting.Test.DisplayName);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, finished.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", finished.Test.DisplayName);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "Messages_NonStaticTestMethod_WithDispose",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<DisposableClass>(\"Passing\", messageBus, \"Display Name\");\n\n\t\tawait invoker.RunAsync();\n\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, starting.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", starting.Test.DisplayName);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg);\n\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Same(invoker.TestCase, finished.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", finished.Test.DisplayName);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus);\n\n\t\tvar result = await invoker.RunAsync();\n\n\t\tAssert.NotEqual(0m, result);\n\t\tAssert.Null(invoker.Aggregator.ToException());\n\t}"
      },
      {
        "name": "Failing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);\n\n\t\tvar result = await invoker.RunAsync();\n\n\t\tAssert.NotEqual(0m, result);\n\t\tAssert.IsType<TrueException>(invoker.Aggregator.ToException());\n\t}"
      },
      {
        "name": "TooManyParameterValues",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Passing\", messageBus, testMethodArguments: new object[] { 42 });\n\n\t\tawait invoker.RunAsync();\n\n\t\tvar ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());\n\t\tAssert.Equal(\"The test method expected 0 parameter values, but 1 parameter value was provided.\", ex.Message);\n\t}"
      },
      {
        "name": "NotEnoughParameterValues",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"FactWithParameter\", messageBus);\n\n\t\tawait invoker.RunAsync();\n\n\t\tvar ex = Assert.IsType<InvalidOperationException>(invoker.Aggregator.ToException());\n\t\tAssert.Equal(\"The test method expected 1 parameter value, but 0 parameter values were provided.\", ex.Message);\n\t}"
      },
      {
        "name": "CancellationRequested_DoesNotInvokeTestMethod",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar invoker = TestableTestInvoker.Create<NonDisposableClass>(\"Failing\", messageBus);\n\t\tinvoker.TokenSource.Cancel();\n\n\t\tvar result = await invoker.RunAsync();\n\n\t\tAssert.Equal(0m, result);\n\t\tAssert.Null(invoker.Aggregator.ToException());\n\t\tAssert.False(invoker.BeforeTestMethodInvoked_Called);\n\t\tAssert.False(invoker.AfterTestMethodInvoked_Called);\n\t}"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "{\n\t\t\tAssert.True(false);\n\t\t}"
      },
      {
        "name": "FactWithParameter",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestMethodRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar summary = new RunSummary { Total = 4, Failed = 2, Skipped = 1, Time = 21.12m };\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus, new[] { testCase }, result: summary);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(result.Total, summary.Total);\n\t\tAssert.Equal(result.Failed, summary.Failed);\n\t\tAssert.Equal(result.Skipped, summary.Skipped);\n\t\tAssert.Equal(result.Time, summary.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestMethodStarting>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, starting.TestCollection);\n\t\t\t\tAssert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", starting.TestClass.Class.Name);\n\t\t\t\tAssert.Equal(\"Passing\", starting.TestMethod.Method.Name);\n\t\t\t},\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestMethodFinished>(msg);\n\t\t\t\tAssert.Same(testCase.TestMethod.TestClass.TestCollection, finished.TestCollection);\n\t\t\t\tAssert.Equal(\"TestMethodRunnerTests+ClassUnderTest\", finished.TestClass.Class.Name);\n\t\t\t\tAssert.Equal(\"Passing\", finished.TestMethod.Method.Name);\n\t\t\t\tAssert.Equal(21.12m, finished.ExecutionTime);\n\t\t\t\tAssert.Equal(4, finished.TestsRun);\n\t\t\t\tAssert.Equal(2, finished.TestsFailed);\n\t\t\t\tAssert.Equal(1, finished.TestsSkipped);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestMethodStarting_DoesNotQueueTestMethodFinished_DoesNotRunTestCases",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestMethodStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestMethodStarting>(starting);\n\t\tAssert.Empty(runner.TestCasesRun);\n\t}"
      },
      {
        "name": "RunTestCaseAsync_AggregatorIncludesPassedInExceptions",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestMethodStarting_GivesErroredAggregatorToTestCaseRunner_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Same(ex, runner.RunTestCaseAsync_AggregatorResult);\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestMethodCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestMethodFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestMethodStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCases = new[] { Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\") };\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus, testCases);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestMethodStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestMethodCleanupFailure>());\n\t\tAssert.Same(testCases[0].TestMethod.TestClass.TestCollection, cleanupFailure.TestCollection);\n\t\tAssert.Equal(testCases, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestMethodStarting_DoesNotCallExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestMethodStarting));\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestMethodStarting_Called);\n\t\tAssert.False(runner.BeforeTestMethodFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestMethodFinished_CallsExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestMethodFinished));\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.True(runner.AfterTestMethodStarting_Called);\n\t\tAssert.True(runner.BeforeTestMethodFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestMethodCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestMethodCleanupFailure));\n\t\tvar runner = TestableTestMethodRunner.Create(messageBus);\n\t\trunner.BeforeTestMethodFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      },
      {
        "name": "SignalingCancellationStopsRunningMethods",
        "body": "{\n\t\tvar passing = Mocks.TestCase<ClassUnderTest>(\"Passing\");\n\t\tvar other = Mocks.TestCase<ClassUnderTest>(\"Other\");\n\t\tvar runner = TestableTestMethodRunner.Create(testCases: new[] { passing, other }, cancelInRunTestCaseAsync: true);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar testCase = Assert.Single(runner.TestCasesRun);\n\t\tAssert.Same(passing, testCase);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Other",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "TestRunnerTests.cs",
    "methods": [
      {
        "name": "Messages",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\tAssert.Equal(21.12m, result.Time);\n\t\tAssert.False(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.Collection(messageBus.Messages,\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testStarting = Assert.IsAssignableFrom<ITestStarting>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testStarting.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testStarting.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", testStarting.Test.DisplayName);\n\t\t\t},\n\t\t\tmsg => { },  // Pass/fail/skip, will be tested elsewhere\n\t\t\tmsg =>\n\t\t\t{\n\t\t\t\tvar testFinished = Assert.IsAssignableFrom<ITestFinished>(msg);\n\t\t\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, testFinished.TestCollection);\n\t\t\t\tAssert.Same(runner.TestCase, testFinished.TestCase);\n\t\t\t\tAssert.Equal(\"Display Name\", testFinished.Test.DisplayName);\n\t\t\t\tAssert.Equal(21.12m, testFinished.ExecutionTime);\n\t\t\t\tAssert.Empty(testFinished.Output);\n\t\t\t}\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m);\n\n\t\tvar result = await runner.RunAsync();\n\n\t\t// Direct run summary\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(0, result.Failed);\n\t\tAssert.Equal(0, result.Skipped);\n\t\tAssert.Equal(21.12m, result.Time);\n\t\t// Pass message\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, passed.TestCollection);\n\t\tAssert.Same(runner.TestCase, passed.TestCase);\n\t\tAssert.Equal(\"Display Name\", passed.Test.DisplayName);\n\t\tAssert.Equal(21.12m, passed.ExecutionTime);\n\t\tAssert.Empty(passed.Output);\n\t}"
      },
      {
        "name": "Failing",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", runTime: 21.12m, lambda: () => Assert.True(false));\n\n\t\tvar result = await runner.RunAsync();\n\n\t\t// Direct run summary\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(1, result.Failed);\n\t\tAssert.Equal(0, result.Skipped);\n\t\tAssert.Equal(21.12m, result.Time);\n\t\t// Fail message\n\t\tvar failed = messageBus.Messages.OfType<ITestFailed>().Single();\n\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);\n\t\tAssert.Same(runner.TestCase, failed.TestCase);\n\t\tAssert.Equal(\"Display Name\", failed.Test.DisplayName);\n\t\tAssert.Equal(21.12m, failed.ExecutionTime);\n\t\tAssert.Empty(failed.Output);\n\t\tAssert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Skipping",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, displayName: \"Display Name\", skipReason: \"Please don't run me\", runTime: 21.12m, lambda: () => Assert.True(false));\n\n\t\tvar result = await runner.RunAsync();\n\n\t\t// Direct run summary\n\t\tAssert.Equal(1, result.Total);\n\t\tAssert.Equal(0, result.Failed);\n\t\tAssert.Equal(1, result.Skipped);\n\t\tAssert.Equal(0m, result.Time);\n\t\t// Skip message\n\t\tvar failed = messageBus.Messages.OfType<ITestSkipped>().Single();\n\t\tAssert.Same(runner.TestCase.TestMethod.TestClass.TestCollection, failed.TestCollection);\n\t\tAssert.Same(runner.TestCase, failed.TestCase);\n\t\tAssert.Equal(\"Display Name\", failed.Test.DisplayName);\n\t\tAssert.Equal(0m, failed.ExecutionTime);\n\t\tAssert.Empty(failed.Output);\n\t\tAssert.Equal(\"Please don't run me\", failed.Reason);\n\t}"
      },
      {
        "name": "Output",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus, output: \"This is my text output\");\n\n\t\tawait runner.RunAsync();\n\n\t\tvar passed = messageBus.Messages.OfType<ITestPassed>().Single();\n\t\tAssert.Equal(\"This is my text output\", passed.Output);\n\t}"
      },
      {
        "name": "FailureInQueueOfTestStarting_DoesNotQueueTestFinished_DoesNotInvokeTest",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar messageBus = Substitute.For<IMessageBus>();\n\t\tmessageBus\n\t\t\t.QueueMessage(null)\n\t\t\t.ReturnsForAnyArgs(callInfo =>\n\t\t\t{\n\t\t\t\tvar msg = callInfo.Arg<IMessageSinkMessage>();\n\t\t\t\tmessages.Add(msg);\n\n\t\t\t\tif (msg is ITestStarting)\n\t\t\t\t\tthrow new InvalidOperationException();\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\n\t\tawait Assert.ThrowsAsync<InvalidOperationException>(() => runner.RunAsync());\n\n\t\tvar starting = Assert.Single(messages);\n\t\tAssert.IsAssignableFrom<ITestStarting>(starting);\n\t\tAssert.False(runner.InvokeTestAsync_Called);\n\t}"
      },
      {
        "name": "WithPreSeededException_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar ex = new DivideByZeroException();\n\t\tvar runner = TestableTestRunner.Create(messageBus, aggregatorSeedException: ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInAfterTestStarting_ReturnsTestFailed_NoCleanupFailureMessage",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\t\tvar ex = new DivideByZeroException();\n\t\trunner.AfterTestStarting_Callback = aggregator => aggregator.Add(ex);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar failed = Assert.Single(messageBus.Messages.OfType<ITestFailed>());\n\t\tAssert.Equal(typeof(DivideByZeroException).FullName, failed.ExceptionTypes.Single());\n\t\tAssert.Empty(messageBus.Messages.OfType<ITestCleanupFailure>());\n\t}"
      },
      {
        "name": "FailureInBeforeTestFinished_ReportsCleanupFailure_DoesNotIncludeExceptionsFromAfterTestStarting",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus();\n\t\tvar testCase = Mocks.TestCase<TestAssemblyRunnerTests.RunAsync>(\"Messages\");\n\t\tvar runner = TestableTestRunner.Create(messageBus, testCase);\n\t\tvar startingException = new DivideByZeroException();\n\t\tvar finishedException = new InvalidOperationException();\n\t\trunner.AfterTestStarting_Callback = aggregator => aggregator.Add(startingException);\n\t\trunner.BeforeTestFinished_Callback = aggregator => aggregator.Add(finishedException);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar cleanupFailure = Assert.Single(messageBus.Messages.OfType<ITestCleanupFailure>());\n\t\tAssert.Same(testCase, cleanupFailure.TestCase);\n\t\tAssert.Equal(new[] { testCase }, cleanupFailure.TestCases);\n\t\tAssert.Equal(typeof(InvalidOperationException).FullName, cleanupFailure.ExceptionTypes.Single());\n\t}"
      },
      {
        "name": "Cancellation_TestStarting_DoesNotCallExtensibilityMethods",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestStarting));\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t\tAssert.False(runner.AfterTestStarting_Called);\n\t\tAssert.False(runner.BeforeTestFinished_Called);\n\t}"
      },
      {
        "name": "Cancellation_TestCleanupFailure_SetsCancellationToken",
        "body": "{\n\t\tvar messageBus = new SpyMessageBus(msg => !(msg is ITestCleanupFailure));\n\t\tvar runner = TestableTestRunner.Create(messageBus);\n\t\trunner.BeforeTestFinished_Callback = aggregator => aggregator.Add(new Exception());\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(runner.TokenSource.IsCancellationRequested);\n\t}"
      }
    ]
  },
  {
    "file": "XunitDelayEnumeratedTheoryTestCaseRunnerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithData));\n\t\tvar runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };\n\n\t\tvar summary = await runner.RunAsync();\n\n\t\tAssert.NotEqual(0m, summary.Time);\n\t\tAssert.Equal(2, summary.Total);\n\t\tAssert.Equal(1, summary.Failed);\n\t\tvar messages = runner.MessageBus.Messages;\n\t\tvar passed = messages.OfType<ITestPassed>().Single();\n\t\tvar passedStarting = messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == passed.TestUniqueID);\n\t\tAssert.Equal($\"Display Name(x: 42, _1: {21.12:G17}, _2: \\\"Hello\\\")\", passedStarting.TestDisplayName);\n\t\tvar failed = messages.OfType<ITestFailed>().Single();\n\t\tvar failedStarting = messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID);\n\t\tAssert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"World!\\\")\", failedStarting.TestDisplayName);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithThrowingData));\n\t\tvar runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };\n\n\t\tvar summary = await runner.RunAsync();\n\n\t\tAssert.Equal(0m, summary.Time);\n\t\tAssert.Equal(1, summary.Total);\n\t\tAssert.Equal(1, summary.Failed);\n\t\tvar messages = runner.MessageBus.Messages;\n\t\tvar failed = messages.OfType<ITestFailed>().Single();\n\t\tvar failedStarting = messages.OfType<ITestStarting>().Single(ts => ts.TestUniqueID == failed.TestUniqueID);\n\t\tAssert.Equal(\"Display Name\", failedStarting.TestDisplayName);\n\t\tAssert.Equal(typeof(DivideByZeroException).SafeName(), failed.ExceptionTypes.Single());\n\t\tAssert.Equal(\"Attempted to divide by zero.\", failed.Messages.Single());\n\t\tAssert.Contains($\"{nameof(ClassUnderTest)}.get_{nameof(ClassUnderTest.ThrowingData)}\", failed.StackTraces.Single());\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tClassUnderTest.DataWasDisposed = false;\n\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithDisposableData));\n\t\tvar runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.True(ClassUnderTest.DataWasDisposed);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.TestWithSomeDataSkipped));\n\t\tvar runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };\n\n\t\tvar summary = await runner.RunAsync();\n\n\t\tvar messages = runner.MessageBus.Messages;\n\t\tAssert.NotEqual(0m, summary.Time);\n\t\tAssert.Equal(6, summary.Total);\n\t\tAssert.Equal(3, summary.Skipped);\n\t\tAssert.Equal(2, summary.Failed);\n\t\tAssert.Collection(\n\t\t\tmessages.OfType<ITestPassed>().Select(p => messages.OfType<ITestStarting>().Single(s => s.TestUniqueID == p.TestUniqueID).TestDisplayName).OrderBy(x => x),\n\t\t\tdisplayName => Assert.Equal($\"Display Name(x: 1, _1: {2.1:G17}, _2: \\\"not skipped\\\")\", displayName)\n\t\t);\n\t\tAssert.Collection(\n\t\t\tmessages.OfType<ITestFailed>().Select(p => messages.OfType<ITestStarting>().Single(s => s.TestUniqueID == p.TestUniqueID).TestDisplayName).OrderBy(x => x),\n\t\t\tdisplayName => Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"also not skipped\\\")\", displayName),\n\t\t\tdisplayName => Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"SomeData2 not skipped\\\")\", displayName)\n\t\t);\n\t\tAssert.Collection(\n\t\t\tmessages.OfType<ITestSkipped>().Select(p => messages.OfType<ITestStarting>().Single(s => s.TestUniqueID == p.TestUniqueID).TestDisplayName).OrderBy(x => x),\n\t\t\tdisplayName => Assert.Equal(\"Display Name(x: 0, _1: 0, _2: \\\"World!\\\")\", displayName),\n\t\t\tdisplayName => Assert.Equal($\"Display Name(x: 18, _1: {36.48:G17}, _2: \\\"SomeData2 skipped\\\")\", displayName),\n\t\t\tdisplayName => Assert.Equal($\"Display Name(x: 42, _1: {21.12:G17}, _2: \\\"Hello\\\")\", displayName)\n\t\t);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar testCase = TestData.XunitTestCase<ClassWithThrowingToString>(nameof(ClassWithThrowingToString.Test));\n\t\tvar runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };\n\n\t\tawait runner.RunAsync();\n\n\t\tvar passed = runner.MessageBus.Messages.OfType<ITestPassed>().Single();\n\t\tvar passedStarting = runner.MessageBus.Messages.OfType<ITestStarting>().Where(ts => ts.TestUniqueID == passed.TestUniqueID).Single();\n\t\tAssert.Equal(\"Display Name(c: TargetInvocationException was thrown formatting an object of type \\\"XunitDelayEnumeratedTheoryTestCaseRunnerTests+ClassWithThrowingToString\\\")\", passedStarting.TestDisplayName);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar testCase = TestData.XunitTestCase<ClassWithThrowingEnumerator>(nameof(ClassWithThrowingEnumerator.Test));\n\t\tvar runner = new TestableXunitDelayEnumeratedTheoryTestCaseRunner(testCase) { DisplayName = \"Display Name\" };\n\n\t\tvar summary = await runner.RunAsync();\n\t\tvar passed = runner.MessageBus.Messages.OfType<ITestPassed>().Single();\n\t\tvar passedStarting = runner.MessageBus.Messages.OfType<ITestStarting>().Where(ts => ts.TestUniqueID == passed.TestUniqueID).Single();\n\t\tAssert.Equal(\"Display Name(_: [ClassWithThrowingEnumerator { }])\", passedStarting.TestDisplayName);\n\t}"
      }
    ]
  },
  {
    "file": "XunitTestAssemblyRunnerTests.cs",
    "methods": [
      {
        "name": "IsXunit",
        "body": "{\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create();\n\n\t\t\tvar result = runner.GetTestFrameworkDisplayName();\n\n\t\t\tAssert.StartsWith(\"xUnit.net \", result);\n\t\t}"
      },
      {
        "name": "Default",
        "body": "{\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create();\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith($\"[collection-per-class, parallel ({Environment.ProcessorCount} threads)]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_NonParallel",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, non-parallel]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_MaxThreads",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: 3);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_Unlimited",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(maxParallelThreads: -1);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (unlimited threads)]\", result);\n\t\t}"
      },
      {
        "name": "Attribute_CustomCollectionFactory",
        "body": "{\n\t\t\tvar factoryType = typeof(MyTestCollectionFactory);\n\t\t\tvar attr = Mocks.CollectionBehaviorAttribute(factoryType.FullName, factoryType.Assembly.FullName, disableTestParallelization: true);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attr });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[My Factory, non-parallel]\", result);\n\t\t}"
      },
      {
        "name": "TestOptions_NonParallel",
        "body": "{\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetDisableParallelization(true);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, non-parallel]\", result);\n\t\t}"
      },
      {
        "name": "TestOptions_MaxThreads",
        "body": "{\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetMaxParallelThreads(3);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);\n\t\t}"
      },
      {
        "name": "TestOptions_MaxThreads_Aggressive",
        "body": "{\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetMaxParallelThreads(3);\n\t\t\toptions.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads/aggressive)]\", result);\n\t\t}"
      },
      {
        "name": "TestOptionsOverrideAttribute",
        "body": "{\n\t\t\tvar attribute = Mocks.CollectionBehaviorAttribute(disableTestParallelization: true, maxParallelThreads: 127);\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetDisableParallelization(false);\n\t\t\toptions.SetMaxParallelThreads(3);\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { attribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionOptions: options);\n\n\t\t\tvar result = runner.GetTestFrameworkEnvironment();\n\n\t\t\tAssert.EndsWith(\"[collection-per-class, parallel (3 threads)]\", result);\n\t\t}"
      },
      {
        "name": "Parallel_SingleThread_Aggressive",
        "body": "{\n\t\t\tvar passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetMaxParallelThreads(1);\n\t\t\toptions.SetParallelAlgorithm(ParallelAlgorithm.Aggressive);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();\n\t\t\tAssert.Equal(threadIDs[0], threadIDs[1]);\n\t\t}"
      },
      {
        "name": "NonParallel",
        "body": "{\n\t\t\tvar passing = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar other = Mocks.XunitTestCase<ClassUnderTest>(\"Other\");\n\t\t\tvar options = TestFrameworkOptions.ForExecution();\n\t\t\toptions.SetDisableParallelization(true);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(testCases: new[] { passing, other }, executionOptions: options);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tvar threadIDs = runner.TestCasesRun.Select(x => x.Item1).ToList();\n\t\t\tAssert.Equal(threadIDs[0], threadIDs[1]);\n\t\t}"
      },
      {
        "name": "CanSetTestCaseOrdererInAssemblyAttribute",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCaseOrdererAttribute<MyTestCaseOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\trunner.Initialize();\n\n\t\t\tAssert.IsType<MyTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCaseOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test case orderer\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar ordererAttribute = Mocks.TestCaseOrdererAttribute<MyCtorThrowingTestCaseOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Assembly-level test case orderer 'XunitTestAssemblyRunnerTests+TestCaseOrderer+MyCtorThrowingTestCaseOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "CanSetTestCollectionOrdererInAssemblyAttribute",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyTestCollectionOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly);\n\n\t\t\trunner.Initialize();\n\n\t\t\tAssert.IsType<MyTestCollectionOrderer>(runner.TestCollectionOrderer);\n\t\t}"
      },
      {
        "name": "UnknownType_HaltsProcessing",
        "body": "{\n\t\t\tvar ordererAttribute = Mocks.TestCollectionOrdererAttribute(\"UnknownType\", \"UnknownAssembly\");\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in 'UnknownAssembly' for assembly-level test collection orderer\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "ThrowsDuringConstruction_HaltsProcessing",
        "body": "{\n\t\t\tThread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;\n\n\t\t\tvar ordererAttribute = Mocks.TestCollectionOrdererAttribute<MyCtorThrowingTestCollectionOrderer>();\n\t\t\tvar assembly = Mocks.TestAssembly(new[] { ordererAttribute });\n\t\t\tvar executionMessages = new List<IMessageSinkMessage>();\n\t\t\tvar executionSink = SpyMessageSink.Create(messages: executionMessages);\n\t\t\tvar runner = TestableXunitTestAssemblyRunner.Create(assembly: assembly, executionMessageSink: executionSink);\n\n\t\t\trunner.Initialize();\n\n\t\t\tvar errorMessage = Assert.Single(executionMessages.OfType<IErrorMessage>());\n\t\t\tvar type = Assert.Single(errorMessage.ExceptionTypes);\n\t\t\tAssert.Equal(typeof(XunitException).FullName, type);\n\t\t\tvar index = Assert.Single(errorMessage.ExceptionParentIndices);\n\t\t\tAssert.Equal(-1, index);\n\t\t\tvar msg = Assert.Single(errorMessage.Messages);\n\t\t\tAssert.Equal(\"Assembly-level test collection orderer 'XunitTestAssemblyRunnerTests+TestCollectionOrderer+MyCtorThrowingTestCollectionOrderer' threw 'System.DivideByZeroException' during construction: Attempted to divide by zero.\", msg);\n\t\t\tAssert.Empty(runner.TestCases);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ Thread.Sleep(0); }"
      },
      {
        "name": "Other",
        "body": "{ Thread.Sleep(0); }"
      }
    ]
  },
  {
    "file": "XunitTestCaseRunnerBaseTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Passing));\n\t\t\tvar runner = new TestableXunitTestCaseRunnerBase(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Null(runner.Aggregator.ToException());\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestCaseStarting>(msg);\n\t\t\t\t\tverifyTestCaseMessage(starting);\n\t\t\t\t\t// Reading the assembly-level trait on the test project\n\t\t\t\t\tvar trait = Assert.Single(starting.Traits);\n\t\t\t\t\tAssert.Equal(\"Assembly\", trait.Key);\n\t\t\t\t\tvar value = Assert.Single(trait.Value);\n\t\t\t\t\tAssert.Equal(\"Trait\", value);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => verifyTestCaseMessage(Assert.IsAssignableFrom<ITestCaseFinished>(msg))\n\t\t\t);\n\n\t\t\tstatic void verifyTestCaseMessage(ITestCaseMessage message)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"assembly-id\", message.AssemblyUniqueID);\n\t\t\t\tAssert.Equal(\"test-case-id\", message.TestCaseUniqueID);\n\t\t\t\tAssert.Equal(\"test-class-id\", message.TestClassUniqueID);\n\t\t\t\tAssert.Equal(\"test-collection-id\", message.TestCollectionUniqueID);\n\t\t\t\tAssert.Equal(\"test-method-id\", message.TestMethodUniqueID);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.StaticPassing));\n\t\t\tvar runner = new TestableXunitTestCaseRunnerBase(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Failing));\n\t\t\tvar runner = new TestableXunitTestCaseRunnerBase(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\t\tAssert.Equal(-1, failed.ExceptionParentIndices.Single());\n\t\t\t\t\tAssert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaAttribute));\n\t\t\tvar runner = new TestableXunitTestCaseRunnerBase(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"Don't run me\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaException));\n\t\t\tvar runner = new TestableXunitTestCaseRunnerBase(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"This isn't a good time\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.ExplicitTest));\n\t\t\tvar runner = new TestableXunitTestCaseRunnerBase(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestNotRun>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "No body available"
      },
      {
        "name": "SkippedViaAttribute",
        "body": "{ }"
      },
      {
        "name": "SkippedViaException",
        "body": "No body available"
      },
      {
        "name": "ExplicitTest",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "XunitTestClassRunnerTests.cs",
    "methods": [
      {
        "name": "ClassCannotBeDecoratedWithICollectionFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithCollectionFixture>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead).\", runner.RunTestMethodAsync_AggregatorResult.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCannotHaveMoreThanOneConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithTwoConstructors>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"A test class may only define a single public constructor.\", runner.RunTestMethodAsync_AggregatorResult.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHavePublicAndPrivateConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithMixedConstructors>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "TestClassCanHaveStaticConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassWithStaticConstructor>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CreatesFixturesFromClassAndCollection",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\", collection);\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.ClassFixtureMappings.OrderBy(mapping => mapping.Key.Name),\n\t\t\tmapping => Assert.IsType<FixtureUnderTest>(mapping.Value),\n\t\t\tmapping => Assert.IsType<object>(mapping.Value)\n\t\t);\n\t}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureUnderTest>().Single();\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassForFixtureAsyncLifetimeAndDisposableUnderTest>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tvar runnerSessionTask = runner.RunAsync();\n\n\t\tawait Task.Delay(500);\n\n\t\tvar fixtureUnderTest = runner.ClassFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();\n\n\t\tAssert.True(fixtureUnderTest.DisposeAsyncCalled);\n\t\tAssert.False(fixtureUnderTest.Disposed);\n\n\t\tfixtureUnderTest.DisposeAsyncSignaler.SetResult(true);\n\n\t\tawait runnerSessionTask;\n\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "MultiplePublicConstructorsOnClassFixture_ReturnsError",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithMultiCtorClassFixture>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UnresolvedConstructorParameterOnClassFixture_ReturnsError",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);\n\t\tAssert.Equal(\"Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);\n\t}"
      },
      {
        "name": "CanInjectCollectionFixtureIntoClassFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>(\"Passing\");\n\t\tvar collectionFixture = new DependentCollectionFixture();\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase, collectionFixture);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t\tvar classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithCollectionFixtureDependency>().Single();\n\t\tAssert.Same(collectionFixture, classFixture.CollectionFixture);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "CanInjectMessageSinkIntoClassFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestMethodAsync_AggregatorResult);\n\t\tvar classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithMessageSinkDependency>().Single();\n\t\tAssert.NotNull(classFixture.MessageSink);\n\t\tAssert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);\n\t}"
      },
      {
        "name": "CanLogSinkMessageFromClassFixture",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithMessageSinkDependency>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\tAssert.Equal(\"ClassFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{\n\t\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{\n\t\t\tvar testCase = Mocks.XunitTestCase<TestClassWithUnknownTestCaseOrderer>(\"Passing\");\n\t\t\tvar runner = TestableXunitTestClassRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for class-level test case orderer on test class 'XunitTestClassRunnerTests+TestCaseOrderer+TestClassWithUnknownTestCaseOrderer'\", diagnosticMessage.Message);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "PassesFixtureValuesToConstructor",
        "body": "{\n\t\tvar testCase = Mocks.XunitTestCase<ClassUnderTest>(\"Passing\");\n\t\tvar runner = TestableXunitTestClassRunner.Create(testCase, 42, \"Hello, world!\", 21.12m);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar args = Assert.Single(runner.ConstructorArguments);\n\t\tAssert.Collection(args,\n\t\t\targ => Assert.IsType<FixtureUnderTest>(arg),\n\t\t\targ => Assert.Equal(\"Hello, world!\", arg),\n\t\t\targ => Assert.Equal(21.12m, arg)\n\t\t);\n\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestCollectionRunnerTests.cs",
    "methods": [
      {
        "name": "CreatesFixtures",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Collection(runner.CollectionFixtureMappings.OrderBy(mapping => mapping.Key.Name),\n\t\t\tmapping => Assert.IsType<FixtureUnderTest>(mapping.Value),\n\t\t\tmapping => Assert.IsType<object>(mapping.Value)\n\t\t);\n\t}"
      },
      {
        "name": "DisposesFixtures",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureUnderTest>().Single();\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionForFixtureAsyncLifetimeAndDisposableUnderTest)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposeAndAsyncLifetimeShouldBeCalledInTheRightOrder\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tvar runnerSessionTask = runner.RunAsync();\n\n\t\tawait Task.Delay(500);\n\n\t\tvar fixtureUnderTest = runner.CollectionFixtureMappings.Values.OfType<FixtureAsyncLifetimeAndDisposableUnderTest>().Single();\n\n\t\tAssert.True(fixtureUnderTest.DisposeAsyncCalled);\n\t\tAssert.False(fixtureUnderTest.Disposed);\n\n\t\tfixtureUnderTest.DisposeAsyncSignaler.SetResult(true);\n\n\t\tawait runnerSessionTask;\n\n\t\tAssert.True(fixtureUnderTest.Disposed);\n\t}"
      },
      {
        "name": "MultiplePublicConstructorsOnCollectionFixture_ReturnsError",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionsWithMultiCtorCollectionFixture)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithMultipleConstructors' may only define a single public constructor.\", ex.Message);\n\t}"
      },
      {
        "name": "UnresolvedConstructorParameterOnCollectionFixture_ReturnsError",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithDependency)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar ex = Assert.IsType<TestClassException>(runner.RunTestClassAsync_AggregatorResult);\n\t\tAssert.Equal(\"Collection fixture type 'XunitTestCollectionRunnerTests+CollectionFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture\", ex.Message);\n\t}"
      },
      {
        "name": "CanInjectMessageSinkIntoCollectionFixture",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tAssert.Null(runner.RunTestClassAsync_AggregatorResult);\n\t\tvar classFixture = runner.CollectionFixtureMappings.Values.OfType<CollectionFixtureWithMessageSinkDependency>().Single();\n\t\tAssert.NotNull(classFixture.MessageSink);\n\t\tAssert.Same(runner.DiagnosticMessageSink, classFixture.MessageSink);\n\t}"
      },
      {
        "name": "CanLogSinkMessageFromCollectionFixture",
        "body": "{\n\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithCollectionFixtureWithMessageSinkDependency)), null);\n\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"CreatesFixtures\", collection);\n\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\tawait runner.RunAsync();\n\n\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\tAssert.Equal(\"CollectionFixtureWithMessageSinkDependency constructor message\", diagnosticMessage.Message);\n\t}"
      },
      {
        "name": "UsesCustomTestOrderer",
        "body": "{\n\t\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionUnderTest)), null);\n\t\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);\n\t\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<CustomTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t}"
      },
      {
        "name": "SettingUnknownTestCaseOrderLogsDiagnosticMessage",
        "body": "{\n\t\t\tvar collection = new TestCollection(Mocks.TestAssembly(), Reflector.Wrap(typeof(CollectionWithUnknownTestCaseOrderer)), \"TestCollectionDisplayName\");\n\t\t\tvar testCase = Mocks.XunitTestCase<XunitTestCollectionRunnerTests>(\"DisposesFixtures\", collection);\n\t\t\tvar runner = TestableXunitTestCollectionRunner.Create(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.IsType<MockTestCaseOrderer>(runner.TestCaseOrderer);\n\t\t\tvar diagnosticMessage = Assert.Single(runner.DiagnosticMessages.Cast<IDiagnosticMessage>());\n\t\t\tAssert.Equal(\"Could not find type 'UnknownType' in UnknownAssembly for collection-level test case orderer on test collection 'TestCollectionDisplayName'\", diagnosticMessage.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "XunitTestInvokerTests.cs",
    "methods": [
      {
        "name": "Success",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest();\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute });\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Null(invoker.Aggregator.ToException());\n\t\t\tAssert.Collection(messageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),  // From TestInvoker\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),  // From TestInvoker\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar beforeStarting = Assert.IsAssignableFrom<IBeforeTestStarting>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeStarting.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, beforeStarting.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", beforeStarting.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", beforeStarting.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar beforeFinished = Assert.IsAssignableFrom<IBeforeTestFinished>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, beforeFinished.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, beforeFinished.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", beforeFinished.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", beforeFinished.AttributeName);\n\t\t\t\t},\n\t\t\t\t// Test method is invoked here; no directly observable message (tested below)\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar afterStarting = Assert.IsAssignableFrom<IAfterTestStarting>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterStarting.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, afterStarting.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", afterStarting.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", afterStarting.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar afterFinished = Assert.IsAssignableFrom<IAfterTestFinished>(msg);\n\t\t\t\t\tAssert.Same(invoker.TestCase.TestMethod.TestClass.TestCollection, afterFinished.TestCollection);\n\t\t\t\t\tAssert.Same(invoker.TestCase, afterFinished.TestCase);\n\t\t\t\t\tAssert.Equal(\"Display Name\", afterFinished.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", afterFinished.AttributeName);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailedBefore",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest { ThrowInBefore = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.IsType<SpyBeforeAfterTest.BeforeException>(invoker.Aggregator.ToException());\n\t\t\tAssert.Collection(messageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailedAfter",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest { ThrowInAfter = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(messageBus, \"Display Name\", new List<BeforeAfterTestAttribute> { attribute }, lambda: () => Assert.True(false));\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tvar aggEx = Assert.IsType<AggregateException>(invoker.Aggregator.ToException());\n\t\t\tAssert.Collection(aggEx.InnerExceptions,\n\t\t\t\tex => Assert.IsType<TrueException>(ex),\n\t\t\t\tex => Assert.IsType<SpyBeforeAfterTest.AfterException>(ex)\n\t\t\t);\n\t\t\tAssert.Collection(messageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IAfterTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IAfterTestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Successful",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingBefore_First",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInBefore = true };\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"Before #1\", msg);\n\t\t}"
      },
      {
        "name": "FailingBefore_Second",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInBefore = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\t// No cleanup for #2, since it threw\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingAfter_First",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1) { ThrowInAfter = true };\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingAfter_Second",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2) { ThrowInAfter = true };\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => messages.Add(\"Test method invocation\")\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "FailingTest",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar invoker = TestableXunitTestInvoker.Create(\n\t\t\t\tbeforeAfterAttributes: new List<BeforeAfterTestAttribute> { attribute1, attribute2 },\n\t\t\t\tlambda: () => { messages.Add(\"Test method invocation\"); Assert.True(false); }\n\t\t\t);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "XunitTestMethodRunnerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Passing));\n\t\t\tvar runner = new TestableXunitTestMethodRunner(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Null(runner.Aggregator.ToException());\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestMethodStarting>(msg);\n\t\t\t\t\tverifyTestMethodMessage(starting);\n\t\t\t\t\tAssert.Equal(\"Passing\", starting.MethodName);\n\t\t\t\t\t// Trait comes from an assembly-level trait attribute on this test assembly\n\t\t\t\t\tvar trait = Assert.Single(starting.Traits);\n\t\t\t\t\tAssert.Equal(\"Assembly\", trait.Key);\n\t\t\t\t\tvar value = Assert.Single(trait.Value);\n\t\t\t\t\tAssert.Equal(\"Trait\", value);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),\n\t\t\t\tmsg => verifyTestMethodMessage(Assert.IsAssignableFrom<ITestMethodFinished>(msg))\n\t\t\t);\n\n\t\t\tstatic void verifyTestMethodMessage(ITestMethodMessage message)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"assembly-id\", message.AssemblyUniqueID);\n\t\t\t\tAssert.Equal(\"test-class-id\", message.TestClassUniqueID);\n\t\t\t\tAssert.Equal(\"test-collection-id\", message.TestCollectionUniqueID);\n\t\t\t\tAssert.Equal(\"test-method-id\", message.TestMethodUniqueID);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.StaticPassing));\n\t\t\tvar runner = new TestableXunitTestMethodRunner(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.Failing));\n\t\t\tvar runner = new TestableXunitTestMethodRunner(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\t\tAssert.Equal(-1, failed.ExceptionParentIndices.Single());\n\t\t\t\t\tAssert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaAttribute));\n\t\t\tvar runner = new TestableXunitTestMethodRunner(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"Don't run me\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaException));\n\t\t\tvar runner = new TestableXunitTestMethodRunner(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"This isn't a good time\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar testCase = TestData.XunitTestCase<ClassUnderTest>(nameof(ClassUnderTest.ExplicitTest));\n\t\t\tvar runner = new TestableXunitTestMethodRunner(testCase);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\trunner.MessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestNotRun>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestCaseFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestMethodFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "No body available"
      },
      {
        "name": "SkippedViaAttribute",
        "body": "{ }"
      },
      {
        "name": "SkippedViaException",
        "body": "No body available"
      },
      {
        "name": "ExplicitTest",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "XunitTestRunnerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Passing), @explicit: true, timeout: 12345678);\n\t\t\tvar runner = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute], messageBus: messageBus, explicitOption: ExplicitOption.On);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Null(runner.Aggregator.ToException());\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestStarting>(msg);\n\t\t\t\t\tverifyTestMessage(starting);\n\t\t\t\t\tAssert.True(starting.Explicit);\n\t\t\t\t\tAssert.Equal(\"test-display-name\", starting.TestDisplayName);\n\t\t\t\t\tAssert.Equal(12345678, starting.Timeout);\n\t\t\t\t\t// Trait comes from an assembly-level trait attribute on this test assembly\n\t\t\t\t\tvar trait = Assert.Single(starting.Traits);\n\t\t\t\t\tAssert.Equal(\"Assembly\", trait.Key);\n\t\t\t\t\tvar value = Assert.Single(trait.Value);\n\t\t\t\t\tAssert.Equal(\"Trait\", value);\n\t\t\t\t},\n\t\t\t\tmsg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg)),\n\t\t\t\tmsg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg)),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar beforeStarting = Assert.IsAssignableFrom<IBeforeTestStarting>(msg);\n\t\t\t\t\tverifyTestMessage(beforeStarting);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", beforeStarting.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar beforeFinished = Assert.IsAssignableFrom<IBeforeTestFinished>(msg);\n\t\t\t\t\tverifyTestMessage(beforeFinished);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", beforeFinished.AttributeName);\n\t\t\t\t},\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar afterStarting = Assert.IsAssignableFrom<IAfterTestStarting>(msg);\n\t\t\t\t\tverifyTestMessage(afterStarting);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", afterStarting.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar afterFinished = Assert.IsAssignableFrom<IAfterTestFinished>(msg);\n\t\t\t\t\tverifyTestMessage(afterFinished);\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest\", afterFinished.AttributeName);\n\t\t\t\t},\n\t\t\t\tmsg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg)),\n\t\t\t\tmsg => verifyTestMessage(Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg)),\n\t\t\t\tmsg => verifyTestMessage(Assert.IsAssignableFrom<ITestPassed>(msg)),\n\t\t\t\tmsg => verifyTestMessage(Assert.IsAssignableFrom<ITestFinished>(msg))\n\t\t\t);\n\n\t\t\tstatic void verifyTestMessage(ITestMessage testMethod)\n\t\t\t{\n\t\t\t\tAssert.Equal(\"assembly-id\", testMethod.AssemblyUniqueID);\n\t\t\t\tAssert.Equal(\"test-case-id\", testMethod.TestCaseUniqueID);\n\t\t\t\tAssert.Equal(\"test-class-id\", testMethod.TestClassUniqueID);\n\t\t\t\tAssert.Equal(\"test-collection-id\", testMethod.TestCollectionUniqueID);\n\t\t\t\tAssert.Equal(\"test-method-id\", testMethod.TestMethodUniqueID);\n\t\t\t\tAssert.Equal(\"test-id\", testMethod.TestUniqueID);\n\t\t\t}\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.StaticPassing));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Failing));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\t\tAssert.Equal(-1, failed.ExceptionParentIndices.Single());\n\t\t\t\t\tAssert.Equal(\"Xunit.Sdk.TrueException\", failed.ExceptionTypes.Single());\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaAttribute));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"Don't run me\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaSkipUnless));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"Conditionally don't run me\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaSkipWhen));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"Conditionally don't run me\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.NotSkippedViaSkipUnless));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.NotSkippedViaSkipWhen));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestPassed>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.SkippedViaException));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar skipped = Assert.IsAssignableFrom<ITestSkipped>(msg);\n\t\t\t\t\tAssert.Equal(\"This isn't a good time\", skipped.Reason);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.ExplicitTest));\n\t\t\tvar runner = new TestableXunitTestRunner(test, messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestNotRun>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest { ThrowInBefore = true };\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Failing));\n\t\t\tvar runner = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute], messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),\n\t\t\t\t// No after messages because nothing to clean up, and test method is NOT invoked\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\t\tAssert.Equal(-1, failed.ExceptionParentIndices.Single());\n\t\t\t\t\tAssert.Equal(\"SpyBeforeAfterTest+BeforeException\", failed.ExceptionTypes.Single());\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messageBus = new SpyMessageBus();\n\t\t\tvar attribute = new SpyBeforeAfterTest { ThrowInAfter = true };\n\t\t\tvar test = TestData.XunitTest<ClassUnderTest>(nameof(ClassUnderTest.Failing));\n\t\t\tvar runner = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute], messageBus: messageBus);\n\n\t\t\tawait runner.RunAsync();\n\n\t\t\tAssert.Collection(\n\t\t\t\tmessageBus.Messages,\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassConstructionFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IBeforeTestFinished>(msg),\n\t\t\t\t// Test method is invoked here\n\t\t\t\tmsg => Assert.IsAssignableFrom<IAfterTestStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<IAfterTestFinished>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeStarting>(msg),\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestClassDisposeFinished>(msg),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar failed = Assert.IsAssignableFrom<ITestFailed>(msg);\n\t\t\t\t\tAssert.Equivalent(new[] { -1, 0, 0 }, failed.ExceptionParentIndices);\n\t\t\t\t\tAssert.Collection(\n\t\t\t\t\t\tfailed.ExceptionTypes,\n\t\t\t\t\t\ttype => Assert.Equal(\"System.AggregateException\", type),\n\t\t\t\t\t\ttype => Assert.Equal(\"Xunit.Sdk.TrueException\", type),\n\t\t\t\t\t\ttype => Assert.Equal(\"SpyBeforeAfterTest+AfterException\", type)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tmsg => Assert.IsAssignableFrom<ITestFinished>(msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar messages = new List<string>();\n\t\t\tvar attribute1 = new RecordingBeforeAfter(messages, 1);\n\t\t\tvar attribute2 = new RecordingBeforeAfter(messages, 2);\n\t\t\tvar test = TestData.XunitTest<RecordingTestClass>(nameof(RecordingTestClass.ExecutionRecorder));\n\t\t\tvar invoker = new TestableXunitTestRunner(test, beforeAfterTestAttributes: [attribute1, attribute2], constructorArguments: [messages]);\n\n\t\t\tawait invoker.RunAsync();\n\n\t\t\tAssert.Collection(messages,\n\t\t\t\tmsg => Assert.Equal(\"Before #1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Before #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Test method invocation\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"After #1\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "StaticPassing",
        "body": "{ }"
      },
      {
        "name": "Failing",
        "body": "No body available"
      },
      {
        "name": "SkippedViaAttribute",
        "body": "{ }"
      },
      {
        "name": "SkippedViaSkipUnless",
        "body": "{ }"
      },
      {
        "name": "SkippedViaSkipWhen",
        "body": "{ }"
      },
      {
        "name": "NotSkippedViaSkipUnless",
        "body": "{ }"
      },
      {
        "name": "NotSkippedViaSkipWhen",
        "body": "{ }"
      },
      {
        "name": "SkippedViaException",
        "body": "No body available"
      },
      {
        "name": "ExplicitTest",
        "body": "No body available"
      },
      {
        "name": "ExecutionRecorder",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "TestContextTests.cs",
    "methods": [
      {
        "name": "AmbientTestContextIsAvailableInTest",
        "body": "{\n\t\tvar context = TestContext.Current;\n\n\t\tAssert.NotNull(context);\n\t\t// Test\n\t\tAssert.Equal(TestEngineStatus.Running, context.TestStatus);\n\t\tAssert.Equal(TestPipelineStage.TestExecution, context.PipelineStage);\n\t\tvar test = context.Test;\n\t\tAssert.NotNull(test);\n\t\tAssert.Equal($\"{nameof(TestContextTests)}.{nameof(AmbientTestContextIsAvailableInTest)}\", test.TestDisplayName);\n\t\tAssert.Null(context.TestState);\n\t\t// Test case\n\t\tAssert.Equal(TestEngineStatus.Running, context.TestCaseStatus);\n\t\tAssert.Same(test.TestCase, context.TestCase);\n\t\t// Test method\n\t\tAssert.Equal(TestEngineStatus.Running, context.TestMethodStatus);\n\t\tAssert.Same(test.TestCase.TestMethod, context.TestMethod);\n\t\t// Test class\n\t\tAssert.Equal(TestEngineStatus.Running, context.TestClassStatus);\n\t\tAssert.Same(test.TestCase.TestMethod!.TestClass, context.TestClass);\n\t\t// Test collection\n\t\tAssert.Equal(TestEngineStatus.Running, context.TestCollectionStatus);\n\t\tAssert.Same(test.TestCase.TestCollection, context.TestCollection);\n\t\t// Test assembly\n\t\tAssert.Equal(TestEngineStatus.Running, context.TestAssemblyStatus);\n\t\tAssert.Same(test.TestCase.TestCollection.TestAssembly, context.TestAssembly);\n\t}"
      },
      {
        "name": "KeyValueStorageIsAvailableThroughoutPipeline",
        "body": "{\n\t\tAssert.Equal(42, TestContext.Current.KeyValueStorage[\"collectionValue\"]);\n\t\tAssert.Equal(2112, TestContext.Current.KeyValueStorage[\"classValue\"]);\n\n\t\tTestContext.Current.KeyValueStorage[\"testValue\"] = 2600;\n\t}"
      }
    ]
  },
  {
    "file": "MockTestCaseOrderer.cs",
    "methods": []
  },
  {
    "file": "SpyBeforeAfterTest.cs",
    "methods": []
  },
  {
    "file": "FixtureMappingManagerTests.cs",
    "methods": [
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\n\t\tvar result = await manager.GetFixture(typeof(int));\n\n\t\tAssert.Null(result);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager(12);\n\n\t\tvar result = await manager.GetFixture(typeof(int));\n\n\t\tAssert.Equal(12, result);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar parent = new TestableFixtureMappingManager(12);\n\t\tvar manager = new TestableFixtureMappingManager(parent);\n\n\t\tvar result = await manager.GetFixture(typeof(int));\n\n\t\tAssert.Equal(12, result);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\t\tawait manager.InitializeAsync(typeof(object));\n\n\t\tvar result = await manager.GetFixture(typeof(object));\n\n\t\tAssert.IsType<object>(result);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\n\t\tvar ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(FixtureWithThrowingCtor)));\n\n\t\tAssert.IsType<TestPipelineException>(ex);\n\t\tAssert.Equal(\"Testable fixture type 'FixtureMappingManagerTests+FixtureWithThrowingCtor' threw in its constructor\", ex.Message);\n\t\tAssert.IsType<DivideByZeroException>(ex.InnerException);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\n\t\tvar ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(FixtureWithThrowingInitializeAsync)));\n\n\t\tAssert.IsType<TestPipelineException>(ex);\n\t\tAssert.Equal(\"Testable fixture type 'FixtureMappingManagerTests+FixtureWithThrowingInitializeAsync' threw in InitializeAsync\", ex.Message);\n\t\tAssert.IsType<DivideByZeroException>(ex.InnerException);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\n\t\tvar ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(FixtureWithDependency)));\n\n\t\tAssert.IsType<TestPipelineException>(ex);\n\t\tAssert.Equal(\"Testable fixture type 'FixtureMappingManagerTests+FixtureWithDependency' had one or more unresolved constructor arguments: Object dependency\", ex.Message);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar parent = new TestableFixtureMappingManager();\n\t\tawait parent.InitializeAsync(typeof(object));\n\t\tvar manager = new TestableFixtureMappingManager(parent);\n\t\tawait manager.InitializeAsync(typeof(FixtureWithDependency));\n\n\t\tvar result = await manager.GetFixture(typeof(FixtureWithDependency));\n\n\t\tvar typedResult = Assert.IsType<FixtureWithDependency>(result);\n\t\tAssert.IsType<object>(typedResult.Dependency);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\t\tawait manager.InitializeAsync(typeof(FixtureWithMessageSinkAndTestContext));\n\n\t\tvar result = await manager.GetFixture(typeof(FixtureWithMessageSinkAndTestContext));\n\n\t\tvar typedResult = Assert.IsType<FixtureWithMessageSinkAndTestContext>(result);\n\t\tAssert.NotNull(TestContext.Current);\n\t\tAssert.Same(TestContext.Current, typedResult.ContextAccessor.Current);\n\t\tAssert.Same(TestContext.CurrentInternal.DiagnosticMessageSink, typedResult.MessageSink);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\t\tawait manager.InitializeAsync(typeof(FixtureWithDispose));\n\n\t\tvar result = await manager.GetFixture(typeof(FixtureWithDispose));\n\n\t\tvar typedResult = Assert.IsType<FixtureWithDispose>(result);\n\t\tAssert.False(typedResult.DisposeCalled);\n\n\t\tawait manager.DisposeAsync();\n\n\t\tAssert.True(typedResult.DisposeCalled);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\t\tawait manager.InitializeAsync(typeof(FixtureWithThrowingDispose));\n\n\t\tawait manager.GetFixture(typeof(FixtureWithThrowingDispose));\n\t\tvar ex = await Record.ExceptionAsync(manager.DisposeAsync);\n\n\t\tAssert.IsType<TestPipelineException>(ex);\n\t\tAssert.Equal($\"Testable fixture type '{typeof(FixtureWithThrowingDispose).SafeName()}' threw in Dispose\", ex.Message);\n\t\tAssert.IsType<DivideByZeroException>(ex.InnerException);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\t\tawait manager.InitializeAsync(typeof(FixtureWithDisposeAsync));\n\n\t\tvar result = await manager.GetFixture(typeof(FixtureWithDisposeAsync));\n\n\t\tvar typedResult = Assert.IsType<FixtureWithDisposeAsync>(result);\n\t\tAssert.False(typedResult.DisposeAsyncCalled);\n\n\t\tawait manager.DisposeAsync();\n\n\t\tAssert.True(typedResult.DisposeAsyncCalled);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\t\tawait manager.InitializeAsync(typeof(FixtureWithThrowingDisposeAsync));\n\n\t\tawait manager.GetFixture(typeof(FixtureWithThrowingDisposeAsync));\n\t\tvar ex = await Record.ExceptionAsync(manager.DisposeAsync);\n\n\t\tAssert.IsType<TestPipelineException>(ex);\n\t\tAssert.Equal($\"Testable fixture type '{typeof(FixtureWithThrowingDisposeAsync).SafeName()}' threw in DisposeAsync\", ex.Message);\n\t\tAssert.IsType<DivideByZeroException>(ex.InnerException);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tvar manager = new TestableFixtureMappingManager();\n\n\t\tvar ex = await Record.ExceptionAsync(() => manager.InitializeAsync(typeof(int)));\n\n\t\tAssert.IsType<TestPipelineException>(ex);\n\t\tAssert.Equal(\"Testable fixture type 'System.Int32' may only define a single public constructor.\", ex.Message);\n\t}"
      }
    ]
  },
  {
    "file": "TestIntrospectionHelperTests.cs",
    "methods": [
      {
        "name": "NullDiscoveryOptionsThrows",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => TestIntrospectionHelper.GetTestCaseDetails(null!, Mocks.XunitTestMethod(), Mocks.FactAttribute()));\n\n\t\t\tvar argnEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"discoveryOptions\", argnEx.ParamName);\n\t\t}"
      },
      {
        "name": "NullTestMethodThrows",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => TestIntrospectionHelper.GetTestCaseDetails(discoveryOptions, null!, Mocks.FactAttribute()));\n\n\t\t\tvar argnEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"testMethod\", argnEx.ParamName);\n\t\t}"
      },
      {
        "name": "NullFactAttributeThrows",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => TestIntrospectionHelper.GetTestCaseDetails(discoveryOptions, Mocks.XunitTestMethod(), null!));\n\n\t\t\tvar argEx = Assert.IsType<ArgumentNullException>(ex);\n\t\t\tAssert.Equal(\"factAttribute\", argEx.ParamName);\n\t\t}"
      },
      {
        "name": "DisplayName",
        "body": "{\n\t\t\tvar testMethod = TestData.XunitTestMethod<GetTestCaseDetails>(nameof(DisplayName));\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod);\n\n\t\t\tAssert.Equal(\"TestIntrospectionHelperTests+GetTestCaseDetails.DisplayName\", details.TestCaseDisplayName);\n\t\t}"
      },
      {
        "name": "NonStandardMethodDisplay",
        "body": "{\n\t\t\tvar testMethod = Mocks.XunitTestMethod(methodName: \"method-name\");\n\t\t\tdiscoveryOptions.SetMethodDisplay(TestMethodDisplay.Method);\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod);\n\n\t\t\tAssert.Equal(\"method-name\", details.TestCaseDisplayName);\n\t\t}"
      },
      {
        "name": "NonStandardMethodDisplayOptions",
        "body": "{\n\t\t\tvar testClass = Mocks.XunitTestClass(testClassName: \"With_an_empty_stack\");\n\t\t\tvar testMethod = Mocks.XunitTestMethod(testClass: testClass, methodName: \"count_eq_0X21\");\n\t\t\tdiscoveryOptions.SetMethodDisplayOptions(TestMethodDisplayOptions.All);\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod);\n\n\t\t\tAssert.Equal(\"With an empty stack, count = 0!\", details.TestCaseDisplayName);\n\t\t}"
      },
      {
        "name": "CustomDisplayName",
        "body": "{\n\t\t\tvar factAttribute = Mocks.FactAttribute(displayName: \"Custom Display Name\");\n\t\t\tvar testMethod = Mocks.XunitTestMethod(factAttributes: [factAttribute]);\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod);\n\n\t\t\tAssert.Equal(\"Custom Display Name\", details.TestCaseDisplayName);\n\t\t}"
      },
      {
        "name": "CustomDisplayNameWithArguments",
        "body": "{\n\t\t\tvar testMethod = TestData.XunitTestMethod<CustomDisplayNameWithArgumentsTestClass>(nameof(CustomDisplayNameWithArgumentsTestClass.TestMethod));\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod, [42, \"Hello, world!\", 'A']);\n\n\t\t\tAssert.Equal(\"Custom Display Name(_1: 42, _2: \\\"Hello, world!\\\", _3: 'A')\", details.TestCaseDisplayName);\n\t\t}"
      },
      {
        "name": "NotEnoughTestArguments",
        "body": "{\n\t\t\tvar testMethod = TestData.XunitTestMethod<CustomDisplayNameWithArgumentsTestClass>(nameof(CustomDisplayNameWithArgumentsTestClass.TestMethod));\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod, [42]);\n\n\t\t\tAssert.Equal(\"Custom Display Name(_1: 42, _2: ???, _3: ???)\", details.TestCaseDisplayName);\n\t\t}"
      },
      {
        "name": "SkipReason",
        "body": "{\n\t\t\tvar factAttribute = Mocks.FactAttribute(skip: \"Skip Reason\");\n\t\t\tvar testMethod = Mocks.XunitTestMethod(factAttributes: [factAttribute]);\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod);\n\n\t\t\tAssert.Equal(\"Skip Reason\", details.SkipReason);\n\t\t}"
      },
      {
        "name": "Timeout",
        "body": "{\n\t\t\tvar factAttribute = Mocks.FactAttribute(timeout: 42);\n\t\t\tvar testMethod = Mocks.XunitTestMethod(factAttributes: [factAttribute]);\n\n\t\t\tvar details = _GetTestCaseDetails(discoveryOptions, testMethod);\n\n\t\t\tAssert.Equal(42, details.Timeout);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestableFixtureMappingManager.cs",
    "methods": []
  },
  {
    "file": "IBeforeAfterTestAttribute.cs",
    "methods": []
  },
  {
    "file": "ITestCaseOrdererAttribute.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionOrdererAttribute.cs",
    "methods": []
  },
  {
    "file": "ITestFrameworkAttribute.cs",
    "methods": []
  },
  {
    "file": "ITestPipelineStartupAttribute.cs",
    "methods": []
  },
  {
    "file": "ITestCaseOrderer.cs",
    "methods": []
  },
  {
    "file": "ITestCollectionOrderer.cs",
    "methods": []
  },
  {
    "file": "ITestFramework.cs",
    "methods": []
  },
  {
    "file": "ITestFrameworkDiscoverer.cs",
    "methods": []
  },
  {
    "file": "ITestFrameworkExecutor.cs",
    "methods": []
  },
  {
    "file": "ITestPipelineStartup.cs",
    "methods": []
  },
  {
    "file": "ITestTimeoutException.cs",
    "methods": []
  },
  {
    "file": "IXunitTestCaseDiscoverer.cs",
    "methods": []
  },
  {
    "file": "IXunitTestCollectionFactory.cs",
    "methods": []
  },
  {
    "file": "IXunitTest.cs",
    "methods": []
  },
  {
    "file": "IXunitTestAssembly.cs",
    "methods": []
  },
  {
    "file": "IXunitTestCase.cs",
    "methods": []
  },
  {
    "file": "IXunitTestClass.cs",
    "methods": []
  },
  {
    "file": "IXunitTestCollection.cs",
    "methods": []
  },
  {
    "file": "IXunitTestMethod.cs",
    "methods": []
  },
  {
    "file": "BeforeAfterTestAttribute.cs",
    "methods": []
  },
  {
    "file": "TestPipelineStartupAttribute.cs",
    "methods": []
  },
  {
    "file": "XunitTestCaseDiscovererAttribute.cs",
    "methods": []
  },
  {
    "file": "TestEventSource.cs",
    "methods": []
  },
  {
    "file": "TestPipelineException.cs",
    "methods": []
  },
  {
    "file": "TestTimeoutException.cs",
    "methods": []
  },
  {
    "file": "TestContextExtensions.cs",
    "methods": []
  },
  {
    "file": "TestFrameworkOptionsReadExtensions.cs",
    "methods": []
  },
  {
    "file": "CollectionPerAssemblyTestCollectionFactory.cs",
    "methods": []
  },
  {
    "file": "CollectionPerClassTestCollectionFactory.cs",
    "methods": []
  },
  {
    "file": "DefaultTestCaseOrderer.cs",
    "methods": []
  },
  {
    "file": "DefaultTestCollectionOrderer.cs",
    "methods": []
  },
  {
    "file": "TestCollectionFactoryBase.cs",
    "methods": []
  },
  {
    "file": "TestContextAccessor.cs",
    "methods": []
  },
  {
    "file": "TestFramework.cs",
    "methods": []
  },
  {
    "file": "TestFrameworkDiscoverer.cs",
    "methods": []
  },
  {
    "file": "TestFrameworkExecutor.cs",
    "methods": []
  },
  {
    "file": "TestOutputHelper.cs",
    "methods": []
  },
  {
    "file": "XunitTestFramework.cs",
    "methods": []
  },
  {
    "file": "XunitTestFrameworkDiscoverer.cs",
    "methods": []
  },
  {
    "file": "XunitTestFrameworkExecutor.cs",
    "methods": []
  },
  {
    "file": "ITestContext.cs",
    "methods": []
  },
  {
    "file": "ITestContextAccessor.cs",
    "methods": []
  },
  {
    "file": "ITestOutputHelper.cs",
    "methods": []
  },
  {
    "file": "ConsoleCaptureTestOutputWriter.cs",
    "methods": []
  },
  {
    "file": "TraceCaptureTestOutputWriter.cs",
    "methods": []
  },
  {
    "file": "AfterTestFinished.cs",
    "methods": []
  },
  {
    "file": "AfterTestStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyMessage.cs",
    "methods": []
  },
  {
    "file": "TestCaseMessage.cs",
    "methods": []
  },
  {
    "file": "TestClassMessage.cs",
    "methods": []
  },
  {
    "file": "TestCollectionMessage.cs",
    "methods": []
  },
  {
    "file": "TestMessage.cs",
    "methods": []
  },
  {
    "file": "TestMethodMessage.cs",
    "methods": []
  },
  {
    "file": "TestResultMessage.cs",
    "methods": []
  },
  {
    "file": "BeforeTestFinished.cs",
    "methods": []
  },
  {
    "file": "BeforeTestStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyFinished.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyStarting.cs",
    "methods": []
  },
  {
    "file": "TestCaseCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCaseDiscovered.cs",
    "methods": []
  },
  {
    "file": "TestCaseFinished.cs",
    "methods": []
  },
  {
    "file": "TestCaseStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestClassConstructionFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassConstructionStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassDisposeFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassDisposeStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassStarting.cs",
    "methods": []
  },
  {
    "file": "TestCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCollectionCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCollectionFinished.cs",
    "methods": []
  },
  {
    "file": "TestCollectionStarting.cs",
    "methods": []
  },
  {
    "file": "TestFailed.cs",
    "methods": []
  },
  {
    "file": "TestFinished.cs",
    "methods": []
  },
  {
    "file": "TestMethodCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestMethodFinished.cs",
    "methods": []
  },
  {
    "file": "TestMethodStarting.cs",
    "methods": []
  },
  {
    "file": "TestNotRun.cs",
    "methods": []
  },
  {
    "file": "TestOutput.cs",
    "methods": []
  },
  {
    "file": "TestPassed.cs",
    "methods": []
  },
  {
    "file": "TestSkipped.cs",
    "methods": []
  },
  {
    "file": "TestStarting.cs",
    "methods": []
  },
  {
    "file": "ExecutionErrorTestCase.cs",
    "methods": []
  },
  {
    "file": "XunitDelayEnumeratedTheoryTestCase.cs",
    "methods": []
  },
  {
    "file": "XunitTest.cs",
    "methods": []
  },
  {
    "file": "XunitTestAssembly.cs",
    "methods": []
  },
  {
    "file": "XunitTestCase.cs",
    "methods": []
  },
  {
    "file": "XunitTestClass.cs",
    "methods": []
  },
  {
    "file": "XunitTestCollection.cs",
    "methods": []
  },
  {
    "file": "XunitTestMethod.cs",
    "methods": []
  },
  {
    "file": "ExecutionErrorTestCaseRunner.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyRunner.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyRunnerContext.cs",
    "methods": []
  },
  {
    "file": "TestCaseRunner.cs",
    "methods": []
  },
  {
    "file": "TestCaseRunnerContext.cs",
    "methods": []
  },
  {
    "file": "TestClassRunner.cs",
    "methods": []
  },
  {
    "file": "TestClassRunnerContext.cs",
    "methods": []
  },
  {
    "file": "TestCollectionRunner.cs",
    "methods": []
  },
  {
    "file": "TestCollectionRunnerContext.cs",
    "methods": []
  },
  {
    "file": "TestInvoker.cs",
    "methods": []
  },
  {
    "file": "TestInvokerContext.cs",
    "methods": []
  },
  {
    "file": "TestMethodRunner.cs",
    "methods": []
  },
  {
    "file": "TestMethodRunnerContext.cs",
    "methods": []
  },
  {
    "file": "TestRunner.cs",
    "methods": []
  },
  {
    "file": "TestRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitDelayEnumeratedTheoryTestCaseRunner.cs",
    "methods": []
  },
  {
    "file": "XunitDelayEnumeratedTheoryTestCaseRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestAssemblyRunner.cs",
    "methods": []
  },
  {
    "file": "XunitTestAssemblyRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestCaseRunner.cs",
    "methods": []
  },
  {
    "file": "XunitTestCaseRunnerBase.cs",
    "methods": []
  },
  {
    "file": "XunitTestCaseRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestClassRunner.cs",
    "methods": []
  },
  {
    "file": "XunitTestClassRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestCollectionRunner.cs",
    "methods": []
  },
  {
    "file": "XunitTestCollectionRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestInvoker.cs",
    "methods": []
  },
  {
    "file": "XunitTestInvokerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestMethodRunner.cs",
    "methods": []
  },
  {
    "file": "XunitTestMethodRunnerContext.cs",
    "methods": []
  },
  {
    "file": "XunitTestRunner.cs",
    "methods": []
  },
  {
    "file": "XunitTestRunnerContext.cs",
    "methods": []
  },
  {
    "file": "TestCaseOrdererAttribute.cs",
    "methods": []
  },
  {
    "file": "TestCollectionOrdererAttribute.cs",
    "methods": []
  },
  {
    "file": "TestContext.cs",
    "methods": []
  },
  {
    "file": "TestEngineStatus.cs",
    "methods": []
  },
  {
    "file": "TestFrameworkAttribute.cs",
    "methods": []
  },
  {
    "file": "TestPipelineStage.cs",
    "methods": []
  },
  {
    "file": "TestResult.cs",
    "methods": []
  },
  {
    "file": "TestResultState.cs",
    "methods": []
  },
  {
    "file": "ExtensibilityPointFactory.TestAssembly.cs",
    "methods": []
  },
  {
    "file": "ExtensibilityPointFactory.TestClass.cs",
    "methods": []
  },
  {
    "file": "ExtensibilityPointFactory.TestCollection.cs",
    "methods": []
  },
  {
    "file": "ExtensibilityPointFactory.TestMethod.cs",
    "methods": []
  },
  {
    "file": "TestClassComparer.cs",
    "methods": []
  },
  {
    "file": "TestCollectionComparer.cs",
    "methods": []
  },
  {
    "file": "TestIntrospectionHelper.cs",
    "methods": []
  },
  {
    "file": "TestMethodComparer.cs",
    "methods": []
  },
  {
    "file": "QueryFilterParserTests.cs",
    "methods": [
      {
        "name": "EscapedSegmentCharacters",
        "body": "{\n\t\t\tvar filter = QueryFilterParser.Parse(\"/a&#x28;b&#x29;c\");\n\n\t\t\tAssert.True(filter.Filter(\"a(b)c\", GetTestCase()));\n\t\t}"
      },
      {
        "name": "EscapedTraitCharacters",
        "body": "{\n\t\t\tvar filter = QueryFilterParser.Parse(\"/[&#x5b;&#x3d;=&#x3d;&#x5d;]\");\n\n\t\t\tAssert.True(filter.Filter(\"asm1\", GetTestCase(traitKey: \"[=\", traitValue: \"=]\")));\n\t\t}"
      }
    ]
  },
  {
    "file": "TestFrameworkOptionsTests.cs",
    "methods": [
      {
        "name": "DefaultOptions_EmptyJson",
        "body": "{\n\t\t\t\tITestFrameworkDiscoveryOptions options = TestFrameworkOptions.Empty();\n\n\t\t\t\tvar result = options.ToJson();\n\n\t\t\t\tAssert.Equal(\"{}\", result);\n\t\t\t}"
      },
      {
        "name": "EmptyJson_DeserializesToDefaultValues",
        "body": "{\n\t\t\t\tvar result = TestFrameworkOptions.ForDiscoveryFromSerialization(\"{}\");\n\n\t\t\t\tAssert.Null(result.GetCulture());\n\t\t\t\tAssert.Null(result.GetDiagnosticMessages());\n\t\t\t\tAssert.Null(result.GetIncludeSourceInformation());\n\t\t\t\tAssert.Null(result.GetInternalDiagnosticMessages());\n\t\t\t\tAssert.Null(result.GetMethodDisplay());\n\t\t\t\tAssert.Null(result.GetMethodDisplayOptions());\n\t\t\t\tAssert.Null(result.GetPreEnumerateTheories());\n\t\t\t\tAssert.Null(result.GetSynchronousMessageReporting());\n\t\t\t}"
      },
      {
        "name": "SettingValue_RoundTripsValue",
        "body": "{\n\t\t\t\t// Set one of each known supported CLR type\n\t\t\t\tvar overrideEnumValue = TestMethodDisplayOptions.ReplaceUnderscoreWithSpace | TestMethodDisplayOptions.UseEscapeSequences;\n\t\t\t\tITestFrameworkDiscoveryOptions options = TestFrameworkOptions.Empty();\n\t\t\t\toptions.SetCulture(\"foo\");\n\t\t\t\toptions.SetDiagnosticMessages(true);\n\t\t\t\toptions.SetMethodDisplayOptions(overrideEnumValue);\n\t\t\t\tvar serialized = options.ToJson();\n\n\t\t\t\tvar deserialized = TestFrameworkOptions.ForDiscoveryFromSerialization(serialized);\n\n\t\t\t\tAssert.Equal(\"foo\", deserialized.GetCulture());\n\t\t\t\tAssert.True(deserialized.GetDiagnosticMessages());\n\t\t\t\tAssert.Equal(overrideEnumValue, deserialized.GetMethodDisplayOptions());\n\t\t\t}"
      },
      {
        "name": "DefaultOptions_EmptyJson",
        "body": "{\n\t\t\t\tITestFrameworkExecutionOptions options = TestFrameworkOptions.Empty();\n\n\t\t\t\tvar result = options.ToJson();\n\n\t\t\t\tAssert.Equal(\"{}\", result);\n\t\t\t}"
      },
      {
        "name": "EmptyJson_DeserializesToDefaultValues",
        "body": "{\n\t\t\t\tvar result = TestFrameworkOptions.ForExecutionFromSerialization(\"{}\");\n\n\t\t\t\tAssert.Null(result.GetCulture());\n\t\t\t\tAssert.Null(result.GetDiagnosticMessages());\n\t\t\t\tAssert.Null(result.GetDisableParallelization());\n\t\t\t\tAssert.Null(result.GetInternalDiagnosticMessages());\n\t\t\t\tAssert.Null(result.GetMaxParallelThreads());\n\t\t\t\tAssert.Null(result.GetSynchronousMessageReporting());\n\t\t\t}"
      },
      {
        "name": "SettingValue_RoundTripsValue",
        "body": "{\n\t\t\t\t// Set one of each known supported CLR type\n\t\t\t\tITestFrameworkExecutionOptions options = TestFrameworkOptions.Empty();\n\t\t\t\toptions.SetCulture(\"foo\");\n\t\t\t\toptions.SetDiagnosticMessages(true);\n\t\t\t\toptions.SetMaxParallelThreads(42);\n\t\t\t\tvar serialized = options.ToJson();\n\n\t\t\t\tvar deserialized = TestFrameworkOptions.ForExecutionFromSerialization(serialized);\n\n\t\t\t\tAssert.Equal(\"foo\", deserialized.GetCulture());\n\t\t\t\tAssert.True(deserialized.GetDiagnosticMessages());\n\t\t\t\tAssert.Equal(42, deserialized.GetMaxParallelThreads());\n\t\t\t}"
      }
    ]
  },
  {
    "file": "XunitFiltersTests.cs",
    "methods": [
      {
        "name": "NoFilters_AlwaysPass",
        "body": "{\n\t\tvar filters = new XunitFilters();\n\n\t\tAssert.True(filters.Filter(\"asm1\", NonClassTest));\n\t\tAssert.True(filters.Filter(\"asm1\", NonMethodTest));\n\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\tAssert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\tAssert.True(filters.Filter(\"asm1\", MethodWithNoTraits));\n\t\tAssert.True(filters.Filter(\"asm1\", MethodWithFooBarTrait));\n\t\tAssert.True(filters.Filter(\"asm1\", MethodWithBazBiffTrait));\n\t}"
      },
      {
        "name": "MixedFilters_NotAllowed_SimpleFirst",
        "body": "{\n\t\tvar filters = new XunitFilters();\n\t\tfilters.AddIncludedClassFilter(\"class\");\n\n\t\tvar ex = Record.Exception(() => filters.AddQueryFilter(\"/1/2/3/4\"));\n\n\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\tAssert.Equal(\"query\", argEx.ParamName);\n\t\tAssert.StartsWith(\"Cannot add query filter; simple filters already exist\", argEx.Message);\n\t}"
      },
      {
        "name": "SingleFilter_MatchesQuery",
        "body": "{\n\t\t\tvar filters = new XunitFilters();\n\t\t\tfilters.AddQueryFilter($\"/asm1/{typeof(InnerClassOne).Namespace}/{typeof(InnerClassOne).Name}/{nameof(InnerClassOne.NameOne)}\");\n\n\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{\n\t\t\tvar filters = new XunitFilters();\n\t\t\tfilters.AddQueryFilter($\"/asm1/{typeof(InnerClassOne).Namespace}/{typeof(InnerClassOne).Name}\");\n\t\t\tfilters.AddQueryFilter($\"/asm1/{typeof(InnerClassOne).Namespace}/{typeof(InnerClassTwo).Name}\");\n\n\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddExcludedClassFilter(typeof(InnerClassOne).FullName!);\n\t\t\t\tfilters.AddExcludedClassFilter(typeof(InnerClassTwo).FullName!.ToUpperInvariant());\n\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsOrOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddExcludedMethodFilter($\"{typeof(InnerClassOne).FullName}.{nameof(InnerClassOne.NameOne)}\");\n\t\t\t\tfilters.AddExcludedMethodFilter($\"*.nAmEtWo\");\n\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddExcludedNamespaceFilter(typeof(InnerClassOne).Namespace!);\n\t\t\t\tfilters.AddExcludedNamespaceFilter(typeof(ClassWithTraits).Namespace!.ToUpperInvariant());\n\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithNoTraits));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithFooBarTrait));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithBazBiffTrait));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsOrOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddExcludedTraitFilter(\"fOo\", \"bAr\");\n\t\t\t\tfilters.AddExcludedTraitFilter(\"bAz\", \"bIff\");\n\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", MethodWithNoTraits));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithFooBarTrait));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithBazBiffTrait));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAnAndOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddIncludedClassFilter(typeof(InnerClassOne).FullName!);\n\t\t\t\tfilters.AddIncludedClassFilter(typeof(InnerClassTwo).FullName!.ToUpperInvariant());\n\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAndOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddIncludedMethodFilter($\"{typeof(InnerClassOne).FullName}.{nameof(InnerClassOne.NameOne)}\");\n\t\t\t\tfilters.AddIncludedMethodFilter($\"*.{nameof(InnerClassOne.NameTwo).ToUpperInvariant()}\");\n\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAnOrOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddIncludedNamespaceFilter(typeof(InnerClassOne).Namespace!);\n\t\t\t\tfilters.AddIncludedNamespaceFilter(typeof(ClassWithTraits).Namespace!.ToUpperInvariant());\n\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", MethodWithNoTraits));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", MethodWithFooBarTrait));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", MethodWithBazBiffTrait));\n\t\t\t}"
      },
      {
        "name": "MultipleFilters_ActsAsAndOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddIncludedTraitFilter(\"fOo\", \"bAr\");\n\t\t\t\tfilters.AddIncludedTraitFilter(\"bAz\", \"bIff\");\n\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithNoTraits));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", MethodWithFooBarTrait));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", MethodWithBazBiffTrait));\n\t\t\t}"
      },
      {
        "name": "ActsAsAnAndOperation",
        "body": "{\n\t\t\t\tvar filters = new XunitFilters();\n\t\t\t\tfilters.AddIncludedClassFilter(typeof(InnerClassOne).FullName!);\n\t\t\t\tfilters.AddIncludedMethodFilter(\"*.nAmEtHrEe\");\n\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonClassTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", NonMethodTest));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameOne));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassOne_NameTwo));\n\t\t\t\tAssert.True(filters.Filter(\"asm1\", InnerClassOne_NameThree));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", InnerClassTwo_NameThree));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithNoTraits));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithFooBarTrait));\n\t\t\t\tAssert.False(filters.Filter(\"asm1\", MethodWithBazBiffTrait));\n\t\t\t}"
      },
      {
        "name": "NameOne",
        "body": "{ }"
      },
      {
        "name": "NameTwo",
        "body": "{ }"
      },
      {
        "name": "NameThree",
        "body": "{ }"
      },
      {
        "name": "NameThree",
        "body": "{ }"
      },
      {
        "name": "NoTraits",
        "body": "{ }"
      },
      {
        "name": "FooBar",
        "body": "{ }"
      },
      {
        "name": "BazBiff",
        "body": "{ }"
      }
    ]
  },
  {
    "file": "ConsoleRunnerLoggerTests.cs",
    "methods": [
      {
        "name": "LogError_InRed",
        "body": "{\n\t\t\tsut.LogError(\"This is an error message\");\n\n\t\t\tAssert.Equal(\"\\u001b[91mThis is an error message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());\n\t\t}"
      },
      {
        "name": "LogImportantMessage_InGray",
        "body": "{\n\t\t\tsut.LogImportantMessage(\"This is an important message\");\n\n\t\t\tAssert.Equal(\"\\u001b[37mThis is an important message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());\n\t\t}"
      },
      {
        "name": "LogMessage_InDarkGray",
        "body": "{\n\t\t\tsut.LogMessage(\"This is a message\");\n\n\t\t\tAssert.Equal(\"\\u001b[90mThis is a message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());\n\t\t}"
      },
      {
        "name": "LogRaw_NoColor",
        "body": "{\n\t\t\tsut.LogRaw(\"This is a raw message\");\n\n\t\t\tAssert.Equal(\"This is a raw message\" + Environment.NewLine, writer.ToString());\n\t\t}"
      },
      {
        "name": "LogWarning_InYellow",
        "body": "{\n\t\t\tsut.LogWarning(\"This is a warning message\");\n\n\t\t\tAssert.Equal(\"\\u001b[93mThis is a warning message\" + Environment.NewLine + \"\\u001b[0m\", writer.ToString());\n\t\t}"
      },
      {
        "name": "Disabled_DoesNotConsumesStdIn",
        "body": "{\n\t\t\tvar reader = new StringReader(Environment.NewLine + \"abc\");\n\t\t\tvar sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(reader, TextWriter.Null), waitForAcknowledgment: false);\n\n\t\t\tsut.WaitForAcknowledgment();\n\n\t\t\tAssert.Equal(Environment.NewLine + \"abc\", reader.ReadToEnd());\n\t\t}"
      },
      {
        "name": "Enabled_ConsumesOneLineFromStdIn",
        "body": "{\n\t\t\tvar reader = new StringReader(Environment.NewLine + \"abc\");\n\t\t\tvar sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(reader, TextWriter.Null), waitForAcknowledgment: true);\n\n\t\t\tsut.WaitForAcknowledgment();\n\n\t\t\tAssert.Equal(\"abc\", reader.ReadToEnd());\n\t\t}"
      },
      {
        "name": "ColorsEnabled_PlainText",
        "body": "{\n\t\t\tvar writer = new StringWriter();\n\t\t\tvar message = \"foo bar\";\n\t\t\tvar sut = new ConsoleRunnerLogger(true, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);\n\n\t\t\tsut.WriteLine(message);\n\n\t\t\tAssert.Equal(message + Environment.NewLine, writer.ToString());\n\t\t}"
      },
      {
        "name": "ColorsEnabled_AnsiText",
        "body": "{\n\t\t\tvar writer = new StringWriter();\n\t\t\tvar message = \"\\x1b[3m\\x1b[36mhello world\\u001b[0m || \\x1b[94;103mbright blue on bright yellow\\x1b[m\";\n\t\t\tvar sut = new ConsoleRunnerLogger(true, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);\n\n\t\t\tsut.WriteLine(message);\n\n\t\t\tAssert.Equal(message + Environment.NewLine, writer.ToString());\n\t\t}"
      },
      {
        "name": "ColorsDisabled_PlainText",
        "body": "{\n\t\t\tvar writer = new StringWriter();\n\t\t\tvar message = \"foo bar\";\n\t\t\tvar sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);\n\n\t\t\tsut.WriteLine(message);\n\n\t\t\tAssert.Equal(message + Environment.NewLine, writer.ToString());\n\t\t}"
      },
      {
        "name": "ColorsDisabled_AnsiText",
        "body": "{\n\t\t\tvar writer = new StringWriter();\n\t\t\tvar sut = new ConsoleRunnerLogger(false, false, new ConsoleHelper(TextReader.Null, writer), waitForAcknowledgment: false);\n\n\t\t\tsut.WriteLine(\"\\x1b[3m\\x1b[36mhello world\\u001b[0m || \\x1b[94;103mbright blue on bright yellow\\x1b[m\");\n\n\t\t\tAssert.Equal(\"hello world || bright blue on bright yellow\" + Environment.NewLine, writer.ToString());\n\t\t}"
      }
    ]
  },
  {
    "file": "MessageSinkMessageTests.cs",
    "methods": [
      {
        "name": "WithoutJsonTypeID_Throws",
        "body": "{\n\t\tvar msg = new DerivedMessageSinkMessage();\n\n\t\tvar ex = Record.Exception(() => msg.ToJson());\n\n\t\tAssert.IsType<InvalidOperationException>(ex);\n\t\tAssert.Equal($\"Message sink message type '{typeof(DerivedMessageSinkMessage).SafeName()}' is missing its [JsonTypeID] decoration\", ex.Message);\n\t}"
      },
      {
        "name": "SerializationExcludesNullValuesAndEmptyTraits",
        "body": "{\n\t\tvar startTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));\n\t\tvar msg = new TestAssemblyStarting\n\t\t{\n\t\t\tAssemblyUniqueID = \"asm-id\",\n\t\t\tAssemblyName = \"asm-name\",\n\t\t\tAssemblyPath = \"asm-path\",\n\t\t\tConfigFilePath = null,\n\t\t\tSeed = null,\n\t\t\tStartTime = startTime,\n\t\t\tTargetFramework = null,\n\t\t\tTestEnvironment = \"test-env\",\n\t\t\tTestFrameworkDisplayName = \"test-framework\",\n\t\t\tTraits = TestData.EmptyTraits,\n\t\t};\n\n\t\tvar json = msg.ToJson();\n\n\t\tAssert.NotNull(json);\n\t\tvar expected =\n@\"{\n    \"\"$type\"\":                    \"\"test-assembly-starting\"\",\n    \"\"AssemblyUniqueID\"\":         \"\"asm-id\"\",\n    \"\"AssemblyName\"\":             \"\"asm-name\"\",\n    \"\"AssemblyPath\"\":             \"\"asm-path\"\",\n    \"\"StartTime\"\":                \"\"2020-09-26T13:55:27.2120000-07:00\"\",\n    \"\"TestEnvironment\"\":          \"\"test-env\"\",\n    \"\"TestFrameworkDisplayName\"\": \"\"test-framework\"\"\n}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");\n\t\tAssert.Equal(expected, json);\n\t}"
      },
      {
        "name": "SerializesEnumsAsStringsAndExcludesEmptyOutput",
        "body": "{\n\t\tvar finishTime = new DateTimeOffset(2020, 09, 26, 13, 55, 27, 212, TimeSpan.FromHours(-7));\n\t\tvar msg = new TestFailed\n\t\t{\n\t\t\tAssemblyUniqueID = \"asm-id\",\n\t\t\tCause = FailureCause.Assertion,\n\t\t\tExceptionParentIndices = [-1],\n\t\t\tExceptionTypes = [\"exception-type\"],\n\t\t\tExecutionTime = 123.45m,\n\t\t\tFinishTime = finishTime,\n\t\t\tMessages = [\"exception-message\"],\n\t\t\tOutput = \"\",\n\t\t\tStackTraces = [null],\n\t\t\tTestCaseUniqueID = \"test-case-id\",\n\t\t\tTestClassUniqueID = null,\n\t\t\tTestCollectionUniqueID = \"test-collection-id\",\n\t\t\tTestMethodUniqueID = null,\n\t\t\tTestUniqueID = \"test-id\",\n\t\t\tWarnings = null,\n\t\t};\n\n\t\tvar json = msg.ToJson();\n\n\t\tAssert.NotNull(json);\n\t\tvar expected =\n@\"{\n    \"\"$type\"\":                  \"\"test-failed\"\",\n    \"\"AssemblyUniqueID\"\":       \"\"asm-id\"\",\n    \"\"TestCollectionUniqueID\"\": \"\"test-collection-id\"\",\n    \"\"TestCaseUniqueID\"\":       \"\"test-case-id\"\",\n    \"\"TestUniqueID\"\":           \"\"test-id\"\",\n    \"\"ExecutionTime\"\":          123.45,\n    \"\"FinishTime\"\":             \"\"2020-09-26T13:55:27.2120000-07:00\"\",\n    \"\"Cause\"\":                  \"\"Assertion\"\",\n    \"\"ExceptionParentIndices\"\": [-1],\n    \"\"ExceptionTypes\"\":         [\"\"exception-type\"\"],\n    \"\"Messages\"\":               [\"\"exception-message\"\"],\n    \"\"StackTraces\"\":            [null]\n}\".Replace(\"\\n\", \"\").Replace(\" \", \"\");\n\t\tAssert.Equal(expected, json);\n\t}"
      },
      {
        "name": "ValidatesAllDerivedTypesAreSupported",
        "body": "{\n\t\tvar excludedTypes = new HashSet<Type> {\n\t\t\ttypeof(MessageSinkMessage),\n\t\t\ttypeof(DerivedMessageSinkMessage),\n\t\t};\n\t\tvar derivedTypes =\n\t\t\ttypeof(MessageSinkMessage)\n\t\t\t\t.Assembly\n\t\t\t\t.GetTypes()\n\t\t\t\t.Where(t => !t.IsAbstract && !excludedTypes.Contains(t) && typeof(IMessageSinkMessage).IsAssignableFrom(t))\n\t\t\t\t.ToList();\n\t\tvar missingTypes =\n\t\t\tderivedTypes\n\t\t\t\t.Where(t => t.GetCustomAttribute<JsonTypeIDAttribute>() is null)\n\t\t\t\t.ToList();\n\n\t\tif (missingTypes.Count > 0)\n\t\t\tthrow new XunitException($\"The following message classes are missing [JsonTypeID]:{Environment.NewLine}{string.Join(Environment.NewLine, missingTypes.Select(t => $\"  - {t.SafeName()}\").OrderBy(t => t))}\");\n\t}"
      }
    ]
  },
  {
    "file": "TestFailedTests.cs",
    "methods": [
      {
        "name": "GuardClause",
        "body": "{\n\t\t\tvar ex = Record.Exception(() => new TestFailed\n\t\t\t{\n\t\t\t\tCause = (FailureCause)2112,\n\n\t\t\t\tAssemblyUniqueID = \"\",\n\t\t\t\tExceptionParentIndices = [],\n\t\t\t\tExceptionTypes = [],\n\t\t\t\tExecutionTime = 0,\n\t\t\t\tFinishTime = DateTimeOffset.UtcNow,\n\t\t\t\tMessages = [],\n\t\t\t\tOutput = \"\",\n\t\t\t\tStackTraces = [],\n\t\t\t\tTestCaseUniqueID = \"\",\n\t\t\t\tTestClassUniqueID = \"\",\n\t\t\t\tTestCollectionUniqueID = \"\",\n\t\t\t\tTestMethodUniqueID = \"\",\n\t\t\t\tTestUniqueID = \"\",\n\t\t\t\tWarnings = [],\n\t\t\t});\n\n\t\t\tvar argEx = Assert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"Cause\", argEx.ParamName);\n\t\t\tAssert.StartsWith($\"Enum value 2112 not in valid set: [Assertion, Exception, Other, Timeout]\", argEx.Message);\n\t\t}"
      },
      {
        "name": "NonAssertionException",
        "body": "{\n\t\t\tvar ex = new DivideByZeroException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Exception, failed.Cause);\n\t\t}"
      },
      {
        "name": "BuiltInAssertionException",
        "body": "{\n\t\t\tvar ex = EqualException.ForMismatchedValues(42, 2112);\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Assertion, failed.Cause);\n\t\t}"
      },
      {
        "name": "CustomAssertionException",
        "body": "{\n\t\t\tvar ex = new MyAssertionException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Assertion, failed.Cause);\n\t\t}"
      },
      {
        "name": "BuiltInTimeoutException",
        "body": "{\n\t\t\tvar ex = TestTimeoutException.ForTimedOutTest(2112);\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Timeout, failed.Cause);\n\t\t}"
      },
      {
        "name": "CustomTimeoutException",
        "body": "{\n\t\t\tvar ex = new MyTimeoutException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Timeout, failed.Cause);\n\t\t}"
      },
      {
        "name": "TimeoutExceptionTrumpsAssertionException",
        "body": "{\n\t\t\tvar ex = new MyMultiException();\n\n\t\t\tvar failed = TestFailed.FromException(ex, \"asm-id\", \"coll-id\", \"class-id\", \"method-id\", \"case-id\", \"test-id\", 21.12M, null, null);\n\n\t\t\tAssert.Equal(FailureCause.Timeout, failed.Cause);\n\t\t}"
      }
    ]
  },
  {
    "file": "DefaultRunnerReporterMessageHandlerTests.cs",
    "methods": [
      {
        "name": "ErrorMessage",
        "body": "{\n\t\t\tvar errorMessage = new ErrorMessage\n\t\t\t{\n\t\t\t\tExceptionParentIndices = exceptionParentIndices,\n\t\t\t\tExceptionTypes = exceptionTypes,\n\t\t\t\tMessages = messages,\n\t\t\t\tStackTraces = stackTraces,\n\t\t\t};\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(errorMessage);\n\n\t\t\tAssertFailureMessages(handler.Messages, \"FATAL ERROR\");\n\t\t}"
      },
      {
        "name": "TestAssemblyCleanupFailure",
        "body": "{\n\t\t\tvar assemblyStarting = TestData.TestAssemblyStarting(assemblyPath: @\"C:\\Foo\\bar.dll\");\n\t\t\tvar assemblyCleanupFailure = TestData.TestAssemblyCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(assemblyStarting);\n\t\t\thandler.OnMessage(assemblyCleanupFailure);\n\n\t\t\tAssertFailureMessages(handler.Messages, @\"Test Assembly Cleanup Failure (C:\\Foo\\bar.dll)\");\n\t\t}"
      },
      {
        "name": "TestCaseCleanupFailure",
        "body": "{\n\t\t\tvar caseStarting = TestData.TestCaseStarting(testCaseDisplayName: \"MyTestCase\");\n\t\t\tvar caseCleanupFailure = TestData.TestCaseCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(caseStarting);\n\t\t\thandler.OnMessage(caseCleanupFailure);\n\n\t\t\tAssertFailureMessages(handler.Messages, \"Test Case Cleanup Failure (MyTestCase)\");\n\t\t}"
      },
      {
        "name": "TestClassCleanupFailure",
        "body": "{\n\t\t\tvar classStarting = TestData.TestClassStarting(testClassName: \"MyType\");\n\t\t\tvar classCleanupFailure = TestData.TestClassCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(classStarting);\n\t\t\thandler.OnMessage(classCleanupFailure);\n\n\t\t\tAssertFailureMessages(handler.Messages, \"Test Class Cleanup Failure (MyType)\");\n\t\t}"
      },
      {
        "name": "TestCleanupFailure",
        "body": "{\n\t\t\tvar testStarting = TestData.TestStarting(testDisplayName: \"MyTest\");\n\t\t\tvar testCleanupFailure = TestData.TestCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(testStarting);\n\t\t\thandler.OnMessage(testCleanupFailure);\n\n\t\t\tAssertFailureMessages(handler.Messages, \"Test Cleanup Failure (MyTest)\");\n\t\t}"
      },
      {
        "name": "TestCollectionCleanupFailure",
        "body": "{\n\t\t\tvar collectionStarting = TestData.TestCollectionStarting(testCollectionDisplayName: \"FooBar\");\n\t\t\tvar collectionCleanupFailure = TestData.TestCollectionCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(collectionStarting);\n\t\t\thandler.OnMessage(collectionCleanupFailure);\n\n\t\t\tAssertFailureMessages(handler.Messages, \"Test Collection Cleanup Failure (FooBar)\");\n\t\t}"
      },
      {
        "name": "TestMethodCleanupFailure",
        "body": "{\n\t\t\tvar methodStarting = TestData.TestMethodStarting(methodName: \"MyMethod\");\n\t\t\tvar methodCleanupFailure = TestData.TestMethodCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(methodStarting);\n\t\t\thandler.OnMessage(methodCleanupFailure);\n\n\t\t\tAssertFailureMessages(handler.Messages, \"Test Method Cleanup Failure (MyMethod)\");\n\t\t}"
      },
      {
        "name": "LogsMessage",
        "body": "{\n\t\t\tvar message = TestData.TestAssemblyExecutionFinished();\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(message);\n\n\t\t\tvar msg = Assert.Single(handler.Messages);\n\t\t\tAssert.Equal(\"[Imp] =>   Finished:    test-assembly\", msg);\n\t\t}"
      },
      {
        "name": "LogsTestNameWithExceptionAndStackTraceAndOutput",
        "body": "{\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(failedMessage);\n\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages,\n\t\t\t\tmsg => Assert.Equal(\"[Err @ SomeFolder\\\\SomeClass.cs:18] =>     This is my display name \\\\t\\\\r\\\\n [FAIL]\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>       ExceptionType : This is my message \\t\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>       Message Line 2\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[--- @ SomeFolder\\\\SomeClass.cs:18] =>       Stack Trace:\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>         Line 1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>         SomeFolder\\\\SomeClass.cs(18,0): at SomeClass.SomeMethod()\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>         Line 3\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[--- @ SomeFolder\\\\SomeClass.cs:18] =>       Output:\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>         This is\\t\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp @ SomeFolder\\\\SomeClass.cs:18] =>         output\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[--- @ SomeFolder\\\\SomeClass.cs:18] =>       Warnings:\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Wrn @ SomeFolder\\\\SomeClass.cs:18] =>         • warning1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Wrn @ SomeFolder\\\\SomeClass.cs:18] =>         • warning2 line 1\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Wrn @ SomeFolder\\\\SomeClass.cs:18] =>           warning2 line 2\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "WithoutFlag_LogsNothing",
        "body": "{\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(outputMessage);\n\n\t\t\tAssert.Empty(handler.Messages);\n\t\t}"
      },
      {
        "name": "WithFlag_LogsOutput",
        "body": "{\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\t\t\thandler.OnMessage(TestData.TestAssemblyExecutionStarting(showLiveOutput: true));\n\t\t\thandler.OnMessage(TestData.TestAssemblyStarting());\n\t\t\thandler.Messages.Clear();  // Reset any output from previous messages\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(outputMessage);\n\n\t\t\tvar msg = Assert.Single(handler.Messages);\n\t\t\tAssert.Equal(\"[---] =>     This is my display name \\\\t\\\\r\\\\n [OUTPUT] This is\\\\t\\\\r\\\\noutput\", msg);\n\t\t}"
      },
      {
        "name": "DoesNotLogOutputByDefault",
        "body": "{\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\t\t\thandler.OnMessage(TestData.TestAssemblyExecutionStarting(diagnosticMessages: false));\n\t\t\thandler.OnMessage(TestData.TestAssemblyStarting());\n\t\t\thandler.Messages.Clear();  // Reset any output from previous messages\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(passedMessage);\n\n\t\t\tAssert.Empty(handler.Messages);\n\t\t}"
      },
      {
        "name": "LogsOutputWhenDiagnosticsAreEnabled",
        "body": "{\n\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\t\t\thandler.OnMessage(TestData.TestAssemblyExecutionStarting(diagnosticMessages: true));\n\t\t\thandler.OnMessage(TestData.TestAssemblyStarting());\n\t\t\thandler.Messages.Clear();  // Reset any output from previous messages\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(passedMessage);\n\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages,\n\t\t\t\tmsg => Assert.Equal(\"[Imp] =>     This is my display name \\\\t\\\\r\\\\n [PASS]\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[---] =>       Output:\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp] =>         This is\\t\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Imp] =>         output\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "DoesNotLogOutputWhenEnvVarIsSetupWithDiagnosticsEnabled",
        "body": "{\n\t\t\tusing (EnvironmentHelper.RestoreEnvironment(DefaultRunnerReporterMessageHandler.EnvVar_HidePassingOutput))\n\t\t\t{\n\t\t\t\tEnvironment.SetEnvironmentVariable(DefaultRunnerReporterMessageHandler.EnvVar_HidePassingOutput, \"1\");\n\n\t\t\t\tvar handler = TestableDefaultRunnerReporterMessageHandler.Create();\n\t\t\t\thandler.OnMessage(TestData.TestAssemblyExecutionStarting(diagnosticMessages: true));\n\t\t\t\thandler.OnMessage(TestData.TestAssemblyStarting());\n\t\t\t\thandler.Messages.Clear();  // Reset any output from previous messages\n\n\t\t\t\thandler.OnMessage(startingMessage);\n\t\t\t\thandler.OnMessage(passedMessage);\n\n\t\t\t\tAssert.Empty(handler.Messages);\n\t\t\t}\n\t\t}"
      }
    ]
  },
  {
    "file": "TeamCityReporterMessageHandlerTests.cs",
    "methods": [
      {
        "name": "ErrorMessage",
        "body": "{\n\t\t\tvar errorMessage = new ErrorMessage\n\t\t\t{\n\t\t\t\tExceptionParentIndices = exceptionParentIndices,\n\t\t\t\tExceptionTypes = exceptionTypes,\n\t\t\t\tMessages = messages,\n\t\t\t\tStackTraces = stackTraces\n\t\t\t};\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(errorMessage);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"FATAL ERROR\");\n\t\t}"
      },
      {
        "name": "TestAssemblyCleanupFailure",
        "body": "{\n\t\t\tvar collectionStarting = TestData.TestAssemblyStarting(assemblyUniqueID: assemblyID, assemblyPath: @\"C:\\Foo\\Bar.dll\");\n\t\t\tvar collectionCleanupFailure = TestData.TestAssemblyCleanupFailure(\n\t\t\t\tassemblyUniqueID: assemblyID,\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(collectionStarting);\n\t\t\thandler.OnMessage(collectionCleanupFailure);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Assembly Cleanup Failure (C:|0x005CFoo|0x005CBar.dll)\", assemblyID);\n\t\t}"
      },
      {
        "name": "TestCaseCleanupFailure",
        "body": "{\n\t\t\tvar caseStarting = TestData.TestCaseStarting(testCollectionUniqueID: collectionID, testCaseDisplayName: \"MyTestCase\\t\\r\\n\");\n\t\t\tvar caseCleanupFailure = TestData.TestCaseCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces,\n\t\t\t\ttestCollectionUniqueID: collectionID\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(caseStarting);\n\t\t\thandler.OnMessage(caseCleanupFailure);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Case Cleanup Failure (MyTestCase\\t|r|n)\", collectionID);\n\t\t}"
      },
      {
        "name": "TestClassCleanupFailure",
        "body": "{\n\t\t\tvar classStarting = TestData.TestClassStarting(testCollectionUniqueID: collectionID, testClassName: \"MyType\\t\\r\\n\");\n\t\t\tvar classCleanupFailure = TestData.TestClassCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces,\n\t\t\t\ttestCollectionUniqueID: collectionID\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(classStarting);\n\t\t\thandler.OnMessage(classCleanupFailure);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Class Cleanup Failure (MyType\\t|r|n)\", collectionID);\n\t\t}"
      },
      {
        "name": "TestCleanupFailure",
        "body": "{\n\t\t\tvar testStarting = TestData.TestStarting(testCollectionUniqueID: collectionID, testDisplayName: \"MyTest\\t\\r\\n\");\n\t\t\tvar testCleanupFailure = TestData.TestCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces,\n\t\t\t\ttestCollectionUniqueID: collectionID\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(testStarting);\n\t\t\thandler.OnMessage(testCleanupFailure);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Cleanup Failure (MyTest\\t|r|n)\", collectionID);\n\t\t}"
      },
      {
        "name": "TestCollectionCleanupFailure",
        "body": "{\n\t\t\tvar collectionStarting = TestData.TestCollectionStarting(testCollectionUniqueID: collectionID, testCollectionDisplayName: \"FooBar\\t\\r\\n\");\n\t\t\tvar collectionCleanupFailure = TestData.TestCollectionCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces,\n\t\t\t\ttestCollectionUniqueID: collectionID\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(collectionStarting);\n\t\t\thandler.OnMessage(collectionCleanupFailure);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Collection Cleanup Failure (FooBar\\t|r|n (test-collection-id\\t|r|n))\", collectionID);\n\t\t}"
      },
      {
        "name": "TestMethodCleanupFailure",
        "body": "{\n\t\t\tvar methodStarting = TestData.TestMethodStarting(testCollectionUniqueID: collectionID, methodName: \"MyMethod\\t\\r\\n\");\n\t\t\tvar methodCleanupFailure = TestData.TestMethodCleanupFailure(\n\t\t\t\texceptionParentIndices: exceptionParentIndices,\n\t\t\t\texceptionTypes: exceptionTypes,\n\t\t\t\tmessages: messages,\n\t\t\t\tstackTraces: stackTraces,\n\t\t\t\ttestCollectionUniqueID: collectionID\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(methodStarting);\n\t\t\thandler.OnMessage(methodCleanupFailure);\n\n\t\t\tAssertFailureMessage(handler.Messages.Where(msg => msg.Contains(\"##teamcity\")), \"Test Method Cleanup Failure (MyMethod\\t|r|n)\", collectionID);\n\t\t}"
      },
      {
        "name": "StartsAndEndsFlowAndSuite",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestAssemblyStarting(assemblyUniqueID: \"assembly-id\\t\\r\\n\", assemblyPath: @\"/path/to\\test-assembly.exe\");\n\t\t\tvar finishedMessage = TestData.TestAssemblyFinished(assemblyUniqueID: \"assembly-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(finishedMessage);\n\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages.Where(msg => msg.Contains(\"##teamcity\")),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[flowStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n']\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n' name='/path/to|0x005Ctest-assembly.exe']\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n' name='/path/to|0x005Ctest-assembly.exe']\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[flowFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n']\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "UsesRootFlowIDFromTeamCityEnvironment",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestAssemblyStarting(assemblyUniqueID: \"assembly-id\\t\\r\\n\", assemblyPath: \"test-assembly.exe\\t\\r\\n\");\n\t\t\tvar finishedMessage = TestData.TestAssemblyFinished(assemblyUniqueID: \"assembly-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create(\"root-flow-id\\t\\r\\n\");\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(finishedMessage);\n\n\t\t\tvar msg = handler.Messages.Where(msg => msg.Contains(\"##teamcity\")).First();\n\t\t\tAssert.Equal(\"[Raw] => ##teamcity[flowStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='assembly-id\\t|r|n' parent='root-flow-id\\t|r|n']\", msg);\n\t\t}"
      },
      {
        "name": "StartsAndEndsFlowAndSuite",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestCollectionStarting(testCollectionUniqueID: \"test-collection-id\\t\\r\\n\", testCollectionDisplayName: \"my-test-collection\\t\\r\\n\");\n\t\t\tvar finishedMessage = TestData.TestCollectionFinished(testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(finishedMessage);\n\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages.Where(msg => msg.Contains(\"##teamcity\")),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[flowStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' parent='assembly-id']\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='my-test-collection\\t|r|n (test-collection-id\\t|r|n)']\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testSuiteFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='my-test-collection\\t|r|n (test-collection-id\\t|r|n)']\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[flowFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n']\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "LogsTestFailed",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar failedMessage = TestData.TestFailed(\n\t\t\t\texceptionParentIndices: new[] { -1 },\n\t\t\t\texceptionTypes: new[] { \"ExceptionType\" },\n\t\t\t\texecutionTime: 1.2345m,\n\t\t\t\tmessages: new[] { \"This is my message \\t\\r\\n\" },\n\t\t\t\toutput: \"This is\\t\\r\\noutput\",\n\t\t\t\tstackTraces: new[] { \"Line 1\\r\\nLine 2\\r\\nLine 3\" },\n\t\t\t\ttestCollectionUniqueID: \"test-collection-id\\t\\r\\n\"\n\t\t\t);\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(failedMessage);\n\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages.Where(msg => msg.Contains(\"##teamcity\")),\n\t\t\t\tmsg => { }, // testStarting\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testFailed timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' details='ExceptionType : This is my message \t|r|n|r|nLine 1|r|nLine 2|r|nLine 3']\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "WithoutOutput",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar finishedMessage = TestData.TestFinished(executionTime: 1.2345m, output: \"\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(finishedMessage);\n\n\t\t\tvar msg = handler.Messages.Last();\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages.Where(msg => msg.Contains(\"##teamcity\")),\n\t\t\t\tmsg => { }, // testStarted\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' duration='1234']\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "WithOutput",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar finishedMessage = TestData.TestFinished(executionTime: 1.2345m, output: \"This is\\t\\r\\noutput\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(finishedMessage);\n\n\t\t\tvar msg = handler.Messages.Last();\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages.Where(msg => msg.Contains(\"##teamcity\")),\n\t\t\t\tmsg => { }, // testStarted\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testStdOut timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' out='This is\t|r|noutput' tc:tags='tc:parseServiceMessagesInside']]\", msg),\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testFinished timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' duration='1234']\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "LogsTestIgnored",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar skippedMessage = TestData.TestSkipped(reason: \"This is my skip reason \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\t\t\thandler.OnMessage(skippedMessage);\n\n\t\t\tAssert.Collection(\n\t\t\t\thandler.Messages.Where(msg => msg.Contains(\"##teamcity\")),\n\t\t\t\tmsg => { }, // testStarted\n\t\t\t\tmsg => Assert.Equal(\"[Raw] => ##teamcity[testIgnored timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n' message='This is my skip reason \\t|r|n']\", msg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "LogsTestName",
        "body": "{\n\t\t\tvar startingMessage = TestData.TestStarting(testDisplayName: \"This is my display name \\t\\r\\n\", testCollectionUniqueID: \"test-collection-id\\t\\r\\n\");\n\t\t\tvar handler = TestableTeamCityReporterMessageHandler.Create();\n\n\t\t\thandler.OnMessage(startingMessage);\n\n\t\t\tvar msg = Assert.Single(handler.Messages);\n\t\t\tAssert.Equal(\"[Raw] => ##teamcity[testStarted timestamp='2023-05-03T21:12:00.000+0000' flowId='test-collection-id\\t|r|n' name='This is my display name \\t|r|n']\", msg);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestMessageSinkTests.cs",
    "methods": []
  },
  {
    "file": "SpyTestMessageSink.cs",
    "methods": []
  },
  {
    "file": "MessageMetadataCacheTests.cs",
    "methods": [
      {
        "name": "AssemblyTest",
        "body": "{\n\t\tvar starting = TestData.TestAssemblyStarting();\n\t\tvar failure = TestData.TestAssemblyCleanupFailure();\n\t\tvar finished = TestData.TestAssemblyFinished();\n\t\tvar cache = new MessageMetadataCache();\n\n\t\t// Starts empty\n\t\tAssert.Null(cache.TryGetAssemblyMetadata(failure));\n\n\t\t// Set the cache, should be able to retrieve it\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryGetAssemblyMetadata(failure));\n\t\tAssert.Same(starting, cache.TryGetAssemblyMetadata(failure.AssemblyUniqueID, remove: false));\n\t\tAssert.Same(starting, cache.TryGetAssemblyMetadata(failure.AssemblyUniqueID, remove: true));\n\n\t\t// After removal, we're empty again\n\t\tAssert.Null(cache.TryGetAssemblyMetadata(failure));\n\n\t\t// Now set and use the explicit finish removal\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryRemove(finished));\n\n\t\t// Finish empty\n\t\tAssert.Null(cache.TryGetAssemblyMetadata(failure));\n\t}"
      },
      {
        "name": "TestCaseTest",
        "body": "{\n\t\tvar starting = TestData.TestCaseStarting();\n\t\tvar failure = TestData.TestCaseCleanupFailure();\n\t\tvar finished = TestData.TestCaseFinished();\n\t\tvar cache = new MessageMetadataCache();\n\n\t\t// Starts empty\n\t\tAssert.Null(cache.TryGetTestCaseMetadata(failure));\n\n\t\t// Set the cache, should be able to retrieve it\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryGetTestCaseMetadata(failure));\n\t\tAssert.Same(starting, cache.TryGetTestCaseMetadata(failure.TestCaseUniqueID, remove: false));\n\t\tAssert.Same(starting, cache.TryGetTestCaseMetadata(failure.TestCaseUniqueID, remove: true));\n\n\t\t// After removal, we're empty again\n\t\tAssert.Null(cache.TryGetTestCaseMetadata(failure));\n\n\t\t// Now set and use the explicit finish removal\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryRemove(finished));\n\n\t\t// Finish empty\n\t\tAssert.Null(cache.TryGetTestCaseMetadata(failure));\n\t}"
      },
      {
        "name": "TestClassTest",
        "body": "{\n\t\tvar starting = TestData.TestClassStarting();\n\t\tvar failure = TestData.TestClassCleanupFailure();\n\t\tvar finished = TestData.TestClassFinished();\n\t\tvar cache = new MessageMetadataCache();\n\n\t\t// Starts empty\n\t\tAssert.Null(cache.TryGetClassMetadata(failure));\n\n\t\t// Set the cache, should be able to retrieve it\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryGetClassMetadata(failure));\n\t\tAssert.Same(starting, cache.TryGetClassMetadata(failure.TestClassUniqueID!, remove: false));\n\t\tAssert.Same(starting, cache.TryGetClassMetadata(failure.TestClassUniqueID!, remove: true));\n\n\t\t// After removal, we're empty again\n\t\tAssert.Null(cache.TryGetClassMetadata(failure));\n\n\t\t// Now set and use the explicit finish removal\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryRemove(finished));\n\n\t\t// Finish empty\n\t\tAssert.Null(cache.TryGetClassMetadata(failure));\n\t}"
      },
      {
        "name": "TestCollectionTest",
        "body": "{\n\t\tvar starting = TestData.TestCollectionStarting();\n\t\tvar failure = TestData.TestCollectionCleanupFailure();\n\t\tvar finished = TestData.TestCollectionFinished();\n\t\tvar cache = new MessageMetadataCache();\n\n\t\t// Starts empty\n\t\tAssert.Null(cache.TryGetCollectionMetadata(failure));\n\n\t\t// Set the cache, should be able to retrieve it\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryGetCollectionMetadata(failure));\n\t\tAssert.Same(starting, cache.TryGetCollectionMetadata(failure.TestCollectionUniqueID, remove: false));\n\t\tAssert.Same(starting, cache.TryGetCollectionMetadata(failure.TestCollectionUniqueID, remove: true));\n\n\t\t// After removal, we're empty again\n\t\tAssert.Null(cache.TryGetCollectionMetadata(failure));\n\n\t\t// Now set and use the explicit finish removal\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryRemove(finished));\n\n\t\t// Finish empty\n\t\tAssert.Null(cache.TryGetCollectionMetadata(failure));\n\t}"
      },
      {
        "name": "TestTest",
        "body": "{\n\t\tvar starting = TestData.TestStarting();\n\t\tvar failure = TestData.TestCleanupFailure();\n\t\tvar finished = TestData.TestFinished();\n\t\tvar cache = new MessageMetadataCache();\n\n\t\t// Starts empty\n\t\tAssert.Null(cache.TryGetTestMetadata(failure));\n\n\t\t// Set the cache, should be able to retrieve it\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryGetTestMetadata(failure));\n\t\tAssert.Same(starting, cache.TryGetTestMetadata(failure.TestUniqueID, remove: false));\n\t\tAssert.Same(starting, cache.TryGetTestMetadata(failure.TestUniqueID, remove: true));\n\n\t\t// After removal, we're empty again\n\t\tAssert.Null(cache.TryGetTestMetadata(failure));\n\n\t\t// Now set and use the explicit finish removal\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryRemove(finished));\n\n\t\t// Finish empty\n\t\tAssert.Null(cache.TryGetTestMetadata(failure));\n\t}"
      },
      {
        "name": "TestMethodTest",
        "body": "{\n\t\tvar starting = TestData.TestMethodStarting();\n\t\tvar failure = TestData.TestMethodCleanupFailure();\n\t\tvar finished = TestData.TestMethodFinished();\n\t\tvar cache = new MessageMetadataCache();\n\n\t\t// Starts empty\n\t\tAssert.Null(cache.TryGetMethodMetadata(failure));\n\n\t\t// Set the cache, should be able to retrieve it\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryGetMethodMetadata(failure));\n\t\tAssert.Same(starting, cache.TryGetMethodMetadata(failure.TestMethodUniqueID!, remove: false));\n\t\tAssert.Same(starting, cache.TryGetMethodMetadata(failure.TestMethodUniqueID!, remove: true));\n\n\t\t// After removal, we're empty again\n\t\tAssert.Null(cache.TryGetMethodMetadata(failure));\n\n\t\t// Now set and use the explicit finish removal\n\t\tcache.Set(starting);\n\t\tAssert.Same(starting, cache.TryRemove(finished));\n\n\t\t// Finish empty\n\t\tAssert.Null(cache.TryGetMethodMetadata(failure));\n\t}"
      }
    ]
  },
  {
    "file": "MessageSinkMessageDeserializerTests.cs",
    "methods": []
  },
  {
    "file": "TestFrameworkOptionsReadWriteExtensions.cs",
    "methods": []
  },
  {
    "file": "ITestCaseFilter.cs",
    "methods": []
  },
  {
    "file": "ITestCaseFilterComposite.cs",
    "methods": []
  },
  {
    "file": "LongRunningTestsSummary.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyConfiguration.cs",
    "methods": []
  },
  {
    "file": "TestFrameworkOptions.cs",
    "methods": []
  },
  {
    "file": "TestProjectConfiguration.cs",
    "methods": []
  },
  {
    "file": "AfterTestFinished.cs",
    "methods": []
  },
  {
    "file": "AfterTestStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyMessage.cs",
    "methods": []
  },
  {
    "file": "TestCaseMessage.cs",
    "methods": []
  },
  {
    "file": "TestClassMessage.cs",
    "methods": []
  },
  {
    "file": "TestCollectionMessage.cs",
    "methods": []
  },
  {
    "file": "TestMessage.cs",
    "methods": []
  },
  {
    "file": "TestMethodMessage.cs",
    "methods": []
  },
  {
    "file": "TestResultMessage.cs",
    "methods": []
  },
  {
    "file": "BeforeTestFinished.cs",
    "methods": []
  },
  {
    "file": "BeforeTestStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyDiscoveryFinished.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyDiscoveryStarting.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyExecutionFinished.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyExecutionStarting.cs",
    "methods": []
  },
  {
    "file": "TestExecutionSummaries.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyFinished.cs",
    "methods": []
  },
  {
    "file": "TestAssemblyStarting.cs",
    "methods": []
  },
  {
    "file": "TestCaseCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCaseDiscovered.cs",
    "methods": []
  },
  {
    "file": "TestCaseFinished.cs",
    "methods": []
  },
  {
    "file": "TestCaseStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestClassConstructionFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassConstructionStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassDisposeFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassDisposeStarting.cs",
    "methods": []
  },
  {
    "file": "TestClassFinished.cs",
    "methods": []
  },
  {
    "file": "TestClassStarting.cs",
    "methods": []
  },
  {
    "file": "TestCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCollectionCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestCollectionFinished.cs",
    "methods": []
  },
  {
    "file": "TestCollectionStarting.cs",
    "methods": []
  },
  {
    "file": "TestFailed.cs",
    "methods": []
  },
  {
    "file": "TestFinished.cs",
    "methods": []
  },
  {
    "file": "TestMethodCleanupFailure.cs",
    "methods": []
  },
  {
    "file": "TestMethodFinished.cs",
    "methods": []
  },
  {
    "file": "TestMethodStarting.cs",
    "methods": []
  },
  {
    "file": "TestNotRun.cs",
    "methods": []
  },
  {
    "file": "TestOutput.cs",
    "methods": []
  },
  {
    "file": "TestPassed.cs",
    "methods": []
  },
  {
    "file": "TestSkipped.cs",
    "methods": []
  },
  {
    "file": "TestStarting.cs",
    "methods": []
  },
  {
    "file": "TestDiscoverySink.cs",
    "methods": []
  },
  {
    "file": "TestMessageSink.cs",
    "methods": []
  },
  {
    "file": "CommandLineTests.cs",
    "methods": [
      {
        "name": "UnknownOptionThrows",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(\"-unknown\");\n\n\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\tAssert.Equal(\"unknown option: -unknown\", exception.Message);\n\t\t}"
      },
      {
        "name": "AssemblyDoesNotExist_Throws",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(\"badAssembly.dll\");\n\n\t\t\tvar exception = Record.Exception(commandLine.Parse);\n\n\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\tAssert.Equal(\"assembly not found: badAssembly.dll\", exception.Message);\n\t\t}"
      },
      {
        "name": "SingleAssembly_NoConfigFile",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location);\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tvar assembly = Assert.Single(project.Assemblies);\n\t\t\tAssert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);\n\t\t\tAssert.Null(assembly.ConfigFileName);\n\t\t}"
      },
      {
        "name": "SingleAssembly_WithConfigFile",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"assembly1.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tvar assembly = Assert.Single(project.Assemblies);\n\t\t\tAssert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);\n\t\t\tvar assemblyFolder = Guard.NotNull(\"Assembly folder cannot be null\", Path.GetDirectoryName(typeof(CommandLineTests).Assembly.Location));\n\t\t\tAssert.Equal(Path.Combine(assemblyFolder, \"assembly1.json\"), assembly.ConfigFileName);\n\t\t}"
      },
      {
        "name": "MultipleAssemblies_NoConfigFiles",
        "body": "{\n\t\t\tvar arguments = new[] { typeof(CommandLineTests).Assembly.Location, typeof(CommandLine).Assembly.Location };\n\t\t\tvar commandLine = new TestableCommandLine(arguments);\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Collection(\n\t\t\t\tproject.Assemblies,\n\t\t\t\ta =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(typeof(CommandLineTests).Assembly.Location, a.AssemblyFileName);\n\t\t\t\t\tAssert.Null(a.ConfigFileName);\n\t\t\t\t},\n\t\t\t\ta =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(typeof(CommandLine).Assembly.Location, a.AssemblyFileName);\n\t\t\t\t\tAssert.Null(a.ConfigFileName);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NoColorSetsEnvironmentVariable",
        "body": "{\n\t\t\tAssert.Null(Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor));\n\n\t\t\tnew TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-nocolor\").Parse();\n\n\t\t\t// Any set (non-null, non-empty) value is acceptable, see https://no-color.org/\n\t\t\tvar envValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor);\n\t\t\tAssert.NotNull(envValue);\n\t\t\tAssert.NotEmpty(envValue);\n\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.AppDomain);\n\t\t\t}"
      },
      {
        "name": "MissingValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\");\n\n\t\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"missing argument for -appdomains\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "InvalidValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\", \"foo\");\n\n\t\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"incorrect argument value for -appdomains (must be 'denied', 'required', or 'ifavailable')\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "ExplicitDefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"default\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "InvariantCultureIsEmptyString",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"invariant\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Equal(string.Empty, assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "ValueIsPreserved",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"foo\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Equal(\"foo\", assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t{\n\t\t\t\t\tAssert.Null(assembly.Configuration.DiagnosticMessages);\n\t\t\t\t\tAssert.Null(assembly.Configuration.LongRunningTestSeconds);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "MissingValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\");\n\n\t\t\t\tvar exception = Record.Exception(commandLine.Parse);\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"missing argument for -longRunning\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "InvalidValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\", \"abc\");\n\n\t\t\t\tvar exception = Record.Exception(commandLine.Parse);\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"incorrect argument value for -longRunning (must be a positive integer)\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "ValidValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-LONGRUNNING\", \"123\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t{\n\t\t\t\t\tAssert.True(assembly.Configuration.DiagnosticMessages);\n\t\t\t\t\tAssert.Equal(123, assembly.Configuration.LongRunningTestSeconds);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.MaxParallelThreads);\n\t\t\t}"
      },
      {
        "name": "MissingValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-maxthreads\");\n\n\t\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"missing argument for -maxThreads\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "ParallelizationOptionsAreNullByDefault",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t{\n\t\t\t\t\tAssert.Null(assembly.Configuration.ParallelizeAssembly);\n\t\t\t\t\tAssert.Null(assembly.Configuration.ParallelizeTestCollections);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "FailsWithoutOptionOrWithIncorrectOptions",
        "body": "{\n\t\t\t\tvar commandLine1 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\");\n\t\t\t\tvar exception1 = Record.Exception(() => commandLine1.Parse());\n\t\t\t\tAssert.IsType<ArgumentException>(exception1);\n\t\t\t\tAssert.Equal(\"missing argument for -parallel\", exception1.Message);\n\n\t\t\t\tvar commandLine2 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\", \"nonsense\");\n\t\t\t\tvar exception2 = Record.Exception(() => commandLine2.Parse());\n\t\t\t\tAssert.IsType<ArgumentException>(exception2);\n\t\t\t\tAssert.Equal(\"incorrect argument value for -parallel\", exception2.Message);\n\t\t\t}"
      },
      {
        "name": "DefaultFilters",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tvar filters = project.Assemblies.Single().Configuration.Filters;\n\t\t\tAssert.True(filters.Empty);\n\t\t}"
      },
      {
        "name": "NoReporters_UsesDefaultReporter",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter",
        "body": "{\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false);\n\t\t\tvar commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar commandLine = new TestableCommandLine([explicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Same(explicitReporter, project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar commandLine = new TestableCommandLine([explicitReporter, implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Same(implicitReporter, project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter",
        "body": "{\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-noautoreporters\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar commandLine = new TestableCommandLine([explicitReporter, implicitReporter1, implicitReporter2], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Same(implicitReporter1, project.RunnerReporter);\n\t\t}"
      }
    ]
  },
  {
    "file": "CommandLineTests.cs",
    "methods": [
      {
        "name": "UnknownOptionThrows",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(\"-unknown\");\n\n\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\tAssert.Equal(\"unknown option: -unknown\", exception.Message);\n\t\t}"
      },
      {
        "name": "AssemblyDoesNotExist_Throws",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(\"badAssembly.dll\");\n\n\t\t\tvar exception = Record.Exception(commandLine.Parse);\n\n\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\tAssert.Equal(\"assembly not found: badAssembly.dll\", exception.Message);\n\t\t}"
      },
      {
        "name": "SingleAssembly_NoConfigFile",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location);\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tvar assembly = Assert.Single(project.Assemblies);\n\t\t\tAssert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);\n\t\t\tAssert.Null(assembly.ConfigFileName);\n\t\t}"
      },
      {
        "name": "SingleAssembly_WithConfigFile",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"assembly1.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tvar assembly = Assert.Single(project.Assemblies);\n\t\t\tAssert.Equal(typeof(CommandLineTests).Assembly.Location, assembly.AssemblyFileName);\n\t\t\tvar assemblyFolder = Guard.NotNull(\"Assembly folder cannot be null\", Path.GetDirectoryName(typeof(CommandLineTests).Assembly.Location));\n\t\t\tAssert.Equal(Path.Combine(assemblyFolder, \"assembly1.json\"), assembly.ConfigFileName);\n\t\t}"
      },
      {
        "name": "MultipleAssemblies_NoConfigFiles",
        "body": "{\n\t\t\tvar arguments = new[] { typeof(CommandLineTests).Assembly.Location, typeof(CommandLine).Assembly.Location };\n\t\t\tvar commandLine = new TestableCommandLine(arguments);\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Collection(\n\t\t\t\tproject.Assemblies,\n\t\t\t\ta =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(typeof(CommandLineTests).Assembly.Location, a.AssemblyFileName);\n\t\t\t\t\tAssert.Null(a.ConfigFileName);\n\t\t\t\t},\n\t\t\t\ta =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(typeof(CommandLine).Assembly.Location, a.AssemblyFileName);\n\t\t\t\t\tAssert.Null(a.ConfigFileName);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "NoColorSetsEnvironmentVariable",
        "body": "{\n\t\t\tAssert.Null(Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor));\n\n\t\t\tnew TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-nocolor\").Parse();\n\n\t\t\t// Any set (non-null, non-empty) value is acceptable, see https://no-color.org/\n\t\t\tvar envValue = Environment.GetEnvironmentVariable(TestProjectConfiguration.EnvNameNoColor);\n\t\t\tAssert.NotNull(envValue);\n\t\t\tAssert.NotEmpty(envValue);\n\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.AppDomain);\n\t\t\t}"
      },
      {
        "name": "MissingValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\");\n\n\t\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"missing argument for -appdomains\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "InvalidValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-appdomains\", \"foo\");\n\n\t\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"incorrect argument value for -appdomains (must be 'denied', 'required', or 'ifavailable')\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "ExplicitDefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"default\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "InvariantCultureIsEmptyString",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"invariant\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Equal(string.Empty, assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "ValueIsPreserved",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-culture\", \"foo\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Equal(\"foo\", assembly.Configuration.Culture);\n\t\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t{\n\t\t\t\t\tAssert.Null(assembly.Configuration.DiagnosticMessages);\n\t\t\t\t\tAssert.Null(assembly.Configuration.LongRunningTestSeconds);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "MissingValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\");\n\n\t\t\t\tvar exception = Record.Exception(commandLine.Parse);\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"missing argument for -longRunning\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "InvalidValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-longrunning\", \"abc\");\n\n\t\t\t\tvar exception = Record.Exception(commandLine.Parse);\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"incorrect argument value for -longRunning (must be a positive integer)\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "ValidValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-LONGRUNNING\", \"123\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t{\n\t\t\t\t\tAssert.True(assembly.Configuration.DiagnosticMessages);\n\t\t\t\t\tAssert.Equal(123, assembly.Configuration.LongRunningTestSeconds);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "DefaultValueIsNull",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t\tAssert.Null(assembly.Configuration.MaxParallelThreads);\n\t\t\t}"
      },
      {
        "name": "MissingValue",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-maxthreads\");\n\n\t\t\t\tvar exception = Record.Exception(() => commandLine.Parse());\n\n\t\t\t\tAssert.IsType<ArgumentException>(exception);\n\t\t\t\tAssert.Equal(\"missing argument for -maxThreads\", exception.Message);\n\t\t\t}"
      },
      {
        "name": "ParallelizationOptionsAreNullByDefault",
        "body": "{\n\t\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\t\tvar project = commandLine.Parse();\n\n\t\t\t\tforeach (var assembly in project.Assemblies)\n\t\t\t\t{\n\t\t\t\t\tAssert.Null(assembly.Configuration.ParallelizeAssembly);\n\t\t\t\t\tAssert.Null(assembly.Configuration.ParallelizeTestCollections);\n\t\t\t\t}\n\t\t\t}"
      },
      {
        "name": "FailsWithoutOptionOrWithIncorrectOptions",
        "body": "{\n\t\t\t\tvar commandLine1 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\");\n\t\t\t\tvar exception1 = Record.Exception(() => commandLine1.Parse());\n\t\t\t\tAssert.IsType<ArgumentException>(exception1);\n\t\t\t\tAssert.Equal(\"missing argument for -parallel\", exception1.Message);\n\n\t\t\t\tvar commandLine2 = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-parallel\", \"nonsense\");\n\t\t\t\tvar exception2 = Record.Exception(() => commandLine2.Parse());\n\t\t\t\tAssert.IsType<ArgumentException>(exception2);\n\t\t\t\tAssert.Equal(\"incorrect argument value for -parallel\", exception2.Message);\n\t\t\t}"
      },
      {
        "name": "DefaultFilters",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tvar filters = project.Assemblies.Single().Configuration.Filters;\n\t\t\tAssert.True(filters.Empty);\n\t\t}"
      },
      {
        "name": "NoReporters_UsesDefaultReporter",
        "body": "{\n\t\t\tvar commandLine = new TestableCommandLine(typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter",
        "body": "{\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false);\n\t\t\tvar commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar commandLine = new TestableCommandLine([explicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Same(explicitReporter, project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar commandLine = new TestableCommandLine([explicitReporter, implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-reporter\", \"switch\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Same(implicitReporter, project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter",
        "body": "{\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar commandLine = new TestableCommandLine([implicitReporter], typeof(CommandLineTests).Assembly.Location, \"no-config.json\", \"-noautoreporters\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(project.RunnerReporter);\n\t\t}"
      },
      {
        "name": "NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar commandLine = new TestableCommandLine([explicitReporter, implicitReporter1, implicitReporter2], typeof(CommandLineTests).Assembly.Location, \"no-config.json\");\n\n\t\t\tvar project = commandLine.Parse();\n\n\t\t\tAssert.Same(implicitReporter1, project.RunnerReporter);\n\t\t}"
      }
    ]
  },
  {
    "file": "CommandLineOptionsProviderTests.cs",
    "methods": [
      {
        "name": "GuardClauses",
        "body": "{\n\t\tAssert.Throws<ArgumentNullException>(\"configuration\", () => CommandLineOptionsProvider.Parse(null!, commandLineOptions, projectAssembly));\n\t\tAssert.Throws<ArgumentNullException>(\"commandLineOptions\", () => CommandLineOptionsProvider.Parse(configuration, null!, projectAssembly));\n\t\tAssert.Throws<ArgumentNullException>(\"projectAssembly\", () => CommandLineOptionsProvider.Parse(configuration, commandLineOptions, null!));\n\t}"
      },
      {
        "name": "AutoReporters_Invalid",
        "body": "{\n\t\t\tcommandLineOptions.Set(\"auto-reporters\", [\"foo\"]);\n\n\t\t\tvar ex = Record.Exception(() => CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly));\n\n\t\t\tAssert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal(\"Invalid value 'foo' (must be one of: 'on', 'off')\", ex.Message);\n\t\t}"
      },
      {
        "name": "ConfigFile",
        "body": "{\n\t\t\tcommandLineOptions.Set(\"xunit-config-filename\", [\"foo-bar-baz.json\"]);\n\n\t\t\tvar ex = Record.Exception(() => CommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly));\n\n\t\t\tAssert.IsType<ArgumentException>(ex);\n\t\t\tAssert.Equal($\"Config file '{Path.GetFullPath(\"foo-bar-baz.json\")}' was not found\", ex.Message);\n\t\t}"
      },
      {
        "name": "LongRunning",
        "body": "{\n\t\t\tcommandLineOptions.Set(\"long-running\", [\"123\"]);\n\n\t\t\tCommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly);\n\n\t\t\tAssert.Equal(123, projectAssembly.Configuration.LongRunningTestSeconds);\n\t\t}"
      },
      {
        "name": "Seed",
        "body": "{\n\t\t\tcommandLineOptions.Set(\"seed\", [\"42\"]);\n\n\t\t\tCommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly);\n\n\t\t\tAssert.Equal(42, projectAssembly.Configuration.Seed);\n\t\t}"
      },
      {
        "name": "FilterTraits",
        "body": "{\n\t\t\tcommandLineOptions.Set(\"filter-trait\", [\"foo=bar\"]);\n\t\t\tcommandLineOptions.Set(\"filter-not-trait\", [\"baz=biff\"]);\n\n\t\t\tCommandLineOptionsProvider.Parse(configuration, commandLineOptions, projectAssembly);\n\n\t\t\tAssert.Collection(\n\t\t\t\tprojectAssembly.Configuration.Filters.ToXunit3Arguments(),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"foo=bar\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"baz=biff\", arg)\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "LoggerDiagnosticMessageSinkTests.cs",
    "methods": []
  },
  {
    "file": "LoggerRunnerLoggerTests.cs",
    "methods": []
  },
  {
    "file": "OutputDeviceDiagnosticMessageSinkTests.cs",
    "methods": []
  },
  {
    "file": "OutputDeviceRunnerLoggerTests.cs",
    "methods": []
  },
  {
    "file": "SpyTestPlatformLogger.cs",
    "methods": []
  },
  {
    "file": "SpyTestPlatformMessageBus.cs",
    "methods": []
  },
  {
    "file": "SpyTestPlatformOutputDevice.cs",
    "methods": []
  },
  {
    "file": "TestPlatformDiscoveryMessageSinkTests.cs",
    "methods": [
      {
        "name": "ReturnsFalseWhenCancellationTokenIsCancelled",
        "body": "{\n\t\tvar message = TestData.DiagnosticMessage();\n\t\tvar classUnderTest = TestableTestPlatformDiscoveryMessageSink.Create();\n\t\tclassUnderTest.InnerSink.Callback = _ => true;\n\t\tclassUnderTest.CancellationTokenSource.Cancel();\n\n\t\tvar result = classUnderTest.OnMessage(message);\n\n\t\tAssert.False(result);\n\t}"
      },
      {
        "name": "ITestCaseDiscovered",
        "body": "{\n\t\t\tvar discovered = TestData.TestCaseDiscovered(\n\t\t\t\tsourceFilePath: \"/path/to/file.cs\",\n\t\t\t\tsourceLineNumber: 42,\n\t\t\t\ttestClassName: \"test-class\",\n\t\t\t\ttestMethodName: \"test-method\",\n\t\t\t\ttestMethodParameterTypesVSTest: [\"System.Int32\", \"System.String\"],\n\t\t\t\ttestMethodReturnTypeVSTest: \"System.Void\",\n\t\t\t\ttestClassNamespace: \"ns\",\n\t\t\t\ttraits: TestData.DefaultTraits\n\t\t\t);\n\t\t\tvar classUnderTest = TestableTestPlatformDiscoveryMessageSink.Create();\n\n\t\t\tclassUnderTest.OnMessage(discovered);\n\n\t\t\tvar message = Assert.Single(classUnderTest.TestNodeMessageBus.PublishedData);\n\t\t\tvar updateMessage = Assert.IsType<TestNodeUpdateMessage>(message);\n\t\t\tvar testNode = updateMessage.TestNode;\n\t\t\tAssert.Equal(\"test-case-display-name\", testNode.DisplayName);\n\t\t\tAssert.Equal(\"test-case-id\", testNode.Uid.Value);\n\n\t\t\tvar testMethodProperty = testNode.Properties.Single<TestMethodIdentifierProperty>();\n\t\t\tAssert.Equal(AssemblyFullName, testMethodProperty.AssemblyFullName);\n\t\t\tAssert.Equal(\"test-method\", testMethodProperty.MethodName);\n\t\t\tAssert.Equal(\"ns\", testMethodProperty.Namespace);\n\t\t\tAssert.Equivalent(new[] { \"System.Int32\", \"System.String\" }, testMethodProperty.ParameterTypeFullNames);\n\t\t\tAssert.Equal(\"System.Void\", testMethodProperty.ReturnTypeFullName);\n\t\t\tAssert.Equal(\"test-class\", testMethodProperty.TypeName);\n\n\t\t\tvar testLocationProperty = testNode.Properties.Single<TestFileLocationProperty>();\n\t\t\tAssert.Equal(\"/path/to/file.cs\", testLocationProperty.FilePath);\n\t\t\tAssert.Equal(42, testLocationProperty.LineSpan.Start.Line);\n\t\t\tAssert.Equal(-1, testLocationProperty.LineSpan.Start.Column);\n\t\t\tAssert.Equal(42, testLocationProperty.LineSpan.End.Line);\n\t\t\tAssert.Equal(-1, testLocationProperty.LineSpan.End.Column);\n\n\t\t\tvar testMetadataProperties = testNode.Properties.OfType<TestMetadataProperty>();\n\t\t\tAssert.Collection(\n\t\t\t\ttestMetadataProperties.OrderBy(p => p.Key).ThenBy(p => p.Value).Select(p => $\"'{p.Key}' = '{p.Value}'\"),\n\t\t\t\tkeyValue => Assert.Equal(\"'biff' = 'bang'\", keyValue),\n\t\t\t\tkeyValue => Assert.Equal(\"'foo' = 'bar'\", keyValue),\n\t\t\t\tkeyValue => Assert.Equal(\"'foo' = 'baz'\", keyValue)\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestPlatformExecutionMessageSinkTests.cs",
    "methods": [
      {
        "name": "ReturnsFalseWhenCancellationTokenIsCancelled",
        "body": "{\n\t\tvar message = TestData.DiagnosticMessage();\n\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create();\n\t\tclassUnderTest.InnerSink.Callback = _ => true;\n\t\tclassUnderTest.CancellationTokenSource.Cancel();\n\n\t\tvar result = classUnderTest.OnMessage(message);\n\n\t\tAssert.False(result);\n\t}"
      },
      {
        "name": "ITestFailed_Timeout",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create();\n\t\t\tSendStartingMessages(classUnderTest);\n\n\t\t\tSendTestFailed(classUnderTest, FailureCause.Timeout);\n\n\t\t\tvar testNode = AssertStandardMetadata(classUnderTest);\n\t\t\tvar timeout = testNode.Properties.Single<TimeoutTestNodeStateProperty>();\n\t\t\tAssert.Equal($\"exception 1 : message 1{Environment.NewLine}---- exception 2 : message 2\", timeout.Explanation);\n\t\t\tAssert.NotNull(timeout.Exception);\n\t\t\tAssert.Equal($\"exception 1 : message 1{Environment.NewLine}---- exception 2 : message 2\", timeout.Exception.Message);\n\t\t\tAssert.Equal($\"stack trace 1{Environment.NewLine}----- Inner Stack Trace -----{Environment.NewLine}stack trace 2\", timeout.Exception.StackTrace);\n\t\t}"
      },
      {
        "name": "ITestNotRun",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create();\n\t\t\tSendStartingMessages(classUnderTest);\n\n\t\t\tclassUnderTest.OnMessage(TestData.TestNotRun());\n\n\t\t\tAssert.Empty(classUnderTest.TestNodeMessageBus.PublishedData);\n\t\t}"
      },
      {
        "name": "ITestSkipped",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create();\n\t\t\tSendStartingMessages(classUnderTest);\n\n\t\t\tclassUnderTest.OnMessage(TestData.TestSkipped());\n\n\t\t\tvar testNode = AssertStandardMetadata(classUnderTest);\n\t\t\tvar skipped = testNode.Properties.Single<SkippedTestNodeStateProperty>();\n\t\t\tAssert.Equal(TestData.DefaultSkipReason, skipped.Explanation);\n\t\t}"
      },
      {
        "name": "ITestStarting",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create();\n\t\t\tSendStartingMessages(classUnderTest, includeTestStarting: false);\n\n\t\t\tclassUnderTest.OnMessage(TestData.TestStarting());\n\n\t\t\tvar testNode = AssertStandardMetadata(classUnderTest, expectTiming: false);\n\t\t\tvar inProgress = testNode.Properties.Single<InProgressTestNodeStateProperty>();\n\t\t\tAssert.Null(inProgress.Explanation);\n\t\t}"
      },
      {
        "name": "ITestOutput_Off",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create(showLiveOutput: false);\n\n\t\t\tclassUnderTest.OnMessage(TestData.TestOutput());\n\n\t\t\tAssert.Empty(classUnderTest.OutputDevice.DisplayedData);\n\t\t}"
      },
      {
        "name": "ITestOutput_On",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create(showLiveOutput: true);\n\t\t\tSendStartingMessages(classUnderTest);\n\n\t\t\tclassUnderTest.OnMessage(TestData.TestOutput());\n\n\t\t\tvar data = Assert.Single(classUnderTest.OutputDevice.DisplayedData);\n\t\t\tAssertColorOutput(data, $\"OUTPUT: [{TestData.DefaultTestDisplayName}] {TestData.DefaultOutput}\", ConsoleColor.DarkGray);\n\t\t}"
      },
      {
        "name": "Warnings",
        "body": "{\n\t\t\tvar classUnderTest = TestableTestPlatformExecutionMessageSink.Create();\n\t\t\tSendStartingMessages(classUnderTest);\n\n\t\t\tclassUnderTest.OnMessage(TestData.TestPassed(warnings: [\"w1\", \"w2\"]));\n\n\t\t\tAssertStandardMetadata(classUnderTest, expectWarnings: true);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestPlatformTestFrameworkTests.cs",
    "methods": [
      {
        "name": "CanCreateAndCloseSession",
        "body": "{\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\n\t\t\tvar createResult = framework.CreateTestSession(uid);\n\n\t\t\tAssert.True(createResult.IsSuccess);\n\n\t\t\tvar closeResult = framework.CloseTestSession(uid);\n\n\t\t\tAssert.True(closeResult.IsSuccess);\n\t\t}"
      },
      {
        "name": "CreateSession_WithLogo",
        "body": "{\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\t\t\tframework.ProjectAssembly.Project.Configuration.NoLogo = false;\n\n\t\t\tframework.CreateTestSession(uid);\n\n\t\t\tvar log = Assert.Single(framework.RunnerLogger.Messages);\n\t\t\tAssert.StartsWith(\"[Imp] xUnit.net v3 In-Process Runner\", log);\n\t\t}"
      },
      {
        "name": "CreateSession_WithoutLogo",
        "body": "{\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\t\t\tframework.ProjectAssembly.Project.Configuration.NoLogo = true;\n\n\t\t\tframework.CreateTestSession(uid);\n\n\t\t\tAssert.Empty(framework.RunnerLogger.Messages);\n\t\t}"
      },
      {
        "name": "CannotCreateSameSessionTwice",
        "body": "{\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\n\t\t\tvar firstResult = framework.CreateTestSession(uid);\n\t\t\tvar secondResult = framework.CreateTestSession(uid);\n\n\t\t\tAssert.True(firstResult.IsSuccess);\n\t\t\tAssert.False(secondResult.IsSuccess);\n\t\t\tAssert.Equal(\"Attempted to reuse session UID 'abc' already in progress\", secondResult.ErrorMessage);\n\t\t}"
      },
      {
        "name": "CannotCloseUnstartedSession",
        "body": "{\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\n\t\t\tvar result = framework.CloseTestSession(uid);\n\n\t\t\tAssert.False(result.IsSuccess);\n\t\t\tAssert.Equal(\"Attempted to close unknown session UID 'abc'\", result.ErrorMessage);\n\t\t}"
      },
      {
        "name": "CannotRecloseSession",
        "body": "{\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\n\t\t\tframework.CreateTestSession(uid);\n\t\t\tvar firstResult = framework.CloseTestSession(uid);\n\t\t\tvar secondResult = framework.CloseTestSession(uid);\n\n\t\t\tAssert.True(firstResult.IsSuccess);\n\t\t\tAssert.False(secondResult.IsSuccess);\n\t\t\tAssert.Equal(\"Attempted to close unknown session UID 'abc'\", secondResult.ErrorMessage);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar completionCalled = false;\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar messageBus = new SpyTestPlatformMessageBus();\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => framework.OnDiscover(uid, messageBus, () => completionCalled = true, CancellationToken.None));\n\n\t\t\tAssert.False(completionCalled);\n\t\t\tAssert.IsType<ArgumentException>(ex);\n\t\t\tAssert.StartsWith(\"Attempted to execute request against unknown session UID 'abc'\", ex.Message);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar completionCalled = false;\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar messageBus = new SpyTestPlatformMessageBus();\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\n\t\t\tvar ex = await Record.ExceptionAsync(() => framework.OnExecute(uid, filter: null, messageBus, () => completionCalled = true, CancellationToken.None));\n\n\t\t\tAssert.False(completionCalled);\n\t\t\tAssert.IsType<ArgumentException>(ex);\n\t\t\tAssert.StartsWith(\"Attempted to execute request against unknown session UID 'abc'\", ex.Message);\n\t\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\t\tvar completionCalled = false;\n\t\t\tvar uid = new SessionUid(\"abc\");\n\t\t\tvar messageBus = new SpyTestPlatformMessageBus();\n\t\t\tvar framework = TestableTestPlatformTestFramework.Create();\n\t\t\tframework.ProjectAssembly.Configuration.Filters.AddIncludedClassFilter(typeof(SessionManagement).FullName!);\n\t\t\tframework.CreateTestSession(uid);\n\n\t\t\t// Discover tests\n\n\t\t\tawait framework.OnDiscover(uid, messageBus, () => completionCalled = true, CancellationToken.None);\n\n\t\t\tAssert.True(completionCalled);\n\t\t\tvar testNodeUpdates = messageBus.PublishedData.OfType<TestNodeUpdateMessage>().ToArray();\n\t\t\tAssert.Collection(\n\t\t\t\ttestNodeUpdates.Select(tnu => tnu.TestNode.DisplayName).OrderBy(x => x),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CanCreateAndCloseSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCloseUnstartedSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCreateSameSessionTwice)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotRecloseSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithLogo)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithoutLogo)}\", testCaseDisplayName)\n\t\t\t);\n\n\t\t\t// Reset observation\n\n\t\t\tmessageBus.PublishedData.Clear();\n\t\t\tcompletionCalled = false;\n\n\t\t\t// Execute the discovered tests\n\n\t\t\tvar testNodeUIDs = testNodeUpdates.Select(tnu => tnu.TestNode.Uid).ToArray();\n\t\t\tvar filter = new TestNodeUidListFilter(testNodeUIDs);\n\n\t\t\tawait framework.OnExecute(uid, filter, messageBus, () => completionCalled = true, CancellationToken.None);\n\n\t\t\tAssert.True(completionCalled);\n\t\t\ttestNodeUpdates = messageBus.PublishedData.OfType<TestNodeUpdateMessage>().ToArray();\n\t\t\tvar inProgressTestNodes = testNodeUpdates.Where(tnu => tnu.TestNode.Properties.Any<InProgressTestNodeStateProperty>()).ToArray();\n\t\t\tAssert.Collection(\n\t\t\t\tinProgressTestNodes.Select(tnu => tnu.TestNode.DisplayName).OrderBy(x => x),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CanCreateAndCloseSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCloseUnstartedSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCreateSameSessionTwice)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotRecloseSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithLogo)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithoutLogo)}\", testCaseDisplayName)\n\t\t\t);\n\t\t\tvar passingTestNodes = testNodeUpdates.Where(tnu => tnu.TestNode.Properties.Any<PassedTestNodeStateProperty>()).ToArray();\n\t\t\tAssert.Collection(\n\t\t\t\tpassingTestNodes.Select(tnu => tnu.TestNode.DisplayName).OrderBy(x => x),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CanCreateAndCloseSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCloseUnstartedSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotCreateSameSessionTwice)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CannotRecloseSession)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithLogo)}\", testCaseDisplayName),\n\t\t\t\ttestCaseDisplayName => Assert.Equal($\"{typeof(SessionManagement).FullName}.{nameof(SessionManagement.CreateSession_WithoutLogo)}\", testCaseDisplayName)\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestNodeExtensions.cs",
    "methods": []
  },
  {
    "file": "TestPlatformDiscoveryMessageSink.cs",
    "methods": []
  },
  {
    "file": "TestPlatformExecutionMessageSink.cs",
    "methods": []
  },
  {
    "file": "TestPlatformTestFramework.cs",
    "methods": []
  },
  {
    "file": "TraitParserTests.cs",
    "methods": [
      {
        "name": "ReturnsEmptyWhenNull",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(null, (name, value) => traits.Add(name, value));\n\n\t\t\tAssert.Empty(traits);\n\t\t}"
      },
      {
        "name": "ReturnsEmptyWhenEmpty",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(string.Empty, (name, value) => traits.Add(name, value));\n\n\t\t\tAssert.Empty(traits);\n\t\t}"
      },
      {
        "name": "ReturnsTraits",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"One=1;Two=2\", (name, value) => traits.Add(name, value));\n\n\t\t\tAssert.Collection(\n\t\t\t\ttraits.Keys,\n\t\t\t\tkey =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"One\", key);\n\t\t\t\t\tAssert.Equal(\"1\", Assert.Single(traits[key]));\n\t\t\t\t},\n\t\t\t\tkey =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Two\", key);\n\t\t\t\t\tAssert.Equal(\"2\", Assert.Single(traits[key]));\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "IgnoresExtraTraitSeperatorsAndWhitespace",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"; One = 1 ;;\", (name, value) => traits.Add(name, value));\n\n\t\t\tvar key = Assert.Single(traits.Keys);\n\t\t\tAssert.Equal(\"One\", key);\n\t\t\tAssert.Equal(\"1\", Assert.Single(traits[key]));\n\t\t}"
      },
      {
        "name": "IncludesExtraKeyValueSeperatorsInValue",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"One=1=2=3\", (name, value) => traits.Add(name, value));\n\n\t\t\tvar key = Assert.Single(traits.Keys);\n\t\t\tAssert.Equal(\"One\", key);\n\t\t\tAssert.Equal(\"1=2=3\", Assert.Single(traits[key]));\n\t\t}"
      },
      {
        "name": "IgnoresMissingKeyValueSeperator",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"One1\", (name, value) => traits.Add(name, value));\n\n\t\t\tAssert.Empty(traits);\n\t\t}"
      },
      {
        "name": "IgnoresMissingKey",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"=1\", (name, value) => traits.Add(name, value));\n\n\t\t\tAssert.Empty(traits);\n\t\t}"
      },
      {
        "name": "IgnoresMissingValue",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"1=\", (name, value) => traits.Add(name, value));\n\n\t\t\tAssert.Empty(traits);\n\t\t}"
      },
      {
        "name": "ContinuesOnError",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\n\t\t\tnew TraitParser().Parse(\"One;Two=2\", (name, value) => traits.Add(name, value));\n\n\t\t\tvar key = Assert.Single(traits.Keys);\n\t\t\tAssert.Equal(\"Two\", key);\n\t\t\tAssert.Equal(\"2\", Assert.Single(traits[key]));\n\t\t}"
      },
      {
        "name": "RaisesWarningOnError",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);\n\t\t\tvar messages = new List<string>();\n\t\t\tvar parser = new TraitParser(messages.Add);\n\n\t\t\tparser.Parse(\"One1\", (name, value) => traits.Add(name, value));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(\"Invalid trait 'One1'. The format should be 'name=value'. This trait will be ignored.\", msg);\n\t\t}"
      }
    ]
  },
  {
    "file": "xunitTests.cs",
    "methods": [
      {
        "name": "ChangesCurrentDirectoryWhenWorkingFolderIsNotNull",
        "body": "{\n\t\t\tvar tempFolder =\n\t\t\t\tEnvironment.GetEnvironmentVariable(\"TEMP\")\n\t\t\t\t?? Environment.GetEnvironmentVariable(\"TMP\")\n\t\t\t\t?? Environment.GetEnvironmentVariable(\"TMPDIR\")\n\t\t\t\t?? \"/tmp\";\n\n\t\t\ttempFolder = Path.GetFullPath(tempFolder); // Ensure that the 8.3 path is not used\n\n\t\t\t// For macOS compatibility, switch to the folder and then get it, because the temp folder\n\t\t\t// is usually under /var/folders/... which is softlinked to /private/var/folders\n\t\t\tvar originalDirectory = Directory.GetCurrentDirectory();\n\t\t\tDirectory.SetCurrentDirectory(tempFolder);\n\t\t\ttempFolder = Directory.GetCurrentDirectory();\n\t\t\tDirectory.SetCurrentDirectory(originalDirectory);\n\n\t\t\tvar xunit = new Testable_xunit { WorkingFolder = tempFolder };\n\n\t\t\txunit.Execute();\n\n\t\t\tvar actual = Directory.GetCurrentDirectory();\n\t\t\tvar expected = tempFolder;\n\n\t\t\tif (actual[actual.Length - 1] != Path.DirectorySeparatorChar)\n\t\t\t\tactual += Path.DirectorySeparatorChar;\n\n\t\t\tif (expected[expected.Length - 1] != Path.DirectorySeparatorChar)\n\t\t\t\texpected += Path.DirectorySeparatorChar;\n\n\t\t\tAssert.Equal(expected, actual);\n\t\t}"
      },
      {
        "name": "LogsWelcomeBanner",
        "body": "{\n\t\t\tvar xunit = new Testable_xunit();\n\n\t\t\txunit.Execute();\n\n\t\t\tvar versionAttribute = typeof(xunit).Assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>();\n\t\t\tvar eventArgs = Assert.IsType<BuildMessageEventArgs>(xunit.BuildEngine.Captured(x => x.LogMessageEvent(null)).Args().Single());\n\t\t\tAssert.Equal($\"xUnit.net v3 MSBuild Runner v{versionAttribute!.InformationalVersion} ({IntPtr.Size * 8}-bit {RuntimeInformation.FrameworkDescription})\", eventArgs.Message);\n\t\t\tAssert.Equal(MessageImportance.High, eventArgs.Importance);\n\t\t}"
      },
      {
        "name": "ReturnsTrueWhenExitCodeIsZeroAndFailCountIsZero",
        "body": "{\n\t\t\tvar xunit = new Testable_xunit(exitCode: 0);\n\n\t\t\tvar result = xunit.Execute();\n\n\t\t\tAssert.True(result);\n\t\t}"
      },
      {
        "name": "ReturnsFalseWhenExitCodeIsNonZero",
        "body": "{\n\t\t\tvar xunit = new Testable_xunit(exitCode: 1);\n\n\t\t\tvar result = xunit.Execute();\n\n\t\t\tAssert.False(result);\n\t\t}"
      },
      {
        "name": "NoReporters_UsesDefaultReporter",
        "body": "{\n\t\t\tvar xunit = new Testable_xunit();\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(reporter);\n\t\t}"
      },
      {
        "name": "NoExplicitReporter_NoEnvironmentallyEnabledReporters_UsesDefaultReporter",
        "body": "{\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: false);\n\t\t\tvar xunit = new Testable_xunit();\n\t\t\txunit.AvailableReporters.Add(implicitReporter);\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(reporter);\n\t\t}"
      },
      {
        "name": "ExplicitReporter_NoEnvironmentalOverride_UsesExplicitReporter",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar xunit = new Testable_xunit { Reporter = \"switch\" };\n\t\t\txunit.AvailableReporters.Add(explicitReporter);\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.Same(explicitReporter, reporter);\n\t\t}"
      },
      {
        "name": "ExplicitReporter_WithEnvironmentalOverride_UsesEnvironmentalOverride",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar xunit = new Testable_xunit { Reporter = \"switch\" };\n\t\t\txunit.AvailableReporters.AddRange(new[] { explicitReporter, implicitReporter });\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.Same(implicitReporter, reporter);\n\t\t}"
      },
      {
        "name": "WithEnvironmentalOverride_WithEnvironmentalOverridesDisabled_UsesDefaultReporter",
        "body": "{\n\t\t\tvar implicitReporter = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar xunit = new Testable_xunit { NoAutoReporters = true };\n\t\t\txunit.AvailableReporters.Add(implicitReporter);\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.IsType<DefaultRunnerReporter>(reporter);\n\t\t}"
      },
      {
        "name": "NoExplicitReporter_SelectsFirstEnvironmentallyEnabledReporter",
        "body": "{\n\t\t\tvar explicitReporter = Mocks.RunnerReporter(\"switch\");\n\t\t\tvar implicitReporter1 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar implicitReporter2 = Mocks.RunnerReporter(isEnvironmentallyEnabled: true);\n\t\t\tvar xunit = new Testable_xunit();\n\t\t\txunit.AvailableReporters.AddRange(new[] { explicitReporter, implicitReporter1, implicitReporter2 });\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.Same(implicitReporter1, reporter);\n\t\t}"
      },
      {
        "name": "BadChosenReporter_NoAvailableReporters",
        "body": "{\n\t\t\tvar xunit = new Testable_xunit { Reporter = \"foo\" };\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.Null(reporter);\n\t\t\tvar eventArgs = Assert.IsType<BuildErrorEventArgs>(xunit.BuildEngine.Captured(x => x.LogErrorEvent(null)).Args().Single());\n\t\t\tAssert.Equal(\"Reporter value 'foo' is invalid. There are no available reporters.\", eventArgs.Message);\n\t\t}"
      },
      {
        "name": "BadChosenReporter_WithAvailableReporters",
        "body": "{\n\t\t\tvar xunit = new Testable_xunit { Reporter = \"foo\" };\n\t\t\txunit.AvailableReporters.AddRange(new[] { Mocks.RunnerReporter(\"switch1\"), Mocks.RunnerReporter(\"switch2\") });\n\n\t\t\tvar reporter = xunit.GetReporter();\n\n\t\t\tAssert.Null(reporter);\n\t\t\tvar eventArgs = Assert.IsType<BuildErrorEventArgs>(xunit.BuildEngine.Captured(x => x.LogErrorEvent(null)).Args().Single());\n\t\t\tAssert.Equal(\"Reporter value 'foo' is invalid. Available reporters: switch1, switch2\", eventArgs.Message);\n\t\t}"
      }
    ]
  },
  {
    "file": "FSharpAcceptanceTestAssembly.cs",
    "methods": []
  },
  {
    "file": "FSharpAcceptanceTestV2Assembly.cs",
    "methods": []
  },
  {
    "file": "FSharpAcceptanceTestV3Assembly.cs",
    "methods": []
  },
  {
    "file": "ConfigReaderTests.cs",
    "methods": [
      {
        "name": "SupportDefaultCulture",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration { Culture = \"override-me\" };\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_CultureDefault.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Null(configuration.Culture);\n\t}"
      },
      {
        "name": "SupportInvariantCulture",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration();\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_CultureInvariant.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Equal(string.Empty, configuration.Culture);\n\t}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsAsMultiplier_ReturnsMultipliedValue",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration();\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsMultiplier.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Equal(Environment.ProcessorCount * 2, configuration.MaxParallelThreadsOrDefault);\n\t}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsAsMultiplierWithComma_ReturnsMultipliedValue",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration();\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsMultiplierComma.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Equal(Environment.ProcessorCount * 2, configuration.MaxParallelThreadsOrDefault);\n\t}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsAsMultiplierWithDecimal_ReturnsMultipliedValue",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration();\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsMultiplierDecimal.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Equal(Environment.ProcessorCount * 2, configuration.MaxParallelThreadsOrDefault);\n\t}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsExplicitDefault_ReturnsProcessorCount",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration { MaxParallelThreads = 2112 };\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsDefault.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Equal(Environment.ProcessorCount, configuration.MaxParallelThreadsOrDefault);\n\t}"
      },
      {
        "name": "ConfigurationFileWithMaxThreadsExplicitUnlimited_ReturnsUnlimited",
        "body": "{\n\t\tvar configuration = new TestAssemblyConfiguration();\n\t\tvar warnings = new List<string>();\n\n\t\tvar result = ConfigReader.Load(configuration, AssemblyFileName, Path.Combine(AssemblyPath, \"ConfigReader_MaxThreadsUnlimited.json\"), warnings);\n\n\t\tAssert.True(result);\n\t\tAssert.Empty(warnings);\n\t\tAssert.Equal(-1, configuration.MaxParallelThreadsOrDefault);\n\t}"
      }
    ]
  },
  {
    "file": "TestClassCallbackHandlerTests.cs",
    "methods": [
      {
        "name": "WithClassNode_ParsesNumbersWithInvariantCulture",
        "body": "{\n\t\tvar handler = new TestClassCallbackHandler([], Substitute.For<IMessageSink>());\n\t\tvar xml = new XmlDocument();\n\t\txml.LoadXml(\"<class time='1.234' total='4' failed='3' skipped='2' />\");\n\n\t\thandler.OnXmlNode(xml.FirstChild);\n\n\t\tAssert.Equal(1.234M, handler.TestClassResults.Time);\n\t\tAssert.Equal(4, handler.TestClassResults.Total);\n\t\tAssert.Equal(3, handler.TestClassResults.Failed);\n\t\tAssert.Equal(2, handler.TestClassResults.Skipped);\n\t}"
      },
      {
        "name": "WithTestNode_ParsesNumberWithInvariantCulture",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar sink = SpyMessageSink.Create(messages: messages);\n\t\tvar testCase = CreateTestCase(\"assembly\", \"config\", \"foo\", \"bar\", \"foo.bar\");\n\t\tvar handler = new TestClassCallbackHandler([testCase], sink);\n\t\tvar startXml = new XmlDocument();\n\t\tstartXml.LoadXml(\"<start type='foo' method='bar' name='foo.bar'></start>\");\n\t\tvar passXml = new XmlDocument();\n\t\tpassXml.LoadXml(\"<test type='foo' method='bar' name='foo.bar' time='1.234' result='Pass' />\");\n\n\t\thandler.OnXmlNode(startXml.FirstChild);\n\t\thandler.OnXmlNode(passXml.FirstChild);\n\n\t\tvar message = Assert.Single(messages.OfType<ITestFinished>());\n\t\tAssert.Equal(1.234M, message.ExecutionTime);\n\t}"
      },
      {
        "name": "WithTestNode_OutputResultsInOutputMessage",
        "body": "{\n\t\tvar messages = new List<IMessageSinkMessage>();\n\t\tvar sink = SpyMessageSink.Create(messages: messages);\n\t\tvar testCase = CreateTestCase(\"assembly\", \"config\", \"foo\", \"bar\", \"foo.bar\");\n\t\tvar handler = new TestClassCallbackHandler([testCase], sink);\n\t\tvar startXml = new XmlDocument();\n\t\tstartXml.LoadXml(\"<start type='foo' method='bar' name='foo.bar'></start>\");\n\t\tvar passXml = new XmlDocument();\n\t\tpassXml.LoadXml(\"<test type='foo' method='bar' name='foo.bar' time='1.234' result='Pass'><output>This is output text</output></test>\");\n\n\t\thandler.OnXmlNode(startXml.FirstChild);\n\t\thandler.OnXmlNode(passXml.FirstChild);\n\n\t\tvar message = Assert.Single(messages.OfType<ITestOutput>());\n\t\tAssert.Equal(\"This is output text\", message.Output);\n\t}"
      }
    ]
  },
  {
    "file": "Xunit1ExceptionUtilityTests.cs",
    "methods": [
      {
        "name": "CanParseEmbeddedExceptions",
        "body": "{\n\t\ttry\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthrow new DivideByZeroException();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthrow new Exception(\"failure\", ex);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tvar (exceptionTypes, messages, stackTraces, exceptionParentIndices) = Xunit1ExceptionUtility.ConvertToErrorMetadata(ex);\n\n\t\t\tAssert.Collection(\n\t\t\t\texceptionTypes,\n\t\t\t\ttype => Assert.Equal(\"System.Exception\", type),\n\t\t\t\ttype => Assert.Equal(\"System.DivideByZeroException\", type)\n\t\t\t);\n\t\t\tAssert.Collection(\n\t\t\t\tmessages,\n\t\t\t\tmsg => Assert.Equal(\"failure\", msg),\n\t\t\t\tmsg => Assert.Equal(\"Attempted to divide by zero.\", msg)\n\t\t\t);\n\t\t\tAssert.Collection(\n\t\t\t\tstackTraces,\n\t\t\t\tstack => Assert.Contains(\"Xunit1ExceptionUtilityTests.CanParseEmbeddedExceptions\", stack),\n\t\t\t\tstack => Assert.Contains(\"Xunit1ExceptionUtilityTests.CanParseEmbeddedExceptions\", stack)\n\t\t\t);\n\t\t\tAssert.Collection(\n\t\t\t\texceptionParentIndices,\n\t\t\t\tindex => Assert.Equal(-1, index),\n\t\t\t\tindex => Assert.Equal(0, index)\n\t\t\t);\n\t\t}\n\t}"
      }
    ]
  },
  {
    "file": "Xunit1TestCaseTests.cs",
    "methods": [
      {
        "name": "CanRoundTrip_PublicClass_PublicTestMethod",
        "body": "{\n\t\t\tvar testCase = Create(typeof(Serialization), nameof(CanRoundTrip_PublicClass_PublicTestMethod));\n\n\t\t\tvar serialized = SerializationHelper.Instance.Serialize(testCase);\n\t\t\tvar deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);\n\n\t\t\tAssert.NotNull(deserialized);\n\t\t}"
      },
      {
        "name": "CanRoundTrip_PublicClass_PrivateTestMethod",
        "body": "{\n\t\t\tvar testCase = Create(typeof(Serialization), nameof(PrivateTestMethod));\n\n\t\t\tvar serialized = SerializationHelper.Instance.Serialize(testCase);\n\t\t\tvar deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);\n\n\t\t\tAssert.NotNull(deserialized);\n\t\t}"
      },
      {
        "name": "CanRoundTrip_PrivateClass",
        "body": "{\n\t\t\tvar testCase = Create(typeof(PrivateClass), nameof(PrivateClass.TestMethod));\n\n\t\t\tvar serialized = SerializationHelper.Instance.Serialize(testCase);\n\t\t\tvar deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);\n\n\t\t\tAssert.NotNull(deserialized);\n\t\t}"
      },
      {
        "name": "CanSerializeTraits_StayCaseInsensitive",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, IReadOnlyCollection<string>>\n\t\t\t{\n\t\t\t\t{ \"foo\", new List<string> { \"bar\", \"baz\" } },\n\t\t\t\t{ \"biff\", new List<string> { \"Hello, world!\" } }\n\t\t\t};\n\t\t\tvar testCase = Create(typeof(Serialization), nameof(CanRoundTrip_PublicClass_PublicTestMethod), traits: traits);\n\n\t\t\tvar serialized = SerializationHelper.Instance.Serialize(testCase);\n\t\t\tvar deserialized = SerializationHelper.Instance.Deserialize<Xunit1TestCase>(serialized);\n\n\t\t\tAssert.NotNull(deserialized);\n\t\t\tAssert.NotNull(deserialized.Traits);\n\t\t\tAssert.Collection(\n\t\t\t\tdeserialized.Traits[\"FOO\"],\n\t\t\t\tbar => Assert.Equal(\"bar\", bar),\n\t\t\t\tbaz => Assert.Equal(\"baz\", baz)\n\t\t\t);\n\t\t\tvar helloWorld = Assert.Single(deserialized.Traits[\"biff\"]);\n\t\t\tAssert.Equal(\"Hello, world!\", helloWorld);\n\t\t}"
      },
      {
        "name": "PrivateTestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\t\tAssert.True(false);\n\t\t\t}"
      },
      {
        "name": "TraitNamesAreCaseInsensitive_PreSeeded",
        "body": "{\n\t\t\tvar traits = new Dictionary<string, IReadOnlyCollection<string>> { { \"FOO\", new List<string> { \"BAR\" } } };\n\t\t\tvar testCase = Create(typeof(Traits), \"TraitNamesAreCaseInsensitive_PreSeeded\", traits: traits);\n\n\t\t\tvar fooTraitValues = testCase.Traits[\"foo\"];\n\n\t\t\tvar fooTraitValue = Assert.Single(fooTraitValues);\n\t\t\tAssert.Equal(\"BAR\", fooTraitValue);\n\t\t}"
      }
    ]
  },
  {
    "file": "Xunit2AcceptanceTests.cs",
    "methods": [
      {
        "name": "NoTests",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(NoTestsClass));\n\n\t\t\tAssert.Collection(results,\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar finished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);\n\t\t\t\t\tAssert.Equal(0, finished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, finished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, finished.TestsSkipped);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SinglePassingTest",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(SinglePassingTestClass));\n\n\t\t\tAssert.Collection(results,\n\t\t\t\tmessage => Assert.IsAssignableFrom<ITestAssemblyStarting>(message),\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar collectionStarting = Assert.IsAssignableFrom<ITestCollectionStarting>(message);\n\t\t\t\t\tAssert.NotNull(collectionStarting.TestCollection);\n\t\t\t\t\t// TODO: There will need to be more tests here eventually...\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classStarting = Assert.IsAssignableFrom<ITestClassStarting>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", classStarting.TestClass.Class.Name);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testMethodStarting = Assert.IsAssignableFrom<ITestMethodStarting>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodStarting.TestClass.Class.Name);\n\t\t\t\t\tAssert.Equal(\"TestMethod\", testMethodStarting.TestMethod.Method.Name);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testCaseStarting = Assert.IsAssignableFrom<ITestCaseStarting>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass.TestMethod\", testCaseStarting.TestCase.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar starting = Assert.IsAssignableFrom<ITestStarting>(message);\n\t\t\t\t\tAssert.Equal(starting.TestCase.DisplayName, starting.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classConstructionStarting = Assert.IsAssignableFrom<ITestClassConstructionStarting>(message);\n\t\t\t\t\tAssert.Equal(classConstructionStarting.TestCase.DisplayName, classConstructionStarting.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classConstructionFinished = Assert.IsAssignableFrom<ITestClassConstructionFinished>(message);\n\t\t\t\t\tAssert.Equal(classConstructionFinished.TestCase.DisplayName, classConstructionFinished.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testPassed = Assert.IsAssignableFrom<ITestPassed>(message);\n\t\t\t\t\tAssert.Equal(testPassed.TestCase.DisplayName, testPassed.Test.DisplayName);\n\t\t\t\t\tAssert.NotEqual(0M, testPassed.ExecutionTime);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testFinished = Assert.IsAssignableFrom<ITestFinished>(message);\n\t\t\t\t\tAssert.Equal(testFinished.TestCase.DisplayName, testFinished.Test.DisplayName);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testCaseFinished = Assert.IsAssignableFrom<ITestCaseFinished>(message);\n\t\t\t\t\tAssert.Equal(1, testCaseFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, testCaseFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, testCaseFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, testCaseFinished.ExecutionTime);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar testMethodFinished = Assert.IsAssignableFrom<ITestMethodFinished>(message);\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SinglePassingTestClass\", testMethodFinished.TestClass.Class.Name);\n\t\t\t\t\tAssert.Equal(\"TestMethod\", testMethodFinished.TestMethod.Method.Name);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar classFinished = Assert.IsAssignableFrom<ITestClassFinished>(message);\n\t\t\t\t\tAssert.Equal(1, classFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, classFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, classFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, classFinished.ExecutionTime);\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar collectionFinished = Assert.IsAssignableFrom<ITestCollectionFinished>(message);\n\t\t\t\t\tAssert.NotNull(collectionFinished.TestCollection);\n\t\t\t\t\tAssert.Equal(1, collectionFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, collectionFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, collectionFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, collectionFinished.ExecutionTime);\n\t\t\t\t\t// TODO: There will need to be more tests here eventually...\n\t\t\t\t},\n\t\t\t\tmessage =>\n\t\t\t\t{\n\t\t\t\t\tvar assemblyFinished = Assert.IsAssignableFrom<ITestAssemblyFinished>(message);\n\t\t\t\t\tAssert.Equal(1, assemblyFinished.TestsRun);\n\t\t\t\t\tAssert.Equal(0, assemblyFinished.TestsFailed);\n\t\t\t\t\tAssert.Equal(0, assemblyFinished.TestsSkipped);\n\t\t\t\t\tAssert.NotEqual(0M, assemblyFinished.ExecutionTime);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "SingleSkippedTest",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(SingleSkippedTestClass));\n\n\t\t\tvar skippedMessage = Assert.Single(results.OfType<ITestSkipped>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+SingleSkippedTestClass.TestMethod\", skippedMessage.Test.DisplayName);\n\t\t\tAssert.Equal(\"This is a skipped test\", skippedMessage.Reason);\n\n\t\t\tvar classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());\n\t\t\tAssert.Equal(1, classFinishedMessage.TestsSkipped);\n\n\t\t\tvar collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());\n\t\t\tAssert.Equal(1, collectionFinishedMessage.TestsSkipped);\n\t\t}"
      },
      {
        "name": "TimedOutTest",
        "body": "{\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar results = Run(typeof(ClassUnderTest));\n\t\t\tstopwatch.Stop();\n\n\t\t\tvar passedMessage = Assert.Single(results.OfType<ITestPassed>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.ShortRunningTest\", passedMessage.Test.DisplayName);\n\n\t\t\tvar failedMessage = Assert.Single(results.OfType<ITestFailed>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+TimeoutTests+ClassUnderTest.LongRunningTest\", failedMessage.Test.DisplayName);\n\t\t\tAssert.Equal(\"Test execution timed out after 10 milliseconds\", failedMessage.Messages.Single());\n\n\t\t\tAssert.True(stopwatch.ElapsedMilliseconds < 10000, \"Elapsed time should be less than 10 seconds\");\n\t\t}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "TestWithUnstartedTaskThrows",
        "body": "{\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar results = Run(typeof(ClassUnderTest));\n\t\t\tstopwatch.Stop();\n\n\t\t\tvar failedMessage = Assert.Single(results.OfType<ITestFailed>());\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+NonStartedTasks+ClassUnderTest.NonStartedTask\", failedMessage.Test.DisplayName);\n\t\t\tAssert.Equal(\"Test method returned a non-started Task (tasks must be started before being returned)\", failedMessage.Messages.Single());\n\t\t}"
      },
      {
        "name": "Task",
        "body": "No body available"
      },
      {
        "name": "SingleFailingTest",
        "body": "{\n\t\t\tList<IMessageSinkMessage> results = Run(typeof(SingleFailingTestClass));\n\n\t\t\tvar failedMessage = Assert.Single(results.OfType<ITestFailed>());\n\t\t\tAssert.Equal(typeof(TrueException).FullName, failedMessage.ExceptionTypes.Single());\n\n\t\t\tvar classFinishedMessage = Assert.Single(results.OfType<ITestClassFinished>());\n\t\t\tAssert.Equal(1, classFinishedMessage.TestsFailed);\n\n\t\t\tvar collectionFinishedMessage = Assert.Single(results.OfType<ITestCollectionFinished>());\n\t\t\tAssert.Equal(1, collectionFinishedMessage.TestsFailed);\n\t\t}"
      },
      {
        "name": "TestFailureResultsFromThrowingCtorInTestClass",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassUnderTest_CtorFailure));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "TestFailureResultsFromThrowingDisposeInTestClass",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassUnderTest_DisposeFailure));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tAssert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());\n\t\t}"
      },
      {
        "name": "CompositeTestFailureResultsFromFailingTestsPlusThrowingDisposeInTestClass",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassUnderTest_FailingTestAndDisposeFailure));\n\n\t\t\tvar msg = Assert.Single(messages);\n\t\t\tvar combinedMessage = Xunit.ExceptionUtility.CombineMessages(msg);\n\t\t\tAssert.StartsWith(\"System.AggregateException : \", combinedMessage);\n\t\t\tAssert.Contains(\n\t\t\t\t\"---- Assert.Equal() Failure: Values differ\" + Environment.NewLine +\n\t\t\t\t\"Expected: 2\" + Environment.NewLine +\n\t\t\t\t\"Actual:   3\" + Environment.NewLine +\n\t\t\t\t\"---- System.DivideByZeroException : \",\n\t\t\t\tcombinedMessage);\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{ }"
      },
      {
        "name": "TheTest",
        "body": "{\n\t\t\t\tAssert.Equal(2, 3);\n\t\t\t}"
      },
      {
        "name": "TestsCanBeInStaticClasses",
        "body": "{\n\t\t\tvar testMessages = Run<ITestResultMessage>(typeof(StaticClassUnderTest));\n\n\t\t\tvar testMessage = Assert.Single(testMessages);\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+StaticClassSupport+StaticClassUnderTest.Passing\", testMessage.Test.DisplayName);\n\t\t\tAssert.IsAssignableFrom<ITestPassed>(testMessage);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "EachTestMethodHasIndividualExceptionMessage",
        "body": "{\n\t\t\tvar testMessages = Run<ITestFailed>(typeof(ClassUnderTest));\n\n\t\t\tvar equalFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.EqualFailure\");\n\t\t\tAssert.Contains(\"Assert.Equal() Failure\", equalFailure.Messages.Single());\n\n\t\t\tvar notNullFailure = Assert.Single(testMessages, msg => msg.Test.DisplayName == \"Xunit2AcceptanceTests+ErrorAggregation+ClassUnderTest.NotNullFailure\");\n\t\t\tAssert.Contains(\"Assert.NotNull() Failure\", notNullFailure.Messages.Single());\n\t\t}"
      },
      {
        "name": "EqualFailure",
        "body": "{\n\t\t\t\tAssert.Equal(42, 40);\n\t\t\t}"
      },
      {
        "name": "NotNullFailure",
        "body": "{\n\t\t\t\tAssert.NotNull(null);\n\t\t\t}"
      },
      {
        "name": "OverrideOfOrderingAtCollectionLevel",
        "body": "{\n\t\t\tvar testMessages = Run<ITestPassed>(typeof(TestClassUsingCollection));\n\n\t\t\tAssert.Collection(testMessages,\n\t\t\t\tmessage => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "OverrideOfOrderingAtClassLevel",
        "body": "{\n\t\t\tvar testMessages = Run<ITestPassed>(typeof(TestClassWithoutCollection));\n\n\t\t\tAssert.Collection(testMessages,\n\t\t\t\tmessage => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test3\", message.TestCase.TestMethod.Method.Name)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test3",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "NonParallelCollectionsRunLast",
        "body": "{\n\t\t\tvar testMessages = Run<ITestPassed>(new[] {\n\t\t\t\ttypeof(TestClassNonParallelCollection),\n\t\t\t\ttypeof(TestClassParallelCollection)\n\t\t\t});\n\n\t\t\tAssert.Collection(testMessages,\n\t\t\t\tmessage => Assert.Equal(\"Test1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"Test2\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"IShouldBeLast1\", message.TestCase.TestMethod.Method.Name),\n\t\t\t\tmessage => Assert.Equal(\"IShouldBeLast2\", message.TestCase.TestMethod.Method.Name)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Test1",
        "body": "{ }"
      },
      {
        "name": "Test2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast2",
        "body": "{ }"
      },
      {
        "name": "IShouldBeLast1",
        "body": "{ }"
      },
      {
        "name": "CanUseCustomFactAttribute",
        "body": "{\n\t\t\tvar msgs = Run<ITestPassed>(typeof(ClassWithCustomFact));\n\n\t\t\tvar msg = Assert.Single(msgs);\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomFact.Passing\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "CanUseCustomFactWithArrayParameters",
        "body": "{\n\t\t\tvar msgs = Run<ITestPassed>(typeof(ClassWithCustomArrayFact));\n\n\t\t\tvar msg = Assert.Single(msgs);\n\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithCustomArrayFact.Passing\", msg.Test.DisplayName);\n\t\t}"
      },
      {
        "name": "CannotMixMultipleFactDerivedAttributes",
        "body": "{\n\t\t\tvar msgs = Run<ITestFailed>(typeof(ClassWithMultipleFacts)).ToList();\n\n\t\t\tAssert.Collection(msgs,\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing\", msg.Test.DisplayName);\n\t\t\t\t\tAssert.Equal(\"System.InvalidOperationException\", msg.ExceptionTypes.Single());\n\t\t\t\t\tAssert.Equal(\"Test method 'Xunit2AcceptanceTests+CustomFacts+ClassWithMultipleFacts.Passing' has multiple [Fact]-derived attributes\", msg.Messages.Single());\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "Passing",
        "body": "{ }"
      },
      {
        "name": "SendOutputMessages",
        "body": "{\n\t\t\tvar msgs = Run(typeof(ClassUnderTest));\n\n\t\t\tvar idxOfTestPassed = msgs.FindIndex(msg => msg is ITestPassed);\n\t\t\tAssert.True(idxOfTestPassed >= 0, \"Test should have passed\");\n\n\t\t\tvar idxOfFirstTestOutput = msgs.FindIndex(msg => msg is ITestOutput);\n\t\t\tAssert.True(idxOfFirstTestOutput >= 0, \"Test should have output\");\n\t\t\tAssert.True(idxOfFirstTestOutput < idxOfTestPassed, \"Test output messages should precede test result\");\n\n\t\t\tAssert.Collection(msgs.OfType<ITestOutput>(),\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);\n\t\t\t\t\tAssert.Equal(\"This is output in the constructor\" + Environment.NewLine, outputMessage.Output);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);\n\t\t\t\t\tAssert.Equal(\"This is test output\" + Environment.NewLine, outputMessage.Output);\n\t\t\t\t},\n\t\t\t\tmsg =>\n\t\t\t\t{\n\t\t\t\t\tvar outputMessage = Assert.IsAssignableFrom<ITestOutput>(msg);\n\t\t\t\t\tAssert.Equal(\"This is output in Dispose\" + Environment.NewLine, outputMessage.Output);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\t\toutput.WriteLine(\"This is test output\");\n\t\t\t}"
      },
      {
        "name": "AsyncLifetimeAcceptanceTest",
        "body": "{\n\t\t\tvar messages = Run<ITestPassed>(typeof(ClassWithAsyncLifetime));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "TheTest",
        "body": "{\n\t\t\t\toutput.WriteLine(\"Run Test\");\n\t\t\t}"
      },
      {
        "name": "ThrowingConstructor",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingCtor));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\");\n\t\t}"
      },
      {
        "name": "ThrowingInitializeAsync",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingInitializeAsync));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "ThrowingDisposeAsync",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_ThrowingDisposeAsync));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "FailingTest",
        "body": "{\n\t\t\tvar messages = Run<ITestFailed>(typeof(ClassWithAsyncLifetime_FailingTest));\n\n\t\t\tvar message = Assert.Single(messages);\n\t\t\tAssertOperations(message, \"Constructor\", \"InitializeAsync\", \"Run Test\", \"DisposeAsync\", \"Dispose\");\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{ }"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\tAssert.True(false);\n\t\t}"
      },
      {
        "name": "TestMethod",
        "body": "{\n\t\t\tAssert.True(false);\n\t\t}"
      }
    ]
  },
  {
    "file": "Xunit2MessageAdapterTests.cs",
    "methods": [
      {
        "name": "AfterTestFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.AfterTestFinished(Test, BeforeAfterAttributeName);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IAfterTestFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "AfterTestStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.AfterTestStarting(Test, BeforeAfterAttributeName);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IAfterTestStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "BeforeTestFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.BeforeTestFinished(Test, BeforeAfterAttributeName);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IBeforeTestFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "BeforeTestStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.BeforeTestStarting(Test, BeforeAfterAttributeName);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IBeforeTestStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(BeforeAfterAttributeName, v3Message.AttributeName);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "DiagnosticMessage",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.DiagnosticMessage(\"Hello, world!\");\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IDiagnosticMessage>(adapted);\n\t\t\tAssert.Equal(\"Hello, world!\", v3Message.Message);\n\t\t}"
      },
      {
        "name": "TestCaseDiscoveryMessage",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCaseDiscoveryMessage(TestCase);\n\t\t\tvar discoverer = Substitute.For<ITestFrameworkDiscoverer>();\n\t\t\tdiscoverer.Serialize(TestCase).Returns(\"abc123\");\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID, discoverer);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseDiscovered>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(\"abc123\", v3Message.Serialization);\n\t\t\tAssert.Equal(\"skip-reason\", v3Message.SkipReason);\n\t\t\tAssert.Equal(\"source-file\", v3Message.SourceFilePath);\n\t\t\tAssert.Equal(2112, v3Message.SourceLineNumber);\n\t\t\tAssert.Equal(\"test-case-display-name\", v3Message.TestCaseDisplayName);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Collection(\n\t\t\t\tv3Message.Traits.OrderBy(kvp => kvp.Key),\n\t\t\t\ttrait =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"key1\", trait.Key);\n\t\t\t\t\tAssert.Equal([\"value1a\", \"value1b\"], trait.Value);\n\t\t\t\t},\n\t\t\t\ttrait =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"key2\", trait.Key);\n\t\t\t\t\tAssert.Equal([\"value2\"], trait.Value);\n\t\t\t\t},\n\t\t\t\ttrait =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"key3\", trait.Key);\n\t\t\t\t\tAssert.Empty(trait.Value);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "ErrorMessage",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.ErrorMessage(ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.IErrorMessage>(adapted);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestAssemblyCleanupFailure",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestAssemblyCleanupFailure(TestAssembly, ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestAssemblyCleanupFailure>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestAssemblyFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestAssemblyFinished(\n\t\t\t\tTestAssembly,\n\t\t\t\ttestsRun: 2112,\n\t\t\t\ttestsFailed: 42,\n\t\t\t\ttestsSkipped: 6,\n\t\t\t\texecutionTime: 123.4567m\n\t\t\t);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestAssemblyFinished>(adapted);\n\t\t\tAssert.NotEmpty(v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(42, v3Message.TestsFailed);\n\t\t\tAssert.Equal(0, v3Message.TestsNotRun);\n\t\t\tAssert.Equal(6, v3Message.TestsSkipped);\n\t\t\tAssert.Equal(2112, v3Message.TestsTotal);\n\t\t}"
      },
      {
        "name": "TestAssemblyStarting",
        "body": "{\n\t\t\tvar assemblyPath =\n\t\t\t\tRuntimeInformation.IsOSPlatform(OSPlatform.Windows)\n\t\t\t\t\t? @\"C:\\Users\\bradwilson\\assembly.dll\"\n\t\t\t\t\t: \"/home/bradwilson/assembly.dll\";\n\t\t\tvar configFilePath =\n\t\t\t\tRuntimeInformation.IsOSPlatform(OSPlatform.Windows)\n\t\t\t\t\t? @\"C:\\Users\\bradwilson\\xunit.runner.json\"\n\t\t\t\t\t: \"/home/bradwilson/xunit.runner.json\";\n\n\t\t\tvar testAssembly = Xunit2Mocks.TestAssembly(assemblyPath, configFilePath, \"target-framework\");\n\t\t\tvar v2Message = Xunit2Mocks.TestAssemblyStarting(\n\t\t\t\ttestAssembly,\n\t\t\t\tnew DateTime(2020, 11, 3, 17, 55, 0, DateTimeKind.Utc),\n\t\t\t\t\"test-environment\",\n\t\t\t\t\"test-framework\"\n\t\t\t);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestAssemblyStarting>(adapted);\n\t\t\tAssert.Equal(Path.GetFileNameWithoutExtension(assemblyPath), v3Message.AssemblyName);\n\t\t\tAssert.Equal(assemblyPath, v3Message.AssemblyPath);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(configFilePath, v3Message.ConfigFilePath);\n\t\t\tAssert.Equal(new DateTimeOffset(2020, 11, 3, 17, 55, 0, TimeSpan.Zero), v3Message.StartTime);\n\t\t\tAssert.Equal(\"target-framework\", v3Message.TargetFramework);\n\t\t\tAssert.Equal(\"test-environment\", v3Message.TestEnvironment);\n\t\t\tAssert.Equal(\"test-framework\", v3Message.TestFrameworkDisplayName);\n\t\t}"
      },
      {
        "name": "TestCaseCleanupFailure",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCaseCleanupFailure(TestCase, ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseCleanupFailure>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestCaseFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCaseFinished(\n\t\t\t\tTestCase,\n\t\t\t\ttestsRun: 2112,\n\t\t\t\ttestsFailed: 42,\n\t\t\t\ttestsSkipped: 404,\n\t\t\t\texecutionTime: 123.4567m\n\t\t\t);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(42, v3Message.TestsFailed);\n\t\t\tAssert.Equal(0, v3Message.TestsNotRun);\n\t\t\tAssert.Equal(404, v3Message.TestsSkipped);\n\t\t\tAssert.Equal(2112, v3Message.TestsTotal);\n\t\t}"
      },
      {
        "name": "TestCaseStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCaseStarting(TestCase);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCaseStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(\"skip-reason\", v3Message.SkipReason);\n\t\t\tAssert.Equal(\"source-file\", v3Message.SourceFilePath);\n\t\t\tAssert.Equal(2112, v3Message.SourceLineNumber);\n\t\t\tAssert.Equal(\"test-case-display-name\", v3Message.TestCaseDisplayName);\n\t\t\tAssert.Equal(\"test-case-id\", v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(\"TestNamespace.TestClass+EmbeddedClass\", v3Message.TestClassName);\n\t\t\tAssert.Equal(\"TestNamespace\", v3Message.TestClassNamespace);\n\t\t\tAssert.Equal(\"TestClass+EmbeddedClass\", v3Message.TestClassSimpleName);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(\"MyTestMethod\", v3Message.TestMethodName);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Collection(\n\t\t\t\tv3Message.Traits.OrderBy(kvp => kvp.Key),\n\t\t\t\ttrait =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"key1\", trait.Key);\n\t\t\t\t\tAssert.Equal([\"value1a\", \"value1b\"], trait.Value);\n\t\t\t\t},\n\t\t\t\ttrait =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"key2\", trait.Key);\n\t\t\t\t\tAssert.Equal([\"value2\"], trait.Value);\n\t\t\t\t},\n\t\t\t\ttrait =>\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(\"key3\", trait.Key);\n\t\t\t\t\tAssert.Empty(trait.Value);\n\t\t\t\t}\n\t\t\t);\n\t\t}"
      },
      {
        "name": "TestClassCleanupFailure",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassCleanupFailure(TestClass, ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassCleanupFailure>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestClassFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassFinished(\n\t\t\t\tTestClass,\n\t\t\t\ttestsRun: 2112,\n\t\t\t\ttestsFailed: 42,\n\t\t\t\ttestsSkipped: 404,\n\t\t\t\texecutionTime: 123.4567m\n\t\t\t);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(42, v3Message.TestsFailed);\n\t\t\tAssert.Equal(0, v3Message.TestsNotRun);\n\t\t\tAssert.Equal(404, v3Message.TestsSkipped);\n\t\t\tAssert.Equal(2112, v3Message.TestsTotal);\n\t\t}"
      },
      {
        "name": "TestClassStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassStarting(TestClass);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(v2Message.TestClass.Class.Name, v3Message.TestClassName);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t}"
      },
      {
        "name": "TestCollectionCleanupFailure",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCollectionCleanupFailure(TestCollection, ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCollectionCleanupFailure>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestCollectionFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCollectionFinished(\n\t\t\t\tTestCollection,\n\t\t\t\ttestsRun: 2112,\n\t\t\t\ttestsFailed: 42,\n\t\t\t\ttestsSkipped: 404,\n\t\t\t\texecutionTime: 123.4567m\n\t\t\t);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCollectionFinished>(adapted);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(42, v3Message.TestsFailed);\n\t\t\tAssert.Equal(0, v3Message.TestsNotRun);\n\t\t\tAssert.Equal(404, v3Message.TestsSkipped);\n\t\t\tAssert.Equal(2112, v3Message.TestsTotal);\n\t\t}"
      },
      {
        "name": "TestCollectionStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCollectionStarting(TestCollection);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCollectionStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCollectionDefinition.Name, v3Message.TestCollectionClassName);\n\t\t\tAssert.Equal(TestCollection.DisplayName, v3Message.TestCollectionDisplayName);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t}"
      },
      {
        "name": "TestMethodCleanupFailure",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestMethodCleanupFailure(TestMethod, ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestMethodCleanupFailure>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestMethodFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestMethodFinished(\n\t\t\t\tTestMethod,\n\t\t\t\ttestsRun: 2112,\n\t\t\t\ttestsFailed: 42,\n\t\t\t\ttestsSkipped: 404,\n\t\t\t\texecutionTime: 123.4567m\n\t\t\t);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestMethodFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(42, v3Message.TestsFailed);\n\t\t\tAssert.Equal(0, v3Message.TestsNotRun);\n\t\t\tAssert.Equal(404, v3Message.TestsSkipped);\n\t\t\tAssert.Equal(2112, v3Message.TestsTotal);\n\t\t}"
      },
      {
        "name": "TestMethodStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestMethodStarting(TestMethod);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestMethodStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethod.Method.Name, v3Message.MethodName);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t}"
      },
      {
        "name": "TestClassConstructionFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassConstructionFinished(Test);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassConstructionFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestClassConstructionStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassConstructionStarting(Test);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassConstructionStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestClassDisposeFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassDisposeFinished(Test);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassDisposeFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestClassDisposeStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestClassDisposeStarting(Test);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestClassDisposeStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestCleanupFailure",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestCleanupFailure(Test, ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestCleanupFailure>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestFinished",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestFinished(Test, 123.4567m, \"abc123\");\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestFinished>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(\"abc123\", v3Message.Output);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestFailed",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestFailed(Test, 123.4567m, \"abc123\", ThrownException);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestFailed>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(FailureCause.Assertion, v3Message.Cause);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(\"abc123\", v3Message.Output);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t\tAssertErrorMetadata(v3Message, ThrownException);\n\t\t}"
      },
      {
        "name": "TestOutput",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestOutput(Test, \"this is my test output\");\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestOutput>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(\"this is my test output\", v3Message.Output);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestPassed",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestPassed(Test, 123.4567m, \"abc123\");\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestPassed>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(123.4567m, v3Message.ExecutionTime);\n\t\t\tAssert.Equal(\"abc123\", v3Message.Output);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestSkipped",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestSkipped(Test, \"I am not running\");\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestSkipped>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(0m, v3Message.ExecutionTime);  // Statically skipped tests always take no runtime\n\t\t\tAssert.Empty(v3Message.Output);\n\t\t\tAssert.Equal(\"I am not running\", v3Message.Reason);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      },
      {
        "name": "TestStarting",
        "body": "{\n\t\t\tvar v2Message = Xunit2Mocks.TestStarting(Test);\n\t\t\tvar v2Adapter = new Xunit2MessageAdapter(TestAssemblyUniqueID);\n\n\t\t\tvar adapted = v2Adapter.Adapt(v2Message);\n\n\t\t\tvar v3Message = Assert.IsAssignableFrom<Xunit.Sdk.ITestStarting>(adapted);\n\t\t\tAssert.Equal(TestAssemblyUniqueID, v3Message.AssemblyUniqueID);\n\t\t\tAssert.Equal(TestCaseUniqueID, v3Message.TestCaseUniqueID);\n\t\t\tAssert.Equal(TestClassUniqueID, v3Message.TestClassUniqueID);\n\t\t\tAssert.Equal(\"test-display-name\", v3Message.TestDisplayName);\n\t\t\tAssert.Equal(TestCollectionUniqueID, v3Message.TestCollectionUniqueID);\n\t\t\tAssert.Equal(TestMethodUniqueID, v3Message.TestMethodUniqueID);\n\t\t\tAssert.Equal(TestUniqueID, v3Message.TestUniqueID);\n\t\t}"
      }
    ]
  },
  {
    "file": "Xunit3ArgumentFactoryTests.cs",
    "methods": [
      {
        "name": "DefaultOptions",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options);\n\n\t\t\tvar arg = Assert.Single(arguments);\n\t\t\tAssert.Equal(\"-automated\", arg);\n\t\t}"
      },
      {
        "name": "DoesNotSendSyncParameterToAutomatedForOlderTestProjects",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions(synchronousMessageReporting: true);\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFind(Version_0_2_999, options);\n\n\t\t\tvar argument = Assert.Single(arguments);\n\t\t\tAssert.Equal(\"-automated\", argument);\n\t\t}"
      },
      {
        "name": "AddConfigFile",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options, configFileName: \"/config/file/name.json\");\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"/config/file/name.json\", arg),\n\t\t\t\targ => Assert.Equal(\"-automated\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AddFilters",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar filters = new XunitFilters();\n\t\t\tfilters.AddIncludedClassFilter(\"class1\");\n\t\t\tfilters.AddIncludedClassFilter(\"class2\");\n\t\t\tfilters.AddExcludedClassFilter(\"class3\");\n\t\t\tfilters.AddExcludedClassFilter(\"class4\");\n\t\t\tfilters.AddIncludedMethodFilter(\"method1\");\n\t\t\tfilters.AddIncludedMethodFilter(\"method2\");\n\t\t\tfilters.AddExcludedMethodFilter(\"method3\");\n\t\t\tfilters.AddExcludedMethodFilter(\"method4\");\n\t\t\tfilters.AddIncludedNamespaceFilter(\"namespace1\");\n\t\t\tfilters.AddIncludedNamespaceFilter(\"namespace2\");\n\t\t\tfilters.AddExcludedNamespaceFilter(\"namespace3\");\n\t\t\tfilters.AddExcludedNamespaceFilter(\"namespace4\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait1\", \"value1a\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait1\", \"value1b\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait2\", \"value2a\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait2\", \"value2b\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait3\", \"value3a\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait3\", \"value3b\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait4\", \"value4a\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait4\", \"value4b\");\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options, filters: filters);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-class\", arg),\n\t\t\t\targ => Assert.Equal(\"class1\", arg),\n\t\t\t\targ => Assert.Equal(\"-class\", arg),\n\t\t\t\targ => Assert.Equal(\"class2\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-class-\", arg),\n\t\t\t\targ => Assert.Equal(\"class3\", arg),\n\t\t\t\targ => Assert.Equal(\"-class-\", arg),\n\t\t\t\targ => Assert.Equal(\"class4\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-method\", arg),\n\t\t\t\targ => Assert.Equal(\"method1\", arg),\n\t\t\t\targ => Assert.Equal(\"-method\", arg),\n\t\t\t\targ => Assert.Equal(\"method2\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-method-\", arg),\n\t\t\t\targ => Assert.Equal(\"method3\", arg),\n\t\t\t\targ => Assert.Equal(\"-method-\", arg),\n\t\t\t\targ => Assert.Equal(\"method4\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-namespace\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace1\", arg),\n\t\t\t\targ => Assert.Equal(\"-namespace\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace2\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-namespace-\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace3\", arg),\n\t\t\t\targ => Assert.Equal(\"-namespace-\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace4\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait1=value1a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait1=value1b\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait2=value2a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait2=value2b\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait3=value3a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait3=value3b\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait4=value4a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait4=value4b\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AddWaitForDebugger",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkDiscoveryOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFind(Version_0_3_0, options, waitForDebugger: true);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\t\t\t\targ => Assert.Equal(\"-waitForDebugger\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "DefaultOptions",
        "body": "{\n\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions);\n\n\t\t\tvar arg = Assert.Single(arguments);\n\t\t\tAssert.Equal(\"-automated\", arg);\n\t\t}"
      },
      {
        "name": "AddConfigFile",
        "body": "{\n\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions, configFileName: \"/config/file/name.json\");\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"/config/file/name.json\", arg),\n\t\t\t\targ => Assert.Equal(\"-automated\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AddFilters",
        "body": "{\n\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\t\t\tvar filters = new XunitFilters();\n\t\t\tfilters.AddIncludedClassFilter(\"class1\");\n\t\t\tfilters.AddIncludedClassFilter(\"class2\");\n\t\t\tfilters.AddExcludedClassFilter(\"class3\");\n\t\t\tfilters.AddExcludedClassFilter(\"class4\");\n\t\t\tfilters.AddIncludedMethodFilter(\"method1\");\n\t\t\tfilters.AddIncludedMethodFilter(\"method2\");\n\t\t\tfilters.AddExcludedMethodFilter(\"method3\");\n\t\t\tfilters.AddExcludedMethodFilter(\"method4\");\n\t\t\tfilters.AddIncludedNamespaceFilter(\"namespace1\");\n\t\t\tfilters.AddIncludedNamespaceFilter(\"namespace2\");\n\t\t\tfilters.AddExcludedNamespaceFilter(\"namespace3\");\n\t\t\tfilters.AddExcludedNamespaceFilter(\"namespace4\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait1\", \"value1a\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait1\", \"value1b\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait2\", \"value2a\");\n\t\t\tfilters.AddIncludedTraitFilter(\"trait2\", \"value2b\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait3\", \"value3a\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait3\", \"value3b\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait4\", \"value4a\");\n\t\t\tfilters.AddExcludedTraitFilter(\"trait4\", \"value4b\");\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions, filters: filters);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-class\", arg),\n\t\t\t\targ => Assert.Equal(\"class1\", arg),\n\t\t\t\targ => Assert.Equal(\"-class\", arg),\n\t\t\t\targ => Assert.Equal(\"class2\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-class-\", arg),\n\t\t\t\targ => Assert.Equal(\"class3\", arg),\n\t\t\t\targ => Assert.Equal(\"-class-\", arg),\n\t\t\t\targ => Assert.Equal(\"class4\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-method\", arg),\n\t\t\t\targ => Assert.Equal(\"method1\", arg),\n\t\t\t\targ => Assert.Equal(\"-method\", arg),\n\t\t\t\targ => Assert.Equal(\"method2\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-method-\", arg),\n\t\t\t\targ => Assert.Equal(\"method3\", arg),\n\t\t\t\targ => Assert.Equal(\"-method-\", arg),\n\t\t\t\targ => Assert.Equal(\"method4\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-namespace\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace1\", arg),\n\t\t\t\targ => Assert.Equal(\"-namespace\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace2\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-namespace-\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace3\", arg),\n\t\t\t\targ => Assert.Equal(\"-namespace-\", arg),\n\t\t\t\targ => Assert.Equal(\"namespace4\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait1=value1a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait1=value1b\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait2=value2a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait\", arg),\n\t\t\t\targ => Assert.Equal(\"trait2=value2b\", arg),\n\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait3=value3a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait3=value3b\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait4=value4a\", arg),\n\t\t\t\targ => Assert.Equal(\"-trait-\", arg),\n\t\t\t\targ => Assert.Equal(\"trait4=value4b\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AddWaitForDebugger",
        "body": "{\n\t\t\tvar discoveryOptions = TestData.TestFrameworkDiscoveryOptions();\n\t\t\tvar executionOptions = TestData.TestFrameworkExecutionOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForFindAndRun(Version_0_3_0, discoveryOptions, executionOptions, waitForDebugger: true);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\t\t\t\targ => Assert.Equal(\"-waitForDebugger\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "DefaultOptions",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkExecutionOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForRun(Version_0_3_0, options, [\"abc\", \"123\"]);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\t\t\t\targ => Assert.Equal(\"-run\", arg),\n\t\t\t\targ => Assert.Equal(\"abc\", arg),\n\t\t\t\targ => Assert.Equal(\"-run\", arg),\n\t\t\t\targ => Assert.Equal(\"123\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "DoesNotSendSyncParameterToAutomatedForOlderTestProjects",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkExecutionOptions(synchronousMessageReporting: true);\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForRun(Version_0_2_999, options, [\"abc\"]);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\t\t\t\targ => Assert.Equal(\"-run\", arg),\n\t\t\t\targ => Assert.Equal(\"abc\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AddConfigFile",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkExecutionOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForRun(Version_0_3_0, options, [\"abc\"], configFileName: \"/config/file/name.json\");\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"/config/file/name.json\", arg),\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\t\t\t\targ => Assert.Equal(\"-run\", arg),\n\t\t\t\targ => Assert.Equal(\"abc\", arg)\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AddWaitForDebugger",
        "body": "{\n\t\t\tvar options = TestData.TestFrameworkExecutionOptions();\n\n\t\t\tvar arguments = Xunit3ArgumentFactory.ForRun(Version_0_3_0, options, [\"abc\"], waitForDebugger: true);\n\n\t\t\tAssert.Collection(\n\t\t\t\targuments,\n\t\t\t\targ => Assert.Equal(\"-automated\", arg),\n\t\t\t\targ => Assert.Equal(\"-run\", arg),\n\t\t\t\targ => Assert.Equal(\"abc\", arg),\n\t\t\t\targ => Assert.Equal(\"-waitForDebugger\", arg)\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "Xunit3Tests.cs",
    "methods": [
      {
        "name": "GuardClauses_Ctor",
        "body": "{\n\t\tAssert.Throws<ArgumentNullException>(\"projectAssembly\", () => Xunit3.ForDiscoveryAndExecution(null!));\n\n\t\tvar assembly = new XunitProjectAssembly(new XunitProject(), \"/this/file/does/not/exist.exe\", new(3, \".NETCoreApp,Version=v6.0\"));\n\t\tvar argEx = Assert.Throws<ArgumentException>(\"projectAssembly.AssemblyFileName\", () => Xunit3.ForDiscoveryAndExecution(assembly));\n\t\tAssert.StartsWith(\"File not found: /this/file/does/not/exist.exe\", argEx.Message);\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tawait using var xunit3 = Xunit3.ForDiscoveryAndExecution(Assembly);\n\n\t\tAssert.Throws<ArgumentNullException>(\"messageSink\", () => xunit3.Find(null!, new FrontControllerFindSettings(DiscoveryOptions)));\n\t\tAssert.Throws<ArgumentNullException>(\"settings\", () => xunit3.Find(SpyMessageSink.Capture(), null!));\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tawait using var xunit3 = Xunit3.ForDiscoveryAndExecution(Assembly);\n\n\t\tAssert.Throws<ArgumentNullException>(\"messageSink\", () => xunit3.FindAndRun(null!, new FrontControllerFindAndRunSettings(DiscoveryOptions, ExecutionOptions)));\n\t\tAssert.Throws<ArgumentNullException>(\"settings\", () => xunit3.FindAndRun(SpyMessageSink.Capture(), null!));\n\t}"
      },
      {
        "name": "ValueTask",
        "body": "{\n\t\tawait using var xunit3 = Xunit3.ForDiscoveryAndExecution(Assembly);\n\n\t\tAssert.Throws<ArgumentNullException>(\"messageSink\", () => xunit3.Run(null!, new FrontControllerRunSettings(ExecutionOptions, [])));\n\t\tAssert.Throws<ArgumentNullException>(\"settings\", () => xunit3.Run(SpyMessageSink.Capture(), null!));\n\t}"
      }
    ]
  },
  {
    "file": "AssemblyUtilityTests.cs",
    "methods": [
      {
        "name": "GetAssemblyMetadata",
        "body": "{\n\t\tvar metadata = AssemblyUtility.GetAssemblyMetadata(typeof(AssemblyUtilityTests).Assembly.Location);\n\n\t\tAssert.NotNull(metadata);\n\t\tAssert.Equal(3, metadata.XunitVersion);\n#if NET472\n\t\tAssert.Equal(TargetFrameworkIdentifier.DotNetFramework, metadata.TargetFrameworkIdentifier);\n\t\tAssert.Equal(new Version(4, 7, 2), metadata.TargetFrameworkVersion);\n#elif NET6_0\n\t\tAssert.Equal(TargetFrameworkIdentifier.DotNetCore, metadata.TargetFrameworkIdentifier);\n\t\tAssert.Equal(new Version(6, 0), metadata.TargetFrameworkVersion);\n#else\n#error Unknown target framework\n#endif\n\t}"
      }
    ]
  },
  {
    "file": "ExceptionUtilityTests.cs",
    "methods": [
      {
        "name": "XunitException",
        "body": "{\n\t\t\tvar errorMetadata = new ErrorMetadata { new XunitException(\"This is the message\") };\n\n\t\t\tvar result = ExceptionUtility.CombineMessages(errorMetadata);\n\n\t\t\tAssert.Equal(\"This is the message\", result);\n\t\t}"
      },
      {
        "name": "NonXunitException",
        "body": "{\n\t\t\tvar errorMetadata = new ErrorMetadata { new Exception(\"This is the message\") };\n\n\t\t\tvar result = ExceptionUtility.CombineMessages(errorMetadata);\n\n\t\t\tAssert.Equal(\"System.Exception : This is the message\", result);\n\t\t}"
      },
      {
        "name": "NonXunitExceptionWithInnerExceptions",
        "body": "{\n\t\t\tvar errorMetadata = new ErrorMetadata {\n\t\t\t\t{ new Exception(\"outer exception\"), -1 },\n\t\t\t\t{ new DivideByZeroException(\"inner exception\"), 0 },\n\t\t\t\t{ new XunitException(\"inner inner exception\"), 1 }\n\t\t\t};\n\n\t\t\tvar result = ExceptionUtility.CombineMessages(errorMetadata);\n\n\t\t\tAssert.Equal(\n\t\t\t\t\"System.Exception : outer exception\" + Environment.NewLine +\n\t\t\t\t\"---- System.DivideByZeroException : inner exception\" + Environment.NewLine +\n\t\t\t\t\"-------- inner inner exception\",\n\t\t\t\tresult\n\t\t\t);\n\t\t}"
      },
      {
        "name": "AggregateException",
        "body": "{\n\t\t\tvar errorMetadata = new ErrorMetadata {\n\t\t\t\t{ new AggregateException(), -1 },\n\t\t\t\t{ new DivideByZeroException(\"inner #1\"), 0 },\n\t\t\t\t{ new NotImplementedException(\"inner #2\"), 0 },\n\t\t\t\t{ new XunitException(\"this is crazy\"), 0 },\n\t\t\t};\n\n\t\t\tvar result = ExceptionUtility.CombineMessages(errorMetadata);\n\n\t\t\tAssert.Equal(\n\t\t\t\t\"System.AggregateException : One or more errors occurred.\" + Environment.NewLine +\n\t\t\t\t\"---- System.DivideByZeroException : inner #1\" + Environment.NewLine +\n\t\t\t\t\"---- System.NotImplementedException : inner #2\" + Environment.NewLine +\n\t\t\t\t\"---- this is crazy\",\n\t\t\t\tresult\n\t\t\t);\n\t\t}"
      },
      {
        "name": "MissingExceptionTypes",
        "body": "{\n\t\t\tvar errorMetadata = new ErrorMetadata();\n\t\t\terrorMetadata.AddMessage(\"Message 1\");\n\t\t\terrorMetadata.AddMessage(\"Message 2\");\n\t\t\terrorMetadata.AddMessage(\"Message 3\");\n\t\t\terrorMetadata.AddIndex(-1);\n\t\t\terrorMetadata.AddIndex(0);\n\t\t\terrorMetadata.AddIndex(0);\n\t\t\terrorMetadata.AddExceptionType(\"ExceptionType1\");\n\t\t\terrorMetadata.AddExceptionType(\"Xunit.Sdk.ExceptionType2\");\n\n\t\t\tvar result = ExceptionUtility.CombineMessages(errorMetadata);\n\n\t\t\tAssert.Equal(\n\t\t\t\t\"ExceptionType1 : Message 1\" + Environment.NewLine +\n\t\t\t\t\"---- Message 2\" + Environment.NewLine +\n\t\t\t\t\"----  : Message 3\",\n\t\t\t\tresult\n\t\t\t);\n\t\t}"
      },
      {
        "name": "XunitException",
        "body": "{\n#if DEBUG\n\t\t\tAssert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");\n#else\n\t\t\tstatic void testCode()\n\t\t\t{\n\t\t\t\tthrow new XunitException(\"Hello world\");\n\t\t\t}\n\t\t\tvar ex = Record.Exception(testCode)!;\n\t\t\tvar errorMetadata = new ErrorMetadata { ex };\n\n\t\t\tvar result = ExceptionUtility.CombineStackTraces(errorMetadata);\n\n\t\t\tAssert.DoesNotContain(typeof(Record).FullName!, result);\n\t\t\tAssert.DoesNotContain(typeof(XunitException).FullName!, result);\n\t\t\tAssert.Contains(\"XunitException\", result);\n#endif\n\t\t}"
      },
      {
        "name": "NonXunitException",
        "body": "{\n#if DEBUG\n\t\t\tAssert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");\n#else\n\t\t\tstatic void testCode()\n\t\t\t{\n\t\t\t\tthrow new Exception();\n\t\t\t}\n\t\t\tvar ex = Record.Exception(testCode)!;\n\t\t\tvar errorMetadata = new ErrorMetadata { ex };\n\n\t\t\tvar result = ExceptionUtility.CombineStackTraces(errorMetadata);\n\n\t\t\tAssert.DoesNotContain(typeof(Record).FullName!, result);\n\t\t\tAssert.DoesNotContain(typeof(XunitException).FullName!, result);\n\t\t\tAssert.Contains(\"NonXunitException\", result);\n#endif\n\t\t}"
      },
      {
        "name": "NonXunitExceptionWithInnerExceptions",
        "body": "{\n#if DEBUG\n\t\t\tAssert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");\n#else\n\t\t\tstatic void innerTestCode()\n\t\t\t{\n\t\t\t\tthrow new DivideByZeroException();\n\t\t\t}\n\t\t\tvar inner = Record.Exception(innerTestCode)!;\n\t\t\tvoid outerTestCode()\n\t\t\t{\n\t\t\t\tthrow new Exception(\"message\", inner);\n\t\t\t}\n\t\t\tvar outer = Record.Exception(outerTestCode)!;\n\t\t\tvar errorMetadata = new ErrorMetadata { { outer, -1 }, { inner, 0 } };\n\n\t\t\tvar result = ExceptionUtility.CombineStackTraces(errorMetadata);\n\n\t\t\tAssert.NotNull(result);\n\t\t\tAssert.Collection(\n\t\t\t\tresult.Split(new[] { Environment.NewLine }, StringSplitOptions.None),\n\t\t\t\tline => Assert.Contains(\"NonXunitExceptionWithInnerExceptions\", line),\n\t\t\t\tline => Assert.Equal(\"----- Inner Stack Trace -----\", line),\n\t\t\t\tline => Assert.Contains(\"NonXunitExceptionWithInnerExceptions\", line)\n\t\t\t);\n#endif\n\t\t}"
      },
      {
        "name": "HandlesAggregateException",
        "body": "{\n#if DEBUG\n\t\t\tAssert.Skip(\"Stack trace filtering is disabled in DEBUG builds\");\n#else\n\t\t\tstatic void inner1TestCode()\n\t\t\t{\n\t\t\t\tthrow new DivideByZeroException();\n\t\t\t}\n\t\t\tvar inner1 = Record.Exception(inner1TestCode)!;\n\t\t\tstatic void inner2TestCode()\n\t\t\t{\n\t\t\t\tthrow new NotImplementedException(\"inner #2\");\n\t\t\t}\n\t\t\tvar inner2 = Record.Exception(inner2TestCode)!;\n\t\t\tstatic void inner3TestCode()\n\t\t\t{\n\t\t\t\tthrow new XunitException(\"this is crazy\");\n\t\t\t}\n\t\t\tvar inner3 = Record.Exception(inner3TestCode)!;\n\t\t\tvoid outerTestCode()\n\t\t\t{\n\t\t\t\tthrow new AggregateException(inner1, inner2, inner3);\n\t\t\t}\n\t\t\tvar outer = Record.Exception(outerTestCode)!;\n\t\t\tvar errorMetadata = new ErrorMetadata { { outer, -1 }, { inner1, 0 }, { inner2, 0 }, { inner3, 0 } };\n\n\t\t\tvar result = ExceptionUtility.CombineStackTraces(errorMetadata);\n\n\t\t\tAssert.NotNull(result);\n\t\t\tAssert.Collection(\n\t\t\t\tresult.Split(new[] { Environment.NewLine }, StringSplitOptions.None),\n\t\t\t\tline => Assert.Contains(\"HandlesAggregateException\", line),\n\t\t\t\tline => Assert.Equal(\"----- Inner Stack Trace #1 (System.DivideByZeroException) -----\", line),\n\t\t\t\tline => Assert.Contains(\"HandlesAggregateException\", line),\n\t\t\t\tline => Assert.Equal(\"----- Inner Stack Trace #2 (System.NotImplementedException) -----\", line),\n\t\t\t\tline => Assert.Contains(\"HandlesAggregateException\", line),\n\t\t\t\tline => Assert.Equal(\"----- Inner Stack Trace #3 (Xunit.Sdk.XunitException) -----\", line),\n\t\t\t\tline => Assert.Contains(\"HandlesAggregateException\", line)\n\t\t\t);\n#endif\n\t\t}"
      },
      {
        "name": "MissingStackTracesAndExceptionTypes",
        "body": "{\n\t\t\tvar errorMetadata = new ErrorMetadata();\n\t\t\terrorMetadata.AddMessage(\"Message 1\");\n\t\t\terrorMetadata.AddMessage(\"Message 2\");\n\t\t\terrorMetadata.AddMessage(\"Message 3\");\n\t\t\terrorMetadata.AddIndex(-1);\n\t\t\terrorMetadata.AddIndex(0);\n\t\t\terrorMetadata.AddIndex(0);\n\t\t\terrorMetadata.AddExceptionType(\"ExceptionType1\");\n\t\t\terrorMetadata.AddExceptionType(\"Xunit.Sdk.ExceptionType2\");\n\t\t\terrorMetadata.AddStackTrace(\"Stack Trace 1\");\n\t\t\terrorMetadata.AddStackTrace(\"Stack Trace 2\");\n\n\t\t\tvar result = ExceptionUtility.CombineStackTraces(errorMetadata);\n\n\t\t\tAssert.Equal(\n\t\t\t\t\"Stack Trace 1\" + Environment.NewLine +\n\t\t\t\t\"----- Inner Stack Trace #1 (Xunit.Sdk.ExceptionType2) -----\" + Environment.NewLine +\n\t\t\t\t\"Stack Trace 2\" + Environment.NewLine +\n\t\t\t\t\"----- Inner Stack Trace #2 () -----\" + Environment.NewLine,\n\t\t\t\tresult\n\t\t\t);\n\t\t}"
      }
    ]
  },
  {
    "file": "TestDiscoverySinkTests.cs",
    "methods": [
      {
        "name": "CollectsTestCases",
        "body": "{\n\t\tvar visitor = new TestDiscoverySink();\n\t\tvar testCase1 = TestData.TestCaseDiscovered();\n\t\tvar testCase2 = TestData.TestCaseDiscovered();\n\t\tvar testCase3 = TestData.TestCaseDiscovered();\n\n\t\tvisitor.OnMessage(testCase1);\n\t\tvisitor.OnMessage(testCase2);\n\t\tvisitor.OnMessage(testCase3);\n\t\tvisitor.OnMessage(TestData.DiagnosticMessage()); // Ignored\n\n\t\tAssert.Collection(\n\t\t\tvisitor.TestCases,\n\t\t\tmsg => Assert.Same(testCase1, msg),\n\t\t\tmsg => Assert.Same(testCase2, msg),\n\t\t\tmsg => Assert.Same(testCase3, msg)\n\t\t);\n\t}"
      }
    ]
  },
  {
    "file": "TestClassCallbackHandler.cs",
    "methods": []
  },
  {
    "file": "Xunit1TestCase.cs",
    "methods": []
  },
  {
    "file": "DefaultTestCaseBulkDeserializer.cs",
    "methods": []
  },
  {
    "file": "ITestCaseBulkDeserializer.cs",
    "methods": []
  },
  {
    "file": "ITestProcess.cs",
    "methods": []
  },
  {
    "file": "ITestProcessLauncher.cs",
    "methods": []
  },
  {
    "file": "InProcessTestProcess.cs",
    "methods": []
  },
  {
    "file": "InProcessTestProcessLauncher.cs",
    "methods": []
  },
  {
    "file": "LocalOutOfProcessTestProcessLauncher.cs",
    "methods": []
  },
  {
    "file": "LocalTestProcess.cs",
    "methods": []
  },
  {
    "file": "OutOfProcessTestProcessLauncherBase.cs",
    "methods": []
  },
  {
    "file": "TestExecutedInfo.cs",
    "methods": []
  },
  {
    "file": "TestFailedInfo.cs",
    "methods": []
  },
  {
    "file": "TestFinishedInfo.cs",
    "methods": []
  },
  {
    "file": "TestInfo.cs",
    "methods": []
  },
  {
    "file": "TestOutputInfo.cs",
    "methods": []
  },
  {
    "file": "TestPassedInfo.cs",
    "methods": []
  },
  {
    "file": "TestSkippedInfo.cs",
    "methods": []
  },
  {
    "file": "TestStartingInfo.cs",
    "methods": []
  },
  {
    "file": "UnitTest1.cs",
    "methods": [
      {
        "name": "Test1",
        "body": "{\n        Assert.True(true);\n    }"
      }
    ]
  },
  {
    "file": "Test.cs",
    "methods": []
  },
  {
    "file": "TestConsole.cs",
    "methods": []
  },
  {
    "file": "TestCore.cs",
    "methods": []
  },
  {
    "file": "TestCoreConsole.cs",
    "methods": []
  },
  {
    "file": "TestCoreMSBuild.cs",
    "methods": []
  },
  {
    "file": "TestCoreMTP.cs",
    "methods": []
  },
  {
    "file": "TestFx.cs",
    "methods": []
  },
  {
    "file": "TestFxConsole.cs",
    "methods": []
  },
  {
    "file": "TestFxMSBuild.cs",
    "methods": []
  },
  {
    "file": "TestFxMTP.cs",
    "methods": []
  },
  {
    "file": "TestMSBuild.cs",
    "methods": []
  },
  {
    "file": "TestMTP.cs",
    "methods": []
  }
]