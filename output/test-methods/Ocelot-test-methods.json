[
  {
    "file": "AggregateTests.cs",
    "methods": [
      {
        "name": "Should_fix_issue_597",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new()\n            {\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/api/values?MailId={userid}\",\n                    UpstreamPathTemplate = \"/key1data/{userid}\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    Key = \"key1\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/api/values?MailId={userid}\",\n                    UpstreamPathTemplate = \"/key2data/{userid}\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    Key = \"key2\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/api/values?MailId={userid}\",\n                    UpstreamPathTemplate = \"/key3data/{userid}\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    Key = \"key3\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/api/values?MailId={userid}\",\n                    UpstreamPathTemplate = \"/key4data/{userid}\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    Key = \"key4\",\n                },\n            },\n            Aggregates = new()\n            {\n                new FileAggregateRoute\n                {\n                    RouteKeys = new() { \"key1\", \"key2\", \"key3\", \"key4\" },\n                    UpstreamPathTemplate = \"/EmpDetail/IN/{userid}\",\n                },\n                new FileAggregateRoute\n                {\n                    RouteKeys = new() { \"key1\", \"key2\" },\n                    UpstreamPathTemplate = \"/EmpDetail/US/{userid}\",\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                RequestIdKey = \"CorrelationID\",\n            },\n        };\n\n        var expected = \"{\\\"key1\\\":some_data,\\\"key2\\\":some_data}\";\n\n        this.Given(x => x.GivenServiceIsRunning($\"http://localhost:{port}\", 200, \"some_data\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/EmpDetail/US/1\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(expected))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_advanced_aggregate_configs",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var port3 = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new()\n            {\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port1,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/Comments\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Comments\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/users/{userId}\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port2,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/UserDetails/{userId}\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"UserDetails\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/posts/{postId}\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port3,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/PostDetails/{postId}\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"PostDetails\",\n                },\n            },\n            Aggregates = new()\n            {\n                new FileAggregateRoute\n                {\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHost = \"localhost\",\n                    RouteKeys = new() { \"Comments\", \"UserDetails\", \"PostDetails\" },\n                    RouteKeysConfig = new()\n                    {\n                        new AggregateRouteConfig\n                            { RouteKey = \"UserDetails\", JsonPath = \"$[*].writerId\", Parameter = \"userId\" },\n                        new AggregateRouteConfig\n                            { RouteKey = \"PostDetails\", JsonPath = \"$[*].postId\", Parameter = \"postId\" },\n                    },\n                },\n            },\n        };\n\n        var userDetailsResponseContent = @\"{\"\"id\"\":1,\"\"firstName\"\":\"\"abolfazl\"\",\"\"lastName\"\":\"\"rajabpour\"\"}\";\n        var postDetailsResponseContent = @\"{\"\"id\"\":1,\"\"title\"\":\"\"post1\"\"}\";\n        var commentsResponseContent = @\"[{\"\"id\"\":1,\"\"writerId\"\":1,\"\"postId\"\":2,\"\"text\"\":\"\"text1\"\"},{\"\"id\"\":2,\"\"writerId\"\":1,\"\"postId\"\":2,\"\"text\"\":\"\"text2\"\"}]\";\n\n        var expected = \"{\\\"Comments\\\":\" + commentsResponseContent + \",\\\"UserDetails\\\":\" + userDetailsResponseContent + \",\\\"PostDetails\\\":\" + postDetailsResponseContent + \"}\";\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/\", 200, commentsResponseContent))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/users/1\", 200, userDetailsResponseContent))\n            .Given(x => x.GivenServiceIsRunning(2, port3, \"/posts/2\", 200, postDetailsResponseContent))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(expected))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_simple_url_user_defined_aggregate",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new()\n            {\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port1,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/laura\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Laura\",\n                },\n\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port2,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/tom\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Tom\",\n                },\n            },\n            Aggregates = new()\n            {\n                new FileAggregateRoute\n                {\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHost = \"localhost\",\n                    RouteKeys = new() { \"Laura\", \"Tom\" },\n                    Aggregator = \"FakeDefinedAggregator\",\n                },\n            },\n        };\n\n        var expected = \"Bye from Laura, Bye from Tom\";\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/\", 200, \"{Hello from Laura}\"))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/\", 200, \"{Hello from Tom}\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunningWithSpecificAggregatorsRegisteredInDi<FakeDefinedAggregator, FakeDep>())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(expected))\n            .And(x => ThenTheDownstreamUrlPathShouldBe(\"/\", \"/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_simple_url",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var route1 = GivenRoute(port1, \"/laura\", \"Laura\");\n        var route2 = GivenRoute(port2, \"/tom\", \"Tom\");\n        var configuration = GivenConfiguration(route1, route2);\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/\", 200, \"{Hello from Laura}\"))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/\", 200, \"{Hello from Tom}\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"{\\\"Laura\\\":{Hello from Laura},\\\"Tom\\\":{Hello from Tom}}\"))\n            .And(x => ThenTheDownstreamUrlPathShouldBe(\"/\", \"/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_simple_url_one_service_404",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new()\n            {\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port1,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/laura\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Laura\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port2,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/tom\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Tom\",\n                },\n            },\n            Aggregates = new()\n            {\n                new FileAggregateRoute\n                {\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHost = \"localhost\",\n                    RouteKeys = new() { \"Laura\", \"Tom\" },\n                },\n            },\n        };\n\n        var expected = \"{\\\"Laura\\\":,\\\"Tom\\\":{Hello from Tom}}\";\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/\", 404, \"\"))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/\", 200, \"{Hello from Tom}\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(expected))\n            .And(x => ThenTheDownstreamUrlPathShouldBe(\"/\", \"/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_simple_url_both_service_404",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new()\n            {\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port1,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/laura\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Laura\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port2,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/tom\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Tom\",\n                },\n            },\n            Aggregates = new()\n            {\n                new FileAggregateRoute\n                {\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHost = \"localhost\",\n                    RouteKeys = new() { \"Laura\", \"Tom\" },\n                },\n            },\n        };\n\n        var expected = \"{\\\"Laura\\\":,\\\"Tom\\\":}\";\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/\", 404, \"\"))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/\", 404, \"\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(expected))\n            .And(x => ThenTheDownstreamUrlPathShouldBe(\"/\", \"/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_be_thread_safe",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new()\n            {\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port1,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/laura\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Laura\",\n                },\n                new FileRoute\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new()\n                    {\n                        new FileHostAndPort\n                        {\n                            Host = \"localhost\",\n                            Port = port2,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/tom\",\n                    UpstreamHttpMethod = new() { \"Get\" },\n                    Key = \"Tom\",\n                },\n            },\n            Aggregates = new()\n            {\n                new FileAggregateRoute\n                {\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHost = \"localhost\",\n                    RouteKeys = new() { \"Laura\", \"Tom\" },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/\", 200, \"{Hello from Laura}\"))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/\", 200, \"{Hello from Tom}\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIMakeLotsOfDifferentRequestsToTheApiGateway())\n            .And(x => ThenTheDownstreamUrlPathShouldBe(\"/\", \"/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_user_forwarding",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var port3 = PortFinder.GetRandomPort();\n        var route1 = GivenRoute(port1, \"/laura\", \"Laura\");\n        var route2 = GivenRoute(port2, \"/tom\", \"Tom\");\n        var configuration = GivenConfiguration(route1, route2);\n        var identityServerUrl = $\"{Uri.UriSchemeHttp}://localhost:{port3}\";\n        Action<IdentityServerAuthenticationOptions> options = o =>\n        {\n            o.Authority = identityServerUrl;\n            o.ApiName = \"api\";\n            o.RequireHttpsMetadata = false;\n            o.SupportedTokens = SupportedTokens.Both;\n            o.ApiSecret = \"secret\";\n            o.ForwardDefault = IdentityServerAuthenticationDefaults.AuthenticationScheme;\n        };\n        Action<IServiceCollection> configureServices = s =>\n        {\n            s.AddOcelot();\n            s.AddMvcCore(options =>\n            {\n                var policy = new AuthorizationPolicyBuilder()\n                    .RequireAuthenticatedUser()\n                    .RequireClaim(\"scope\", \"api\")\n                    .Build();\n                options.Filters.Add(new AuthorizeFilter(policy));\n            });\n            s.AddAuthentication(IdentityServerAuthenticationDefaults.AuthenticationScheme)\n                .AddIdentityServerAuthentication(options);\n        };\n        var count = 0;\n        var actualContexts = new HttpContext[2];\n        Action<IApplicationBuilder> configureApp = async (app) =>\n        {\n            var configuration = new OcelotPipelineConfiguration\n            {\n                PreErrorResponderMiddleware = async (context, next) =>\n                {\n                    var auth = await context.AuthenticateAsync();\n                    context.User = (auth.Succeeded && auth.Principal?.IsAuthenticated() == true)\n                        ? auth.Principal : null;\n                    await next.Invoke();\n                },\n                AuthorizationMiddleware = (context, next) =>\n                {\n                    actualContexts[count++] = context;\n                    return next.Invoke();\n                },\n            };\n            await app.UseOcelot(configuration);\n        };\n        using (var auth = new AuthenticationTests())\n        {\n            this.Given(x => auth.GivenThereIsAnIdentityServerOn(identityServerUrl, AccessTokenType.Jwt))\n                .And(x => x.GivenServiceIsRunning(0, port1, \"/\", 200, \"{Hello from Laura}\"))\n                .And(x => x.GivenServiceIsRunning(1, port2, \"/\", 200, \"{Hello from Tom}\"))\n                .And(x => auth.GivenIHaveAToken(identityServerUrl))\n                .And(x => auth.GivenThereIsAConfiguration(configuration))\n                .And(x => auth.GivenOcelotIsRunningWithServices(configureServices, configureApp))\n                .And(x => auth.GivenIHaveAddedATokenToMyRequest())\n                .When(x => auth.WhenIGetUrlOnTheApiGateway(\"/\"))\n                .Then(x => auth.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n                .And(x => auth.ThenTheResponseBodyShouldBe(\"{\\\"Laura\\\":{Hello from Laura},\\\"Tom\\\":{Hello from Tom}}\"))\n                .And(x => x.ThenTheDownstreamUrlPathShouldBe(\"/\", \"/\"))\n                .BDDfy();\n        }\n\n        // Assert\n        for (var i = 0; i < actualContexts.Length; i++)\n        {\n            var ctx = actualContexts[i].ShouldNotBeNull();\n            ctx.Items.DownstreamRoute().Key.ShouldBe(configuration.Routes[i].Key);\n            var user = ctx.User.ShouldNotBeNull();\n            user.IsAuthenticated().ShouldBeTrue();\n            user.Claims.Count().ShouldBeGreaterThan(1);\n            user.Claims.FirstOrDefault(c => c is { Type: \"scope\", Value: \"api\" }).ShouldNotBeNull();\n        }\n    }"
      },
      {
        "name": "Should_return_response_200_with_copied_body_sent_on_multiple_services",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var route1 = GivenRoute(port1, \"/Service1\", \"Service1\", \"/Sub1\");\n        var route2 = GivenRoute(port2, \"/Service2\", \"Service2\", \"/Sub2\");\n        var configuration = GivenConfiguration(route1, route2);\n        var requestBody = @\"{\"\"id\"\":1,\"\"response\"\":\"\"fromBody-#REPLACESTRING#\"\"}\";\n        var sub1ResponseContent = @\"{\"\"id\"\":1,\"\"response\"\":\"\"fromBody-s1\"\"}\";\n        var sub2ResponseContent = @\"{\"\"id\"\":1,\"\"response\"\":\"\"fromBody-s2\"\"}\";\n        var expected = $\"{{\\\"Service1\\\":{sub1ResponseContent},\\\"Service2\\\":{sub2ResponseContent}}}\";\n\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/Sub1\", 200, reqBody => reqBody.Replace(\"#REPLACESTRING#\", \"s1\")))\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/Sub2\", 200, reqBody => reqBody.Replace(\"#REPLACESTRING#\", \"s2\")))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlWithBodyOnTheApiGateway(\"/\", requestBody))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(expected))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_copied_form_sent_on_multiple_services",
        "body": "{\r\n        var port1 = PortFinder.GetRandomPort();\r\n        var port2 = PortFinder.GetRandomPort();\r\n        var route1 = GivenRoute(port1, \"/Service1\", \"Service1\", \"/Sub1\");\r\n        var route2 = GivenRoute(port2, \"/Service2\", \"Service2\", \"/Sub2\");\r\n        var configuration = GivenConfiguration(route1, route2);\r\n\r\n        var formValues = new[]\r\n        {\r\n            new KeyValuePair<string, string>(\"param1\", \"value1\"),\r\n            new KeyValuePair<string, string>(\"param2\", \"from-form-REPLACESTRING\"),\r\n        };\r\n\r\n        var sub1ResponseContent = \"\\\"[key:param1=value1&param2=from-form-s1]\\\"\";\r\n        var sub2ResponseContent = \"\\\"[key:param1=value1&param2=from-form-s2]\\\"\";\r\n        var expected = $\"{{\\\"Service1\\\":{sub1ResponseContent},\\\"Service2\\\":{sub2ResponseContent}}}\";\r\n\r\n        this.Given(x => x.GivenServiceIsRunning(0, port1, \"/Sub1\", 200, (IFormCollection reqForm) => FormatFormCollection(reqForm).Replace(\"REPLACESTRING\", \"s1\")))\r\n            .Given(x => x.GivenServiceIsRunning(1, port2, \"/Sub2\", 200, (IFormCollection reqForm) => FormatFormCollection(reqForm).Replace(\"REPLACESTRING\", \"s2\")))\r\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunning())\r\n            .When(x => WhenIGetUrlWithFormOnTheApiGateway(\"/\", \"key\", formValues))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => ThenTheResponseBodyShouldBe(expected))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "AuthenticationTests.cs",
    "methods": [
      {
        "name": "Should_return_401_using_identity_server_access_token",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenDefaultAuthRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, AccessTokenType.Jwt))\n           .And(x => x.GivenThereIsAServiceRunningOn(DownstreamServiceUrl(port), HttpStatusCode.Created, string.Empty))\n           .And(x => GivenThereIsAConfiguration(configuration))\n           .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n           .And(x => GivenThePostHasContent(\"postContent\"))\n           .When(x => WhenIPostUrlOnTheApiGateway(\"/\"))\n           .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Unauthorized))\n           .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_using_identity_server",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenDefaultAuthRoute(port);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn(DownstreamServiceUrl(port), HttpStatusCode.OK, \"Hello from Laura\"))\n            .And(x => GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_401_using_identity_server_with_token_requested_for_other_api",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenDefaultAuthRoute(port);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn(DownstreamServiceUrl(port), HttpStatusCode.OK, \"Hello from Laura\"))\n            .And(x => GivenAuthToken(_identityServerRootUrl, \"api2\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Unauthorized))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_201_using_identity_server_access_token",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenDefaultAuthRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn(DownstreamServiceUrl(port), HttpStatusCode.Created, string.Empty))\n            .And(x => GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .And(x => GivenThePostHasContent(\"postContent\"))\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Created))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_201_using_identity_server_reference_token",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenDefaultAuthRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, AccessTokenType.Reference))\n            .And(x => x.GivenThereIsAServiceRunningOn(DownstreamServiceUrl(port), HttpStatusCode.Created, string.Empty))\n            .And(x => GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .And(x => GivenThePostHasContent(\"postContent\"))\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Created))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "MultipleAuthSchemesFeatureTests.cs",
    "methods": []
  },
  {
    "file": "AuthorizationTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_authorizing_route",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                    },\n                    AddHeadersToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"LocationId\", \"Claims[LocationId] > value\"},\n                        {\"UserType\", \"Claims[sub] > value[0] > |\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                    AddClaimsToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"UserType\", \"Claims[sub] > value[0] > |\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                    RouteClaimsRequirement =\n                    {\n                        {\"UserType\", \"registered\"},\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"Hello from Laura\"))\n            .And(x => GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_response_403_authorizing_route",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                    },\n                    AddHeadersToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"LocationId\", \"Claims[LocationId] > value\"},\n                        {\"UserType\", \"Claims[sub] > value[0] > |\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                    AddClaimsToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                    RouteClaimsRequirement =\n                    {\n                        {\"UserType\", \"registered\"},\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"Hello from Laura\"))\n            .And(x => GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Forbidden))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_response_200_using_identity_server_with_allowed_scope",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                        AllowedScopes = new List<string>{ \"api\", \"api.readOnly\", \"openid\", \"offline_access\" },\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"Hello from Laura\"))\n            .And(x => GivenIHaveATokenForApiReadOnlyScope(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_response_403_using_identity_server_with_scope_not_allowed",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                        AllowedScopes = new List<string>{ \"api\", \"openid\", \"offline_access\" },\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"Hello from Laura\"))\n            .And(x => GivenIHaveATokenForApiReadOnlyScope(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Forbidden))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_fix_issue_240",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                    },\n                    RouteClaimsRequirement =\n                    {\n                        {\"Role\", \"User\"},\n                    },\n                },\n            },\n        };\n\n        var users = new List<TestUser>\n        {\n            new()\n            {\n                Username = \"test\",\n                Password = \"test\",\n                SubjectId = \"registered|1231231\",\n                Claims = new List<Claim>\n                {\n                    new(\"Role\", \"AdminUser\"),\n                    new(\"Role\", \"User\"),\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt, users))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"Hello from Laura\"))\n            .And(x => GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => GivenIHaveAddedATokenToMyRequest())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ButterflyTracingTests.cs",
    "methods": [
      {
        "name": "should_forward_tracing_information_from_ocelot_and_downstream_services",
        "body": "{\r\n        var port1 = PortFinder.GetRandomPort();\r\n        var port2 = PortFinder.GetRandomPort();\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/values\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port1,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/api001/values\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            UseTracing = true,\r\n                        },\r\n                    },\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/values\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port2,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/api002/values\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            UseTracing = true,\r\n                        },\r\n                    },\r\n                },\r\n        };\n\n        var butterflyPort = PortFinder.GetRandomPort();\r\n        var butterflyUrl = $\"http://localhost:{butterflyPort}\";\r\n\r\n        this.Given(x => GivenFakeButterfly(butterflyUrl))\r\n            .And(x => GivenServiceOneIsRunning($\"http://localhost:{port1}\", \"/api/values\", 200, \"Hello from Laura\", butterflyUrl))\r\n            .And(x => GivenServiceTwoIsRunning($\"http://localhost:{port2}\", \"/api/values\", 200, \"Hello from Tom\", butterflyUrl))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningUsingButterfly(butterflyUrl))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/api001/values\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/api002/values\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Tom\"))\r\n            .BDDfy();\r\n\r\n        var commandOnAllStateMachines = Wait.WaitFor(10000).Until(() => _butterflyCalled >= 4);\r\n\r\n        _output.WriteLine($\"_butterflyCalled is {_butterflyCalled}\");\r\n\r\n        commandOnAllStateMachines.ShouldBeTrue();\r\n    }"
      },
      {
        "name": "should_return_tracing_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/values\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/api001/values\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            UseTracing = true,\r\n                        },\r\n                        DownstreamHeaderTransform = new Dictionary<string, string>\r\n                        {\r\n                            {\"Trace-Id\", \"{TraceId}\"},\r\n                            {\"Tom\", \"Laura\"},\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        var butterflyPort = PortFinder.GetRandomPort();\r\n        var butterflyUrl = $\"http://localhost:{butterflyPort}\";\r\n\r\n        this.Given(x => GivenFakeButterfly(butterflyUrl))\r\n            .And(x => GivenServiceOneIsRunning($\"http://localhost:{port}\", \"/api/values\", 200, \"Hello from Laura\", butterflyUrl))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningUsingButterfly(butterflyUrl))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/api001/values\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .And(x => _steps.ThenTheTraceHeaderIsSet(\"Trace-Id\"))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Tom\", \"Laura\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "CachingTests.cs",
    "methods": [
      {
        "name": "Should_return_cached_response",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var options = new FileCacheOptions\n        {\n            TtlSeconds = 100,\n        };\n        var configuration = GivenFileConfiguration(port, options);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", HttpStatusCode.OK, HelloLauraContent, null, null))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .Given(x => x.GivenTheServiceNowReturns($\"http://localhost:{port}\", HttpStatusCode.OK, HelloTomContent, null, null))\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .And(x => _steps.ThenTheContentLengthIs(HelloLauraContent.Length))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_cached_response_with_expires_header",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var options = new FileCacheOptions\n        {\n            TtlSeconds = 100,\n        };\n        var configuration = GivenFileConfiguration(port, options);\n        var headerExpires = \"Expires\";\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", HttpStatusCode.OK, HelloLauraContent, headerExpires, \"-1\"))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .Given(x => x.GivenTheServiceNowReturns($\"http://localhost:{port}\", HttpStatusCode.OK, HelloTomContent, null, null))\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .And(x => _steps.ThenTheContentLengthIs(HelloLauraContent.Length))\n            .And(x => _steps.ThenTheResponseBodyHeaderIs(headerExpires, \"-1\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_cached_response_when_using_jsonserialized_cache",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var options = new FileCacheOptions\n        {\n            TtlSeconds = 100,\n        };\n        var configuration = GivenFileConfiguration(port, options);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", HttpStatusCode.OK, HelloLauraContent, null, null))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunningUsingJsonSerializedCache())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .Given(x => x.GivenTheServiceNowReturns($\"http://localhost:{port}\", HttpStatusCode.OK, HelloTomContent, null, null))\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_return_cached_response_as_ttl_expires",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var options = new FileCacheOptions\n        {\n            TtlSeconds = 1,\n        };\n        var configuration = GivenFileConfiguration(port, options);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", HttpStatusCode.OK, HelloLauraContent, null, null))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .Given(x => x.GivenTheServiceNowReturns($\"http://localhost:{port}\", HttpStatusCode.OK, HelloTomContent, null, null))\n            .And(x => GivenTheCacheExpires())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloTomContent))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_clean_cached_response_by_cache_header_via_new_caching_key",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var options = new FileCacheOptions\n        {\n            TtlSeconds = 100,\n            Region = \"europe-central\",\n            Header = \"Authorization\",\n        };\n        var configuration = GivenFileConfiguration(port, options);\n        var headerExpires = \"Expires\";\n\n        // Add to cache\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", HttpStatusCode.OK, HelloLauraContent, headerExpires, options.TtlSeconds))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n\n            // Read from cache\n            .Given(x => x.GivenTheServiceNowReturns($\"http://localhost:{port}\", HttpStatusCode.OK, HelloTomContent, headerExpires, options.TtlSeconds / 2))\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloLauraContent))\n            .And(x => _steps.ThenTheContentLengthIs(HelloLauraContent.Length))\n\n            // Clean cache by the header and cache new content\n            .Given(x => x.GivenTheServiceNowReturns($\"http://localhost:{port}\", HttpStatusCode.OK, HelloTomContent, headerExpires, -1))\n            .And(x => _steps.GivenIAddAHeader(options.Header, \"123\"))\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(HelloTomContent))\n            .And(x => _steps.ThenTheContentLengthIs(HelloTomContent.Length))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "CancelRequestTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var port = PortFinder.GetRandomPort();\n        var route = GivenDefaultRoute(port);\n        var configuration = GivenConfiguration(route);\n        var started = new Notifier(\"service work started notifier\");\n        var stopped = new Notifier(\"service work finished notifier\");\n        GivenThereIsAServiceRunningOn(DownstreamUrl(port), started, stopped);\n        GivenThereIsAConfiguration(configuration);\n        GivenOcelotIsRunning();\n\n        // Act: Initialize\n        var getting = WhenIGetUrl(\"/\");\n        var canceling = WhenIWaitForNotification(started).ContinueWith(Cancel);\n        Exception ex = null;\n\n        // Act\n        try\n        {\n            await Task.WhenAll(getting, canceling);\n        }\n        catch (Exception e)\n        {\n            ex = e;\n        }\n\n        // Assert\n        started.NotificationSent.ShouldBeTrue();\n        stopped.NotificationSent.ShouldBeFalse();\n#if NET8_0_OR_GREATER\n        ex.ShouldNotBeNull().ShouldBeOfType<TaskCanceledException>();\n#else\n        ex.ShouldNotBeNull().ShouldBeOfType<OperationCanceledException>();\n#endif\n    }"
      }
    ]
  },
  {
    "file": "CannotStartOcelotTests.cs",
    "methods": [
      {
        "name": "should_throw_exception_if_cannot_start_because_service_discovery_provider_specified_in_config_but_no_service_discovery_provider_registered_with_dynamic_re_routes",
        "body": "{\r\n        var invalidConfig = new FileConfiguration\r\n        {\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\r\n                {\r\n                    Scheme = \"https\",\r\n                    Host = \"localhost\",\r\n                    Type = \"consul\",\r\n                    Port = 8500,\r\n                },\r\n            },\r\n        };\r\n\r\n        Exception exception = null;\r\n        _steps.GivenThereIsAConfiguration(invalidConfig);\r\n        try\r\n        {\r\n            _steps.GivenOcelotIsRunning();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n\r\n        exception.ShouldNotBeNull();\r\n        exception.Message.ShouldBe(\"One or more errors occurred. (Unable to start Ocelot, errors are: Unable to start Ocelot, errors are: Unable to start Ocelot because either a Route or GlobalConfiguration are using ServiceDiscoveryOptions but no ServiceDiscoveryFinderDelegate has been registered in dependency injection container. Are you missing a package like Ocelot.Provider.Consul and services.AddConsul() or Ocelot.Provider.Eureka and services.AddEureka()?)\");\r\n    }"
      },
      {
        "name": "should_throw_exception_if_cannot_start_because_service_discovery_provider_specified_in_config_but_no_service_discovery_provider_registered",
        "body": "{\r\n        var invalidConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    UpstreamPathTemplate = \"/laura\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    ServiceName = \"test\",\r\n                },\r\n            },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\r\n                {\r\n                    Scheme = \"https\",\r\n                    Host = \"localhost\",\r\n                    Type = \"consul\",\r\n                    Port = 8500,\r\n                },\r\n            },\r\n        };\r\n\r\n        Exception exception = null;\r\n        _steps.GivenThereIsAConfiguration(invalidConfig);\r\n        try\r\n        {\r\n            _steps.GivenOcelotIsRunning();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n\r\n        exception.ShouldNotBeNull();\r\n        exception.Message.ShouldBe(\"One or more errors occurred. (Unable to start Ocelot, errors are: Unable to start Ocelot, errors are: Unable to start Ocelot because either a Route or GlobalConfiguration are using ServiceDiscoveryOptions but no ServiceDiscoveryFinderDelegate has been registered in dependency injection container. Are you missing a package like Ocelot.Provider.Consul and services.AddConsul() or Ocelot.Provider.Eureka and services.AddEureka()?,Unable to start Ocelot, errors are: Unable to start Ocelot because either a Route or GlobalConfiguration are using ServiceDiscoveryOptions but no ServiceDiscoveryFinderDelegate has been registered in dependency injection container. Are you missing a package like Ocelot.Provider.Consul and services.AddConsul() or Ocelot.Provider.Eureka and services.AddEureka()?)\");\r\n    }"
      },
      {
        "name": "should_throw_exception_if_cannot_start_because_no_qos_delegate_registered_globally",
        "body": "{\r\n        var invalidConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 51878,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/laura\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    Key = \"Laura\",\r\n                },\r\n            },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                QoSOptions = new FileQoSOptions\r\n                {\r\n                    TimeoutValue = 1,\r\n                    ExceptionsAllowedBeforeBreaking = 1,\r\n                },\r\n            },\r\n        };\r\n\r\n        Exception exception = null;\r\n        _steps.GivenThereIsAConfiguration(invalidConfig);\r\n        try\r\n        {\r\n            _steps.GivenOcelotIsRunning();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n\r\n        exception.ShouldNotBeNull();\r\n        exception.Message.ShouldBe(\"One or more errors occurred. (Unable to start Ocelot, errors are: Unable to start Ocelot because either a Route or GlobalConfiguration are using QoSOptions but no QosDelegatingHandlerDelegate has been registered in dependency injection container. Are you missing a package like Ocelot.Provider.Polly and services.AddPolly()?)\");\r\n    }"
      },
      {
        "name": "should_throw_exception_if_cannot_start_because_no_qos_delegate_registered_for_re_route",
        "body": "{\r\n        var invalidConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 51878,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/laura\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    Key = \"Laura\",\r\n                    QoSOptions = new FileQoSOptions\r\n                    {\r\n                        TimeoutValue = 1,\r\n                        ExceptionsAllowedBeforeBreaking = 1,\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        Exception exception = null;\r\n        _steps.GivenThereIsAConfiguration(invalidConfig);\r\n        try\r\n        {\r\n            _steps.GivenOcelotIsRunning();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n\r\n        exception.ShouldNotBeNull();\r\n        exception.Message.ShouldBe(\"One or more errors occurred. (Unable to start Ocelot, errors are: Unable to start Ocelot because either a Route or GlobalConfiguration are using QoSOptions but no QosDelegatingHandlerDelegate has been registered in dependency injection container. Are you missing a package like Ocelot.Provider.Polly and services.AddPolly()?)\");\r\n    }"
      },
      {
        "name": "should_throw_exception_if_cannot_start",
        "body": "{\r\n        var invalidConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    UpstreamPathTemplate = \"api\",\r\n                    DownstreamPathTemplate = \"test\",\r\n                },\r\n            },\r\n        };\r\n\r\n        Exception exception = null;\r\n        _steps.GivenThereIsAConfiguration(invalidConfig);\r\n        try\r\n        {\r\n            _steps.GivenOcelotIsRunning();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            exception = ex;\r\n        }\r\n\r\n        exception.ShouldNotBeNull();\r\n        exception.Message.ShouldBe(\"One or more errors occurred. (Unable to start Ocelot, errors are: Downstream Path Template test doesnt start with forward slash,Upstream Path Template api doesnt start with forward slash,When not using service discovery DownstreamHostAndPorts must be set and not empty or Ocelot cannot find your service!)\");\r\n    }"
      }
    ]
  },
  {
    "file": "CaseSensitiveRoutingTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_when_global_ignore_case_sensitivity_set",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/products/{productId}\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/products/{productId}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/api/products/1\", 200, \"Some Product\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/PRODUCTS/1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_route_ignore_case_sensitivity_set",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/products/{productId}\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/products/{productId}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        RouteIsCaseSensitive = false,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/api/products/1\", 200, \"Some Product\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/PRODUCTS/1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_404_when_route_respect_case_sensitivity_set",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/products/{productId}\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/products/{productId}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        RouteIsCaseSensitive = true,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/api/products/1\", 200, \"Some Product\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/PRODUCTS/1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_route_respect_case_sensitivity_set",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/products/{productId}\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/PRODUCTS/{productId}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        RouteIsCaseSensitive = true,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/api/products/1\", 200, \"Some Product\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/PRODUCTS/1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_404_when_global_respect_case_sensitivity_set",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/products/{productId}\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/products/{productId}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        RouteIsCaseSensitive = true,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/api/products/1\", 200, \"Some Product\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/PRODUCTS/1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_global_respect_case_sensitivity_set",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/products/{productId}\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/PRODUCTS/{productId}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        RouteIsCaseSensitive = true,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/api/products/1\", 200, \"Some Product\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/PRODUCTS/1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToDownstreamPathTests.cs",
    "methods": [
      {
        "name": "should_return_200_and_change_downstream_path",
        "body": "{\n        var user = new TestUser\n        {\n            Username = \"test\",\n            Password = \"test\",\n            SubjectId = \"registered|1231231\",\n        };\n\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n               {\n                   new()\n                   {\n                       DownstreamPathTemplate = \"/users/{userId}\",\n                       DownstreamHostAndPorts = new List<FileHostAndPort>\n                       {\n                           new()\n                           {\n                               Host = \"localhost\",\n                               Port = port,\n                           },\n                       },\n                       DownstreamScheme = \"http\",\n                       UpstreamPathTemplate = \"/users/{userId}\",\n                       UpstreamHttpMethod = new List<string> { \"Get\" },\n                       AuthenticationOptions = new FileAuthenticationOptions\n                       {\n                           AuthenticationProviderKey = \"Test\",\n                           AllowedScopes = new List<string>\n                           {\n                               \"openid\", \"offline_access\", \"api\",\n                           },\n                       },\n                       ChangeDownstreamPathTemplate =\n                       {\n                           {\"userId\", \"Claims[sub] > value[1] > |\"},\n                       },\n                   },\n               },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt, user))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200))\n            .And(x => _steps.GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => _steps.GivenIHaveAddedATokenToMyRequest())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/users\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"UserId: 1231231\"))\n            .And(x => ThenTheDownstreamPathIs(\"/users/1231231\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToHeadersForwardingTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_and_foward_claim_as_header",
        "body": "{\n        var user = new TestUser\n        {\n            Username = \"test\",\n            Password = \"test\",\n            SubjectId = \"registered|1231231\",\n            Claims = new List<Claim>\n            {\n                new(\"CustomerId\", \"123\"),\n                new(\"LocationId\", \"1\"),\n            },\n        };\n\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                        AllowedScopes = new List<string>\n                        {\n                            \"openid\", \"offline_access\", \"api\",\n                        },\n                    },\n                    AddHeadersToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"LocationId\", \"Claims[LocationId] > value\"},\n                        {\"UserType\", \"Claims[sub] > value[0] > |\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt, user))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200))\n            .And(x => _steps.GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => _steps.GivenIHaveAddedATokenToMyRequest())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"CustomerId: 123 LocationId: 1 UserType: registered UserId: 1231231\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToQueryStringForwardingTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_and_foward_claim_as_query_string",
        "body": "{\n        var user = new TestUser\n        {\n            Username = \"test\",\n            Password = \"test\",\n            SubjectId = \"registered|1231231\",\n            Claims = new List<Claim>\n            {\n                new(\"CustomerId\", \"123\"),\n                new(\"LocationId\", \"1\"),\n            },\n        };\n\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                        AllowedScopes = new List<string>\n                        {\n                            \"openid\", \"offline_access\", \"api\",\n                        },\n                    },\n                    AddQueriesToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"LocationId\", \"Claims[LocationId] > value\"},\n                        {\"UserType\", \"Claims[sub] > value[0] > |\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt, user))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200))\n            .And(x => _steps.GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => _steps.GivenIHaveAddedATokenToMyRequest())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"CustomerId: 123 LocationId: 1 UserType: registered UserId: 1231231\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_response_200_and_foward_claim_as_query_string_and_preserve_original_string",
        "body": "{\n        var user = new TestUser\n        {\n            Username = \"test\",\n            Password = \"test\",\n            SubjectId = \"registered|1231231\",\n            Claims = new List<Claim>\n            {\n                new(\"CustomerId\", \"123\"),\n                new(\"LocationId\", \"1\"),\n            },\n        };\n\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port,\n                        },\n                    },\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    AuthenticationOptions = new FileAuthenticationOptions\n                    {\n                        AuthenticationProviderKey = \"Test\",\n                        AllowedScopes = new List<string>\n                        {\n                            \"openid\", \"offline_access\", \"api\",\n                        },\n                    },\n                    AddQueriesToRequest =\n                    {\n                        {\"CustomerId\", \"Claims[CustomerId] > value\"},\n                        {\"LocationId\", \"Claims[LocationId] > value\"},\n                        {\"UserType\", \"Claims[sub] > value[0] > |\"},\n                        {\"UserId\", \"Claims[sub] > value[1] > |\"},\n                    },\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAnIdentityServerOn(_identityServerRootUrl, \"api\", AccessTokenType.Jwt, user))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200))\n            .And(x => _steps.GivenIHaveAToken(_identityServerRootUrl))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning(_options, \"Test\"))\n            .And(x => _steps.GivenIHaveAddedATokenToMyRequest())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/?test=1&test=2\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"CustomerId: 123 LocationId: 1 UserType: registered UserId: 1231231\"))\n            .And(_ => ThenTheQueryStringIs(\"?test=1&test=2&CustomerId=123&LocationId=1&UserId=1231231&UserType=registered\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ConfigurationInConsulTests.cs",
    "methods": [
      {
        "name": "Should_return_response_200_with_simple_url_when_using_jsonserialized_cache",
        "body": "{\n        var consulPort = PortFinder.GetRandomPort();\n        var servicePort = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n                {\n                    new()\n                    {\n                        DownstreamPathTemplate = \"/\",\n                        DownstreamScheme = \"http\",\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\n                        {\n                            new()\n                            {\n                                Host = \"localhost\",\n                                Port = servicePort,\n                            },\n                        },\n                        UpstreamPathTemplate = \"/\",\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\n                    },\n                },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        var fakeConsulServiceDiscoveryUrl = DownstreamUrl(consulPort);\n\n        this.Given(x => GivenThereIsAFakeConsulServiceDiscoveryProvider(fakeConsulServiceDiscoveryUrl, string.Empty))\n            .And(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(servicePort), string.Empty, 200, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => x.GivenOcelotIsRunningUsingConsulToStoreConfigAndJsonSerializedCache())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ConfigurationMergeTests.cs",
    "methods": []
  },
  {
    "file": "ConfigurationReloadTests.cs",
    "methods": [
      {
        "name": "should_reload_config_on_change",
        "body": "{\n        this.Given(x => _steps.GivenThereIsAConfiguration(_initialConfig))\n            .And(x => _steps.GivenOcelotIsRunningReloadingConfig(true))\n            .And(x => _steps.GivenThereIsAConfiguration(_anotherConfig))\n            .And(x => _steps.ThenConfigShouldBeWithTimeout(_anotherConfig, 10000))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_reload_config_on_change",
        "body": "{\n        this.Given(x => _steps.GivenThereIsAConfiguration(_initialConfig))\n            .And(x => _steps.GivenOcelotIsRunningReloadingConfig(false))\n            .And(x => _steps.GivenThereIsAConfiguration(_anotherConfig))\n            .And(x => Steps.GivenIWait(MillisecondsToWaitForChangeToken))\n            .And(x => _steps.ThenConfigShouldBe(_initialConfig))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_trigger_change_token_on_change",
        "body": "{\n        this.Given(x => _steps.GivenThereIsAConfiguration(_initialConfig))\n            .And(x => _steps.GivenOcelotIsRunningReloadingConfig(true))\n            .And(x => _steps.GivenIHaveAChangeToken())\n            .And(x => _steps.GivenThereIsAConfiguration(_anotherConfig))\n            .And(x => Steps.GivenIWait(MillisecondsToWaitForChangeToken))\n            .Then(x => _steps.TheChangeTokenShouldBeActive(true))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_trigger_change_token_with_no_change",
        "body": "{\n        this.Given(x => _steps.GivenThereIsAConfiguration(_initialConfig))\n            .And(x => _steps.GivenOcelotIsRunningReloadingConfig(false))\n            .And(x => _steps.GivenIHaveAChangeToken())\n            .And(x => Steps.GivenIWait(MillisecondsToWaitForChangeToken)) // Wait for prior activation to expire.\n            .And(x => _steps.GivenThereIsAConfiguration(_anotherConfig))\n            .And(x => Steps.GivenIWait(MillisecondsToWaitForChangeToken))\n            .Then(x => _steps.TheChangeTokenShouldBeActive(false))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ContentTests.cs",
    "methods": [
      {
        "name": "Should_Not_add_content_type_or_content_length_headers",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var configuration = GivenConfiguration(port);\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", HttpStatusCode.OK, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .And(x => ThenTheContentTypeShouldBeEmpty())\r\n            .And(x => ThenTheContentLengthShouldBeZero())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_add_content_type_and_content_length_headers",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var configuration = GivenConfiguration(port, HttpMethods.Post);\r\n        var contentType = \"application/json\";\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", HttpStatusCode.Created, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenThePostHasContent(\"postContent\"))\r\n            .And(x => _steps.GivenThePostHasContentType(contentType))\r\n            .When(x => _steps.WhenIPostUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Created))\r\n            .And(x => ThenTheContentTypeIsIs(contentType))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_add_default_content_type_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var configuration = GivenConfiguration(port, HttpMethods.Post);\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", HttpStatusCode.Created, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenThePostHasContent(\"postContent\"))\r\n            .When(x => _steps.WhenIPostUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Created))\r\n            .And(x => ThenTheContentTypeIsIs(\"text/plain; charset=utf-8\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_Not_increase_memory_usage_When_downloading_large_file",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var configuration = GivenConfiguration(port);\n        var dummyDatFilePath = GenerateDummyDatFile(100);\r\n        this.Given(x => x.GivenThereIsAServiceWithPayloadRunningOn($\"http://localhost:{port}\", \"/\", dummyDatFilePath))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .Then(x => x.ThenMemoryUsageShouldNotIncrease())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "CustomMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_pre_query_string_builder_middleware",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            AuthorizationMiddleware = async (ctx, next) =>\r\n            {\r\n                _counter++;\r\n                await next.Invoke();\r\n            },\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_authorization_middleware",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            AuthorizationMiddleware = async (ctx, next) =>\r\n            {\r\n                _counter++;\r\n                await next.Invoke();\r\n            },\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_authentication_middleware",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            AuthenticationMiddleware = async (ctx, next) =>\r\n            {\r\n                _counter++;\r\n                await next.Invoke();\r\n            },\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/41879/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_pre_error_middleware",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            PreErrorResponderMiddleware = async (ctx, next) =>\r\n            {\r\n                _counter++;\r\n                await next.Invoke();\r\n            },\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_pre_authorization_middleware",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            PreAuthorizationMiddleware = async (ctx, next) =>\r\n            {\r\n                _counter++;\r\n                await next.Invoke();\r\n            },\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_pre_http_authentication_middleware",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            PreAuthenticationMiddleware = async (ctx, next) =>\r\n            {\r\n                _counter++;\r\n                await next.Invoke();\r\n            },\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, string.Empty))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_throw_when_pipeline_terminates_early",
        "body": "{\r\n        var configuration = new OcelotPipelineConfiguration\r\n        {\r\n            PreQueryStringBuilderMiddleware = (context, next) =>\n                Task.Run(() =>\n                {\n                    _counter++;\n                    return; // do not invoke the rest of the pipeline\n                }),\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunning(configuration))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => x.ThenTheCounterIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_237",
        "body": "{\r\n        Func<object, Task> callback = state =>\r\n        {\r\n            var httpContext = (HttpContext)state;\r\n\r\n            if (httpContext.Response.StatusCode > 400)\r\n            {\n                Debug.WriteLine(\"COUNT CALLED\");\r\n                Console.WriteLine(\"COUNT CALLED\");\r\n            }\r\n\r\n            return Task.CompletedTask;\r\n        };\n\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var fileConfiguration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/west\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", 200, \"/test\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(fileConfiguration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithMiddlewareBeforePipeline<FakeMiddleware>(callback))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "DefaultVersionPolicyTests.cs",
    "methods": [
      {
        "name": "Should_return_bad_gateway_when_request_higher_receive_lower",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"2.0\", VersionPolicies.RequestVersionOrHigher);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http1))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.BadGateway))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_bad_gateway_when_request_lower_receive_higher",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"1.1\", VersionPolicies.RequestVersionOrLower);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http2))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.BadGateway))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_bad_gateway_when_request_exact_receive_different",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"1.1\", VersionPolicies.RequestVersionExact);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http2))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.BadGateway))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_ok_when_request_version_exact_receive_exact",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"2.0\", VersionPolicies.RequestVersionExact);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http2))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_ok_when_request_version_lower_receive_lower",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"2.0\", VersionPolicies.RequestVersionOrLower);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http1))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_ok_when_request_version_lower_receive_exact",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"2.0\", VersionPolicies.RequestVersionOrLower);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http2))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_ok_when_request_version_higher_receive_higher",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"1.1\", VersionPolicies.RequestVersionOrHigher);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http2))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_ok_when_request_version_higher_receive_exact",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenHttpsRoute(port, \"1.1\", VersionPolicies.RequestVersionOrHigher);\n        var configuration = GivenConfiguration(route);\n        this.Given(x => GivenThereIsAServiceRunningOn(port, HttpProtocols.Http1))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "GzipTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_with_simple_url",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Post\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        var input = \"people\";\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\", \"\\\"people\\\"\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenThePostHasGzipContent(input))\r\n            .When(x => _steps.WhenIPostUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HeaderTests.cs",
    "methods": [
      {
        "name": "should_transform_upstream_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        UpstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Laz\", \"D, GP\"},\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Laz\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenIAddAHeader(\"Laz\", \"D\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"GP\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_transform_downstream_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", \"http://www.bbc.co.uk/, http://ocelot.com/\"},\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Location\", \"http://www.bbc.co.uk/\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://ocelot.com/\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_190",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", $\"http://localhost:{port}, {{BaseUrl}}\"},\r\n                        },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            AllowAutoRedirect = false,\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 302, \"Location\", $\"http://localhost:{port}/pay/Receive\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Redirect))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://localhost:5000/pay/Receive\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_205",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", \"{DownstreamBaseUrl}, {BaseUrl}\"},\r\n                        },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            AllowAutoRedirect = false,\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 302, \"Location\", $\"http://localhost:{port}/pay/Receive\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Redirect))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://localhost:5000/pay/Receive\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_417",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", \"{DownstreamBaseUrl}, {BaseUrl}\"},\r\n                        },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            AllowAutoRedirect = false,\r\n                        },\r\n                    },\r\n                },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                BaseUrl = \"http://anotherapp.azurewebsites.net\",\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 302, \"Location\", $\"http://localhost:{port}/pay/Receive\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Redirect))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://anotherapp.azurewebsites.net/pay/Receive\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "request_should_reuse_cookies_with_cookie_container",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/sso/{everything}\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/sso/{everything}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\", \"Post\", \"Options\" },\r\n                    HttpHandlerOptions = new FileHttpHandlerOptions\r\n                    {\r\n                        UseCookieContainer = true,\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/sso/test\", 200))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .And(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Set-Cookie\", \"test=0; path=/\"))\r\n            .And(x => _steps.GivenIAddCookieToMyRequest(\"test=1; path=/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "request_should_have_own_cookies_no_cookie_container",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/sso/{everything}\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/sso/{everything}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\", \"Post\", \"Options\" },\r\n                    HttpHandlerOptions = new FileHttpHandlerOptions\r\n                    {\r\n                        UseCookieContainer = false,\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/sso/test\", 200))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .And(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Set-Cookie\", \"test=0; path=/\"))\r\n            .And(x => _steps.GivenIAddCookieToMyRequest(\"test=1; path=/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "issue_474_should_not_put_spaces_in_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Accept\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"text/html,application/xhtml+xml,application/xml;\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"text/html,application/xhtml+xml,application/xml;\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "issue_474_should_put_spaces_in_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Accept\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"text/html\"))\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"application/xhtml+xml\"))\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"application/xml\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"text/html, application/xhtml+xml, application/xml\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HttpDelegatingHandlersTests.cs",
    "methods": [
      {
        "name": "should_call_re_route_ordered_specific_handlers",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    DelegatingHandlers = new List<string>\r\n                    {\r\n                        \"FakeHandlerTwo\",\r\n                        \"FakeHandler\",\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithSpecificHandlersRegisteredInDi<FakeHandler, FakeHandlerTwo>())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .And(x => ThenTheOrderedHandlersAreCalledCorrectly())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_global_di_handlers",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithGlobalHandlersRegisteredInDi<FakeHandler, FakeHandlerTwo>())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .And(x => ThenTheHandlersAreCalledCorrectly())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_global_di_handlers_multiple_times",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithHandlerRegisteredInDi<FakeHandlerAgain>(true))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_global_di_handlers_with_dependency",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                },\r\n            },\r\n        };\r\n\r\n        var dependency = new FakeDependency();\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithGlobalHandlersRegisteredInDi<FakeHandlerWithDependency>(dependency))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .And(x => ThenTheDependencyIsCalled(dependency))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HttpTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_when_using_http_one",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/{url}\",\r\n                    DownstreamScheme = \"http\",\r\n                    UpstreamPathTemplate = \"/{url}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamHttpMethod = \"POST\",\r\n                    DownstreamHttpVersion = \"1.0\",\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", port, HttpProtocols.Http1))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_using_http_one_point_one",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/{url}\",\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/{url}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamHttpMethod = \"POST\",\r\n                        DownstreamHttpVersion = \"1.1\",\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", port, HttpProtocols.Http1))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_using_http_two_point_zero",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/{url}\",\r\n                    DownstreamScheme = \"https\",\r\n                    UpstreamPathTemplate = \"/{url}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamHttpMethod = \"POST\",\r\n                    DownstreamHttpVersion = \"2.0\",\r\n                    DangerousAcceptAnyServerCertificateValidator = true,\r\n                },\r\n            },\r\n        };\r\n\r\n        const string expected = \"here is some content\";\r\n        var httpContent = new StringContent(expected);\r\n\r\n        this.Given(x => x.GivenThereIsAServiceUsingHttpsRunningOn($\"http://localhost:{port}/\", \"/\", port, HttpProtocols.Http2))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\", httpContent))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(_ => _steps.ThenTheResponseBodyShouldBe(expected))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_502_when_using_http_one_to_talk_to_server_running_http_two",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/{url}\",\r\n                    DownstreamScheme = \"https\",\r\n                    UpstreamPathTemplate = \"/{url}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamHttpMethod = \"POST\",\r\n                    DownstreamHttpVersion = \"1.1\",\r\n                    DangerousAcceptAnyServerCertificateValidator = true,\r\n                },\r\n            },\r\n        };\r\n\r\n        const string expected = \"here is some content\";\r\n        var httpContent = new StringContent(expected);\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", port, HttpProtocols.Http2))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\", httpContent))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.BadGateway))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_using_http_two_to_talk_to_server_running_http_one_point_one",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/{url}\",\r\n                    DownstreamScheme = \"http\",\r\n                    UpstreamPathTemplate = \"/{url}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamHttpMethod = \"POST\",\r\n                    DownstreamHttpVersion = \"1.1\",\r\n                    DangerousAcceptAnyServerCertificateValidator = true,\r\n                },\r\n            },\r\n        };\r\n\r\n        const string expected = \"here is some content\";\r\n        var httpContent = new StringContent(expected);\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", port, HttpProtocols.Http1))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\", httpContent))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(_ => _steps.ThenTheResponseBodyShouldBe(expected))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "LoadBalancerTests.cs",
    "methods": [
      {
        "name": "ShouldLoadBalanceRequestWithCustomLoadBalancer",
        "body": "{\n        Func<IServiceProvider, DownstreamRoute, IServiceDiscoveryProvider, CustomLoadBalancer> loadBalancerFactoryFunc =\n            (serviceProvider, route, discoveryProvider) => new CustomLoadBalancer(discoveryProvider.GetAsync);\n        var ports = PortFinder.GetPorts(2);\n        var route = GivenRoute(nameof(CustomLoadBalancer), ports);\n        var configuration = GivenConfiguration(route);\n        var downstreamServiceUrls = ports.Select(DownstreamUrl).ToArray();\n        Action<IServiceCollection> withCustomLoadBalancer = (s)\n            => s.AddOcelot().AddCustomLoadBalancer<CustomLoadBalancer>(loadBalancerFactoryFunc);\n        GivenMultipleServiceInstancesAreRunning(downstreamServiceUrls);\n        this.Given(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunningWithServices(withCustomLoadBalancer))\n            .When(x => WhenIGetUrlOnTheApiGatewayConcurrently(\"/\", 50))\n            .Then(x => ThenAllServicesShouldHaveBeenCalledTimes(50))\n            .And(x => ThenAllServicesCalledRealisticAmountOfTimes(Bottom(50, ports.Length), Top(50, ports.Length)))\n            .And(x => ThenServicesShouldHaveBeenCalledTimes(25, 25)) // strict assertion\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "LogLevelTests.cs",
    "methods": [
      {
        "name": "if_minimum_log_level_is_critical_then_only_critical_messages_are_logged",
        "body": "No body available"
      },
      {
        "name": "if_minimum_log_level_is_error_then_critical_and_error_are_logged",
        "body": "No body available"
      },
      {
        "name": "if_minimum_log_level_is_warning_then_critical_error_and_warning_are_logged",
        "body": "No body available"
      },
      {
        "name": "if_minimum_log_level_is_information_then_critical_error_warning_and_information_are_logged",
        "body": "No body available"
      },
      {
        "name": "if_minimum_log_level_is_debug_then_critical_error_warning_information_and_debug_are_logged",
        "body": "No body available"
      },
      {
        "name": "if_minimum_log_level_is_trace_then_critical_error_warning_information_debug_and_trace_are_logged",
        "body": "No body available"
      }
    ]
  },
  {
    "file": "DownstreamMetadataTests.cs",
    "methods": []
  },
  {
    "file": "MethodTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_when_get_converted_to_post",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/{url}\",\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/{url}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamHttpMethod = \"POST\",\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", \"POST\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_get_converted_to_post_with_content",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/{url}\",\r\n                    DownstreamScheme = \"http\",\r\n                    UpstreamPathTemplate = \"/{url}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamHttpMethod = \"POST\",\r\n                },\r\n            },\r\n        };\r\n\r\n        const string expected = \"here is some content\";\r\n        var httpContent = new StringContent(expected);\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", \"POST\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\", httpContent))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(_ => _steps.ThenTheResponseBodyShouldBe(expected))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_when_get_converted_to_get_with_content",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/{url}\",\r\n                    DownstreamScheme = \"http\",\r\n                    UpstreamPathTemplate = \"/{url}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Post\" },\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamHttpMethod = \"GET\",\r\n                },\r\n            },\r\n        };\r\n\r\n        const string expected = \"here is some content\";\r\n        var httpContent = new StringContent(expected);\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}/\", \"/\", \"GET\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIPostUrlOnTheApiGateway(\"/\", httpContent))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(_ => _steps.ThenTheResponseBodyShouldBe(expected))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "OpenTracingTests.cs",
    "methods": [
      {
        "name": "should_forward_tracing_information_from_ocelot_and_downstream_services",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/api/values\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port1,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/api001/values\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    HttpHandlerOptions = new FileHttpHandlerOptions\n                    {\n                        UseTracing = true,\n                    },\n                },\n                new()\n                {\n                    DownstreamPathTemplate = \"/api/values\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = port2,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/api002/values\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    HttpHandlerOptions = new FileHttpHandlerOptions\n                    {\n                        UseTracing = true,\n                    },\n                },\n            },\n        };\n\n        var tracingPort = PortFinder.GetRandomPort();\n        var tracingUrl = $\"http://localhost:{tracingPort}\";\n\n        var fakeTracer = new FakeTracer();\n\n        this.Given(_ => GivenFakeOpenTracing(tracingUrl))\n            .And(_ => GivenServiceOneIsRunning($\"http://localhost:{port1}\", \"/api/values\", 200, \"Hello from Laura\", tracingUrl))\n            .And(_ => GivenServiceTwoIsRunning($\"http://localhost:{port2}\", \"/api/values\", 200, \"Hello from Tom\", tracingUrl))\n            .And(_ => _steps.GivenThereIsAConfiguration(configuration))\n            .And(_ => _steps.GivenOcelotIsRunningUsingOpenTracing(fakeTracer))\n            .When(_ => _steps.WhenIGetUrlOnTheApiGateway(\"/api001/values\"))\n            .Then(_ => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(_ => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .When(_ => _steps.WhenIGetUrlOnTheApiGateway(\"/api002/values\"))\n            .Then(_ => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(_ => _steps.ThenTheResponseBodyShouldBe(\"Hello from Tom\"))\n            .And(_ => ThenTheTracerIsCalled(fakeTracer))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_tracing_header",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n                {\n                    new()\n                    {\n                        DownstreamPathTemplate = \"/api/values\",\n                        DownstreamScheme = \"http\",\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\n                        {\n                            new()\n                            {\n                                Host = \"localhost\",\n                                Port = port,\n                            },\n                        },\n                        UpstreamPathTemplate = \"/api001/values\",\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\n                        HttpHandlerOptions = new FileHttpHandlerOptions\n                        {\n                            UseTracing = true,\n                        },\n                        DownstreamHeaderTransform = new Dictionary<string, string>\n                        {\n                            {\"Trace-Id\", \"{TraceId}\"},\n                            {\"Tom\", \"Laura\"},\n                        },\n                    },\n                },\n        };\n\n        var butterflyPort = PortFinder.GetRandomPort();\n\n        var butterflyUrl = $\"http://localhost:{butterflyPort}\";\n\n        var fakeTracer = new FakeTracer();\n\n        this.Given(x => GivenFakeOpenTracing(butterflyUrl))\n            .And(x => GivenServiceOneIsRunning($\"http://localhost:{port}\", \"/api/values\", 200, \"Hello from Laura\", butterflyUrl))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunningUsingOpenTracing(fakeTracer))\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/api001/values\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .And(x => _steps.ThenTheTraceHeaderIsSet(\"Trace-Id\"))\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Tom\", \"Laura\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "PollyQoSTests.cs",
    "methods": [
      {
        "name": "Should_not_timeout",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(port, new QoSOptions(10, 500, 1000, null), HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, HttpStatusCode.OK, string.Empty, 10))\r\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunningWithPolly())\r\n            .And(x => GivenThePostHasContent(\"postContent\"))\r\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_timeout",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(port, new QoSOptions(0, 0, 1000, null), HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, HttpStatusCode.Created, string.Empty, 2100))\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunningWithPolly())\r\n            .And(x => GivenThePostHasContent(\"postContent\"))\r\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_open_circuit_breaker_after_two_exceptions",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(port, new QoSOptions(2, 1000, 100000, null));\r\n        var configuration = GivenConfiguration(route);\r\n\r\n        this.Given(x => x.GivenThereIsABrokenServiceRunningOn(port, HttpStatusCode.InternalServerError))\r\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunningWithPolly())\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.InternalServerError))\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.InternalServerError))\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\")) // opened\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable)) // Polly status\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_open_circuit_breaker_for_DefaultBreakDuration",
        "body": "{\r\n        int invalidDuration = QoSOptions.LowBreakDuration; // valid value must be >500ms, exact 500ms is invalid\r\n        var port = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(port, new QoSOptions(2, invalidDuration, 100000, null));\r\n        var configuration = GivenConfiguration(route);\r\n\r\n        this.Given(x => x.GivenThereIsABrokenServiceRunningOn(port, HttpStatusCode.InternalServerError))\r\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunningWithPolly())\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.InternalServerError))\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.InternalServerError))\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\")) // opened\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable)) // Polly status\r\n            .Given(x => GivenIWaitMilliseconds(QoSOptions.DefaultBreakDuration - 500)) // BreakDuration is not elapsed\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\")) // still opened\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable)) // still opened\r\n            .Given(x => GivenThereIsABrokenServiceOnline(HttpStatusCode.NotFound))\r\n            .Given(x => GivenIWaitMilliseconds(500)) // BreakDuration should elapse now\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\")) // closed, service online\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound)) // closed, service online\r\n            .And(x => ThenTheResponseBodyShouldBe(nameof(HttpStatusCode.NotFound)))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_open_circuit_breaker_then_close",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(port, new QoSOptions(2, 500, 1000, null));\n        var configuration = GivenConfiguration(route);\n\r\n        this.Given(x => x.GivenThereIsAPossiblyBrokenServiceRunningOn(port, \"Hello from Laura\"))\r\n            .Given(x => GivenThereIsAConfiguration(configuration))\r\n            .Given(x => GivenOcelotIsRunningWithPolly())\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\")) // repeat same request because min ExceptionsAllowedBeforeBreaking is 2\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .Given(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Given(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .Given(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Given(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .Given(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Given(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .Given(x => GivenIWaitMilliseconds(3000))\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Open_circuit_should_not_effect_different_route",
        "body": "{\r\n        var port1 = PortFinder.GetRandomPort();\r\n        var port2 = PortFinder.GetRandomPort();\r\n        var qos1 = new QoSOptions(2, 500, 1000, null);\n        var route = GivenRoute(port1, qos1);\r\n        var route2 = GivenRoute(port2, new(new FileQoSOptions()), null, \"/working\");\r\n        var configuration = GivenConfiguration(route, route2);\r\n\r\n        this.Given(x => x.GivenThereIsAPossiblyBrokenServiceRunningOn(port1, \"Hello from Laura\"))\r\n            .And(x => x.GivenThereIsAServiceRunningOn(port2, HttpStatusCode.OK, \"Hello from Tom\", 0))\r\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunningWithPolly())\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\")) // repeat same request because min ExceptionsAllowedBeforeBreaking is 2\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/working\"))\r\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Tom\"))\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .And(x => GivenIWaitMilliseconds(3000))\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_timeout_per_default_after_90_seconds",
        "body": "{\n        var port = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(port, new QoSOptions(new FileQoSOptions()), HttpMethods.Get);\n        var configuration = GivenConfiguration(route);\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, HttpStatusCode.Created, string.Empty, 3500)) // 3.5s > 3s -> ServiceUnavailable\r\n            .And(x => GivenThereIsAConfiguration(configuration))\r\n            .And(x => GivenOcelotIsRunningWithPolly())\r\n            .And(x => GivenIHackDefaultTimeoutValue(3)) // after 3 secs -> Timeout exception aka request cancellation\r\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.ServiceUnavailable))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ClientRateLimitingTests.cs",
    "methods": [
      {
        "name": "Should_call_with_rate_limiting",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, null, null, new(), 3, \"1s\", 1); // periods are equal\n        var configuration = GivenConfigurationWithRateLimitOptions(route);\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/api/ClientRateLimit\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/api/ClientRateLimit\", 1))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/api/ClientRateLimit\", 2))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/api/ClientRateLimit\", 1))\n            .Then(x => ThenTheStatusCodeShouldBe(TooManyRequests))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_wait_for_period_timespan_to_elapse_before_making_next_request",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, \"/api/ClientRateLimit?count={count}\", \"/ClientRateLimit/?{count}\", new(), 3, \"1s\", 2);\n        var configuration = GivenConfigurationWithRateLimitOptions(route);\n        _counterOne = 0;\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/api/ClientRateLimit\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 1))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 2))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 1))\n            .Then(x => ThenTheStatusCodeShouldBe(TooManyRequests))\n            .And(x => GivenIWait(1000))\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 1))\n            .Then(x => ThenTheStatusCodeShouldBe(TooManyRequests))\n            .And(x => GivenIWait(1000))\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 1))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"4\")) // total 4 OK responses\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_call_middleware_with_white_list_client",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, null, null, whitelist: new() { \"ocelotclient1\" }, 3, \"3s\", 2); // main period is greater than ban one\n        var configuration = GivenConfigurationWithRateLimitOptions(route);\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/api/ClientRateLimit\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/api/ClientRateLimit\", 4))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "StatusShouldNotBeEqualTo429_PeriodTimespanValueIsGreaterThanPeriod",
        "body": "{\n        _counterOne = 0;\n\n        // Bug scenario\n        const string period = \"1s\";\n        const double periodTimespan = /*30*/3; // but decrease 30 to 3 secs, \"no wasting time\" life hack\n        const long limit = 100L;\n\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, \"/api/ClientRateLimit?count={count}\", \"/ClientRateLimit/?{count}\", new(),\n            limit, period, periodTimespan); // bug scenario, adapted\n        var configuration = GivenConfigurationWithRateLimitOptions(route);\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/api/ClientRateLimit\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n\n            // main scenario\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, route.RateLimitOptions.Limit)) // 100 times to reach the limit\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .And(x => ThenTheResponseBodyShouldBe(route.RateLimitOptions.Limit.ToString())) // total 100 OK responses\n\n            // extra scenario\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 1)) // 101st request should fail\n            .Then(x => ThenTheStatusCodeShouldBe(TooManyRequests))\n            .And(x => GivenIWait((int)TimeSpan.FromSeconds(route.RateLimitOptions.PeriodTimespan).TotalMilliseconds)) // in 3 secs PeriodTimespan will elapse\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(Url, 1))\n            .Then(x => ThenTheStatusCodeShouldBe(OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"101\")) // total 101 OK responses\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ReasonPhraseTests.cs",
    "methods": [
      {
        "name": "should_return_reason_phrase",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", \"some reason\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .And(_ => _steps.ThenTheReasonPhraseIs(\"some reason\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RequestMapperTests.cs",
    "methods": [
      {
        "name": "Should_map_request_without_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";;\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_content_length",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new StringContent(\"This is some content\")))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"20;;This is some content\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_empty_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new StringContent(\"\")))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"0;;\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_chunked_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new ChunkedContent(\"This \", \"is some content\")))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";chunked;This is some content\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_empty_chunked_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new ChunkedContent()))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";chunked;\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "StreamContentTests.cs",
    "methods": [
      {
        "name": "Should_stream_with_content_length",
        "body": "{\n        var contentSize = 1024L * 1024L * 1024L; // 1GB\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new StreamTestContent(contentSize, false)))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(contentSize + \";;\" + contentSize))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_stream_with_chunked_content",
        "body": "{\n        var contentSize = 1024L * 1024L * 1024L; // 1GB\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new StreamTestContent(contentSize, true)))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";chunked;\" + contentSize))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "RequestIdTests.cs",
    "methods": [
      {
        "name": "should_use_default_request_id_and_forward",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    DownstreamScheme = \"http\",\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    RequestIdKey = _steps.RequestIdKey,\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheRequestIdIsReturned())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_request_id_and_forward",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        var requestId = Guid.NewGuid().ToString();\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\", requestId))\r\n            .Then(x => _steps.ThenTheRequestIdIsReturned(requestId))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_global_request_id_and_forward",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                RequestIdKey = _steps.RequestIdKey,\r\n            },\r\n        };\r\n\r\n        var requestId = Guid.NewGuid().ToString();\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\", requestId))\r\n            .Then(x => _steps.ThenTheRequestIdIsReturned(requestId))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_global_request_id_create_and_forward",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                RequestIdKey = _steps.RequestIdKey,\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheRequestIdIsReturned())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "PayloadTooLargeTests.cs",
    "methods": [
      {
        "name": "Should_throw_payload_too_large_exception_using_kestrel",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port)))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunningOnKestrelWithCustomBodyMaxSize(1024))\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new ByteArrayContent(Encoding.UTF8.GetBytes(Payload))))\n            .Then(x => ThenTheStatusCodeShouldBe((int)HttpStatusCode.RequestEntityTooLarge))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ResponseCodeTests.cs",
    "methods": [
      {
        "name": "ShouldReturnResponse304WhenServiceReturns304",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/{everything}\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/{everything}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/inline.132.bundle.js\", 304))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/inline.132.bundle.js\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.NotModified))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ReturnsErrorTests.cs",
    "methods": [
      {
        "name": "Should_return_bad_gateway_error_if_downstream_service_doesnt_respond",
        "body": "{\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = 53877,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                    },\r\n                },\r\n        };\n\n        this.Given(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.BadGateway))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_internal_server_error_if_downstream_service_returns_internal_server_error",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.InternalServerError))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_log_warning_if_downstream_service_returns_internal_server_error",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        DownstreamScheme = \"http\",\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithLogger())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenWarningShouldBeLogged(1))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RoutingBasedOnHeadersTests.cs",
    "methods": [
      {
        "name": "Should_match_one_header_value",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, headerValue))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello()))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_one_header_value_when_more_headers",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(\"other\", \"otherValue\"))\n            .And(x => GivenIAddAHeader(headerName, headerValue))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello()))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_two_header_values_when_more_headers",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName1 = \"country_code\";\n        var headerValue1 = \"PL\";\n        var headerName2 = \"region\";\n        var headerValue2 = \"MAZ\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName1] = headerValue1,\n            [headerName2] = headerValue2,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName1, headerValue1))\n            .And(x => GivenIAddAHeader(\"other\", \"otherValue\"))\n            .And(x => GivenIAddAHeader(headerName2, headerValue2))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello()))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_match_one_header_value",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var anotherHeaderValue = \"UK\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, anotherHeaderValue))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_match_one_header_value_when_no_headers",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_match_two_header_values_when_one_different",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName1 = \"country_code\";\n        var headerValue1 = \"PL\";\n        var headerName2 = \"region\";\n        var headerValue2 = \"MAZ\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName1] = headerValue1,\n            [headerName2] = headerValue2,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName1, headerValue1))\n            .And(x => GivenIAddAHeader(\"other\", \"otherValue\"))\n            .And(x => GivenIAddAHeader(headerName2, \"anothervalue\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_match_two_header_values_when_one_not_existing",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName1 = \"country_code\";\n        var headerValue1 = \"PL\";\n        var headerName2 = \"region\";\n        var headerValue2 = \"MAZ\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName1] = headerValue1,\n            [headerName2] = headerValue2,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName1, headerValue1))\n            .And(x => GivenIAddAHeader(\"other\", \"otherValue\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_match_one_header_value_when_header_duplicated",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, headerValue))\n            .And(x => GivenIAddAHeader(headerName, \"othervalue\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_aggregated_route_match_header_value",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var routeA = GivenRoute(port1, \"/a\", \"Laura\");\n        var routeB = GivenRoute(port2, \"/b\", \"Tom\");\n        var route = GivenAggRouteWithUpstreamHeaderTemplates(new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(routeA, routeB);\n        configuration.Aggregates.Add(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port1, \"/a\", HttpStatusCode.OK, Hello(\"Laura\")))\n            .And(x => GivenThereIsAServiceRunningOn(port2, \"/b\", HttpStatusCode.OK, Hello(\"Tom\")))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, headerValue))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_aggregated_route_not_match_header_value",
        "body": "{\n        var port1 = PortFinder.GetRandomPort();\n        var port2 = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue = \"PL\";\n        var routeA = GivenRoute(port1, \"/a\", \"Laura\");\n        var routeB = GivenRoute(port2, \"/b\", \"Tom\");\n        var route = GivenAggRouteWithUpstreamHeaderTemplates(new()\n        {\n            [headerName] = headerValue,\n        });\n        var configuration = GivenConfiguration(routeA, routeB);\n        configuration.Aggregates.Add(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port1, \"/a\", HttpStatusCode.OK, Hello(\"Laura\")))\n            .And(x => x.GivenThereIsAServiceRunningOn(port2, \"/b\", HttpStatusCode.OK, Hello(\"Tom\")))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_header_placeholder",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"Region\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, \"/products\", \"/api.internal-{code}/products\",\n            new()\n            {\n                [headerName] = \"{header:code}\",\n            });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/api.internal-uk/products\", HttpStatusCode.OK, Hello(\"UK\")))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, \"uk\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/products\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello(\"UK\")))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_header_placeholder_not_in_downstream_path",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"ProductName\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, \"/products\", \"/products-info\",\n            new()\n            {\n                [headerName] = \"product-{header:everything}\",\n            });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/products-info\", HttpStatusCode.OK, Hello(\"products\")))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, \"product-Camera\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/products\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello(\"products\")))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_distinguish_route_for_different_roles",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"Origin\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, \"/products\", \"/products-admin\",\n            new()\n            {\n                [headerName] = \"admin.xxx.com\",\n            });\n        var route2 = GivenRouteWithUpstreamHeaderTemplates(port, \"/products\", \"/products\", null);\n        var configuration = GivenConfiguration(route, route2);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/products-admin\", HttpStatusCode.OK, Hello(\"products admin\")))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, \"admin.xxx.com\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/products\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello(\"products admin\")))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_header_and_url_placeholders",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, \"/{aa}\", \"/{country_code}/{version}/{aa}\",\n            new()\n            {\n                [headerName] = \"start_{header:country_code}_version_{header:version}_end\",\n            });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/pl/v1/bb\", HttpStatusCode.OK, Hello()))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, \"start_pl_version_v1_end\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/bb\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello()))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_header_with_braces",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port, \"/\", \"/aa\",\n            new()\n            {\n                [headerName] = \"my_{header}\",\n            });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/aa\", HttpStatusCode.OK, Hello()))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, \"my_{header}\"))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello()))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_match_two_headers_with_the_same_name",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var headerName = \"country_code\";\n        var headerValue1 = \"PL\";\n        var headerValue2 = \"UK\";\n        var route = GivenRouteWithUpstreamHeaderTemplates(port,\n            new()\n            {\n                [headerName] = headerValue1 + \";{header:whatever}\",\n            });\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .And(x => GivenIAddAHeader(headerName, headerValue1))\n            .And(x => GivenIAddAHeader(headerName, headerValue2))\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(Hello()))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "RoutingWithQueryStringTests.cs",
    "methods": [
      {
        "name": "Should_return_response_200_with_query_string_template",
        "body": "{\n        var subscriptionId = Guid.NewGuid().ToString();\n        var unitId = Guid.NewGuid().ToString();\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\",\n            \"/api/units/{subscriptionId}/{unitId}/updates\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, $\"/api/subscriptions/{subscriptionId}/updates\", $\"?unitId={unitId}\", \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/api/units/{subscriptionId}/{unitId}/updates\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_query_parameters_with_different_names",
        "body": "{\n        const string userId = \"webley\";\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/persons?personId={userId}\",\n            \"/users?userId={userId}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/persons\", $\"?personId={userId}\", \"Hello from @webley\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/users?userId={userId}\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from @webley\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_query_parameters_with_different_names_and_save_old_param_if_placeholder_and_param_names_differ",
        "body": "{\n        const string uid = \"webley\";\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/persons?personId={uid}\",\n            \"/users?userId={uid}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/persons\", $\"?personId={uid}&userId={uid}\", \"Hello from @webley\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/users?userId={uid}\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from @webley\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_query_parameters_with_different_names_and_save_old_param_if_placeholder_and_param_names_differ_case_sensitive",
        "body": "{\n        const string userid = \"webley\";\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/persons?personId={userid}\",\n            \"/users?userId={userid}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/persons\", $\"?personId={userid}&userId={userid}\", \"Hello from @webley\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/users?userId={userid}\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from @webley\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_odata_query_string",
        "body": "{\n        var subscriptionId = Guid.NewGuid().ToString();\n        var unitId = Guid.NewGuid().ToString();\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, \"/{everything}\", \"/{everything}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, \"/odata/customers\", \"?$filter=Name%20eq%20'Sam'\", \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/odata/customers?$filter=Name eq 'Sam' \"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_query_string_upstream_template",
        "body": "{\n        var subscriptionId = Guid.NewGuid().ToString();\n        var unitId = Guid.NewGuid().ToString();\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/api/units/{subscriptionId}/{unitId}/updates\",\n            \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, $\"/api/units/{subscriptionId}/{unitId}/updates\", string.Empty, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_404_with_query_string_upstream_template_no_query_string",
        "body": "{\n        var subscriptionId = Guid.NewGuid().ToString();\n        var unitId = Guid.NewGuid().ToString();\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/api/units/{subscriptionId}/{unitId}/updates\",\n            \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, $\"/api/units/{subscriptionId}/{unitId}/updates\", string.Empty, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/api/subscriptions/{subscriptionId}/updates\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_404_with_query_string_upstream_template_different_query_string",
        "body": "{\n        var subscriptionId = Guid.NewGuid().ToString();\n        var unitId = Guid.NewGuid().ToString();\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/api/units/{subscriptionId}/{unitId}/updates\",\n            \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, $\"/api/units/{subscriptionId}/{unitId}/updates\", string.Empty, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/api/subscriptions/{subscriptionId}/updates?test=1\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_response_200_with_query_string_upstream_template_multiple_params",
        "body": "{\n        var subscriptionId = Guid.NewGuid().ToString();\n        var unitId = Guid.NewGuid().ToString();\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/api/units/{subscriptionId}/{unitId}/updates\",\n            \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, $\"/api/units/{subscriptionId}/{unitId}/updates\", \"?productId=1\", \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}&productId=1\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_when_query_parameters_has_same_names_with_placeholder",
        "body": "{\n        const string username = \"bbenameur\";\n        const string groupName = \"Paris\";\n        const string roleid = \"123456\";\n        const string everything = \"something=9874565\";\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            \"/account/{username}/groups/{groupName}/roles?roleId={roleid}&{everything}\",\n            \"/WeatherForecast/{roleid}/groups?username={username}&groupName={groupName}&{everything}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port,\n                $\"/account/{username}/groups/{groupName}/roles\",\n                $\"?roleId={roleid}&{everything}\",\n                \"Hello from Bchir\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/WeatherForecast/{roleid}/groups?username={username}&groupName={groupName}&{everything}\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Bchir\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_copy_query_string_to_downstream_path",
        "body": "{\n        var idName = \"id\";\n        var idValue = \"3\";\n        var queryName = idName + \"1\";\n        var queryValue = \"2\" + idValue + \"12\";\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port,\n            $\"/cpx/t1/{{{idName}}}\",\n            $\"/safe/{{{idName}}}\");\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, $\"/cpx/t1/{idValue}\", $\"?{queryName}={queryValue}\", \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway($\"/safe/{idValue}?{queryName}={queryValue}\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "SecurityOptionsTests.cs",
    "methods": [
      {
        "name": "Should_call_with_allowed_ip_in_global_config",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var ip = Dns.GetHostAddresses(\"192.168.1.35\")[0];\n        var route = GivenRoute(port, \"/myPath\", \"/worldPath\");\n        var configuration = GivenGlobalConfiguration(route, \"192.168.1.30-50\", \"192.168.1.1-100\");\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, ip))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/worldPath\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK));\n    }"
      },
      {
        "name": "Should_block_call_with_blocked_ip_in_global_config",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var ip = Dns.GetHostAddresses(\"192.168.1.55\")[0];\n        var route = GivenRoute(port, \"/myPath\", \"/worldPath\");\n        var configuration = GivenGlobalConfiguration(route, \"192.168.1.30-50\", \"192.168.1.1-100\");\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, ip))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/worldPath\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Unauthorized));\n    }"
      },
      {
        "name": "Should_call_with_allowed_ip_in_route_config",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var ip = Dns.GetHostAddresses(\"192.168.1.1\")[0];\n        var securityConfig = new FileSecurityOptions\n        {\n            IPAllowedList = new() { \"192.168.1.1\" },\n        };\n        var route = GivenRoute(port, \"/myPath\", \"/worldPath\", securityConfig);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, ip))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/worldPath\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK));\n    }"
      },
      {
        "name": "Should_block_call_with_blocked_ip_in_route_config",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var ip = Dns.GetHostAddresses(\"192.168.1.1\")[0];\n        var securityConfig = new FileSecurityOptions\n        {\n            IPBlockedList = new() { \"192.168.1.1\" },\n        };\n        var route = GivenRoute(port, \"/myPath\", \"/worldPath\", securityConfig);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, ip))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/worldPath\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Unauthorized));\n    }"
      },
      {
        "name": "Should_call_with_allowed_ip_in_route_config_and_blocked_ip_in_global_config",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var ip = Dns.GetHostAddresses(\"192.168.1.55\")[0];\n        var securityConfig = new FileSecurityOptions\n        {\n            IPAllowedList = new() { \"192.168.1.55\" },\n        };\n        var route = GivenRoute(port, \"/myPath\", \"/worldPath\", securityConfig);\n        var configuration = GivenGlobalConfiguration(route, \"192.168.1.30-50\", \"192.168.1.1-100\");\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, ip))\n           .And(x => GivenThereIsAConfiguration(configuration))\n           .And(x => GivenOcelotIsRunning())\n           .When(x => WhenIGetUrlOnTheApiGateway(\"/worldPath\"))\n           .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n           .Then(x => ThenTheResponseBodyShouldBe(\"Hello from Fabrizio\"));\n    }"
      },
      {
        "name": "Should_block_call_with_blocked_ip_in_route_config_and_allowed_ip_in_global_config",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var ip = Dns.GetHostAddresses(\"192.168.1.35\")[0];\n        var securityConfig = new FileSecurityOptions\n        {\n            IPBlockedList = new() { \"192.168.1.35\" },\n        };\n        var route = GivenRoute(port, \"/myPath\", \"/worldPath\", securityConfig);\n        var configuration = GivenGlobalConfiguration(route, \"192.168.1.30-50\", \"192.168.1.1-100\");\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(port, ip))\n           .And(x => GivenThereIsAConfiguration(configuration))\n           .And(x => GivenOcelotIsRunning())\n           .When(x => WhenIGetUrlOnTheApiGateway(\"/worldPath\"))\n           .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.Unauthorized));\n    }"
      }
    ]
  },
  {
    "file": "SequentialTests.cs",
    "methods": []
  },
  {
    "file": "ConsulConfigurationInConsulTests.cs",
    "methods": [
      {
        "name": "Should_return_response_200_with_simple_url",
        "body": "{\n        var consulPort = PortFinder.GetRandomPort();\n        var servicePort = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n                {\n                    new()\n                    {\n                        DownstreamPathTemplate = \"/\",\n                        DownstreamScheme = \"http\",\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\n                        {\n                            new()\n                            {\n                                Host = \"localhost\",\n                                Port = servicePort,\n                            },\n                        },\n                        UpstreamPathTemplate = \"/\",\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\n                    },\n                },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        var fakeConsulServiceDiscoveryUrl = $\"http://localhost:{consulPort}\";\n\n        this.Given(x => GivenThereIsAFakeConsulServiceDiscoveryProvider(fakeConsulServiceDiscoveryUrl, string.Empty))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{servicePort}\", string.Empty, 200, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => x.GivenOcelotIsRunningUsingConsulToStoreConfig())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_load_configuration_out_of_consul",
        "body": "{\n        var consulPort = PortFinder.GetRandomPort();\n        var servicePort = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        var fakeConsulServiceDiscoveryUrl = $\"http://localhost:{consulPort}\";\n\n        var consulConfig = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/status\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = servicePort,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/cs/status\",\n                    UpstreamHttpMethod = new List<string> {\"Get\"},\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        this.Given(x => GivenTheConsulConfigurationIs(consulConfig))\n            .And(x => GivenThereIsAFakeConsulServiceDiscoveryProvider(fakeConsulServiceDiscoveryUrl, string.Empty))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{servicePort}\", \"/status\", 200, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => x.GivenOcelotIsRunningUsingConsulToStoreConfig())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/cs/status\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_load_configuration_out_of_consul_if_it_is_changed",
        "body": "{\n        var consulPort = PortFinder.GetRandomPort();\n        var servicePort = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        var fakeConsulServiceDiscoveryUrl = $\"http://localhost:{consulPort}\";\n\n        var consulConfig = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/status\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = servicePort,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/cs/status\",\n                    UpstreamHttpMethod = new List<string> {\"Get\"},\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        var secondConsulConfig = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/status\",\n                    DownstreamScheme = \"http\",\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\n                    {\n                        new()\n                        {\n                            Host = \"localhost\",\n                            Port = servicePort,\n                        },\n                    },\n                    UpstreamPathTemplate = \"/cs/status/awesome\",\n                    UpstreamHttpMethod = new List<string> {\"Get\"},\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        this.Given(x => GivenTheConsulConfigurationIs(consulConfig))\n            .And(x => GivenThereIsAFakeConsulServiceDiscoveryProvider(fakeConsulServiceDiscoveryUrl, string.Empty))\n            .And(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{servicePort}\", \"/status\", 200, \"Hello from Laura\"))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => x.GivenOcelotIsRunningUsingConsulToStoreConfig())\n            .And(x => WhenIGetUrlOnTheApiGateway(\"/cs/status\"))\n            .And(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .When(x => GivenTheConsulConfigurationIs(secondConsulConfig))\n            .Then(x => ThenTheConfigIsUpdatedInOcelot())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_handle_request_to_consul_for_downstream_service_and_make_request_no_re_routes_and_rate_limit",
        "body": "{\n        var consulPort = PortFinder.GetRandomPort();\n        const string serviceName = \"web\";\n        var downstreamServicePort = PortFinder.GetRandomPort();\n        var downstreamServiceOneUrl = $\"http://localhost:{downstreamServicePort}\";\n        var fakeConsulServiceDiscoveryUrl = $\"http://localhost:{consulPort}\";\n        var serviceEntryOne = new ServiceEntry\n        {\n            Service = new AgentService\n            {\n                Service = serviceName,\n                Address = \"localhost\",\n                Port = downstreamServicePort,\n                ID = \"web_90_0_2_224_8080\",\n                Tags = new[] { \"version-v1\" },\n            },\n        };\n\n        var consulConfig = new FileConfiguration\n        {\n            DynamicRoutes = new List<FileDynamicRoute>\n            {\n                new()\n                {\n                    ServiceName = serviceName,\n                    RateLimitRule = new FileRateLimitRule\n                    {\n                        EnableRateLimiting = true,\n                        ClientWhitelist = new List<string>(),\n                        Limit = 3,\n                        Period = \"1s\",\n                        PeriodTimespan = 1000,\n                    },\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n                RateLimitOptions = new FileRateLimitOptions\n                {\n                    ClientIdHeader = \"ClientId\",\n                    DisableRateLimitHeaders = false,\n                    QuotaExceededMessage = string.Empty,\n                    RateLimitCounterPrefix = string.Empty,\n                    HttpStatusCode = 428,\n                },\n                DownstreamScheme = \"http\",\n            },\n        };\n\n        var configuration = new FileConfiguration\n        {\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(downstreamServiceOneUrl, \"/something\", 200, \"Hello from Laura\"))\n        .And(x => GivenTheConsulConfigurationIs(consulConfig))\n        .And(x => x.GivenThereIsAFakeConsulServiceDiscoveryProvider(fakeConsulServiceDiscoveryUrl, serviceName))\n        .And(x => x.GivenTheServicesAreRegisteredWithConsul(serviceEntryOne))\n        .And(x => GivenThereIsAConfiguration(configuration))\n        .And(x => x.GivenOcelotIsRunningUsingConsulToStoreConfig())\n        .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/web/something\", 1))\n        .Then(x => ThenTheStatusCodeShouldBe(200))\n        .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/web/something\", 2))\n        .Then(x => ThenTheStatusCodeShouldBe(200))\n        .When(x => WhenIGetUrlOnTheApiGatewayMultipleTimesForRateLimit(\"/web/something\", 1))\n        .Then(x => ThenTheStatusCodeShouldBe(428))\n        .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ConsulWebSocketTests.cs",
    "methods": [
      {
        "name": "ShouldProxyWebsocketInputToDownstreamServiceAndUseServiceDiscoveryAndLoadBalancer",
        "body": "{\n        var downstreamPort = PortFinder.GetRandomPort();\n        var downstreamHost = \"localhost\";\n\n        var secondDownstreamPort = PortFinder.GetRandomPort();\n        var secondDownstreamHost = \"localhost\";\n\n        var serviceName = \"websockets\";\n        var consulPort = PortFinder.GetRandomPort();\n        var serviceEntryOne = new ServiceEntry\n        {\n            Service = new AgentService\n            {\n                Service = serviceName,\n                Address = downstreamHost,\n                Port = downstreamPort,\n                ID = Guid.NewGuid().ToString(),\n                Tags = Array.Empty<string>(),\n            },\n        };\n        var serviceEntryTwo = new ServiceEntry\n        {\n            Service = new AgentService\n            {\n                Service = serviceName,\n                Address = secondDownstreamHost,\n                Port = secondDownstreamPort,\n                ID = Guid.NewGuid().ToString(),\n                Tags = Array.Empty<string>(),\n            },\n        };\n\n        var config = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    UpstreamPathTemplate = \"/\",\n                    DownstreamPathTemplate = \"/ws\",\n                    DownstreamScheme = \"ws\",\n                    LoadBalancerOptions = new FileLoadBalancerOptions { Type = \"RoundRobin\" },\n                    ServiceName = serviceName,\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Scheme = \"http\",\n                    Host = \"localhost\",\n                    Port = consulPort,\n                    Type = \"consul\",\n                },\n            },\n        };\n\n        this.Given(_ => GivenThereIsAConfiguration(config))\n            .And(_ => StartFakeOcelotWithWebSocketsWithConsul())\n            .And(_ => GivenThereIsAFakeConsulServiceDiscoveryProvider(consulPort, serviceName))\n            .And(_ => GivenTheServicesAreRegisteredWithConsul(serviceEntryOne, serviceEntryTwo))\n            .And(_ => StartFakeDownstreamService($\"http://{downstreamHost}:{downstreamPort}\", \"/ws\"))\n            .And(_ => StartSecondFakeDownstreamService($\"http://{secondDownstreamHost}:{secondDownstreamPort}\", \"/ws\"))\n            .When(_ => WhenIStartTheClients())\n            .Then(_ => ThenBothDownstreamServicesAreCalled())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "EurekaServiceDiscoveryTests.cs",
    "methods": []
  },
  {
    "file": "KubernetesServiceDiscoveryTests.cs",
    "methods": [
      {
        "name": "ShouldReturnServicesFromK8s",
        "body": "{\n        const string namespaces = nameof(KubernetesServiceDiscoveryTests);\n        const string serviceName = nameof(ShouldReturnServicesFromK8s);\n        var servicePort = PortFinder.GetRandomPort();\n        var downstreamUrl = LoopbackLocalhostUrl(servicePort);\n        var downstream = new Uri(downstreamUrl);\n        var subsetV1 = GivenSubsetAddress(downstream);\n        var endpoints = GivenEndpoints(subsetV1);\n        var route = GivenRouteWithServiceName(namespaces);\n        var configuration = GivenKubeConfiguration(namespaces, route);\n        var downstreamResponse = serviceName;\n        this.Given(x => GivenServiceInstanceIsRunning(downstreamUrl, downstreamResponse))\n            .And(x => x.GivenThereIsAFakeKubernetesProvider(endpoints, serviceName, namespaces))\n            .And(_ => GivenThereIsAConfiguration(configuration))\n            .And(_ => GivenOcelotIsRunningWithServices(WithKubernetes))\n            .When(_ => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(_ => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(_ => ThenTheResponseBodyShouldBe($\"1:{downstreamResponse}\"))\n            .And(x => ThenAllServicesShouldHaveBeenCalledTimes(1))\n            .And(x => x.ThenTheTokenIs(\"Bearer txpc696iUhbVoudg164r93CxDTrKRVWG\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ServiceFabricTests.cs",
    "methods": [
      {
        "name": "should_fix_issue_555",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n                {\n                    new()\n                    {\n                        DownstreamPathTemplate = \"/{everything}\",\n                        DownstreamScheme = \"http\",\n                        UpstreamPathTemplate = \"/{everything}\",\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\n                        ServiceName = \"OcelotServiceApplication/OcelotApplicationService\",\n                    },\n                },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Host = \"localhost\",\n                    Port = port,\n                    Type = \"ServiceFabric\",\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/OcelotServiceApplication/OcelotApplicationService/a\", 200, \"Hello from Laura\", \"b=c\"))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/a?b=c\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_support_service_fabric_naming_and_dns_service_stateless_and_guest",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n                {\n                    new()\n                    {\n                        DownstreamPathTemplate = \"/api/values\",\n                        DownstreamScheme = \"http\",\n                        UpstreamPathTemplate = \"/EquipmentInterfaces\",\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\n                        ServiceName = \"OcelotServiceApplication/OcelotApplicationService\",\n                    },\n                },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Host = \"localhost\",\n                    Port = port,\n                    Type = \"ServiceFabric\",\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/OcelotServiceApplication/OcelotApplicationService/api/values\", 200, \"Hello from Laura\", \"test=best\"))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/EquipmentInterfaces?test=best\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_support_service_fabric_naming_and_dns_service_statefull_and_actors",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n\n        var configuration = new FileConfiguration\n        {\n            Routes = new List<FileRoute>\n            {\n                new()\n                {\n                    DownstreamPathTemplate = \"/api/values\",\n                    DownstreamScheme = \"http\",\n                    UpstreamPathTemplate = \"/EquipmentInterfaces\",\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\n                    ServiceName = \"OcelotServiceApplication/OcelotApplicationService\",\n                },\n            },\n            GlobalConfiguration = new FileGlobalConfiguration\n            {\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n                {\n                    Host = \"localhost\",\n                    Port = port,\n                    Type = \"ServiceFabric\",\n                },\n            },\n        };\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/OcelotServiceApplication/OcelotApplicationService/api/values\", 200, \"Hello from Laura\", \"PartitionKind=test&PartitionKey=1\"))\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\n            .And(x => _steps.GivenOcelotIsRunning())\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/EquipmentInterfaces?PartitionKind=test&PartitionKey=1\"))\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "SslTests.cs",
    "methods": [
      {
        "name": "should_dangerous_accept_any_server_certificate_validator",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"https\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DangerousAcceptAnyServerCertificateValidator = true,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"https://localhost:{port}\", \"/\", 200, \"Hello from Laura\", port))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_dangerous_accept_any_server_certificate_validator",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"https\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DangerousAcceptAnyServerCertificateValidator = false,\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"https://localhost:{port}\", \"/\", 200, \"Hello from Laura\", port))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.BadGateway))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "StartupTests.cs",
    "methods": [
      {
        "name": "should_not_try_and_write_to_disk_on_startup_when_not_using_admin_api",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                },\r\n            },\r\n        };\r\n\r\n        var fakeRepo = new FakeFileConfigurationRepository();\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunningWithBlowingUpDiskRepo(fakeRepo))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "StickySessionsTests.cs",
    "methods": [
      {
        "name": "ShouldUseSameDownstreamHost_ForSingleRouteWithHighLoad",
        "body": "{\r\n        var port1 = PortFinder.GetRandomPort();\r\n        var port2 = PortFinder.GetRandomPort();\r\n        var route = GivenRoute(\"/\")\r\n            .WithHosts(Localhost(port1), Localhost(port2));\r\n        var cookieName = route.LoadBalancerOptions.Key;\r\n        var configuration = GivenConfiguration(route);\r\n\r\n        this.Given(x => x.GivenProductServiceIsRunning(0, DownstreamUrl(port1)))\r\n            .Given(x => x.GivenProductServiceIsRunning(1, DownstreamUrl(port2)))\r\n            .And(_ => GivenThereIsAConfiguration(configuration))\r\n            .And(_ => GivenOcelotIsRunning())\r\n            .When(x => x.WhenIGetUrlOnTheApiGatewayMultipleTimes(\"/\", 10, cookieName, Guid.NewGuid().ToString()))\r\n            .Then(x => x.ThenServiceShouldHaveBeenCalledTimes(0, 10)) // RoundRobin should return first service with port1\r\n            .Then(x => x.ThenServiceShouldHaveBeenCalledTimes(1, 0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "ShouldUseDifferentDownstreamHost_ForDoubleRoutesWithDifferentCookies",
        "body": "{\r\n        var port1 = PortFinder.GetRandomPort();\r\n        var port2 = PortFinder.GetRandomPort();\r\n        var route1 = GivenRoute(\"/\")\r\n            .WithHosts(Localhost(port1), Localhost(port2));\r\n        var cookieName = route1.LoadBalancerOptions.Key;\r\n        var route2 = GivenRoute(\"/test\", cookieName + \"bestid\")\r\n            .WithHosts(Localhost(port2), Localhost(port1));\r\n        var configuration = GivenConfiguration(route1, route2);\r\n\r\n        this.Given(x => x.GivenProductServiceIsRunning(0, DownstreamUrl(port1)))\r\n            .Given(x => x.GivenProductServiceIsRunning(1, DownstreamUrl(port2)))\r\n            .And(_ => GivenThereIsAConfiguration(configuration))\r\n            .And(_ => GivenOcelotIsRunning())\r\n            .When(_ => WhenIGetUrlOnTheApiGatewayWithCookie(\"/\", cookieName, \"123\")) // both cookies should have different values\r\n            .When(_ => WhenIGetUrlOnTheApiGatewayWithCookie(\"/test\", cookieName + \"bestid\", \"123\")) // stick by cookie value\r\n            .Then(x => x.ThenServiceShouldHaveBeenCalledTimes(0, 1))\r\n            .Then(x => x.ThenServiceShouldHaveBeenCalledTimes(1, 1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "ShouldUseSameDownstreamHost_ForDifferentRoutesWithSameCookie",
        "body": "{\r\n        var port1 = PortFinder.GetRandomPort();\r\n        var port2 = PortFinder.GetRandomPort();\r\n        var route1 = GivenRoute(\"/\")\r\n            .WithHosts(Localhost(port1), Localhost(port2));\r\n        var cookieName = route1.LoadBalancerOptions.Key;\r\n        var route2 = GivenRoute(\"/test\", cookieName)\r\n            .WithHosts(Localhost(port2), Localhost(port1));\r\n        var configuration = GivenConfiguration(route1, route2);\r\n\r\n        this.Given(x => x.GivenProductServiceIsRunning(0, DownstreamUrl(port1)))\r\n            .Given(x => x.GivenProductServiceIsRunning(1, DownstreamUrl(port2)))\r\n            .And(_ => GivenThereIsAConfiguration(configuration))\r\n            .And(_ => GivenOcelotIsRunning())\r\n            .When(_ => WhenIGetUrlOnTheApiGatewayWithCookie(\"/\", cookieName, \"123\"))\r\n            .When(_ => WhenIGetUrlOnTheApiGatewayWithCookie(\"/test\", cookieName, \"123\"))\r\n            .Then(x => x.ThenServiceShouldHaveBeenCalledTimes(0, 2))\r\n            .Then(x => x.ThenServiceShouldHaveBeenCalledTimes(1, 0))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "TwoDownstreamServicesTests.cs",
    "methods": [
      {
        "name": "should_fix_issue_194",
        "body": "{\r\n        var consulPort = PortFinder.GetRandomPort();\r\n        var servicePort1 = PortFinder.GetRandomPort();\r\n        var servicePort2 = PortFinder.GetRandomPort();\r\n        var downstreamServiceOneUrl = $\"http://localhost:{servicePort1}\";\r\n        var downstreamServiceTwoUrl = $\"http://localhost:{servicePort2}\";\r\n        var fakeConsulServiceDiscoveryUrl = $\"http://localhost:{consulPort}\";\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/user/{user}\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = servicePort1,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/api/user/{user}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/api/product/{product}\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = servicePort2,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/api/product/{product}\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\r\n                {\r\n                    Scheme = \"https\",\r\n                    Host = \"localhost\",\r\n                    Port = consulPort,\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenProductServiceOneIsRunning(downstreamServiceOneUrl, \"/api/user/info\", 200, \"user\"))\r\n            .And(x => x.GivenProductServiceTwoIsRunning(downstreamServiceTwoUrl, \"/api/product/info\", 200, \"product\"))\r\n            .And(x => x.GivenThereIsAFakeConsulServiceDiscoveryProvider(fakeConsulServiceDiscoveryUrl))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/api/user/info?id=1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"user\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/api/product/info?id=1\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"product\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "UpstreamHostTests.cs",
    "methods": [
      {
        "name": "should_return_response_200_with_simple_url_and_hosts_match",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        UpstreamHost = \"localhost\",\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_with_simple_url_and_hosts_match_multiple_re_routes",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    UpstreamHost = \"localhost\",\r\n                },\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 50000,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    UpstreamHost = \"DONTMATCH\",\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_with_simple_url_and_hosts_match_multiple_re_routes_reversed",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 50000,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    UpstreamHost = \"DONTMATCH\",\r\n                },\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    UpstreamHost = \"localhost\",\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_200_with_simple_url_and_hosts_match_multiple_re_routes_reversed_with_no_host_first",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 50000,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                },\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    UpstreamHost = \"localhost\",\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"Hello from Laura\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_response_404_with_simple_url_and_hosts_dont_match",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    UpstreamHost = \"127.0.0.20:5000\",\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Hello from Laura\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.NotFound))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "WebSocketTests.cs",
    "methods": [
      {
        "name": "ShouldProxyWebsocketInputToDownstreamService",
        "body": "{\r\n        var downstreamPort = PortFinder.GetRandomPort();\r\n        var downstreamHost = \"localhost\";\r\n\r\n        var config = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    UpstreamPathTemplate = \"/\",\r\n                    DownstreamPathTemplate = \"/ws\",\r\n                    DownstreamScheme = \"ws\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = downstreamHost,\r\n                            Port = downstreamPort,\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(_ => _steps.GivenThereIsAConfiguration(config))\r\n            .And(_ => _steps.StartFakeOcelotWithWebSockets())\r\n            .And(_ => StartFakeDownstreamService($\"http://{downstreamHost}:{downstreamPort}\", \"/ws\"))\r\n            .When(_ => StartClient(\"ws://localhost:5000/\"))\r\n            .Then(_ => ThenTheReceivedCountIs(10))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "ShouldProxyWebsocketInputToDownstreamServiceAndUseLoadBalancer",
        "body": "{\r\n        var downstreamPort = PortFinder.GetRandomPort();\r\n        var downstreamHost = \"localhost\";\r\n        var secondDownstreamPort = PortFinder.GetRandomPort();\r\n        var secondDownstreamHost = \"localhost\";\r\n\r\n        var config = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    UpstreamPathTemplate = \"/\",\r\n                    DownstreamPathTemplate = \"/ws\",\r\n                    DownstreamScheme = \"ws\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = downstreamHost,\r\n                            Port = downstreamPort,\r\n                        },\r\n                        new()\r\n                        {\r\n                            Host = secondDownstreamHost,\r\n                            Port = secondDownstreamPort,\r\n                        },\r\n                    },\r\n                    LoadBalancerOptions = new FileLoadBalancerOptions { Type = \"RoundRobin\" },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(_ => _steps.GivenThereIsAConfiguration(config))\r\n            .And(_ => _steps.StartFakeOcelotWithWebSockets())\r\n            .And(_ => StartFakeDownstreamService($\"http://{downstreamHost}:{downstreamPort}\", \"/ws\"))\r\n            .And(_ => StartSecondFakeDownstreamService($\"http://{secondDownstreamHost}:{secondDownstreamPort}\", \"/ws\"))\r\n            .When(_ => WhenIStartTheClients())\r\n            .Then(_ => ThenBothDownstreamServicesAreCalled())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "CacheManagerTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\r\n        var initialConfiguration = new FileConfiguration\r\n        {\r\n            GlobalConfiguration = new FileGlobalConfiguration(),\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 80,\r\n                        },\r\n                    },\r\n                    DownstreamScheme = \"https\",\r\n                    DownstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"get\" },\r\n                    UpstreamPathTemplate = \"/\",\r\n                    FileCacheOptions = new FileCacheOptions\r\n                    {\r\n                        TtlSeconds = 10,\r\n                    },\r\n                },\r\n                new()\r\n                {\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = 80,\r\n                        },\r\n                    },\r\n                    DownstreamScheme = \"https\",\r\n                    DownstreamPathTemplate = \"/\",\r\n                    UpstreamHttpMethod = new List<string> { \"get\" },\r\n                    UpstreamPathTemplate = \"/test\",\r\n                    FileCacheOptions = new FileCacheOptions\r\n                    {\r\n                        TtlSeconds = 10,\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        var regionToClear = \"gettest\";\r\n\r\n        GivenThereIsAConfiguration(initialConfiguration);\r\n        GivenOcelotIsRunning();\r\n        await GivenIHaveAnOcelotToken(\"/administration\");\r\n        GivenIHaveAddedATokenToMyRequest();\r\n        await WhenIDeleteOnTheApiGateway($\"/administration/outputcache/{regionToClear}\");\r\n        ThenTheStatusCodeShouldBe(HttpStatusCode.NoContent);\r\n    }"
      }
    ]
  },
  {
    "file": "HeaderTests.cs",
    "methods": [
      {
        "name": "should_transform_upstream_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        UpstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Laz\", \"D, GP\"},\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Laz\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenIAddAHeader(\"Laz\", \"D\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"GP\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_transform_downstream_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", \"http://www.bbc.co.uk/, http://ocelot.com/\"},\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Location\", \"http://www.bbc.co.uk/\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://ocelot.com/\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_190",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", $\"http://localhost:{port}, {{BaseUrl}}\"},\r\n                        },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            AllowAutoRedirect = false,\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 302, \"Location\", $\"http://localhost:{port}/pay/Receive\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Redirect))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://localhost:5000/pay/Receive\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_205",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", \"{DownstreamBaseUrl}, {BaseUrl}\"},\r\n                        },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            AllowAutoRedirect = false,\r\n                        },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 302, \"Location\", $\"http://localhost:{port}/pay/Receive\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Redirect))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://localhost:5000/pay/Receive\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_fix_issue_417",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                        DownstreamHeaderTransform = new Dictionary<string,string>\r\n                        {\r\n                            {\"Location\", \"{DownstreamBaseUrl}, {BaseUrl}\"},\r\n                        },\r\n                        HttpHandlerOptions = new FileHttpHandlerOptions\r\n                        {\r\n                            AllowAutoRedirect = false,\r\n                        },\r\n                    },\r\n                },\r\n            GlobalConfiguration = new FileGlobalConfiguration\r\n            {\r\n                BaseUrl = \"http://anotherapp.azurewebsites.net\",\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 302, \"Location\", $\"http://localhost:{port}/pay/Receive\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.Redirect))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Location\", \"http://anotherapp.azurewebsites.net/pay/Receive\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "request_should_reuse_cookies_with_cookie_container",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/sso/{everything}\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/sso/{everything}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\", \"Post\", \"Options\" },\r\n                    HttpHandlerOptions = new FileHttpHandlerOptions\r\n                    {\r\n                        UseCookieContainer = true,\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/sso/test\", 200))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .And(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Set-Cookie\", \"test=0; path=/\"))\r\n            .And(x => _steps.GivenIAddCookieToMyRequest(\"test=1; path=/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "request_should_have_own_cookies_no_cookie_container",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamPathTemplate = \"/sso/{everything}\",\r\n                    DownstreamScheme = \"http\",\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"localhost\",\r\n                            Port = port,\r\n                        },\r\n                    },\r\n                    UpstreamPathTemplate = \"/sso/{everything}\",\r\n                    UpstreamHttpMethod = new List<string> { \"Get\", \"Post\", \"Options\" },\r\n                    HttpHandlerOptions = new FileHttpHandlerOptions\r\n                    {\r\n                        UseCookieContainer = false,\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/sso/test\", 200))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .And(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseHeaderIs(\"Set-Cookie\", \"test=0; path=/\"))\r\n            .And(x => _steps.GivenIAddCookieToMyRequest(\"test=1; path=/\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/sso/test\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "issue_474_should_not_put_spaces_in_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Accept\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"text/html,application/xhtml+xml,application/xml;\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"text/html,application/xhtml+xml,application/xml;\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "issue_474_should_put_spaces_in_header",
        "body": "{\r\n        var port = PortFinder.GetRandomPort();\r\n\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        this.Given(x => x.GivenThereIsAServiceRunningOn($\"http://localhost:{port}\", \"/\", 200, \"Accept\"))\r\n            .And(x => _steps.GivenThereIsAConfiguration(configuration))\r\n            .And(x => _steps.GivenOcelotIsRunning())\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"text/html\"))\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"application/xhtml+xml\"))\r\n            .And(x => _steps.GivenIAddAHeader(\"Accept\", \"application/xml\"))\r\n            .When(x => _steps.WhenIGetUrlOnTheApiGateway(\"/\"))\r\n            .Then(x => _steps.ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\r\n            .And(x => _steps.ThenTheResponseBodyShouldBe(\"text/html, application/xhtml+xml, application/xml\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ThreadSafeHeadersTests.cs",
    "methods": [
      {
        "name": "Should_return_same_response_for_each_different_header_under_load_to_downsteam_service",
        "body": "{\n        var port = PortFinder.GetRandomPort();\r\n        var configuration = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n                {\r\n                    new()\r\n                    {\r\n                        DownstreamPathTemplate = \"/\",\r\n                        DownstreamScheme = \"http\",\r\n                        DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                        {\r\n                            new()\r\n                            {\r\n                                Host = \"localhost\",\r\n                                Port = port,\r\n                            },\r\n                        },\r\n                        UpstreamPathTemplate = \"/\",\r\n                        UpstreamHttpMethod = new List<string> { \"Get\" },\r\n                    },\r\n                },\r\n        };\r\n\r\n        GivenThereIsAConfiguration(configuration);\r\n        GivenThereIsAServiceRunningOn($\"http://localhost:{port}\");\r\n        GivenOcelotIsRunning();\r\n        WhenIGetUrlOnTheApiGatewayMultipleTimesWithDifferentHeaderValues(\"/\", 300);\r\n        ThenTheSameHeaderValuesAreReturnedByTheDownstreamService();\r\n    }"
      }
    ]
  },
  {
    "file": "TestHostBuilder.cs",
    "methods": []
  },
  {
    "file": "OcelotAdministrationBuilderTests.cs",
    "methods": [
      {
        "name": "should_set_up_administration_with_identity_server_options",
        "body": "{\r\n        Action<JwtBearerOptions> options = o => { };\r\n\r\n        this.Given(x => WhenISetUpOcelotServices())\r\n            .When(x => WhenISetUpAdministration(options))\r\n            .Then(x => ThenAnExceptionIsntThrown())\r\n            .Then(x => ThenTheCorrectAdminPathIsRegitered())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_set_up_administration",
        "body": "{\r\n        this.Given(x => WhenISetUpOcelotServices())\r\n            .When(x => WhenISetUpAdministration())\r\n            .Then(x => ThenAnExceptionIsntThrown())\r\n            .Then(x => ThenTheCorrectAdminPathIsRegitered())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "AuthenticationMiddlewareTests.cs",
    "methods": [
      {
        "name": "MiddlewareName_Cstor_ReturnsTypeName",
        "body": "{\n        // Arrange\n        var isNextCalled = false;\n        _next = (context) =>\n        {\n            isNextCalled = true;\n            return Task.CompletedTask;\n        };\n        _middleware = new AuthenticationMiddleware(_next, _factory.Object);\n        var expected = _middleware.GetType().Name;\n\n        // Act\n        var actual = _middleware.MiddlewareName;\n\n        // Assert\n        Assert.False(isNextCalled);\n        Assert.NotNull(actual);\n        Assert.Equal(expected, actual);\n    }"
      },
      {
        "name": "Should_call_next_middleware_if_route_is_not_authenticated",
        "body": "{\n        var methods = new List<string> { \"Get\" };\n        this.Given(x => GivenTheDownStreamRouteIs(new DownstreamRouteBuilder()\n                .WithUpstreamHttpMethod(methods)\n                .Build()\n            ))\n            .When(x => WhenICallTheMiddleware())\n            .Then(x => ThenTheUserIsAuthenticated())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_call_next_middleware_if_route_is_using_options_method",
        "body": "{\n        const string OPTIONS = \"OPTIONS\";\n        var methods = new List<string> { OPTIONS };\n        this.Given(x => GivenTheDownStreamRouteIs(new DownstreamRouteBuilder()\n                .WithUpstreamHttpMethod(methods)\n                .WithIsAuthenticated(true)\n                .Build()\n            ))\n            .And(x => GivenTheRequestIsUsingMethod(OPTIONS))\n            .When(x => WhenICallTheMiddleware())\n            .Then(x => ThenTheUserIsAuthenticated())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_provide_backward_compatibility_if_route_has_several_options_authentication_providers",
        "body": "{\n        var options = new AuthenticationOptions(null,\n            \"Test\",\n            new string[] { string.Empty, \"Fail\", \"Test\" }\n        );\n        var methods = new List<string> { \"Get\" };\n        this.Given(x => GivenTheDownStreamRouteIs(new DownstreamRouteBuilder()\n                .WithAuthenticationOptions(options)\n                .WithIsAuthenticated(true)\n                .WithUpstreamHttpMethod(methods)\n                .Build()\n            ))\n            .And(x => GivenTheRequestIsUsingMethod(methods.First()))\n            .And(x => GivenTheAuthenticationIsFail())\n            .And(x => GivenTheAuthenticationIsSuccess())\n            .And(x => GivenTheAuthenticationThrowsException())\n            .When(x => WhenICallTheMiddleware())\n            .Then(x => ThenTheUserIsAuthenticated())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_not_call_next_middleware_and_return_no_result_if_all_multiple_keys_were_failed",
        "body": "{\n        var options = new AuthenticationOptions(null, null,\n            new string[] { string.Empty, \"Fail\", \"Fail\", \"UnknownScheme\" }\n        );\n        var methods = new List<string> { \"Get\" };\n\n        this.Given(x => GivenTheDownStreamRouteIs(new DownstreamRouteBuilder()\n                .WithAuthenticationOptions(options)\n                .WithIsAuthenticated(true)\n                .WithUpstreamHttpMethod(methods)\n                .Build()\n            ))\n            .And(x => GivenTheRequestIsUsingMethod(methods.First()))\n            .And(x => GivenTheAuthenticationIsFail())\n            .And(x => GivenTheAuthenticationIsSuccess())\n            .When(x => WhenICallTheMiddleware())\n            .Then(x => ThenTheUserIsNotAuthenticated())\n            .BDDfy();\n        _httpContext.User.Identity.IsAuthenticated.ShouldBeFalse();\n        _logWarningMessages.Count.ShouldBe(1);\n        _logWarningMessages.First().ShouldStartWith(\"Client has NOT been authenticated for path\");\n        _httpContext.Items.Errors().First().ShouldBeOfType(typeof(UnauthenticatedError));\n    }"
      }
    ]
  },
  {
    "file": "AuthorizationMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_authorization_service",
        "body": "{\n        this.Given(x => x.GivenTheDownStreamRouteIs(new List<PlaceholderNameAndValue>(),\n            new DownstreamRouteBuilder()\n                .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder().Build())\n                .WithIsAuthorized(true)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()))\n            .And(x => x.GivenTheAuthServiceReturns(new OkResponse<bool>(true)))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheAuthServiceIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsAuthorizerTests.cs",
    "methods": [
      {
        "name": "should_authorize_user",
        "body": "{\r\n        this.Given(x => x.GivenAClaimsPrincipal(new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>\r\n            {\r\n                new(\"UserType\", \"registered\"),\r\n            }))))\r\n            .And(x => x.GivenARouteClaimsRequirement(new Dictionary<string, string>\r\n            {\r\n                {\"UserType\", \"registered\"},\r\n            }))\r\n            .When(x => x.WhenICallTheAuthorizer())\r\n            .Then(x => x.ThenTheUserIsAuthorized())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_authorize_dynamic_user",
        "body": "{\r\n        this.Given(x => x.GivenAClaimsPrincipal(new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>\r\n            {\r\n                new(\"userid\", \"14\"),\r\n            }))))\r\n           .And(x => x.GivenARouteClaimsRequirement(new Dictionary<string, string>\r\n            {\r\n                {\"userid\", \"{userId}\"},\r\n            }))\r\n           .And(x => x.GivenAPlaceHolderNameAndValueList(new List<PlaceholderNameAndValue>\r\n            {\r\n               new(\"{userId}\", \"14\"),\r\n            }))\r\n           .When(x => x.WhenICallTheAuthorizer())\r\n           .Then(x => x.ThenTheUserIsAuthorized())\r\n           .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_authorize_dynamic_user",
        "body": "{\r\n        this.Given(x => x.GivenAClaimsPrincipal(new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>\r\n            {\r\n                new(\"userid\", \"15\"),\r\n            }))))\r\n           .And(x => x.GivenARouteClaimsRequirement(new Dictionary<string, string>\r\n            {\r\n                {\"userid\", \"{userId}\"},\r\n            }))\r\n           .And(x => x.GivenAPlaceHolderNameAndValueList(new List<PlaceholderNameAndValue>\r\n            {\r\n                new(\"{userId}\", \"14\"),\r\n            }))\r\n           .When(x => x.WhenICallTheAuthorizer())\r\n           .Then(x => x.ThenTheUserIsntAuthorized())\r\n           .BDDfy();\r\n    }"
      },
      {
        "name": "should_authorize_user_multiple_claims_of_same_type",
        "body": "{\r\n        this.Given(x => x.GivenAClaimsPrincipal(new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>\r\n            {\r\n                new(\"UserType\", \"guest\"),\r\n                new(\"UserType\", \"registered\"),\r\n            }))))\r\n            .And(x => x.GivenARouteClaimsRequirement(new Dictionary<string, string>\r\n            {\r\n                {\"UserType\", \"registered\"},\r\n            }))\r\n            .When(x => x.WhenICallTheAuthorizer())\r\n            .Then(x => x.ThenTheUserIsAuthorized())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_authorize_user",
        "body": "{\r\n        this.Given(x => x.GivenAClaimsPrincipal(new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>()))))\r\n        .And(x => x.GivenARouteClaimsRequirement(new Dictionary<string, string>\r\n            {\r\n                { \"UserType\", \"registered\" },\r\n            }))\r\n        .When(x => x.WhenICallTheAuthorizer())\r\n        .Then(x => x.ThenTheUserIsntAuthorized())\r\n        .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "CacheOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_region",
        "body": "{\n        var route = new FileRoute\n        {\n            UpstreamHttpMethod = new List<string> { \"Get\" },\n            UpstreamPathTemplate = \"/testdummy\",\n        };\n\n        this.Given(_ => GivenTheRoute(route))\n            .When(_ => WhenICreateTheRegion())\n            .Then(_ => ThenTheRegionIs(\"Gettestdummy\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_use_region",
        "body": "{\n        var route = new FileRoute\n        {\n            FileCacheOptions = new FileCacheOptions\n            {\n                Region = \"region\",\n            },\n        };\n\n        this.Given(_ => GivenTheRoute(route))\n            .When(_ => WhenICreateTheRegion())\n            .Then(_ => ThenTheRegionIs(\"region\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DefaultCacheKeyGeneratorTests.cs",
    "methods": [
      {
        "name": "should_generate_cache_key_with_request_content",
        "body": "{\n        const string noHeader = null;\n        const string content = nameof(should_generate_cache_key_with_request_content);\n        var cachekey = MD5Helper.GenerateMd5($\"{verb}-{url}-{content}\");\n        CacheOptions options = new CacheOptions(100, \"region\", noHeader, true);\n\n        this.Given(x => x.GivenDownstreamRoute(options))\n            .And(x => GivenHasContent(content))\n            .When(x => x.WhenGenerateRequestCacheKey())\n            .Then(x => x.ThenGeneratedCacheKeyIs(cachekey))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_generate_cache_key_without_request_content",
        "body": "{\n        CacheOptions options = null;\n        var cachekey = MD5Helper.GenerateMd5($\"{verb}-{url}\");\n\n        this.Given(x => x.GivenDownstreamRoute(options))\n            .When(x => x.WhenGenerateRequestCacheKey())\n            .Then(x => x.ThenGeneratedCacheKeyIs(cachekey))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_generate_cache_key_with_cache_options_header",
        "body": "{\n        CacheOptions options = new CacheOptions(100, \"region\", headerName, false);\n        var cachekey = MD5Helper.GenerateMd5($\"{verb}-{url}-{header}\");\n\n        this.Given(x => x.GivenDownstreamRoute(options))\n            .When(x => x.WhenGenerateRequestCacheKey())\n            .Then(x => x.ThenGeneratedCacheKeyIs(cachekey))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_generate_cache_key_happy_path",
        "body": "{\n        const string content = nameof(should_generate_cache_key_happy_path);\n        CacheOptions options = new CacheOptions(100, \"region\", headerName, true);\n        var cachekey = MD5Helper.GenerateMd5($\"{verb}-{url}-{header}-{content}\");\n\n        this.Given(x => x.GivenDownstreamRoute(options))\n            .And(x => GivenHasContent(content))\n            .When(x => x.WhenGenerateRequestCacheKey())\n            .Then(x => x.ThenGeneratedCacheKeyIs(cachekey))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DefaultMemoryCacheTests.cs",
    "methods": [
      {
        "name": "should_cache",
        "body": "{\n        var fake = new Fake(1);\n        _cache.Add(\"1\", fake, TimeSpan.FromSeconds(100), \"region\");\n        var result = _cache.Get(\"1\", \"region\");\n        result.ShouldBe(fake);\n        fake.Value.ShouldBe(1);\n    }"
      },
      {
        "name": "doesnt_exist",
        "body": "{\n        var result = _cache.Get(\"1\", \"region\");\n        result.ShouldBeNull();\n    }"
      },
      {
        "name": "should_add_and_delete",
        "body": "{\n        var fake = new Fake(1);\n        _cache.Add(\"1\", fake, TimeSpan.FromSeconds(100), \"region\");\n        var newFake = new Fake(1);\n        _cache.AddAndDelete(\"1\", newFake, TimeSpan.FromSeconds(100), \"region\");\n        var result = _cache.Get(\"1\", \"region\");\n        result.ShouldBe(newFake);\n        newFake.Value.ShouldBe(1);\n    }"
      },
      {
        "name": "should_clear_region",
        "body": "{\n        var fake1 = new Fake(1);\n        var fake2 = new Fake(2);\n        _cache.Add(\"1\", fake1, TimeSpan.FromSeconds(100), \"region\");\n        _cache.Add(\"2\", fake2, TimeSpan.FromSeconds(100), \"region\");\n        _cache.ClearRegion(\"region\");\n        var result1 = _cache.Get(\"1\", \"region\");\n        result1.ShouldBeNull();\n        var result2 = _cache.Get(\"2\", \"region\");\n        result2.ShouldBeNull();\n    }"
      },
      {
        "name": "should_clear_key_if_ttl_expired",
        "body": "{\n        var fake = new Fake(1);\n        _cache.Add(\"1\", fake, TimeSpan.FromMilliseconds(50), \"region\");\n        Thread.Sleep(200);\n        var result = _cache.Get(\"1\", \"region\");\n        result.ShouldBeNull();\n    }"
      }
    ]
  },
  {
    "file": "OutputCacheMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_returned_cached_item_when_it_is_in_cache",
        "body": "{\n        var headers = new Dictionary<string, IEnumerable<string>>\n        {\n            { \"test\", new List<string> { \"test\" } },\n        };\n\n        var contentHeaders = new Dictionary<string, IEnumerable<string>>\n        {\n            { \"content-type\", new List<string> { \"application/json\" } },\n        };\n\n        var cachedResponse = new CachedResponse(HttpStatusCode.OK, headers, string.Empty, contentHeaders, \"some reason\");\n        this.Given(x => x.GivenThereIsACachedResponse(cachedResponse))\n            .And(x => x.GivenTheDownstreamRouteIs())\n            .When(x => x.WhenICallTheMiddlewareAsync())\n            .Then(x => x.ThenTheCacheGetIsCalledCorrectly())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_returned_cached_item_when_it_is_in_cache_expires_header",
        "body": "{\n        var contentHeaders = new Dictionary<string, IEnumerable<string>>\n        {\n            { \"Expires\", new List<string> { \"-1\" } },\n        };\n\n        var cachedResponse = new CachedResponse(HttpStatusCode.OK, new Dictionary<string, IEnumerable<string>>(), string.Empty, contentHeaders, \"some reason\");\n        this.Given(x => x.GivenThereIsACachedResponse(cachedResponse))\n            .And(x => x.GivenTheDownstreamRouteIs())\n            .When(x => x.WhenICallTheMiddlewareAsync())\n            .Then(x => x.ThenTheCacheGetIsCalledCorrectly())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_continue_with_pipeline_and_cache_response",
        "body": "{\n        this.Given(x => x.GivenResponseIsNotCached(new HttpResponseMessage()))\n            .And(x => x.GivenTheDownstreamRouteIs())\n            .When(x => x.WhenICallTheMiddlewareAsync())\n            .Then(x => x.ThenTheCacheAddIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OcelotBuilderExtensionsTests.cs",
    "methods": [
      {
        "name": "should_set_up_cache_manager",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => WhenISetUpCacheManager())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .And(x => OnlyOneVersionOfEachCacheIsRegistered())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OutputCacheMiddlewareRealCacheTests.cs",
    "methods": [
      {
        "name": "should_cache_content_headers",
        "body": "{\r\n        var content = new StringContent(\"{\\\"Test\\\": 1}\")\r\n        {\r\n            Headers = { ContentType = new MediaTypeHeaderValue(\"application/json\") },\r\n        };\r\n\r\n        var response = new DownstreamResponse(content, HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"fooreason\");\r\n\r\n        this.Given(x => x.GivenResponseIsNotCached(response))\r\n            .And(x => x.GivenTheDownstreamRouteIs())\r\n            .When(x => x.WhenICallTheMiddleware())\r\n            .Then(x => x.ThenTheContentTypeHeaderIsCached())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "AddClaimsToRequestTests.cs",
    "methods": [
      {
        "name": "should_add_claims_to_context",
        "body": "{\n        var context = new DefaultHttpContext\n        {\n            User = new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>\n            {\n                new(\"test\", \"data\"),\n            })),\n        };\n\n        this.Given(\n            x => x.GivenClaimsToThings(new List<ClaimToThing>\n            {\n                new(\"claim-key\", string.Empty, string.Empty, 0),\n            }))\n            .Given(x => x.GivenHttpContext(context))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIAddClaimsToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .BDDfy();\n    }"
      },
      {
        "name": "if_claims_exists_should_replace_it",
        "body": "{\n        var context = new DefaultHttpContext\n        {\n            User = new ClaimsPrincipal(new ClaimsIdentity(new List<Claim>\n            {\n                new(\"existing-key\", \"data\"),\n                new(\"new-key\", \"data\"),\n            })),\n        };\n\n        this.Given(\n            x => x.GivenClaimsToThings(new List<ClaimToThing>\n            {\n                new(\"existing-key\", \"new-key\", string.Empty, 0),\n            }))\n            .Given(x => x.GivenHttpContext(context))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIAddClaimsToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error",
        "body": "{\n        this.Given(\n           x => x.GivenClaimsToThings(new List<ClaimToThing>\n           {\n                new(string.Empty, string.Empty, string.Empty, 0),\n           }))\n           .Given(x => x.GivenHttpContext(new DefaultHttpContext()))\n           .And(x => x.GivenTheClaimParserReturns(new ErrorResponse<string>(new List<Error>\n           {\n               new AnyError(),\n           })))\n           .When(x => x.WhenIAddClaimsToTheRequest())\n           .Then(x => x.ThenTheResultIsError())\n           .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToClaimsMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_claims_to_request_correctly",
        "body": "{\n        var downstreamRoute = new Ocelot.DownstreamRouteFinder.DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithClaimsToClaims(new List<ClaimToThing>\n                    {\n                        new(\"sub\", \"UserType\", \"|\", 0),\n                    })\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => x.GivenTheAddClaimsToRequestReturns())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheClaimsToRequestIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "AggregatesCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_no_aggregates",
        "body": "{\r\n        var fileConfig = new FileConfiguration\r\n        {\r\n            Aggregates = new List<FileAggregateRoute>\r\n            {\r\n                new()\r\n                {\r\n                    RouteKeys = new List<string>{\"key1\"},\r\n                },\r\n            },\r\n        };\r\n        var routes = new List<Route>();\r\n\r\n        this.Given(_ => GivenThe(fileConfig))\r\n            .And(_ => GivenThe(routes))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => TheUtpCreatorIsNotCalled())\r\n            .And(_ => ThenTheResultIsNotNull())\r\n            .And(_ => ThenTheResultIsEmpty())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_aggregates",
        "body": "{\r\n        var fileConfig = new FileConfiguration\r\n        {\r\n            Aggregates = new List<FileAggregateRoute>\r\n            {\r\n                new()\r\n                {\r\n                    RouteKeys = new List<string>{\"key1\", \"key2\"},\r\n                    UpstreamHost = \"hosty\",\r\n                    UpstreamPathTemplate = \"templatey\",\r\n                    Aggregator = \"aggregatory\",\r\n                    RouteIsCaseSensitive = true,\r\n                },\r\n                new()\r\n                {\r\n                    RouteKeys = new List<string>{\"key3\", \"key4\"},\r\n                    UpstreamHost = \"hosty\",\r\n                    UpstreamPathTemplate = \"templatey\",\r\n                    Aggregator = \"aggregatory\",\r\n                    RouteIsCaseSensitive = true,\r\n                },\r\n            },\r\n        };\r\n\r\n        var routes = new List<Route>\r\n        {\r\n            new RouteBuilder().WithDownstreamRoute(new DownstreamRouteBuilder().WithKey(\"key1\").Build()).Build(),\r\n            new RouteBuilder().WithDownstreamRoute(new DownstreamRouteBuilder().WithKey(\"key2\").Build()).Build(),\r\n            new RouteBuilder().WithDownstreamRoute(new DownstreamRouteBuilder().WithKey(\"key3\").Build()).Build(),\r\n            new RouteBuilder().WithDownstreamRoute(new DownstreamRouteBuilder().WithKey(\"key4\").Build()).Build(),\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileConfig))\r\n            .And(_ => GivenThe(routes))\r\n            .And(_ => GivenTheUtpCreatorReturns())\n            .And(_ => GivenTheUhtpCreatorReturns())\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheUtpCreatorIsCalledCorrectly())\r\n            .And(_ => ThenTheAggregatesAreCreated())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "AuthenticationOptionsCreatorTests.cs",
    "methods": []
  },
  {
    "file": "CacheOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_region",
        "body": "{\n        var route = new FileRoute\n        {\n            UpstreamHttpMethod = new List<string> { \"Get\" },\n            UpstreamPathTemplate = \"/testdummy\",\n        };\n\n        this.Given(_ => GivenTheRoute(route))\n            .When(_ => WhenICreateTheRegion())\n            .Then(_ => ThenTheRegionIs(\"Gettestdummy\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_use_region",
        "body": "{\n        var route = new FileRoute\n        {\n            FileCacheOptions = new FileCacheOptions\n            {\n                Region = \"region\",\n            },\n        };\n\n        this.Given(_ => GivenTheRoute(route))\n            .When(_ => WhenICreateTheRegion())\n            .Then(_ => ThenTheRegionIs(\"region\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OcelotConfigurationChangeTokenSourceTests.cs",
    "methods": [
      {
        "name": "should_activate_change_token",
        "body": "{\r\n        this.Given(_ => GivenIActivateTheChangeTokenSource())\r\n            .Then(_ => ThenTheChangeTokenShouldBeActivated())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "OcelotConfigurationChangeTokenTests.cs",
    "methods": [
      {
        "name": "should_call_callback_with_state",
        "body": "{\r\n        this.Given(_ => GivenIHaveAChangeToken())\r\n            .And(_ => AndIRegisterACallback())\r\n            .Then(_ => ThenIShouldGetADisposableWrapper())\r\n            .Given(_ => GivenIActivateTheToken())\r\n            .Then(_ => ThenTheCallbackShouldBeCalled())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_call_callback_if_it_is_disposed",
        "body": "{\r\n        this.Given(_ => GivenIHaveAChangeToken())\r\n            .And(_ => AndIRegisterACallback())\r\n            .Then(_ => ThenIShouldGetADisposableWrapper())\r\n            .And(_ => GivenIActivateTheToken())\r\n            .And(_ => AndIDisposeTheCallbackWrapper())\r\n            .And(_ => GivenIActivateTheToken())\r\n            .Then(_ => ThenTheCallbackShouldNotBeCalled())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ClaimToThingConfigurationParserTests.cs",
    "methods": [
      {
        "name": "returns_no_instructions_error",
        "body": "{\r\n        this.Given(x => x.GivenTheDictionaryIs(new Dictionary<string, string>\r\n        {\r\n            {\"CustomerId\", string.Empty},\r\n        }))\r\n            .When(x => x.WhenICallTheExtractor())\r\n            .Then(\r\n                x =>\r\n                    x.ThenAnErrorIsReturned(new ErrorResponse<ClaimToThing>(\r\n                        new List<Error>\r\n                        {\r\n                            new NoInstructionsError(\">\"),\r\n                        })))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "returns_no_instructions_not_for_claims_error",
        "body": "{\r\n        this.Given(x => x.GivenTheDictionaryIs(new Dictionary<string, string>\r\n        {\r\n            {\"CustomerId\", \"Cheese[CustomerId] > value\"},\r\n        }))\r\n            .When(x => x.WhenICallTheExtractor())\r\n            .Then(\r\n                x =>\r\n                    x.ThenAnErrorIsReturned(new ErrorResponse<ClaimToThing>(\r\n                        new List<Error>\r\n                        {\r\n                            new InstructionNotForClaimsError(),\r\n                        })))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "can_parse_entry_to_work_out_properties_with_key",
        "body": "{\r\n        this.Given(x => x.GivenTheDictionaryIs(new Dictionary<string, string>\r\n        {\r\n            {\"CustomerId\", \"Claims[CustomerId] > value\"},\r\n        }))\r\n            .When(x => x.WhenICallTheExtractor())\r\n            .Then(\r\n                x =>\r\n                    x.ThenTheClaimParserPropertiesAreReturned(\r\n                        new OkResponse<ClaimToThing>(\r\n                            new ClaimToThing(\"CustomerId\", \"CustomerId\", string.Empty, 0))))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "can_parse_entry_to_work_out_properties_with_key_delimiter_and_index",
        "body": "{\r\n        this.Given(x => x.GivenTheDictionaryIs(new Dictionary<string, string>\r\n        {\r\n            {\"UserId\", \"Claims[Subject] > value[0] > |\"},\r\n        }))\r\n            .When(x => x.WhenICallTheExtractor())\r\n            .Then(\r\n                x =>\r\n                    x.ThenTheClaimParserPropertiesAreReturned(\r\n                        new OkResponse<ClaimToThing>(\r\n                            new ClaimToThing(\"UserId\", \"Subject\", \"|\", 0))))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToThingCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_claims_to_things",
        "body": "{\r\n        var userInput = new Dictionary<string, string>\r\n        {\r\n            {\"CustomerId\", \"Claims[CustomerId] > value\"},\r\n        };\r\n\r\n        var claimsToThing = new OkResponse<ClaimToThing>(new ClaimToThing(\"CustomerId\", \"CustomerId\", string.Empty, 0));\n\n        this.Given(x => x.GivenTheFollowingDictionary(userInput))\r\n            .And(x => x.GivenTheConfigHeaderExtractorReturns(claimsToThing))\r\n            .When(x => x.WhenIGetTheThings())\r\n            .Then(x => x.ThenTheConfigParserIsCalledCorrectly())\r\n            .And(x => x.ThenClaimsToThingsAreReturned())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_log_error_if_cannot_parse_claim_to_thing",
        "body": "{\n        var userInput = new Dictionary<string, string>\r\n        {\r\n            {\"CustomerId\", \"Claims[CustomerId] > value\"},\r\n        };\r\n\r\n        var claimsToThing = new ErrorResponse<ClaimToThing>(It.IsAny<Error>());\n\n        this.Given(x => x.GivenTheFollowingDictionary(userInput))\r\n            .And(x => x.GivenTheConfigHeaderExtractorReturns(claimsToThing))\r\n            .When(x => x.WhenIGetTheThings())\r\n            .Then(x => x.ThenTheConfigParserIsCalledCorrectly())\r\n            .And(x => x.ThenNoClaimsToThingsAreReturned())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ConfigurationCreatorTests.cs",
    "methods": [
      {
        "name": "should_build_configuration_with_no_admin_path",
        "body": "{\r\n        this.Given(_ => GivenTheDependenciesAreSetUp())\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDepdenciesAreCalledCorrectly())\r\n            .And(_ => ThenThePropertiesAreSetCorrectly())\r\n            .And(_ => ThenTheAdminPathIsNull())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_build_configuration_with_admin_path",
        "body": "{\r\n        this.Given(_ => GivenTheDependenciesAreSetUp())\r\n            .And(_ => GivenTheAdminPath())\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDepdenciesAreCalledCorrectly())\r\n            .And(_ => ThenThePropertiesAreSetCorrectly())\r\n            .And(_ => ThenTheAdminPathIsSet())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "DefaultMetadataCreatorTests.cs",
    "methods": [
      {
        "name": "Should_return_empty_metadata",
        "body": "{\n        // Arrange\n        GivenEmptyMetadataInGlobalConfiguration();\n        GivenEmptyMetadataInRoute();\n\n        // Act\n        WhenICreate();\n\n        // Assert\n        ThenDownstreamRouteMetadataMustBeEmpty();\n    }"
      },
      {
        "name": "Should_return_global_metadata",
        "body": "{\n        // Arrange\n        GivenSomeMetadataInGlobalConfiguration();\n        GivenEmptyMetadataInRoute();\n\n        // Act\n        WhenICreate();\n\n        // Assert\n        ThenDownstreamMetadataMustContain(\"foo\", \"bar\");\n    }"
      },
      {
        "name": "Should_return_route_metadata",
        "body": "{\n        // Arrange\n        GivenEmptyMetadataInGlobalConfiguration();\n        GivenSomeMetadataInRoute();\n\n        // Act\n        WhenICreate();\n\n        // Assert\n        ThenDownstreamMetadataMustContain(\"foo\", \"baz\");\n    }"
      },
      {
        "name": "Should_overwrite_global_metadata",
        "body": "{\n        // Arrange\n        GivenSomeMetadataInGlobalConfiguration();\n        GivenSomeMetadataInRoute();\n\n        // Act\n        WhenICreate();\n\n        // Assert\n        ThenDownstreamMetadataMustContain(\"foo\", \"baz\");\n    }"
      }
    ]
  },
  {
    "file": "DiskFileConfigurationRepositoryTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        Arrange();\r\n        var config = FakeFileConfigurationForGet();\r\n        GivenTheConfigurationIs(config);\r\n\n        // Act\n        await WhenIGetTheRoutes();\n\n        // Assert\r\n        ThenTheFollowingIsReturned(config);\r\n    }"
      },
      {
        "name": "Task",
        "body": "{\r\n        Arrange();\r\n        var config = FakeFileConfigurationForGet();\r\n        GivenTheEnvironmentNameIsUnavailable();\r\n        GivenTheConfigurationIs(config);\n\n        // Act\r\n        await WhenIGetTheRoutes();\r\n\n        // Assert\r\n        ThenTheFollowingIsReturned(config);\r\n    }"
      },
      {
        "name": "Task",
        "body": "{\r\n        Arrange();\r\n        var config = FakeFileConfigurationForSet();\r\n\n        // Act\r\n        await WhenISetTheConfiguration(config);\r\n\n        // Assert\r\n        ThenTheConfigurationIsStoredAs(config);\r\n        ThenTheConfigurationJsonIsIndented(config);\r\n        AndTheChangeTokenIsActivated();\r\n    }"
      },
      {
        "name": "Task",
        "body": "{\r\n        Arrange();\r\n        var config = FakeFileConfigurationForSet();\r\n        GivenTheEnvironmentNameIsUnavailable();\r\n\n        // Act\r\n        await WhenISetTheConfiguration(config);\r\n\n        // Assert\r\n        ThenTheConfigurationIsStoredAs(config);\r\n        ThenTheConfigurationJsonIsIndented(config);\r\n    }"
      },
      {
        "name": "Task",
        "body": "{\r\n        Arrange();\r\n        var config = FakeFileConfigurationForSet();\r\n        GivenTheConfigurationIs(config);\r\n        var ocelotJson = GivenTheUserAddedOcelotJson();\r\n\n        // Act\r\n        await WhenISetTheConfiguration(config);\n\n        // Assert\r\n        ThenTheConfigurationIsStoredAs(config);\n        ThenTheConfigurationJsonIsIndented(config);\n        ThenTheOcelotJsonIsStoredAs(ocelotJson, config);\r\n    }"
      }
    ]
  },
  {
    "file": "DownstreamAddressesCreatorTests.cs",
    "methods": [
      {
        "name": "should_do_nothing",
        "body": "{\n        var route = new FileRoute();\n\n        var expected = new List<DownstreamHostAndPort>();\n\n        this.Given(x => GivenTheFollowingRoute(route))\n            .When(x => WhenICreate())\n            .Then(x => TheThenFollowingIsReturned(expected))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_create_downstream_addresses_from_old_downstream_path_and_port",
        "body": "{\n        var route = new FileRoute\n        {\n            DownstreamHostAndPorts = new List<FileHostAndPort>\n            {\n                new()\n                {\n                    Host = \"test\",\n                    Port = 80,\n                },\n            },\n        };\n\n        var expected = new List<DownstreamHostAndPort>\n        {\n            new(\"test\", 80),\n        };\n\n        this.Given(x => GivenTheFollowingRoute(route))\n            .When(x => WhenICreate())\n            .Then(x => TheThenFollowingIsReturned(expected))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_create_downstream_addresses_from_downstream_host_and_ports",
        "body": "{\n        var route = new FileRoute\n        {\n            DownstreamHostAndPorts = new List<FileHostAndPort>\n            {\n                new()\n                {\n                    Host = \"test\",\n                    Port = 80,\n                },\n                new()\n                {\n                    Host = \"west\",\n                    Port = 443,\n                },\n            },\n        };\n\n        var expected = new List<DownstreamHostAndPort>\n        {\n            new(\"test\", 80),\n            new(\"west\", 443),\n        };\n\n        this.Given(x => GivenTheFollowingRoute(route))\n            .When(x => WhenICreate())\n            .Then(x => TheThenFollowingIsReturned(expected))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRouteExtensionsTests.cs",
    "methods": [
      {
        "name": "Should_parse_from_json_null",
        "body": "No body available"
      },
      {
        "name": "Should_parse_from_json_string",
        "body": "No body available"
      },
      {
        "name": "Should_parse_from_json_numbers",
        "body": "No body available"
      },
      {
        "name": "Should_parse_from_object",
        "body": "No body available"
      },
      {
        "name": "Should_parse_from_json_array",
        "body": "{\n        // Arrange\n        var key = \"mykey\";\n        _downstreamRoute.MetadataOptions.Metadata.Add(key, \"[\\\"value1\\\", \\\"value2\\\", \\\"value3\\\"]\");\n\n        // Act\n        var metadataValue = _downstreamRoute.GetMetadata<IEnumerable<string>>(key);\n\n        //Assert\n        IEnumerable<string> enumerable = metadataValue as string[] ?? metadataValue.ToArray();\n        enumerable.ShouldNotBeNull();\n        enumerable.ElementAt(0).ShouldBe(\"value1\");\n        enumerable.ElementAt(1).ShouldBe(\"value2\");\n        enumerable.ElementAt(2).ShouldBe(\"value3\");\n    }"
      },
      {
        "name": "Should_throw_error_when_invalid_json",
        "body": "{\n        // Arrange\n        var key = \"mykey\";\n        _downstreamRoute.MetadataOptions.Metadata.Add(key, \"[[[\");\n\n        // Act\n\n        //Assert\n        Assert.Throws<JsonException>(() =>\n        {\n            _ = _downstreamRoute.GetMetadata<IEnumerable<string>>(key);\n        });\n    }"
      },
      {
        "name": "Should_parse_json_with_custom_json_settings_options",
        "body": "{\n        // Arrange\n        var key = \"mykey\";\n        var value = \"{\\\"id\\\": 88, \\\"value\\\": \\\"Hello World!\\\", \\\"myTime\\\": \\\"2024-01-01T10:10:10.000Z\\\"}\";\n        var expected = new FakeObject\n        {\n            Id = 88,\n            Value = \"Hello World!\",\n            MyTime = new DateTime(2024, 1, 1, 10, 10, 10, DateTimeKind.Unspecified),\n        };\n        var serializerOptions = new JsonSerializerOptions()\n        {\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n        };\n        _downstreamRoute.MetadataOptions.Metadata.Add(key, value);\n\n        // Act\n        var metadataValue = _downstreamRoute.GetMetadata<FakeObject>(key, jsonSerializerOptions: serializerOptions);\n\n        //Assert\n        metadataValue.ShouldBeEquivalentTo(expected);\n    }"
      },
      {
        "name": "Should_throw_error_when_invalid_number",
        "body": "{\n        // Arrange\n        var key = \"mykey\";\n        _downstreamRoute.MetadataOptions.Metadata.Add(key, \"xyz\");\n\n        // Act\n\n        // Assert\n        Assert.Throws<FormatException>(() =>\n        {\n            _ = _downstreamRoute.GetMetadata<int>(key);\n        });\n    }"
      }
    ]
  },
  {
    "file": "DynamicsCreatorTests.cs",
    "methods": [
      {
        "name": "Should_return_nothing",
        "body": "{\r\n        // Arrange\r\n        var fileConfig = new FileConfiguration();\r\n        GivenThe(fileConfig);\r\n\r\n        // Act\r\n        WhenICreate();\r\n\r\n        // Assert\r\n        ThenNothingIsReturned();\r\n        ThenTheRloCreatorIsNotCalled();\r\n        ThenTheMetadataCreatorIsNotCalled();\n    }"
      },
      {
        "name": "Should_return_routes",
        "body": "{\r\n        // Arrange\r\n        var fileConfig = new FileConfiguration\r\n        {\r\n            DynamicRoutes = new()\r\n            {\r\n                GivenDynamicRoute(\"1\", false, \"1.1\", \"foo\", \"bar\"),\r\n                GivenDynamicRoute(\"2\", true, \"2.0\", \"foo\", \"baz\"),\r\n            },\r\n        };\r\n        GivenThe(fileConfig);\r\n        GivenTheRloCreatorReturns();\r\n        GivenTheVersionCreatorReturns();\r\n        GivenTheVersionPolicyCreatorReturns();\r\n        GivenTheMetadataCreatorReturns();\r\n\r\n        // Act\r\n        WhenICreate();\r\n\r\n        // Assert\r\n        ThenTheRoutesAreReturned();\r\n        ThenTheRloCreatorIsCalledCorrectly();\r\n        ThenTheVersionCreatorIsCalledCorrectly();\r\n        ThenTheMetadataCreatorIsCalledCorrectly();\n    }"
      }
    ]
  },
  {
    "file": "FileConfigurationPollerTests.cs",
    "methods": [
      {
        "name": "should_start",
        "body": "{\r\n        this.Given(x => GivenPollerHasStarted())\r\n            .Given(x => ThenTheSetterIsCalled(_fileConfig, 1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_call_setter_when_gets_new_config",
        "body": "{\r\n        var newConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"test\",\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => GivenPollerHasStarted())\r\n            .Given(x => WhenTheConfigIsChanged(newConfig, 0))\r\n            .Then(x => ThenTheSetterIsCalledAtLeast(newConfig, 1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_poll_if_already_polling",
        "body": "{\r\n        var newConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"test\",\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => GivenPollerHasStarted())\r\n            .Given(x => WhenTheConfigIsChanged(newConfig, 10))\r\n            .Then(x => ThenTheSetterIsCalled(newConfig, 1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_do_nothing_if_call_to_provider_fails",
        "body": "{\r\n        var newConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    DownstreamHostAndPorts = new List<FileHostAndPort>\r\n                    {\r\n                        new()\r\n                        {\r\n                            Host = \"test\",\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(x => GivenPollerHasStarted())\r\n            .Given(x => WhenProviderErrors())\r\n            .Then(x => ThenTheSetterIsCalled(newConfig, 0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_dispose_cleanly_without_starting",
        "body": "{\r\n        this.When(x => WhenPollerIsDisposed())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "FileConfigurationSetterTests.cs",
    "methods": [
      {
        "name": "should_set_configuration",
        "body": "{\r\n        var fileConfig = new FileConfiguration();\r\n        var serviceProviderConfig = new ServiceProviderConfigurationBuilder().Build();\r\n        var config = new InternalConfiguration(\r\n            new List<Route>(),\r\n            string.Empty,\r\n            serviceProviderConfig,\r\n            \"asdf\",\r\n            new LoadBalancerOptionsBuilder().Build(),\r\n            string.Empty,\r\n            new QoSOptionsBuilder().Build(),\r\n            new HttpHandlerOptionsBuilder().Build(),\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(x => GivenTheFollowingConfiguration(fileConfig))\r\n            .And(x => GivenTheRepoReturns(new OkResponse()))\r\n            .And(x => GivenTheCreatorReturns(new OkResponse<IInternalConfiguration>(config)))\r\n            .When(x => WhenISetTheConfiguration())\r\n            .Then(x => ThenTheConfigurationRepositoryIsCalledCorrectly())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_error_if_unable_to_set_file_configuration",
        "body": "{\r\n        var fileConfig = new FileConfiguration();\r\n\r\n        this.Given(x => GivenTheFollowingConfiguration(fileConfig))\r\n            .And(x => GivenTheRepoReturns(new ErrorResponse(It.IsAny<Error>())))\r\n            .When(x => WhenISetTheConfiguration())\r\n            .And(x => ThenAnErrorResponseIsReturned())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_error_if_unable_to_set_ocelot_configuration",
        "body": "{\r\n        var fileConfig = new FileConfiguration();\r\n\r\n        this.Given(x => GivenTheFollowingConfiguration(fileConfig))\r\n            .And(x => GivenTheRepoReturns(new OkResponse()))\r\n            .And(x => GivenTheCreatorReturns(new ErrorResponse<IInternalConfiguration>(It.IsAny<Error>())))\r\n            .When(x => WhenISetTheConfiguration())\r\n            .And(x => ThenAnErrorResponseIsReturned())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "FileInternalConfigurationCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_validation_error",
        "body": "{\r\n        var fileConfiguration = new FileConfiguration();\r\n\r\n        this.Given(_ => GivenThe(fileConfiguration))\r\n            .And(_ => GivenTheValidationFails())\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenAnErrorIsReturned())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_internal_configuration",
        "body": "{\r\n        var fileConfiguration = new FileConfiguration();\r\n\r\n        this.Given(_ => GivenThe(fileConfiguration))\r\n            .And(_ => GivenTheValidationSucceeds())\r\n            .And(_ => GivenTheDependenciesAreSetUp())\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDependenciesAreCalledCorrectly())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "FileQoSOptionsTests.cs",
    "methods": [
      {
        "name": "Cstor_Default_AssignedZeroToTimeoutValue",
        "body": "{\n        // Arrange, Act\n        var actual = new FileQoSOptions();\n\n        // Assert\n        Assert.Equal(0, actual.TimeoutValue);\n    }"
      },
      {
        "name": "Cstor_Default_AssignedZeroToExceptionsAllowedBeforeBreaking",
        "body": "{\n        // Arrange, Act\n        var actual = new FileQoSOptions();\n\n        // Assert\n        Assert.Equal(0, actual.ExceptionsAllowedBeforeBreaking);\n    }"
      },
      {
        "name": "Cstor_Default_AssignedOneToDurationOfBreak",
        "body": "{\n        // Arrange, Act\n        var actual = new FileQoSOptions();\n\n        // Assert\n        Assert.Equal(1, actual.DurationOfBreak);\n    }"
      }
    ]
  },
  {
    "file": "HashCreationTests.cs",
    "methods": [
      {
        "name": "should_create_hash_and_salt",
        "body": "{\r\n        var password = \"secret\";\r\n\r\n        var salt = new byte[128 / 8];\r\n\r\n        using (var rng = RandomNumberGenerator.Create())\r\n        {\r\n            rng.GetBytes(salt);\r\n        }\r\n\r\n        var storedSalt = Convert.ToBase64String(salt);\n\n        var storedHash = Convert.ToBase64String(KeyDerivation.Pbkdf2(\r\n            password: password,\r\n            salt: salt,\r\n            prf: KeyDerivationPrf.HMACSHA256,\r\n            iterationCount: 10000,\r\n            numBytesRequested: 256 / 8));\r\n    }"
      }
    ]
  },
  {
    "file": "HeaderFindAndReplaceCreatorTests.cs",
    "methods": [
      {
        "name": "should_create",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Test\", \"Test, Chicken\"},\r\n                {\"Moop\", \"o, a\"},\r\n            },\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Pop\", \"West, East\"},\r\n                {\"Bop\", \"e, r\"},\r\n            },\r\n        };\r\n\r\n        var upstream = new List<HeaderFindAndReplace>\r\n        {\r\n            new(\"Test\", \"Test\", \"Chicken\", 0),\r\n            new(\"Moop\", \"o\", \"a\", 0),\r\n        };\r\n\r\n        var downstream = new List<HeaderFindAndReplace>\r\n        {\r\n            new(\"Pop\", \"West\", \"East\", 0),\r\n            new(\"Bop\", \"e\", \"r\", 0),\r\n        };\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingUpstreamIsReturned(upstream))\r\n            .Then(x => ThenTheFollowingDownstreamIsReturned(downstream))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_with_add_headers_to_request",
        "body": "{\r\n        const string key = \"X-Forwarded-For\";\r\n        const string value = \"{RemoteIpAddress}\";\r\n\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {key, value},\r\n            },\r\n        };\r\n\r\n        var expected = new AddHeader(key, value);\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingAddHeaderToUpstreamIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_base_url_placeholder",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Location\", \"http://www.bbc.co.uk/, {BaseUrl}\"},\r\n            },\r\n        };\r\n\r\n        var downstream = new List<HeaderFindAndReplace>\r\n        {\r\n            new(\"Location\", \"http://www.bbc.co.uk/\", \"http://ocelot.com/\", 0),\r\n        };\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => GivenThePlaceholderIs(\"http://ocelot.com/\"))\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingDownstreamIsReturned(downstream))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_log_errors_and_not_add_headers",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Location\", \"http://www.bbc.co.uk/, {BaseUrl}\"},\r\n            },\r\n            UpstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Location\", \"http://www.bbc.co.uk/, {BaseUrl}\"},\r\n            },\r\n        };\r\n\r\n        var expected = new List<HeaderFindAndReplace>();\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => GivenTheBaseUrlErrors())\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingDownstreamIsReturned(expected))\r\n            .And(x => ThenTheFollowingUpstreamIsReturned(expected))\r\n            .And(x => ThenTheLoggerIsCalledCorrectly(\"Unable to add DownstreamHeaderTransform Location: http://www.bbc.co.uk/, {BaseUrl}\"))\r\n            .And(x => ThenTheLoggerIsCalledCorrectly(\"Unable to add UpstreamHeaderTransform Location: http://www.bbc.co.uk/, {BaseUrl}\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_base_url_partial_placeholder",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Location\", \"http://www.bbc.co.uk/pay, {BaseUrl}pay\"},\r\n            },\r\n        };\r\n\r\n        var downstream = new List<HeaderFindAndReplace>\r\n        {\r\n            new(\"Location\", \"http://www.bbc.co.uk/pay\", \"http://ocelot.com/pay\", 0),\r\n        };\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => GivenThePlaceholderIs(\"http://ocelot.com/\"))\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingDownstreamIsReturned(downstream))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_map_with_partial_placeholder_in_the_middle",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Host-Next\", \"www.bbc.co.uk, subdomain.{Host}/path\"},\r\n            },\r\n        };\r\n\r\n        var expected = new List<HeaderFindAndReplace>\r\n        {\r\n            new(\"Host-Next\", \"www.bbc.co.uk\", \"subdomain.ocelot.next/path\", 0),\r\n        };\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => GivenThePlaceholderIs(\"ocelot.next\"))\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingDownstreamIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_add_trace_id_header",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"Trace-Id\", \"{TraceId}\"},\r\n            },\r\n        };\r\n\r\n        var expected = new AddHeader(\"Trace-Id\", \"{TraceId}\");\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => GivenThePlaceholderIs(\"http://ocelot.com/\"))\r\n            .When(x => WhenICreate())\r\n            .Then(x => ThenTheFollowingAddHeaderToDownstreamIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_add_downstream_header_as_is_when_no_replacement_is_given",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            DownstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"X-Custom-Header\", \"Value\"},\r\n            },\r\n        };\r\n\r\n        var expected = new AddHeader(\"X-Custom-Header\", \"Value\");\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => WhenICreate())\r\n            .Then(x => x.ThenTheFollowingAddHeaderToDownstreamIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_add_upstream_header_as_is_when_no_replacement_is_given",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamHeaderTransform = new Dictionary<string, string>\r\n            {\r\n                {\"X-Custom-Header\", \"Value\"},\r\n            },\r\n        };\r\n\r\n        var expected = new AddHeader(\"X-Custom-Header\", \"Value\");\r\n\r\n        this.Given(x => GivenTheRoute(route))\r\n            .And(x => WhenICreate())\r\n            .Then(x => x.ThenTheFollowingAddHeaderToUpstreamIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HttpHandlerOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_not_use_tracing_if_fake_tracer_registered",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                UseTracing = true,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_tracing_if_real_tracer_registered",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                UseTracing = true,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, true, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .And(x => GivenARealTracer())\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_with_useCookie_false_and_allowAutoRedirect_true_as_default",
        "body": "{\r\n        var fileRoute = new FileRoute();\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_with_specified_useCookie_and_allowAutoRedirect",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                AllowAutoRedirect = false,\r\n                UseCookieContainer = false,\r\n                UseTracing = false,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_with_useproxy_true_as_default",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions(),\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_with_specified_useproxy",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                UseProxy = false,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, false, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_with_specified_MaxConnectionsPerServer",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                MaxConnectionsPerServer = 10,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, 10, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_fixing_specified_MaxConnectionsPerServer_range",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                MaxConnectionsPerServer = -1,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_options_fixing_specified_MaxConnectionsPerServer_range_when_zero",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            HttpHandlerOptions = new FileHttpHandlerOptions\r\n            {\r\n                MaxConnectionsPerServer = 0,\r\n            },\r\n        };\r\n\r\n        var expectedOptions = new HttpHandlerOptions(false, false, false, true, int.MaxValue, DefaultPooledConnectionLifeTime);\r\n\r\n        this.Given(x => GivenTheFollowing(fileRoute))\r\n            .When(x => WhenICreateHttpHandlerOptions())\r\n            .Then(x => ThenTheFollowingOptionsReturned(expectedOptions))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HttpVersionPolicyCreatorTests.cs",
    "methods": [
      {
        "name": "Should_default_to_request_version_or_lower_when_setting_gibberish",
        "body": "{\n        // Arrange, Act\n        var actual = _creator.Create(\"string is gibberish\");\n\n        // Assert\n        Assert.Equal(HttpVersionPolicy.RequestVersionOrLower, actual);\n    }"
      }
    ]
  },
  {
    "file": "InMemoryConfigurationRepositoryTests.cs",
    "methods": [
      {
        "name": "can_add_config",
        "body": "{\r\n        this.Given(x => x.GivenTheConfigurationIs(new FakeConfig(\"initial\", \"adminath\")))\r\n            .When(x => x.WhenIAddOrReplaceTheConfig())\r\n            .Then(x => x.ThenNoErrorsAreReturned())\r\n            .And(x => AndTheChangeTokenIsActivated())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "can_get_config",
        "body": "{\r\n        this.Given(x => x.GivenThereIsASavedConfiguration())\r\n            .When(x => x.WhenIGetTheConfiguration())\r\n            .Then(x => x.ThenTheConfigurationIsReturned())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "LoadBalancerOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_create",
        "body": "{\n        var fileLoadBalancerOptions = new FileLoadBalancerOptions\n        {\n            Type = \"test\",\n            Key = \"west\",\n            Expiry = 1,\n        };\n\n        this.Given(_ => GivenThe(fileLoadBalancerOptions))\n            .When(_ => WhenICreate())\n            .Then(_ => ThenTheOptionsAreCreated(fileLoadBalancerOptions))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "QoSOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_qos_options",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            QoSOptions = new FileQoSOptions\r\n            {\r\n                ExceptionsAllowedBeforeBreaking = 1,\r\n                DurationOfBreak = 1,\r\n                TimeoutValue = 1,\r\n            },\r\n        };\r\n        var expected = new QoSOptionsBuilder()\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .WithTimeoutValue(1)\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenTheFollowingRoute(route))\r\n            .When(x => x.WhenICreate())\r\n            .Then(x => x.ThenTheFollowingIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RateLimitOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_rate_limit_options",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            RateLimitOptions = new FileRateLimitRule\r\n            {\r\n                ClientWhitelist = new List<string>(),\r\n                Period = \"Period\",\r\n                Limit = 1,\r\n                PeriodTimespan = 1,\r\n                EnableRateLimiting = true,\r\n            },\r\n        };\r\n        var fileGlobalConfig = new FileGlobalConfiguration\r\n        {\r\n            RateLimitOptions = new FileRateLimitOptions\r\n            {\r\n                ClientIdHeader = \"ClientIdHeader\",\r\n                DisableRateLimitHeaders = true,\r\n                QuotaExceededMessage = \"QuotaExceededMessage\",\r\n                RateLimitCounterPrefix = \"RateLimitCounterPrefix\",\r\n                HttpStatusCode = 200,\r\n            },\r\n        };\r\n        var expected = new RateLimitOptionsBuilder()\r\n            .WithClientIdHeader(\"ClientIdHeader\")\r\n            .WithClientWhiteList(() => fileRoute.RateLimitOptions.ClientWhitelist)\r\n            .WithDisableRateLimitHeaders(true)\r\n            .WithEnableRateLimiting(true)\r\n            .WithHttpStatusCode(200)\r\n            .WithQuotaExceededMessage(\"QuotaExceededMessage\")\r\n            .WithRateLimitCounterPrefix(\"RateLimitCounterPrefix\")\r\n            .WithRateLimitRule(new RateLimitRule(fileRoute.RateLimitOptions.Period,\r\n                   fileRoute.RateLimitOptions.PeriodTimespan,\r\n                   fileRoute.RateLimitOptions.Limit))\r\n            .Build();\r\n\n        _enabled = false;\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .And(x => x.GivenTheFollowingFileGlobalConfig(fileGlobalConfig))\r\n            .And(x => x.GivenRateLimitingIsEnabled())\r\n            .When(x => x.WhenICreate())\r\n            .Then(x => x.ThenTheFollowingIsReturned(expected))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RequestIdKeyCreatorTests.cs",
    "methods": [
      {
        "name": "should_use_global_configuration",
        "body": "{\r\n        var route = new FileRoute();\r\n        var globalConfig = new FileGlobalConfiguration\r\n        {\r\n            RequestIdKey = \"cheese\",\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingRoute(route))\r\n            .And(x => x.GivenTheFollowingGlobalConfig(globalConfig))\r\n            .When(x => x.WhenICreate())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"cheese\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_re_route_specific",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            RequestIdKey = \"cheese\",\r\n        };\r\n        var globalConfig = new FileGlobalConfiguration();\r\n\r\n        this.Given(x => x.GivenTheFollowingRoute(route))\r\n            .And(x => x.GivenTheFollowingGlobalConfig(globalConfig))\r\n            .When(x => x.WhenICreate())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"cheese\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_re_route_over_global_specific",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            RequestIdKey = \"cheese\",\r\n        };\r\n        var globalConfig = new FileGlobalConfiguration\r\n        {\r\n            RequestIdKey = \"test\",\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingRoute(route))\r\n            .And(x => x.GivenTheFollowingGlobalConfig(globalConfig))\r\n            .When(x => x.WhenICreate())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"cheese\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RouteKeyCreatorTests.cs",
    "methods": [
      {
        "name": "Should_return_sticky_session_key",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            LoadBalancerOptions = new FileLoadBalancerOptions\r\n            {\r\n                Key = \"testy\",\r\n                Type = nameof(CookieStickySessions),\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(route))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheResultIs(\"CookieStickySessions:testy\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_route_key",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/product\",\r\n            UpstreamHttpMethod = new() { \"GET\", \"POST\", \"PUT\" },\r\n            DownstreamHostAndPorts = new()\r\n            {\r\n                new(\"localhost\", 8080),\r\n                new(\"localhost\", 4430),\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(route))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheResultIs(\"GET,POST,PUT|/api/product|no-host|localhost:8080,localhost:4430|no-svc-ns|no-svc-name|no-lb-type|no-lb-key\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_route_key_with_upstream_host",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamHost = \"my-host\",\r\n            UpstreamPathTemplate = \"/api/product\",\r\n            UpstreamHttpMethod = new() { \"GET\", \"POST\", \"PUT\" },\r\n            DownstreamHostAndPorts = new()\r\n            {\r\n                new(\"localhost\", 8080),\r\n                new(\"localhost\", 4430),\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(route))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheResultIs(\"GET,POST,PUT|/api/product|my-host|localhost:8080,localhost:4430|no-svc-ns|no-svc-name|no-lb-type|no-lb-key\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_route_key_with_svc_name",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/product\",\r\n            UpstreamHttpMethod = new() { \"GET\", \"POST\", \"PUT\" },\r\n            ServiceName = \"products-service\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(route))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheResultIs(\"GET,POST,PUT|/api/product|no-host|no-host-and-port|no-svc-ns|products-service|no-lb-type|no-lb-key\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_route_key_with_load_balancer_options",
        "body": "{\r\n        var route = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/product\",\r\n            UpstreamHttpMethod = new() { \"GET\", \"POST\", \"PUT\" },\r\n            ServiceName = \"products-service\",\r\n            LoadBalancerOptions = new FileLoadBalancerOptions\r\n            {\r\n                Type = nameof(LeastConnection),\r\n                Key = \"testy\",\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(route))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheResultIs(\"GET,POST,PUT|/api/product|no-host|no-host-and-port|no-svc-ns|products-service|LeastConnection|testy\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RouteOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "Create_ArgumentIsNull_OptionsObjIsCreated",
        "body": "{\n        // Arrange, Act\n        var actual = _creator.Create(null);\n\n        // Assert\n        Assert.NotNull(actual);\n    }"
      },
      {
        "name": "Create_AuthenticationOptionsObjIsNull_IsAuthenticatedIsFalse",
        "body": "{\n        // Arrange\n        var route = new FileRoute { AuthenticationOptions = null };\n\n        // Act\n        var actual = _creator.Create(route);\n\n        // Assert\n        Assert.NotNull(actual);\n        Assert.False(actual.IsAuthenticated);\n    }"
      },
      {
        "name": "Create_AuthenticationOptionsWithNoProviderKeys_IsAuthenticatedIsFalse",
        "body": "{\n        // Arrange\n        var route = new FileRoute\n        {\n            AuthenticationOptions = new(),\n        };\n\n        // Act\n        var actual = _creator.Create(route);\n\n        // Assert\n        Assert.NotNull(actual);\n        Assert.False(actual.IsAuthenticated);\n    }"
      },
      {
        "name": "Create_AuthenticationOptionsWithAuthenticationProviderKeysObjIsNull_IsAuthenticatedIsFalse",
        "body": "{\n        // Arrange\n        var route = new FileRoute\n        {\n            AuthenticationOptions = new()\n            {\n                AuthenticationProviderKeys = null,\n            },\n        };\n\n        // Act\n        var actual = _creator.Create(route);\n\n        // Assert\n        Assert.NotNull(actual);\n        Assert.False(actual.IsAuthenticated);\n    }"
      },
      {
        "name": "Create_RateLimitOptionsObjIsNull_EnableRateLimitingIsFalse",
        "body": "{\n        // Arrange\n        var route = new FileRoute\n        {\n            RateLimitOptions = null,\n        };\n\n        // Act\n        var actual = _creator.Create(route);\n\n        // Assert\n        Assert.NotNull(actual);\n        Assert.False(actual.EnableRateLimiting);\n    }"
      }
    ]
  },
  {
    "file": "RoutesCreatorTests.cs",
    "methods": [
      {
        "name": "Should_return_nothing",
        "body": "{\r\n        var fileConfig = new FileConfiguration();\r\n\r\n        this.Given(_ => GivenThe(fileConfig))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenNoRoutesAreReturned())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_routes",
        "body": "{\r\n        var fileConfig = new FileConfiguration\r\n        {\r\n            Routes = new List<FileRoute>\r\n            {\r\n                new()\r\n                {\r\n                    ServiceName = \"dave\",\r\n                    DangerousAcceptAnyServerCertificateValidator = true,\r\n                    AddClaimsToRequest = new Dictionary<string, string>\r\n                    {\r\n                        { \"a\",\"b\" },\r\n                    },\r\n                    AddHeadersToRequest = new Dictionary<string, string>\r\n                    {\r\n                        { \"c\",\"d\" },\r\n                    },\r\n                    AddQueriesToRequest = new Dictionary<string, string>\r\n                    {\r\n                        { \"e\",\"f\" },\r\n                    },\r\n                    UpstreamHttpMethod = new List<string> { \"GET\", \"POST\" },\n                    Metadata = new Dictionary<string, string>\r\n                    {\r\n                        [\"foo\"] = \"bar\",\r\n                    },\r\n                },\r\n                new()\r\n                {\r\n                    ServiceName = \"wave\",\r\n                    DangerousAcceptAnyServerCertificateValidator = false,\r\n                    AddClaimsToRequest = new Dictionary<string, string>\r\n                    {\r\n                        { \"g\",\"h\" },\r\n                    },\r\n                    AddHeadersToRequest = new Dictionary<string, string>\r\n                    {\r\n                        { \"i\",\"j\" },\r\n                    },\r\n                    AddQueriesToRequest = new Dictionary<string, string>\r\n                    {\r\n                        { \"k\",\"l\" },\r\n                    },\r\n                    UpstreamHttpMethod = new List<string> { \"PUT\", \"DELETE\" },\r\n                    Metadata = new Dictionary<string, string>\r\n                    {\r\n                        [\"foo\"] = \"baz\",\r\n                    },\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileConfig))\r\n          .And(_ => GivenTheDependenciesAreSetUpCorrectly())\r\n          .When(_ => WhenICreate())\r\n          .Then(_ => ThenTheDependenciesAreCalledCorrectly())\r\n          .And(_ => ThenTheRoutesAreCreated())\r\n          .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "SecurityOptionsCreatorTests.cs",
    "methods": [
      {
        "name": "Should_create_route_security_config",
        "body": "{\r\n        // Arrange\r\n        var ipAllowedList = new List<string> { \"127.0.0.1\", \"192.168.1.1\" };\r\n        var ipBlockedList = new List<string> { \"127.0.0.1\", \"192.168.1.1\" };\r\n        var securityOptions = new FileSecurityOptions\r\n        {\r\n            IPAllowedList = ipAllowedList,\r\n            IPBlockedList = ipBlockedList,\r\n        };\r\n        var expected = new SecurityOptions(ipAllowedList, ipBlockedList);\r\n        var globalConfig = new FileGlobalConfiguration();\r\n\r\n        // Act\r\n        var actual = _creator.Create(securityOptions, globalConfig);\r\n\r\n        // Assert\r\n        ThenTheResultIs(actual, expected);\r\n    }"
      },
      {
        "name": "Should_create_global_security_config",
        "body": "{\r\n        // Arrange\r\n        var ipAllowedList = new List<string> { \"127.0.0.1\", \"192.168.1.1\" };\r\n        var ipBlockedList = new List<string> { \"127.0.0.1\", \"192.168.1.1\" };\r\n        var globalConfig = new FileGlobalConfiguration\r\n        {\r\n            SecurityOptions = new()\r\n            {\r\n                IPAllowedList = ipAllowedList,\r\n                IPBlockedList = ipBlockedList,\r\n            },\r\n        };\r\n        var expected = new SecurityOptions(ipAllowedList, ipBlockedList);\r\n\r\n        // Act\r\n        var actual = _creator.Create(new(), globalConfig);\r\n\r\n        // Assert\r\n        ThenTheResultIs(actual, expected);\r\n    }"
      },
      {
        "name": "Should_create_global_route_security_config",
        "body": "{\r\n        // Arrange\r\n        var routeIpAllowedList = new List<string> { \"127.0.0.1\", \"192.168.1.1\" };\r\n        var routeIpBlockedList = new List<string> { \"127.0.0.1\", \"192.168.1.1\" };\r\n        var securityOptions = new FileSecurityOptions\r\n        {\r\n            IPAllowedList = routeIpAllowedList,\r\n            IPBlockedList = routeIpBlockedList,\r\n        };\r\n        var globalIpAllowedList = new List<string> { \"127.0.0.2\", \"192.168.1.2\" };\r\n        var globalIpBlockedList = new List<string> { \"127.0.0.2\", \"192.168.1.2\" };\r\n        var globalConfig = new FileGlobalConfiguration\r\n        {\r\n            SecurityOptions = new FileSecurityOptions\r\n            {\r\n                IPAllowedList = globalIpAllowedList,\r\n                IPBlockedList = globalIpBlockedList,\r\n            },\r\n        };\r\n        var expected = new SecurityOptions(routeIpAllowedList, routeIpBlockedList);\r\n\r\n        // Act\r\n        var actual = _creator.Create(securityOptions, globalConfig);\r\n\r\n        // Assert\r\n        ThenTheResultIs(actual, expected);\r\n    }"
      }
    ]
  },
  {
    "file": "ServiceProviderCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_service_provider_config",
        "body": "{\n        var globalConfig = new FileGlobalConfiguration\n        {\n            ServiceDiscoveryProvider = new FileServiceDiscoveryProvider\n            {\n                Scheme = \"https\",\n                Host = \"127.0.0.1\",\n                Port = 1234,\n                Type = \"ServiceFabric\",\n                Token = \"testtoken\",\n                ConfigurationKey = \"woo\",\n                Namespace = \"default\",\n            },\n        };\n\n        var expected = new ServiceProviderConfigurationBuilder()\n            .WithScheme(\"https\")\n            .WithHost(\"127.0.0.1\")\n            .WithPort(1234)\n            .WithType(\"ServiceFabric\")\n            .WithToken(\"testtoken\")\n            .WithConfigurationKey(\"woo\")\n            .WithNamespace(\"default\")\n            .Build();\n\n        this.Given(x => x.GivenTheFollowingGlobalConfig(globalConfig))\n            .When(x => x.WhenICreate())\n            .Then(x => x.ThenTheConfigIs(expected))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "UpstreamHeaderTemplatePatternCreatorTests.cs",
    "methods": []
  },
  {
    "file": "UpstreamTemplatePatternCreatorTests.cs",
    "methods": [
      {
        "name": "should_match_up_to_next_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/v{apiVersion}/cards\",\r\n            Priority = 0,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^(?i)/api/v[^/]+/cards$\"))\r\n            .And(x => ThenThePriorityIs(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_re_route_priority",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/orders/{catchAll}\",\r\n            Priority = 0,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^(?i)/orders(?:|/{MatchEverything})$\"))\r\n            .And(x => ThenThePriorityIs(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_zero_priority",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/{catchAll}\",\r\n            Priority = 1,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^/.*\"))\r\n            .And(x => ThenThePriorityIs(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_set_upstream_template_pattern_to_ignore_case_sensitivity",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/PRODUCTS/{productId}\",\r\n            RouteIsCaseSensitive = false,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^(?i)/PRODUCTS(?:|/{MatchEverything})$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_match_forward_slash_or_no_forward_slash_if_template_end_with_forward_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/PRODUCTS/\",\r\n            RouteIsCaseSensitive = false,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^(?i)/PRODUCTS(/|)$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_set_upstream_template_pattern_to_respect_case_sensitivity",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/PRODUCTS/{productId}\",\r\n            RouteIsCaseSensitive = true,\r\n        };\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^/PRODUCTS(?:|/{MatchEverything})$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_anything_to_end_of_string",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/products/{productId}\",\r\n            RouteIsCaseSensitive = true,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^/api/products(?:|/{MatchEverything})$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_more_than_one_placeholder",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/products/{productId}/variants/{variantId}\",\r\n            RouteIsCaseSensitive = true,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^/api/products/[^/]+/variants(?:|/{MatchEverything})$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_more_than_one_placeholder_with_trailing_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/products/{productId}/variants/{variantId}/\",\r\n            RouteIsCaseSensitive = true,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^/api/products/[^/]+/variants/[^/]+(/|)$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_to_end_of_string",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/\",\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^/$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_to_end_of_string_when_slash_and_placeholder",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/{url}\",\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^/.*\"))\r\n            .And(x => ThenThePriorityIs(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_starts_with_placeholder_then_has_another_later",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/{productId}/products/variants/{variantId}/\",\r\n            RouteIsCaseSensitive = true,\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned(\"^/[^/]+/products/variants/[^/]+(/|)$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_query_string",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}\",\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^(?i)/api/subscriptions/[^/]+/updates(|\\\\?)unitId={MatchEverything}$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_template_pattern_that_matches_query_string_with_multiple_params",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            UpstreamPathTemplate = \"/api/subscriptions/{subscriptionId}/updates?unitId={unitId}&productId={productId}\",\r\n        };\r\n\r\n        this.Given(x => x.GivenTheFollowingFileRoute(fileRoute))\r\n            .When(x => x.WhenICreateTheTemplatePattern())\r\n            .Then(x => x.ThenTheFollowingIsReturned($\"^(?i)/api/subscriptions/[^/]+/updates(|\\\\?)unitId={MatchEverything}&productId={MatchEverything}$\"))\r\n            .And(x => ThenThePriorityIs(1))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "FileQoSOptionsFluentValidatorTests.cs",
    "methods": [
      {
        "name": "should_be_valid_as_nothing_set",
        "body": "{\r\n        this.Given(_ => GivenThe(new FileQoSOptions()))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsValid())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_be_valid_as_qos_delegate_set",
        "body": "{\r\n        var qosOptions = new FileQoSOptions\r\n        {\r\n            TimeoutValue = 1,\r\n            ExceptionsAllowedBeforeBreaking = 1,\r\n        };\r\n\r\n        this.Given(_ => GivenThe(qosOptions))\r\n            .And(_ => GivenAQosDelegate())\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsValid())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_be_invalid_as_no_qos_delegate",
        "body": "{\r\n        var qosOptions = new FileQoSOptions\r\n        {\r\n            TimeoutValue = 1,\r\n            ExceptionsAllowedBeforeBreaking = 1,\r\n        };\r\n\r\n        this.Given(_ => GivenThe(qosOptions))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInValid())\r\n            .And(_ => ThenTheErrorIs())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HostAndPortValidatorTests.cs",
    "methods": [
      {
        "name": "should_be_valid_because_host_set",
        "body": "{\r\n        var fileHostAndPort = new FileHostAndPort\r\n        {\r\n            Host = \"test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileHostAndPort))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsValid())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RouteFluentValidatorTests.cs",
    "methods": [
      {
        "name": "downstream_path_template_should_not_be_empty",
        "body": "{\r\n        var fileRoute = new FileRoute();\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"Downstream Path Template cannot be empty\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "upstream_path_template_should_not_be_empty",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"Upstream Path Template cannot be empty\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "downstream_path_template_should_start_with_forward_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"Downstream Path Template test doesnt start with forward slash\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "downstream_path_template_should_not_contain_double_forward_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"//test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"Downstream Path Template //test contains double forward slash, Ocelot does not support this at the moment. Please raise an issue in GitHib if you need this feature.\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "upstream_path_template_should_start_with_forward_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"Upstream Path Template test doesnt start with forward slash\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "upstream_path_template_should_not_contain_double_forward_slash",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"//test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"Upstream Path Template //test contains double forward slash, Ocelot does not support this at the moment. Please raise an issue in GitHib if you need this feature.\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_be_valid_if_enable_rate_limiting_true_and_period_is_empty",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n            RateLimitOptions = new FileRateLimitRule\r\n            {\r\n                EnableRateLimiting = true,\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"RateLimitOptions.Period is empty\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_be_valid_if_enable_rate_limiting_true_and_period_has_value",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n            RateLimitOptions = new FileRateLimitRule\r\n            {\r\n                EnableRateLimiting = true,\r\n                Period = \"test\",\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"RateLimitOptions.Period does not contain integer then s (second), m (minute), h (hour), d (day) e.g. 1m for 1 minute period\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_be_valid_if_specified_authentication_provider_isnt_registered",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n            AuthenticationOptions = new FileAuthenticationOptions\r\n            {\r\n                AuthenticationProviderKey = \"JwtLads\",\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains($\"Authentication Options AuthenticationProviderKey:'JwtLads',AuthenticationProviderKeys:[],AllowedScopes:[] is unsupported authentication provider\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_be_valid_if_not_using_service_discovery_and_no_host_and_ports",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsInvalid())\r\n            .And(_ => ThenTheErrorsContains(\"When not using service discovery DownstreamHostAndPorts must be set and not empty or Ocelot cannot find your service!\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_be_valid_if_using_service_discovery_and_no_host_and_ports",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n            ServiceName = \"Lads\",\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsValid())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_be_valid_re_route_using_host_and_port_and_paths",
        "body": "{\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n            DownstreamHostAndPorts = new List<FileHostAndPort>\r\n            {\r\n                new()\r\n                {\r\n                    Host = \"localhost\",\r\n                    Port = 5000,\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsValid())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_be_valid_if_specified_authentication_provider_is_registered",
        "body": "{\r\n        const string key = \"JwtLads\";\r\n\r\n        var fileRoute = new FileRoute\r\n        {\r\n            DownstreamPathTemplate = \"/test\",\r\n            UpstreamPathTemplate = \"/test\",\r\n            AuthenticationOptions = new FileAuthenticationOptions\r\n            {\r\n                AuthenticationProviderKey = key,\r\n            },\r\n            DownstreamHostAndPorts = new List<FileHostAndPort>\r\n            {\r\n                new()\r\n                {\r\n                    Host = \"localhost\",\r\n                    Port = 5000,\r\n                },\r\n            },\r\n        };\r\n\r\n        this.Given(_ => GivenThe(fileRoute))\r\n            .And(_ => GivenAnAuthProvider(key))\r\n            .When(_ => WhenIValidate())\r\n            .Then(_ => ThenTheResultIsValid())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "VersionCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_version_based_on_input",
        "body": "{\n        this.Given(_ => GivenTheInput(\"2.0\"))\n            .When(_ => WhenICreate())\n            .Then(_ => ThenTheResultIs(2, 0))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_default_to_version_one_point_one",
        "body": "{\n        this.Given(_ => GivenTheInput(string.Empty))\n            .When(_ => WhenICreate())\n            .Then(_ => ThenTheResultIs(1, 1))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ConsulFileConfigurationRepositoryTests.cs",
    "methods": [
      {
        "name": "should_set_config",
        "body": "{\r\n        var config = FakeFileConfiguration();\r\n\r\n        this.Given(_ => GivenIHaveAConfiguration(config))\r\n            .And(_ => GivenWritingToConsulSucceeds())\r\n            .When(_ => WhenISetTheConfiguration())\r\n            .Then(_ => ThenTheConfigurationIsStoredAs(config))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_get_config",
        "body": "{\r\n        var config = FakeFileConfiguration();\r\n\r\n        this.Given(_ => GivenIHaveAConfiguration(config))\r\n           .And(_ => GivenFetchFromConsulSucceeds())\r\n           .When(_ => WhenIGetTheConfiguration())\r\n           .Then(_ => ThenTheConfigurationIs(config))\r\n           .BDDfy();\r\n    }"
      },
      {
        "name": "should_get_null_config",
        "body": "{\r\n        var config = FakeFileConfiguration();\r\n\r\n        this.Given(_ => GivenIHaveAConfiguration(config))\r\n           .Given(_ => GivenFetchFromConsulReturnsNull())\r\n           .When(_ => WhenIGetTheConfiguration())\r\n           .Then(_ => ThenTheConfigurationIsNull())\r\n           .BDDfy();\r\n    }"
      },
      {
        "name": "should_get_config_from_cache",
        "body": "{\r\n        var config = FakeFileConfiguration();\r\n\r\n        this.Given(_ => GivenIHaveAConfiguration(config))\r\n           .And(_ => GivenFetchFromCacheSucceeds())\r\n           .When(_ => WhenIGetTheConfiguration())\r\n           .Then(_ => ThenTheConfigurationIs(config))\r\n           .BDDfy();\r\n    }"
      },
      {
        "name": "should_set_config_key",
        "body": "{\r\n        var config = FakeFileConfiguration();\r\n\r\n        this.Given(_ => GivenIHaveAConfiguration(config))\r\n            .And(_ => GivenTheConfigKeyComesFromFileConfig(\"Tom\"))\r\n            .And(_ => GivenFetchFromConsulSucceeds())\r\n            .When(_ => WhenIGetTheConfiguration())\r\n            .And(_ => ThenTheConfigKeyIs(\"Tom\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_set_default_config_key",
        "body": "{\r\n        var config = FakeFileConfiguration();\r\n\r\n        this.Given(_ => GivenIHaveAConfiguration(config))\r\n            .And(_ => GivenFetchFromConsulSucceeds())\r\n            .When(_ => WhenIGetTheConfiguration())\r\n            .And(_ => ThenTheConfigKeyIs(\"InternalConfiguration\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ConsulProviderFactoryTests.cs",
    "methods": [
      {
        "name": "Get_EmptyTypeName_ReturnedConsul",
        "body": "{\n        // Arrange\n        var emptyType = string.Empty;\n        var route = GivenRoute(string.Empty);\n\n        // Act\n        var actual = CreateProvider(route, emptyType);\n\n        // Assert\n        actual.ShouldNotBeNull().ShouldBeOfType<Provider.Consul.Consul>();\n    }"
      },
      {
        "name": "Get_PollConsulTypeName_ReturnedPollConsul",
        "body": "{\n        // Arrange, Act\n        var route = GivenRoute(string.Empty);\n        var actual = CreateProvider(route, nameof(PollConsul));\n\n        // Assert\n        actual.ShouldNotBeNull().ShouldBeOfType<PollConsul>();\n    }"
      },
      {
        "name": "Get_RoutesWithTheSameServiceName_ReturnedSameProvider",
        "body": "{\n        // Arrange, Act: 1\n        var route1 = GivenRoute(\"test\");\n        var actual1 = CreateProvider(route1);\n\n        // Arrange, Act: 2\n        var route2 = GivenRoute(\"test\");\n        var actual2 = CreateProvider(route2);\n\n        // Assert\n        actual1.ShouldNotBeNull().ShouldBeOfType<PollConsul>();\n        actual2.ShouldNotBeNull().ShouldBeOfType<PollConsul>();\n        actual1.ShouldBeEquivalentTo(actual2);\n        var provider1 = actual1 as PollConsul;\n        var provider2 = actual2 as PollConsul;\n        provider1.ServiceName.ShouldBeEquivalentTo(provider2.ServiceName);\n    }"
      },
      {
        "name": "Get_MultipleServiceNames_ShouldReturnProviderAccordingToServiceName",
        "body": "{\n        string[] serviceNames = new[] { \"service1\", \"service2\", \"service3\", \"service4\" };\n        var providersList = serviceNames.Select(DummyPollingConsulServiceFactory).ToList();\n\n        foreach (var serviceName in serviceNames)\n        {\n            var currentProvider = DummyPollingConsulServiceFactory(serviceName);\n            providersList.ShouldContain(currentProvider);\n        }\n\n        var convertedProvidersList = providersList.Select(x => x as PollConsul).ToList();\n        convertedProvidersList.ForEach(x => x.ShouldNotBeNull());\n\n        foreach (var serviceName in serviceNames)\n        {\n            var cProvider = DummyPollingConsulServiceFactory(serviceName);\n            var convertedCProvider = cProvider as PollConsul;\n            convertedCProvider.ShouldNotBeNull();\n\n            var matchingProviders = convertedProvidersList\n                .Where(x => x.ServiceName == convertedCProvider.ServiceName)\n                .ToList();\n            matchingProviders.ShouldHaveSingleItem();\n\n            matchingProviders.First()\n                .ShouldNotBeNull()\n                .ServiceName.ShouldBeEquivalentTo(convertedCProvider.ServiceName);\n        }\n    }"
      },
      {
        "name": "Get_RootProvider_ShouldThrowInvalidOperationException",
        "body": "{\n        // Arrange\n        var route = GivenRoute(string.Empty);\n        _context.RequestServices = _provider; // given service provider is root provider\n\n        // Act\n        Func<IServiceDiscoveryProvider> consulProviderFactoryCall = () => CreateProvider(route);\n\n        // Assert\n        consulProviderFactoryCall.ShouldThrow<InvalidOperationException>();\n    }"
      }
    ]
  },
  {
    "file": "ConsulTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        var service1 = GivenService(50881);\n        _consulServiceEntries.Add(service1.ToServiceEntry());\n        GivenThereIsAFakeConsulServiceDiscoveryProvider();\n\n        // Act\n        var actual = await _provider.GetAsync();\n\n        // Assert\n        actual.ShouldNotBeNull().Count.ShouldBe(1);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        const string token = \"test token\";\n        var service1 = GivenService(50881);\n        _consulServiceEntries.Add(service1.ToServiceEntry());\n        GivenThereIsAFakeConsulServiceDiscoveryProvider();\n        var config = new ConsulRegistryConfiguration(_consulScheme, _consulHost, _port, nameof(Should_use_token), token);\n        _provider = new ConsulProvider(config, _factory.Object, _clientFactory, _serviceBuilder);\n\n        // Act\n        var actual = await _provider.GetAsync();\n\n        // Assert\n        actual.ShouldNotBeNull().Count.ShouldBe(1);\n        _receivedToken.ShouldBe(token);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        var service1 = GivenService(50881, \"http://localhost\");\n        var service2 = GivenService(50888, \"http://localhost\");\n        _consulServiceEntries.Add(service1.ToServiceEntry());\n        _consulServiceEntries.Add(service2.ToServiceEntry());\n        GivenThereIsAFakeConsulServiceDiscoveryProvider();\n\n        // Act\n        var actual = await _provider.GetAsync();\n\n        // Assert\n        actual.ShouldNotBeNull().Count.ShouldBe(0);\n        ThenTheLoggerHasBeenCalledCorrectlyWithValidationWarning();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        var service1 = GivenService(50881).WithAddress(string.Empty);\n        var service2 = GivenService(50888).WithAddress(null);\n        _consulServiceEntries.Add(service1.ToServiceEntry());\n        _consulServiceEntries.Add(service2.ToServiceEntry());\n        GivenThereIsAFakeConsulServiceDiscoveryProvider();\n\n        // Act\n        var actual = await _provider.GetAsync();\n\n        // Assert\n        actual.ShouldNotBeNull().Count.ShouldBe(0);\n        ThenTheLoggerHasBeenCalledCorrectlyWithValidationWarning();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        var service1 = GivenService(-1);\n        var service2 = GivenService(0);\n        _consulServiceEntries.Add(service1.ToServiceEntry());\n        _consulServiceEntries.Add(service2.ToServiceEntry());\n        GivenThereIsAFakeConsulServiceDiscoveryProvider();\n\n        // Act\n        var actual = await _provider.GetAsync();\n\n        // Assert\n        actual.ShouldNotBeNull().Count.ShouldBe(0);\n        ThenTheLoggerHasBeenCalledCorrectlyWithValidationWarning();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        _consulServiceEntries.Clear(); // NoEntries\n        _logger.Setup(x => x.LogWarning(It.IsAny<Func<string>>())).Verifiable();\n        GivenThereIsAFakeConsulServiceDiscoveryProvider();\n\n        // Act\n        var actual = await _provider.GetAsync();\n\n        // Assert\n        actual.ShouldNotBeNull().ShouldBeEmpty();\n        var expected = $\"Consul Provider: No service entries found for '{nameof(GetAsync_NoEntries_ShouldLogWarning)}' service!\";\n        _logger.Verify(x => x.LogWarning(It.Is<Func<string>>(y => y.Invoke() == expected)), Times.Once);\n    }"
      }
    ]
  },
  {
    "file": "DefaultConsulServiceBuilderTests.cs",
    "methods": [
      {
        "name": "Ctor_PrivateMembers_PropertiesAreInitialized",
        "body": "{\n        Arrange();\n        var propClient = sut.GetType().GetProperty(\"Client\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var propLogger = sut.GetType().GetProperty(\"Logger\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var propConfiguration = sut.GetType().GetProperty(\"Configuration\", BindingFlags.NonPublic | BindingFlags.Instance);\n\n        // Act\n        //var actualConfiguration = sut.Configuration;\n        var actualConfiguration = propConfiguration.GetValue(sut);\n        var actualClient = propClient.GetValue(sut);\n        var actualLogger = propLogger.GetValue(sut);\n\n        // Assert\n        actualConfiguration.ShouldNotBeNull().ShouldBe(_configuration);\n        actualClient.ShouldNotBeNull();\n        actualLogger.ShouldNotBeNull();\n    }"
      },
      {
        "name": "GetNode_EntryBranch_ReturnsEntryNode",
        "body": "{\n        Arrange();\n        Node node = new() { Name = nameof(GetNode_EntryBranch_ReturnsEntryNode) };\n        ServiceEntry entry = new() { Node = node };\n\n        // Act\n        var actual = GetNode.Invoke(sut, new object[] { entry, null }) as Node;\n\n        // Assert\n        actual.ShouldNotBeNull().ShouldBe(node);\n        actual.Name.ShouldBe(node.Name);\n    }"
      },
      {
        "name": "GetNode_NodesBranch_ReturnsNodeFromCollection",
        "body": "{\n        Arrange();\n        ServiceEntry entry = new()\n        {\n            Node = null,\n            Service = new() { Address = nameof(GetNode_NodesBranch_ReturnsNodeFromCollection) },\n        };\n        Node[] nodes = null;\n\n        // Act, Assert: nodes is null\n        var actual = GetNode.Invoke(sut, new object[] { entry, nodes }) as Node;\n        actual.ShouldBeNull();\n\n        // Arrange, Act, Assert: nodes has items, happy path\n        var node = new Node { Address = nameof(GetNode_NodesBranch_ReturnsNodeFromCollection) };\n        nodes = new[] { node };\n        actual = GetNode.Invoke(sut, new object[] { entry, nodes }) as Node;\n        actual.ShouldNotBeNull().ShouldBe(node);\n        actual.Address.ShouldBe(entry.Service.Address);\n\n        // Arrange, Act, Assert: nodes has items, some nulls in entry\n        entry.Service.Address = null;\n        actual = GetNode.Invoke(sut, new object[] { entry, nodes }) as Node;\n        actual.ShouldBeNull();\n\n        entry.Service = null;\n        actual = GetNode.Invoke(sut, new object[] { entry, nodes }) as Node;\n        actual.ShouldBeNull();\n\n        entry = null;\n        actual = GetNode.Invoke(sut, new object[] { entry, nodes }) as Node;\n        actual.ShouldBeNull();\n    }"
      },
      {
        "name": "GetDownstreamHost_BothBranches_NameOrAddress",
        "body": "{\n        Arrange();\n\n        // Arrange, Act, Assert: node branch\n        ServiceEntry entry = new()\n        {\n            Service = new() { Address = nameof(GetDownstreamHost_BothBranches_NameOrAddress) },\n        };\n        var node = new Node { Name = \"test1\" };\n        var actual = GetDownstreamHost.Invoke(sut, new object[] { entry, node }) as string;\n        actual.ShouldNotBeNull().ShouldBe(\"test1\");\n\n        // Arrange, Act, Assert: entry branch\n        node = null;\n        actual = GetDownstreamHost.Invoke(sut, new object[] { entry, node }) as string;\n        actual.ShouldNotBeNull().ShouldBe(nameof(GetDownstreamHost_BothBranches_NameOrAddress));\n    }"
      },
      {
        "name": "GetServiceVersion_TagsIsNull_EmptyString",
        "body": "{\n        Arrange();\n\n        // Arrange, Act, Assert: collection is null\n        ServiceEntry entry = new()\n        {\n            Service = new() { Tags = null },\n        };\n        Node node = null;\n        var actual = GetServiceVersion.Invoke(sut, new object[] { entry, node }) as string;\n        actual.ShouldBe(string.Empty);\n\n        // Arrange, Act, Assert: collection has no version tag\n        entry.Service.Tags = new[] { \"test\" };\n        actual = GetServiceVersion.Invoke(sut, new object[] { entry, node }) as string;\n        actual.ShouldBe(string.Empty);\n    }"
      },
      {
        "name": "GetServiceVersion_HasTags_HappyPath",
        "body": "{\n        Arrange();\n\n        // Arrange\n        var tags = new string[] { \"test\", \"version-v2\" };\n        ServiceEntry entry = new()\n        {\n            Service = new() { Tags = tags },\n        };\n        Node node = null;\n\n        // Act\n        var actual = GetServiceVersion.Invoke(sut, new object[] { entry, node }) as string;\n\n        // Assert\n        actual.ShouldBe(\"v2\");\n    }"
      },
      {
        "name": "GetServiceTags_BothBranches",
        "body": "{\n        Arrange();\n\n        // Arrange, Act, Assert: collection is null\n        ServiceEntry entry = new()\n        {\n            Service = new() { Tags = null },\n        };\n        Node node = null;\n        var actual = GetServiceTags.Invoke(sut, new object[] { entry, node }) as IEnumerable<string>;\n        actual.ShouldNotBeNull().ShouldBeEmpty();\n\n        // Arrange, Act, Assert: happy path\n        entry.Service.Tags = new string[] { \"1\", \"2\", \"3\" };\n        actual = GetServiceTags.Invoke(sut, new object[] { entry, node }) as IEnumerable<string>;\n        actual.ShouldNotBeNull().ShouldNotBeEmpty();\n        actual.Count().ShouldBe(3);\n        actual.ShouldContain(\"3\");\n    }"
      }
    ]
  },
  {
    "file": "OcelotBuilderExtensionsTests.cs",
    "methods": [
      {
        "name": "should_set_up_cache_manager",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => WhenISetUpCacheManager())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .And(x => OnlyOneVersionOfEachCacheIsRegistered())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "PollingConsulServiceDiscoveryProviderTests.cs",
    "methods": [
      {
        "name": "should_return_service_from_consul",
        "body": "{\n        var service = new Service(string.Empty, new ServiceHostAndPort(string.Empty, 0), string.Empty, string.Empty, new List<string>());\n\n        this.Given(x => GivenConsulReturns(service))\n            .When(x => WhenIGetTheServices(1))\n            .Then(x => ThenTheCountIs(1))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_service_from_consul_without_delay",
        "body": "{\n        var service = new Service(string.Empty, new ServiceHostAndPort(string.Empty, 0), string.Empty, string.Empty, new List<string>());\n\n        this.Given(x => GivenConsulReturns(service))\n            .When(x => WhenIGetTheServicesWithoutDelay(1))\n            .Then(x => ThenTheCountIs(1))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "FileConfigurationControllerTests.cs",
    "methods": [
      {
        "name": "should_get_file_configuration",
        "body": "{\n        var expected = new OkResponse<FileConfiguration>(new FileConfiguration());\n\n        this.Given(x => x.GivenTheGetConfigurationReturns(expected))\n            .When(x => x.WhenIGetTheFileConfiguration())\n            .Then(x => x.TheTheGetFileConfigurationIsCalledCorrectly())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_when_cannot_get_config",
        "body": "{\n        var expected = new ErrorResponse<FileConfiguration>(It.IsAny<Error>());\n\n        this.Given(x => x.GivenTheGetConfigurationReturns(expected))\n           .When(x => x.WhenIGetTheFileConfiguration())\n           .Then(x => x.TheTheGetFileConfigurationIsCalledCorrectly())\n           .And(x => x.ThenTheResponseIs<BadRequestObjectResult>())\n           .BDDfy();\n    }"
      },
      {
        "name": "should_post_file_configuration",
        "body": "{\n        var expected = new FileConfiguration();\n\n        this.Given(x => GivenTheFileConfiguration(expected))\n            .And(x => GivenTheConfigSetterReturns(new OkResponse()))\n            .When(x => WhenIPostTheFileConfiguration())\n            .Then(x => x.ThenTheConfigrationSetterIsCalledCorrectly())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_when_cannot_set_config",
        "body": "{\n        var expected = new FileConfiguration();\n\n        this.Given(x => GivenTheFileConfiguration(expected))\n            .And(x => GivenTheConfigSetterReturns(new ErrorResponse(new FakeError())))\n            .When(x => WhenIPostTheFileConfiguration())\n            .Then(x => x.ThenTheConfigrationSetterIsCalledCorrectly())\n            .And(x => ThenTheResponseIs<BadRequestObjectResult>())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OutputCacheControllerTests.cs",
    "methods": [
      {
        "name": "should_delete_key",
        "body": "{\n        this.When(_ => WhenIDeleteTheKey(\"a\"))\n           .Then(_ => ThenTheKeyIsDeleted(\"a\"))\n           .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ConfigurationBuilderExtensionsTests.cs",
    "methods": [
      {
        "name": "Should_add_base_url_to_config",
        "body": "{\n        // Arrange\r\n        _configuration = new ConfigurationBuilder()\r\n            .AddOcelotBaseUrl(\"test\")\n            .Build();\n\r\n        // Act\n        var actual = _configuration.GetValue(\"BaseUrl\", string.Empty);\r\n\n        // Assert\n        actual.ShouldBe(\"test\");\r\n    }"
      },
      {
        "name": "Should_merge_files_to_file",
        "body": "{\n        // Arrange\r\n        GivenTheEnvironmentIs(TestID);\n        GivenMultipleConfigurationFiles(TestID);\n\n        // Act\n        WhenIAddOcelotConfiguration(TestID);\n\n        // Assert\n        ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(false);\n        TheOcelotPrimaryConfigFileExists(true);\r\n    }"
      },
      {
        "name": "Should_store_given_configurations_when_provided_file_configuration_object",
        "body": "{\n        // Arrange\r\n        GivenTheEnvironmentIs(TestID);\n        GivenCombinedFileConfigurationObject();\n\n        // Act\n        WhenIAddOcelotConfigurationWithCombinedFileConfiguration();\n\n        // Assert\n        ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(true);\r\n    }"
      },
      {
        "name": "Should_merge_files_except_env",
        "body": "{\r\n        // Arrange\r\n        GivenTheEnvironmentIs(TestID);\r\n        GivenMultipleConfigurationFiles(TestID, true);\r\n\n        // Act\n        WhenIAddOcelotConfiguration(TestID);\r\n\n        // Assert\n        ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(false);\r\n        NotContainsEnvSpecificConfig();\r\n    }"
      },
      {
        "name": "Should_merge_files_in_specific_folder",
        "body": "{\r\n        // Arrange\r\n        GivenMultipleConfigurationFiles(TestID);\n\n        // Act\n        WhenIAddOcelotConfiguration(TestID);\n\n        // Assert\n        ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(false);\r\n    }"
      },
      {
        "name": "Should_merge_files_to_memory",
        "body": "{\n        // Arrange\r\n        GivenTheEnvironmentIs(TestID);\n        GivenMultipleConfigurationFiles(TestID);\r\n\n        // Act\n        WhenIAddOcelotConfiguration(TestID, MergeOcelotJson.ToMemory);\n\n        // Assert\n        ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(false);\n        TheOcelotPrimaryConfigFileExists(false);\r\n    }"
      },
      {
        "name": "Should_merge_files_with_null_environment",
        "body": "{\n        // Arrange\r\n        _environmentConfigFileName = null; // Ups!\n        const IWebHostEnvironment NullEnvironment = null; // Wow!\n        GivenMultipleConfigurationFiles(TestID, false);\r\n\n        // Act\n        _configRoot = new ConfigurationBuilder()\n            .AddOcelot(TestID, NullEnvironment, MergeOcelotJson.ToMemory, _primaryConfigFileName, _globalConfigFileName, _environmentConfigFileName, false, false)\n            .Build();\r\n\n        // Assert\n        ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(false);\n        TheOcelotPrimaryConfigFileExists(false);\r\n    }"
      },
      {
        "name": "Should_use_relative_path_for_global_config",
        "body": "{\r\n        // Arrange\r\n        GivenMultipleConfigurationFiles(TestID);\r\n\r\n        // Act\r\n        WhenIAddOcelotConfigurationWithDefaultFilePaths(TestID);\r\n\r\n        // Assert\r\n        var config = ThenTheConfigsAreMergedAndAddedInApplicationConfiguration(false);\r\n        config.ShouldNotBeNull().GlobalConfiguration.RequestIdKey.ShouldBe(nameof(Should_use_relative_path_for_global_config));\r\n    }"
      }
    ]
  },
  {
    "file": "OcelotBuilderTests.cs",
    "methods": [
      {
        "name": "Should_add_specific_delegating_handlers_transient",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => AddSpecificTransientDelegatingHandler<FakeDelegatingHandler>())\n            .And(x => AddSpecificTransientDelegatingHandler<FakeDelegatingHandlerTwo>())\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsSpecificHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\n            .And(x => ThenTheSpecificHandlersAreTransient())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_type_specific_delegating_handlers_transient",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => AddTypeSpecificTransientDelegatingHandler(typeof(FakeDelegatingHandler)))\n            .And(x => AddTypeSpecificTransientDelegatingHandler(typeof(FakeDelegatingHandlerTwo)))\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsSpecificHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\n            .And(x => ThenTheSpecificHandlersAreTransient())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_global_delegating_handlers_transient",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => AddTransientGlobalDelegatingHandler<FakeDelegatingHandler>())\n            .And(x => AddTransientGlobalDelegatingHandler<FakeDelegatingHandlerTwo>())\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\n            .And(x => ThenTheGlobalHandlersAreTransient())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_global_type_delegating_handlers_transient",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => AddTransientGlobalDelegatingHandler<FakeDelegatingHandler>())\n            .And(x => AddTransientGlobalDelegatingHandler<FakeDelegatingHandlerTwo>())\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\n            .And(x => ThenTheGlobalHandlersAreTransient())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_set_up_services",
        "body": "{\n        this.When(x => WhenISetUpOcelotServices())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_return_ocelot_builder",
        "body": "{\n        this.When(x => WhenISetUpOcelotServices())\n            .Then(x => ThenAnOcelotBuilderIsReturned())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_use_logger_factory",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => WhenIValidateScopes())\n            .When(x => WhenIAccessLoggerFactory())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_set_up_without_passing_in_config",
        "body": "{\n        this.When(x => WhenISetUpOcelotServicesWithoutConfig())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_singleton_defined_aggregators",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => AddSingletonDefinedAggregator<TestDefinedAggregator>())\n            .When(x => AddSingletonDefinedAggregator<TestDefinedAggregator>())\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsSpecificAggregators<TestDefinedAggregator, TestDefinedAggregator>())\n            .And(x => ThenTheAggregatorsAreSingleton<TestDefinedAggregator, TestDefinedAggregator>())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_transient_defined_aggregators",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => AddTransientDefinedAggregator<TestDefinedAggregator>())\n            .When(x => AddTransientDefinedAggregator<TestDefinedAggregator>())\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsSpecificAggregators<TestDefinedAggregator, TestDefinedAggregator>())\n            .And(x => ThenTheAggregatorsAreTransient<TestDefinedAggregator, TestDefinedAggregator>())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_custom_load_balancer_creators_by_default_ctor",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => _ocelotBuilder.AddCustomLoadBalancer<FakeCustomLoadBalancer>())\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsBothBuiltInAndCustomLoadBalancerCreators())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_custom_load_balancer_creators_by_factory_method",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => _ocelotBuilder.AddCustomLoadBalancer(() => new FakeCustomLoadBalancer()))\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsBothBuiltInAndCustomLoadBalancerCreators())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_custom_load_balancer_creators_by_di_factory_method",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => _ocelotBuilder.AddCustomLoadBalancer(provider => new FakeCustomLoadBalancer()))\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsBothBuiltInAndCustomLoadBalancerCreators())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_custom_load_balancer_creators_by_factory_method_with_arguments",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => _ocelotBuilder.AddCustomLoadBalancer((route, discoveryProvider) => new FakeCustomLoadBalancer()))\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsBothBuiltInAndCustomLoadBalancerCreators())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_replace_iplaceholder",
        "body": "{\n        this.Given(x => x.WhenISetUpOcelotServices())\n            .When(x => AddConfigPlaceholders())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .And(x => ThenTheIPlaceholderInstanceIsReplaced())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_add_custom_load_balancer_creators",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => _ocelotBuilder.AddCustomLoadBalancer((provider, route, discoveryProvider) => new FakeCustomLoadBalancer()))\n            .Then(x => ThenTheProviderIsRegisteredAndReturnsBothBuiltInAndCustomLoadBalancerCreators())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_use_default_mvc_builder",
        "body": "{\n        WhenISetUpOcelotServicesWithoutConfig();\n        CstorShouldUseDefaultBuilderToInitMvcCoreBuilder();\n    }"
      },
      {
        "name": "Should_use_custom_mvc_builder_no_configuration",
        "body": "{\n        // Arrange, Act\n        WhenISetupOcelotServicesWithCustomMvcBuider();\n\n        // Assert\n        CstorShouldUseCustomBuilderToInitMvcCoreBuilder();\n        ShouldFindConfiguration();\n    }"
      }
    ]
  },
  {
    "file": "ServiceCollectionExtensionsTests.cs",
    "methods": [
      {
        "name": "AddOcelot_NoConfiguration_DefaultConfiguration",
        "body": "{\n        // Arrange\n        var services = new ServiceCollection();\n\n        // Act\n        var ocelot = services.AddOcelot();\n\n        // Assert\n        ocelot.ShouldNotBeNull()\n            .Configuration.ShouldNotBeNull();\n    }"
      },
      {
        "name": "AddOcelotUsingBuilder_NoConfigurationParam_ShouldFindConfiguration",
        "body": "{\n        // Arrange\n        var services = new ServiceCollection();\n        var config = new ConfigurationBuilder().Build();\n        services.AddSingleton<IConfiguration>(config);\n\n        // Act\n        var ocelot = services.AddOcelotUsingBuilder(null, CustomBuilder);\n\n        // Assert\n        AssertConfiguration(ocelot, config);\n    }"
      }
    ]
  },
  {
    "file": "ChangeDownstreamPathTemplateTests.cs",
    "methods": [
      {
        "name": "should_change_downstream_path_request",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n        var placeHolderValues = new List<PlaceholderNameAndValue>();\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"path-key\", string.Empty, string.Empty, 0),\n            }))\n            .And(x => x.GivenClaims(claims))\n            .And(x => x.GivenDownstreamPathTemplate(\"/api/test/{path-key}\"))\n            .And(x => x.GivenPlaceholderNameAndValues(placeHolderValues))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIChangeDownstreamPath())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenClaimDataIsContainedInPlaceHolder(\"{path-key}\", \"value\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_existing_placeholder_value",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n        var placeHolderValues = new List<PlaceholderNameAndValue>\n        {\n            new(\"{path-key}\", \"old_value\"),\n        };\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"path-key\", string.Empty, string.Empty, 0),\n            }))\n            .And(x => x.GivenClaims(claims))\n            .And(x => x.GivenDownstreamPathTemplate(\"/api/test/{path-key}\"))\n            .And(x => x.GivenPlaceholderNameAndValues(placeHolderValues))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIChangeDownstreamPath())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenClaimDataIsContainedInPlaceHolder(\"{path-key}\", \"value\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_when_no_placeholder_in_downstream_path",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n        var placeHolderValues = new List<PlaceholderNameAndValue>();\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"path-key\", string.Empty, string.Empty, 0),\n            }))\n            .And(x => x.GivenClaims(claims))\n            .And(x => x.GivenDownstreamPathTemplate(\"/api/test\"))\n            .And(x => x.GivenPlaceholderNameAndValues(placeHolderValues))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIChangeDownstreamPath())\n            .Then(x => x.ThenTheResultIsCouldNotFindPlaceholderError())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_when_claim_parser_returns_error",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n        var placeHolderValues = new List<PlaceholderNameAndValue>();\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"path-key\", string.Empty, string.Empty, 0),\n            }))\n            .And(x => x.GivenClaims(claims))\n            .And(x => x.GivenDownstreamPathTemplate(\"/api/test/{path-key}\"))\n            .And(x => x.GivenPlaceholderNameAndValues(placeHolderValues))\n            .And(x => x.GivenTheClaimParserReturns(new ErrorResponse<string>(new List<Error>\n            {\n               new AnyError(),\n            })))\n            .When(x => x.WhenIChangeDownstreamPath())\n            .Then(x => x.ThenTheResultIsError())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToDownstreamPathMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_add_queries_correctly",
        "body": "{\n        var downstreamRoute = new Ocelot.DownstreamRouteFinder.DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithClaimsToDownstreamPath(new List<ClaimToThing>\n                    {\n                        new(\"UserId\", \"Subject\", string.Empty, 0),\n                    })\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n           .And(x => x.GivenTheChangeDownstreamPathReturnsOk())\n           .When(x => x.WhenICallTheMiddleware())\n           .Then(x => x.ThenChangeDownstreamPathIsCalledCorrectly())\n           .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRouteCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_downstream_route",
        "body": "{\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDownstreamRouteIsCreated())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_with_rate_limit_options",
        "body": "{\r\n        var rateLimitOptions = new RateLimitOptionsBuilder()\r\n            .WithEnableRateLimiting(true)\r\n            .WithClientIdHeader(\"test\")\r\n            .Build();\r\n\r\n        var downstreamRoute = new DownstreamRouteBuilder()\r\n            .WithServiceName(\"auth\")\r\n            .WithRateLimitOptions(rateLimitOptions)\r\n            .Build();\r\n\r\n        var route = new RouteBuilder()\r\n            .WithDownstreamRoute(downstreamRoute)\r\n            .Build();\r\n\r\n        var routes = new List<Route> { route };\r\n\r\n        var configuration = new InternalConfiguration(\r\n            routes,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDownstreamRouteIsCreated())\r\n            .And(_ => WithRateLimitOptions(rateLimitOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_cache_downstream_route",
        "body": "{\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration, \"/geoffisthebest/\"))\r\n            .When(_ => WhenICreate())\r\n            .And(_ => GivenTheConfiguration(configuration, \"/geoffisthebest/\"))\r\n            .When(_ => WhenICreateAgain())\r\n            .Then(_ => ThenTheDownstreamRoutesAreTheSameReference())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_cache_downstream_route",
        "body": "{\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration, \"/geoffistheworst/\"))\r\n            .When(_ => WhenICreate())\r\n            .And(_ => GivenTheConfiguration(configuration, \"/geoffisthebest/\"))\r\n            .When(_ => WhenICreateAgain())\r\n            .Then(_ => ThenTheDownstreamRoutesAreTheNotSameReference())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_with_no_path",
        "body": "{\r\n        var upstreamUrlPath = \"/auth/\";\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration, upstreamUrlPath))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDownstreamPathIsForwardSlash())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_with_only_first_segment_no_traling_slash",
        "body": "{\r\n        var upstreamUrlPath = \"/auth\";\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration, upstreamUrlPath))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheDownstreamPathIsForwardSlash())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_with_segments_no_traling_slash",
        "body": "{\r\n        var upstreamUrlPath = \"/auth/test\";\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrHigher);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration, upstreamUrlPath))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenThePathDoesNotHaveTrailingSlash())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_and_remove_query_string",
        "body": "{\r\n        var upstreamUrlPath = \"/auth/test?test=1&best=2\";\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration, upstreamUrlPath))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheQueryStringIsRemoved())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_for_sticky_sessions",
        "body": "{\r\n        var loadBalancerOptions = new LoadBalancerOptionsBuilder().WithType(nameof(CookieStickySessions)).WithKey(\"boom\").WithExpiryInMs(1).Build();\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheStickySessionLoadBalancerIsUsed(loadBalancerOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_with_qos",
        "body": "{\r\n        var qoSOptions = new QoSOptionsBuilder()\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .WithTimeoutValue(1)\r\n            .Build();\r\n\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration))\r\n            .And(_ => GivenTheQosCreatorReturns(qoSOptions))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheQosOptionsAreSet(qoSOptions))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_create_downstream_route_with_handler_options",
        "body": "{\r\n        var configuration = new InternalConfiguration(\r\n            null,\r\n            \"doesnt matter\",\r\n            null,\r\n            \"doesnt matter\",\r\n            _loadBalancerOptions,\r\n            \"http\",\r\n            _qoSOptions,\r\n            _handlerOptions,\r\n            new Version(\"1.1\"),\r\n            HttpVersionPolicy.RequestVersionOrLower);\r\n\r\n        this.Given(_ => GivenTheConfiguration(configuration))\r\n            .When(_ => WhenICreate())\r\n            .Then(_ => ThenTheHandlerOptionsAreSet())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRouteFinderMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_scoped_data_repository_correctly",
        "body": "{\n        var config = new InternalConfiguration(\n            null,\n            null,\n            new ServiceProviderConfigurationBuilder().Build(),\n            string.Empty,\n            new LoadBalancerOptionsBuilder().Build(),\n            string.Empty,\n            new QoSOptionsBuilder().Build(),\n            new HttpHandlerOptionsBuilder().Build(),\n            new Version(\"1.1\"),\n            HttpVersionPolicy.RequestVersionOrLower);\n\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"any old string\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenTheDownStreamRouteFinderReturns(\n            new DownstreamRouteHolder(\n                new List<PlaceholderNameAndValue>(),\n                new RouteBuilder()\n                    .WithDownstreamRoute(downstreamRoute)\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())))\n            .And(x => GivenTheFollowingConfig(config))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheScopedDataRepositoryIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRouteProviderFactoryTests.cs",
    "methods": [
      {
        "name": "should_return_downstream_route_finder",
        "body": "{\r\n        var routes = new List<Route>\r\n        {\r\n            new RouteBuilder().Build(),\r\n        };\r\n\r\n        this.Given(_ => GivenTheRoutes(routes))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteFinder>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_finder_when_not_dynamic_re_route_and_service_discovery_on",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(\"http\").WithHost(\"test\").WithPort(50).WithType(\"test\").Build();\r\n        var routes = new List<Route>\r\n        {\r\n            new RouteBuilder().WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder().WithOriginalValue(\"woot\").Build()).Build(),\r\n        };\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteFinder>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_finder_as_no_service_discovery_given_no_scheme",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(string.Empty).WithHost(\"test\").WithPort(50).Build();\r\n        var routes = new List<Route>();\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteFinder>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_finder_as_no_service_discovery_given_no_host",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(\"http\").WithHost(string.Empty).WithPort(50).Build();\r\n        var routes = new List<Route>();\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteFinder>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_finder_given_no_service_discovery_port",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(\"http\").WithHost(\"localhost\").WithPort(0).Build();\r\n        var routes = new List<Route>();\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteFinder>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_finder_given_no_service_discovery_type",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(\"http\").WithHost(\"localhost\").WithPort(50).WithType(string.Empty).Build();\r\n        var routes = new List<Route>();\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteFinder>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_creator",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(\"http\").WithHost(\"test\").WithPort(50).WithType(\"test\").Build();\r\n        var routes = new List<Route>();\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteCreator>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_downstream_route_creator_with_dynamic_re_route",
        "body": "{\r\n        var spConfig = new ServiceProviderConfigurationBuilder().WithScheme(\"http\").WithHost(\"test\").WithPort(50).WithType(\"test\").Build();\r\n        var routes = new List<Route>\r\n        {\r\n            new RouteBuilder().Build(),\r\n        };\r\n\r\n        this.Given(_ => GivenTheRoutes(routes, spConfig))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheResultShouldBe<DownstreamRouteCreator>())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HeaderPlaceholderNameAndValueFinderTests.cs",
    "methods": [
      {
        "name": "Should_return_no_placeholders",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>();\n        var upstreamHeaders = new Dictionary<string, string>();\n        var expected = new List<PlaceholderNameAndValue>();\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      },
      {
        "name": "Should_return_one_placeholder_with_value_when_no_other_text",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>\n        {\n            [\"country\"] = new(\"^(?i)(?<countrycode>.+)$\", \"{header:countrycode}\"),\n        };\n        var upstreamHeaders = new Dictionary<string, string>\n        {\n            [\"country\"] = \"PL\",\n        };\n        var expected = new List<PlaceholderNameAndValue>\n        {\n            new(\"{countrycode}\", \"PL\"),\n        };\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      },
      {
        "name": "Should_return_one_placeholder_with_value_when_other_text_on_the_right",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>\n        {\n            [\"country\"] = new(\"^(?<countrycode>.+)-V1$\", \"{header:countrycode}-V1\"),\n        };\n        var upstreamHeaders = new Dictionary<string, string>\n        {\n            [\"country\"] = \"PL-V1\",\n        };\n        var expected = new List<PlaceholderNameAndValue>\n        {\n            new(\"{countrycode}\", \"PL\"),\n        };\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      },
      {
        "name": "Should_return_one_placeholder_with_value_when_other_text_on_the_left",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>\n        {\n            [\"country\"] = new(\"^V1-(?<countrycode>.+)$\", \"V1-{header:countrycode}\"),\n        };\n        var upstreamHeaders = new Dictionary<string, string>\n        {\n            [\"country\"] = \"V1-PL\",\n        };\n        var expected = new List<PlaceholderNameAndValue>\n        {\n            new(\"{countrycode}\", \"PL\"),\n        };\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      },
      {
        "name": "Should_return_one_placeholder_with_value_when_other_texts_surrounding",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>\n        {\n            [\"country\"] = new(\"^cc:(?<countrycode>.+)-V1$\", \"cc:{header:countrycode}-V1\"),\n        };\n        var upstreamHeaders = new Dictionary<string, string>\n        {\n            [\"country\"] = \"cc:PL-V1\",\n        };\n        var expected = new List<PlaceholderNameAndValue>\n        {\n            new(\"{countrycode}\", \"PL\"),\n        };\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      },
      {
        "name": "Should_return_two_placeholders_with_text_between",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>\n        {\n            [\"countryAndVersion\"] = new(\"^(?i)(?<countrycode>.+)-(?<version>.+)$\", \"{header:countrycode}-{header:version}\"),\n        };\n        var upstreamHeaders = new Dictionary<string, string>\n        {\n            [\"countryAndVersion\"] = \"PL-v1\",\n        };\n        var expected = new List<PlaceholderNameAndValue>\n        {\n            new(\"{countrycode}\", \"PL\"),\n            new(\"{version}\", \"v1\"),\n        };\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      },
      {
        "name": "Should_return_placeholders_from_different_headers",
        "body": "{\n        // Arrange\n        var upstreamHeaderTemplates = new Dictionary<string, UpstreamHeaderTemplate>\n        {\n            [\"country\"] = new(\"^(?i)(?<countrycode>.+)$\", \"{header:countrycode}\"),\n            [\"version\"] = new(\"^(?i)(?<version>.+)$\", \"{header:version}\"),\n        };\n        var upstreamHeaders = new Dictionary<string, string>\n        {\n            [\"country\"] = \"PL\",\n            [\"version\"] = \"v1\",\n        };\n        var expected = new List<PlaceholderNameAndValue>\n        {\n            new(\"{countrycode}\", \"PL\"),\n            new(\"{version}\", \"v1\"),\n        };\n        GivenUpstreamHeaderTemplatesAre(upstreamHeaderTemplates);\n        GivenUpstreamHeadersAre(upstreamHeaders);\n\n        // Act\n        WhenICallFindPlaceholders();\n\n        // Assert\n        TheResultIs(expected);\n    }"
      }
    ]
  },
  {
    "file": "HeadersToHeaderTemplatesMatcherTests.cs",
    "methods": [
      {
        "name": "Should_match_when_no_template_headers",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"anyHeaderValue\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>();\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsTrue();\n    }"
      },
      {
        "name": "Should_match_the_same_headers",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"anyHeaderValue\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsTrue();\n    }"
      },
      {
        "name": "Should_not_match_the_same_headers_when_differ_case_and_case_sensitive",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"ANYHEADERVALUE\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsFalse();\n    }"
      },
      {
        "name": "Should_match_the_same_headers_when_differ_case_and_case_insensitive",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"ANYHEADERVALUE\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsTrue();\n    }"
      },
      {
        "name": "Should_not_match_different_headers_values",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"anyHeaderValueDifferent\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsFalse();\n    }"
      },
      {
        "name": "Should_not_match_the_same_headers_names",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeaderDifferent\"] = \"anyHeaderValue\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsFalse();\n    }"
      },
      {
        "name": "Should_match_all_the_same_headers",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"anyHeaderValue\",\n            [\"notNeededHeader\"] = \"notNeededHeaderValue\",\n            [\"secondHeader\"] = \"secondHeaderValue\",\n            [\"thirdHeader\"] = \"thirdHeaderValue\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"secondHeader\"] = new(\"^(?i)secondHeaderValue$\", \"secondHeaderValue\"),\n            [\"thirdHeader\"] = new(\"^(?i)thirdHeaderValue$\", \"thirdHeaderValue\"),\n            [\"anyHeader\"] = new(\"^(?i)anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsTrue();\n    }"
      },
      {
        "name": "Should_not_match_the_headers_when_one_of_them_different",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"anyHeaderValue\",\n            [\"notNeededHeader\"] = \"notNeededHeaderValue\",\n            [\"secondHeader\"] = \"secondHeaderValueDIFFERENT\",\n            [\"thirdHeader\"] = \"thirdHeaderValue\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"secondHeader\"] = new(\"^(?i)secondHeaderValue$\", \"secondHeaderValue\"),\n            [\"thirdHeader\"] = new(\"^(?i)thirdHeaderValue$\", \"thirdHeaderValue\"),\n            [\"anyHeader\"] = new(\"^(?i)anyHeaderValue$\", \"anyHeaderValue\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsFalse();\n    }"
      },
      {
        "name": "Should_match_the_header_with_placeholder",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"PL\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)(?<countrycode>.+)$\", \"{header:countrycode}\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsTrue();\n    }"
      },
      {
        "name": "Should_match_the_header_with_placeholders",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"PL-V1\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)(?<countrycode>.+)-(?<version>.+)$\", \"{header:countrycode}-{header:version}\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsTrue();\n    }"
      },
      {
        "name": "Should_not_match_the_header_with_placeholders",
        "body": "{\n        // Arrange\n        var upstreamHeaders = new Dictionary<string, string>()\n        {\n            [\"anyHeader\"] = \"PL\",\n        };\n        var templateHeaders = new Dictionary<string, UpstreamHeaderTemplate>()\n        {\n            [\"anyHeader\"] = new(\"^(?i)(?<countrycode>.+)-(?<version>.+)$\", \"{header:countrycode}-{header:version}\"),\n        };\n        GivenIHaveUpstreamHeaders(upstreamHeaders);\n        GivenIHaveTemplateHeadersInRoute(templateHeaders);\n\n        // Act\n        WhenIMatchTheHeaders();\n\n        // Assert\n        ThenTheResultIsFalse();\n    }"
      }
    ]
  },
  {
    "file": "RegExUrlMatcherTests.cs",
    "methods": [
      {
        "name": "should_not_match",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/v1/aaaaaaaaa/cards\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^(?i)/api/v[^/]+/cards$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .And(x => x.ThenTheResultIsFalse())\n          .BDDfy();\n    }"
      },
      {
        "name": "should_match",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/v1/cards\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^(?i)/api/v[^/]+/cards$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .And(x => x.ThenTheResultIsTrue())\n          .BDDfy();\n    }"
      },
      {
        "name": "should_match_path_with_no_query_string",
        "body": "{\n        const string regExForwardSlashAndOnePlaceHolder = \"^(?i)/newThing$\";\n\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/newThing\"))\n            .And(_ => GivenIHaveAQueryString(\"?DeviceType=IphoneApp&Browser=moonpigIphone&BrowserString=-&CountryCode=123&DeviceName=iPhone 5 (GSM+CDMA)&OperatingSystem=iPhone OS 7.1.2&BrowserVersion=3708AdHoc&ipAddress=-\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(regExForwardSlashAndOnePlaceHolder))\n            .When(x => x.WhenIMatchThePaths())\n            .And(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_match_query_string",
        "body": "{\n        const string regExForwardSlashAndOnePlaceHolder = \"^(?i)/api/subscriptions/[^/]+/updates\\\\?unitId=.+$\";\n\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/subscriptions/1/updates\"))\n            .And(_ => GivenIHaveAQueryString(\"?unitId=2\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(regExForwardSlashAndOnePlaceHolder))\n            .And(_ => GivenThereIsAQueryInTemplate())\n            .When(x => x.WhenIMatchThePaths())\n            .And(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_match_query_string_with_multiple_params",
        "body": "{\n        const string regExForwardSlashAndOnePlaceHolder = \"^(?i)/api/subscriptions/[^/]+/updates\\\\?unitId=.+&productId=.+$\";\n\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/subscriptions/1/updates?unitId=2\"))\n            .And(_ => GivenIHaveAQueryString(\"?unitId=2&productId=2\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(regExForwardSlashAndOnePlaceHolder))\n            .And(_ => GivenThereIsAQueryInTemplate())\n            .When(x => x.WhenIMatchThePaths())\n            .And(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_match_slash_becaue_we_need_to_match_something_after_it",
        "body": "{\n        const string regExForwardSlashAndOnePlaceHolder = \"^/[0-9a-zA-Z].+\";\n\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(regExForwardSlashAndOnePlaceHolder))\n          .When(x => x.WhenIMatchThePaths())\n          .And(x => x.ThenTheResultIsFalse())\n          .BDDfy();\n    }"
      },
      {
        "name": "should_not_match_forward_slash_only_regex",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/working/\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^/$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .And(x => x.ThenTheResultIsFalse())\n          .BDDfy();\n    }"
      },
      {
        "name": "should_not_match_issue_134",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/vacancy/1/\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^(?i)/vacancy/[^/]+/$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .And(x => x.ThenTheResultIsFalse())\n          .BDDfy();\n    }"
      },
      {
        "name": "should_match_forward_slash_only_regex",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^/$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .And(x => x.ThenTheResultIsTrue())\n          .BDDfy();\n    }"
      },
      {
        "name": "should_find_match_when_template_smaller_than_valid_path",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/products/2354325435624623464235\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^/api/products/.+$\"))\n            .When(x => x.WhenIMatchThePaths())\n            .And(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_find_match",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"/api/values\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^/$\"))\n            .When(x => x.WhenIMatchThePaths())\n            .And(x => x.ThenTheResultIsFalse())\n            .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(string.Empty))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^$\"))\n            .When(x => x.WhenIMatchThePaths())\n            .And(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_no_slash",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api\"))\n             .Given(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api$\"))\n             .When(x => x.WhenIMatchThePaths())\n             .Then(x => x.ThenTheResultIsTrue())\n             .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_one_slash",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/\"))\n             .Given(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/$\"))\n             .When(x => x.WhenIMatchThePaths())\n             .Then(x => x.ThenTheResultIsTrue())\n             .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_downstream_template",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/product/products/\"))\n          .Given(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .Then(x => x.ThenTheResultIsTrue())\n          .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_downstream_template_with_one_place_holder",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/product/products/1\"))\n           .Given(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/.+$\"))\n           .When(x => x.WhenIMatchThePaths())\n           .Then(x => x.ThenTheResultIsTrue())\n           .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_downstream_template_with_two_place_holders",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/product/products/1/2\"))\n             .Given(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/[^/]+/.+$\"))\n             .When(x => x.WhenIMatchThePaths())\n             .Then(x => x.ThenTheResultIsTrue())\n             .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_downstream_template_with_two_place_holders_seperated_by_something",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/product/products/1/categories/2\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/[^/]+/categories/.+$\"))\n            .When(x => x.WhenIMatchThePaths())\n            .Then(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_downstream_template_with_three_place_holders_seperated_by_something",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/product/products/1/categories/2/variant/123\"))\n            .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/[^/]+/categories/[^/]+/variant/.+$\"))\n            .When(x => x.WhenIMatchThePaths())\n            .Then(x => x.ThenTheResultIsTrue())\n            .BDDfy();\n    }"
      },
      {
        "name": "can_match_down_stream_url_with_downstream_template_with_three_place_holders",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"api/product/products/1/categories/2/variant/\"))\n             .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/[^/]+/categories/[^/]+/variant/$\"))\n             .When(x => x.WhenIMatchThePaths())\n             .Then(x => x.ThenTheResultIsTrue())\n             .BDDfy();\n    }"
      },
      {
        "name": "should_ignore_case_sensitivity",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"API/product/products/1/categories/2/variant/\"))\n           .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^(?i)api/product/products/[^/]+/categories/[^/]+/variant/$\"))\n           .When(x => x.WhenIMatchThePaths())\n           .Then(x => x.ThenTheResultIsTrue())\n           .BDDfy();\n    }"
      },
      {
        "name": "should_respect_case_sensitivity",
        "body": "{\n        this.Given(x => x.GivenIHaveAUpstreamPath(\"API/product/products/1/categories/2/variant/\"))\n          .And(x => x.GivenIHaveAnUpstreamUrlTemplatePattern(\"^api/product/products/[^/]+/categories/[^/]+/variant/$\"))\n          .When(x => x.WhenIMatchThePaths())\n          .Then(x => x.ThenTheResultIsFalse())\n          .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "UrlPathPlaceholderNameAndValueFinderTests.cs",
    "methods": [
      {
        "name": "Can_match_down_stream_url",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(Empty, Empty, Empty);\n\n        // Assert\n        ThenTheTemplatesVariablesAre();\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_nothing_then_placeholder_no_value_is_blank",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(Empty, Empty, \"/{url}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{url}\", Empty);\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_nothing_then_placeholder_value_is_test",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/test\", Empty, \"/{url}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{url}\", \"test\");\n    }"
      },
      {
        "name": "Should_match_everything_in_path_with_query",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/test/toot\", \"?$filter=Name%20eq%20'Sam'\", \"/{everything}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{everything}\", \"test/toot\");\n    }"
      },
      {
        "name": "Should_match_everything_in_path",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/test/toot\", Empty, \"/{everything}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{everything}\", \"test/toot\");\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_forward_slash_then_placeholder_no_value_is_blank",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/\", Empty, \"/{url}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{url}\", Empty);\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_forward_slash",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/\", Empty, \"/\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre();\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_forward_slash_then_placeholder_then_another_value",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/1/products\", Empty, \"/{url}/products\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{url}\", \"1\");\n    }"
      },
      {
        "name": "Should_not_find_anything",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/products\", Empty, \"/products/\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre();\n    }"
      },
      {
        "name": "Should_find_query_string",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/products\", \"?productId=1\", \"/products?productId={productId}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{productId}\", \"1\");\n    }"
      },
      {
        "name": "Should_find_query_string_dont_include_hardcoded",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/products\", \"?productId=1&categoryId=2\", \"/products?productId={productId}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{productId}\", \"1\");\n    }"
      },
      {
        "name": "Should_find_multiple_query_string",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/products\", \"?productId=1&categoryId=2\", \"/products?productId={productId}&categoryId={categoryId}\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"));\n    }"
      },
      {
        "name": "Should_find_multiple_query_string_and_path",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/products/3\", \"?productId=1&categoryId=2\", \"/products/{account}?productId={productId}&categoryId={categoryId}\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"),\n            new(\"{account}\", \"3\"));\n    }"
      },
      {
        "name": "Should_find_multiple_query_string_and_path_that_ends_with_slash",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/products/3/\", \"?productId=1&categoryId=2\", \"/products/{account}/?productId={productId}&categoryId={categoryId}\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"),\n            new(\"{account}\", \"3\"));\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_no_slash",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api\", Empty, \"api\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre();\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_one_slash",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/\", Empty, \"api/\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre();\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_downstream_template",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/product/products/\", Empty, \"api/product/products/\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre();\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_downstream_template_with_one_place_holder",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/product/products/1\", Empty, \"api/product/products/{productId}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{productId}\", \"1\");\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_downstream_template_with_two_place_holders",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/product/products/1/2\", Empty, \"api/product/products/{productId}/{categoryId}\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"));\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_downstream_template_with_two_place_holders_seperated_by_something",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/product/products/1/categories/2\", Empty, \"api/product/products/{productId}/categories/{categoryId}\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"));\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_downstream_template_with_three_place_holders_seperated_by_something",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/product/products/1/categories/2/variant/123\", Empty, \"api/product/products/{productId}/categories/{categoryId}/variant/{variantId}\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"),\n            new(\"{variantId}\", \"123\"));\n    }"
      },
      {
        "name": "Can_match_down_stream_url_with_downstream_template_with_three_place_holders",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"api/product/products/1/categories/2/variant/\", Empty, \"api/product/products/{productId}/categories/{categoryId}/variant/\");\n\n        // Assert\n        ThenTheTemplatesVariablesAre(\n            new(\"{productId}\", \"1\"),\n            new(\"{categoryId}\", \"2\"));\n    }"
      },
      {
        "name": "Check_for_placeholder_at_end_of_template",
        "body": "{\n        // Arrange, Act\n        _result = _finder.Find(\"/upstream/test/\", Empty, \"/upstream/test/{testId}\");\n\n        // Assert\n        ThenSinglePlaceholderIs(\"{testId}\", Empty);\n    }"
      }
    ]
  },
  {
    "file": "DownstreamPathPlaceholderReplacerTests.cs",
    "methods": [
      {
        "name": "can_replace_no_template_variables",
        "body": "{\n        this.Given(x => x.GivenThereIsAUrlMatch(\n            new DownstreamRouteHolder(\n                new List<PlaceholderNameAndValue>(),\n                new RouteBuilder()\n                    .WithDownstreamRoute(new DownstreamRouteBuilder()\n                        .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                        .Build())\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())))\n            .When(x => x.WhenIReplaceTheTemplateVariables())\n            .Then(x => x.ThenTheDownstreamUrlPathIsReturned(string.Empty))\n            .BDDfy();\n    }"
      },
      {
        "name": "can_replace_no_template_variables_with_slash",
        "body": "{\n        this.Given(x => x.GivenThereIsAUrlMatch(\n            new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"/\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n            .When(x => x.WhenIReplaceTheTemplateVariables())\n            .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_no_slash",
        "body": "{\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"api\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n            .When(x => x.WhenIReplaceTheTemplateVariables())\n            .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"api\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_one_slash",
        "body": "{\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"api/\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n            .When(x => x.WhenIReplaceTheTemplateVariables())\n            .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"api/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_multiple_slash",
        "body": "{\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"api/product/products/\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n            .When(x => x.WhenIReplaceTheTemplateVariables())\n            .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"api/product/products/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_one_template_variable",
        "body": "{\n        var templateVariables = new List<PlaceholderNameAndValue>\n        {\n            new(\"{productId}\", \"1\"),\n        };\n\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(templateVariables,\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"productservice/products/{productId}/\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n         .When(x => x.WhenIReplaceTheTemplateVariables())\n         .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"productservice/products/1/\"))\n         .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_one_template_variable_with_path_after",
        "body": "{\n        var templateVariables = new List<PlaceholderNameAndValue>\n        {\n            new(\"{productId}\", \"1\"),\n        };\n\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(templateVariables,\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"productservice/products/{productId}/variants\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n         .When(x => x.WhenIReplaceTheTemplateVariables())\n         .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"productservice/products/1/variants\"))\n         .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_two_template_variable",
        "body": "{\n        var templateVariables = new List<PlaceholderNameAndValue>\n        {\n            new(\"{productId}\", \"1\"),\n            new(\"{variantId}\", \"12\"),\n        };\n\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(templateVariables,\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"productservice/products/{productId}/variants/{variantId}\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build())))\n         .When(x => x.WhenIReplaceTheTemplateVariables())\n         .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"productservice/products/1/variants/12\"))\n         .BDDfy();\n    }"
      },
      {
        "name": "can_replace_url_three_template_variable",
        "body": "{\n        var templateVariables = new List<PlaceholderNameAndValue>\n        {\n            new(\"{productId}\", \"1\"),\n            new(\"{variantId}\", \"12\"),\n            new(\"{categoryId}\", \"34\"),\n        };\n\n        this.Given(x => x.GivenThereIsAUrlMatch(new DownstreamRouteHolder(templateVariables,\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"productservice/category/{categoryId}/products/{productId}/variants/{variantId}\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build())))\n         .When(x => x.WhenIReplaceTheTemplateVariables())\n         .Then(x => x.ThenTheDownstreamUrlPathIsReturned(\"productservice/category/34/products/1/variants/12\"))\n         .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DownstreamUrlCreatorMiddlewareTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"any old string\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .WithDownstreamScheme(\"https\")\n            .Build();\n        var config = new ServiceProviderConfigurationBuilder()\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://my.url/abc?q=123\");\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheUrlReplacerWillReturn(\"/api/products/1\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://my.url:80/api/products/1?q=123\");\n        ThenTheQueryStringIs(\"?q=123\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"/api/units/{subscriptionId}/{unitId}/updates\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .WithDownstreamScheme(\"https\")\n            .Build();\n        var config = new ServiceProviderConfigurationBuilder()\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{subscriptionId}\", \"1\"),\n                new(\"{unitId}\", \"2\"),\n            },\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://localhost:5000/api/subscriptions/1/updates?unitId=2\");\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheUrlReplacerWillReturn(\"api/units/1/2/updates\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://localhost:5000/api/units/1/2/updates\");\n        ThenTheQueryStringIs(string.Empty);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"/api/units/{subscriptionId}/{unitId}/updates\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .WithDownstreamScheme(\"https\")\n            .Build();\n        var config = new ServiceProviderConfigurationBuilder()\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{subscriptionId}\", \"1\"),\n                new(\"{unitId}\", \"2\"),\n            },\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://localhost:5000/api/subscriptions/1/updates?unitId=2&productId=2\"); // unitId is the first\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheUrlReplacerWillReturn(\"api/units/1/2/updates\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://localhost:5000/api/units/1/2/updates?productId=2\");\n        ThenTheQueryStringIs(\"?productId=2\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"/api/units/{subscriptionId}/{unitId}/updates\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .WithDownstreamScheme(\"https\")\n            .Build();\n        var config = new ServiceProviderConfigurationBuilder()\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{subscriptionId}\", \"1\"),\n                new(\"{unitId}\", \"2\"),\n            },\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://localhost:5000/api/subscriptions/1/updates?productId=2&unitId=2\"); // unitId is the second\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheUrlReplacerWillReturn(\"api/units/1/2/updates\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://localhost:5000/api/units/1/2/updates?productId=2\");\n        ThenTheQueryStringIs(\"?productId=2\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"/api/units/{subscriptionId}/{unitId}/updates/{unitIdIty}\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .WithDownstreamScheme(\"https\")\n            .Build();\n        var config = new ServiceProviderConfigurationBuilder()\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{subscriptionId}\", \"1\"),\n                new(\"{unitId}\", \"2\"),\n                new(\"{unitIdIty}\", \"3\"),\n            },\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://localhost:5000/api/subscriptions/1/updates?unitId=2?unitIdIty=3\");\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheUrlReplacerWillReturn(\"api/units/1/2/updates/3\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://localhost:5000/api/units/1/2/updates/3\");\n        ThenTheQueryStringIs(string.Empty);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamPathTemplate(\"any old string\")\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .WithDownstreamScheme(\"https\")\n            .Build();\n        var config = new ServiceProviderConfigurationBuilder()\n            .WithType(\"ServiceFabric\")\n            .WithHost(\"localhost\")\n            .WithPort(19081)\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://my.url/abc?q=123\");\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheUrlReplacerWillReturn(\"/api/products/1\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://my.url:80/api/products/1?q=123\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamScheme(\"http\")\n            .WithServiceName(\"Ocelot/OcelotApp\")\n            .WithUseServiceDiscovery(true)\n            .Build();\n        var downstreamRouteHolder = new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute).Build());\n        var config = new ServiceProviderConfigurationBuilder()\n            .WithType(\"ServiceFabric\")\n            .WithHost(\"localhost\")\n            .WithPort(19081)\n            .Build();\n        GivenTheDownStreamRouteIs(downstreamRouteHolder);\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheDownstreamRequestUriIs(\"http://localhost:19081\");\n        GivenTheUrlReplacerWillReturnSequence(\"/api/products/1\", \"Ocelot/OcelotApp\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"http://localhost:19081/Ocelot/OcelotApp/api/products/1\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamScheme(\"http\")\n            .WithServiceName(\"Ocelot/OcelotApp\")\n            .WithUseServiceDiscovery(true)\n            .Build();\n        var downstreamRouteHolder = new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute).Build());\n        var config = new ServiceProviderConfigurationBuilder()\n            .WithType(\"ServiceFabric\")\n            .WithHost(\"localhost\")\n            .WithPort(19081)\n            .Build();\n        GivenTheDownStreamRouteIs(downstreamRouteHolder);\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheDownstreamRequestUriIs(\"http://localhost:19081?Tom=test&laura=1\");\n        GivenTheUrlReplacerWillReturnSequence(\"/api/products/1\", \"Ocelot/OcelotApp\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"http://localhost:19081/Ocelot/OcelotApp/api/products/1?Tom=test&laura=1\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamScheme(\"http\")\n            .WithServiceName(\"Ocelot/OcelotApp\")\n            .WithUseServiceDiscovery(true)\n            .Build();\n        var downstreamRouteHolder = new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute).Build());\n        var config = new ServiceProviderConfigurationBuilder()\n            .WithType(\"ServiceFabric\")\n            .WithHost(\"localhost\")\n            .WithPort(19081)\n            .Build();\n        GivenTheDownStreamRouteIs(downstreamRouteHolder);\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheDownstreamRequestUriIs(\"http://localhost:19081?PartitionKind=test&PartitionKey=1\");\n        GivenTheUrlReplacerWillReturnSequence(\"/api/products/1\", \"Ocelot/OcelotApp\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"http://localhost:19081/Ocelot/OcelotApp/api/products/1?PartitionKind=test&PartitionKey=1\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var route = new DownstreamRouteBuilder()\n            .WithDownstreamScheme(\"http\")\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder().WithOriginalValue(\"/products\").Build())\n            .WithUseServiceDiscovery(true)\n            .Build();\n        var routeHolder = new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder().WithDownstreamRoute(route).Build());\n        var config = new ServiceProviderConfigurationBuilder()\n            .WithType(\"ServiceFabric\")\n            .WithHost(\"localhost\")\n            .WithPort(19081)\n            .Build();\n        GivenTheDownStreamRouteIs(routeHolder);\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheDownstreamRequestUriIs(\"http://localhost:19081?PartitionKind=test&PartitionKey=1\");\n        GivenTheUrlReplacerWillReturnSequence(\"/products\", \"Service_1.0/Api\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"http://localhost:19081/Service_1.0/Api/products?PartitionKind=test&PartitionKey=1\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var methods = new List<string> { \"Post\", \"Get\" };\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder()\n                .WithOriginalValue(\"/uc/Authorized/{servak}/{action}\").Build())\n            .WithDownstreamPathTemplate(\"/Authorized/{action}?server={servak}\")\n            .WithUpstreamHttpMethod(methods)\n            .WithDownstreamScheme(Uri.UriSchemeHttp)\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{action}\", \"1\"),\n                new(\"{servak}\", \"2\"),\n            },\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(methods)\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs(\"http://localhost:5000/uc/Authorized/2/1/refresh?refreshToken=123456789\");\n        GivenTheServiceProviderConfigIs(new ServiceProviderConfigurationBuilder().Build());\n        GivenTheUrlReplacerWillReturn(\"/Authorized/1?server=2\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"http://localhost:5000/Authorized/1?server=2&refreshToken=123456789\");\n        ThenTheQueryStringIs(\"?server=2&refreshToken=123456789\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithDownstreamScheme(string.Empty)\n            .WithServiceName(\"Ocelot/OcelotApp\")\n            .WithUseServiceDiscovery(true)\n            .Build();\n        var downstreamRouteHolder = new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(downstreamRoute)\n                .Build());\n        var config = new ServiceProviderConfigurationBuilder()\n            .WithType(\"ServiceFabric\")\n            .WithHost(\"localhost\")\n            .WithPort(19081)\n            .Build();\n        GivenTheDownStreamRouteIs(downstreamRouteHolder);\n        GivenTheServiceProviderConfigIs(config);\n        GivenTheDownstreamRequestUriIs(\"https://localhost:19081?PartitionKind=test&PartitionKey=1\");\n        GivenTheUrlReplacerWillReturnSequence(\"/api/products/1\", \"Ocelot/OcelotApp\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs(\"https://localhost:19081/Ocelot/OcelotApp/api/products/1?PartitionKind=test&PartitionKey=1\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var methods = new List<string> { \"Post\", \"Get\" };\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder()\n                .WithOriginalValue(\"/users?userId={userId}\").Build())\n            .WithDownstreamPathTemplate(\"/persons?personId={userId}\")\n            .WithUpstreamHttpMethod(methods)\n            .WithDownstreamScheme(Uri.UriSchemeHttp)\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{userId}\", \"webley\"),\n            },\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(methods)\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs($\"http://localhost:5000/users?userId=webley\");\n        GivenTheServiceProviderConfigIs(new ServiceProviderConfigurationBuilder().Build());\n        GivenTheUrlReplacerWillReturn(\"/persons?personId=webley\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs($\"http://localhost:5000/persons?personId=webley\");\n        ThenTheQueryStringIs($\"?personId=webley\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var methods = new List<string> { \"Post\", \"Get\" };\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder()\n                .WithOriginalValue(\"/users?userId={uid}\").Build())\n            .WithDownstreamPathTemplate(\"/persons?personId={uid}\")\n            .WithUpstreamHttpMethod(methods)\n            .WithDownstreamScheme(Uri.UriSchemeHttp)\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{uid}\", \"webley\"),\n            },\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(methods)\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs($\"http://localhost:5000/users?userId=webley\");\n        GivenTheServiceProviderConfigIs(new ServiceProviderConfigurationBuilder().Build());\n        GivenTheUrlReplacerWillReturn(\"/persons?personId=webley\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs($\"http://localhost:5000/persons?personId=webley&userId=webley\");\n        ThenTheQueryStringIs($\"?personId=webley&userId=webley\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        const string username = \"bbenameur\";\n        const string groupName = \"Paris\";\n        const string roleid = \"123456\";\n        const string everything = \"something=9874565\";\n        var withGetMethod = new List<string> { \"Get\" };\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder()\n                .WithOriginalValue(\"/WeatherForecast/{roleid}/groups?username={username}&groupName={groupName}&{everything}\")\n                .Build())\n            .WithDownstreamPathTemplate(\"/account/{username}/groups/{groupName}/roles?roleId={roleid}&{everything}\")\n            .WithUpstreamHttpMethod(withGetMethod)\n            .WithDownstreamScheme(Uri.UriSchemeHttp)\n            .Build();\n        GivenTheDownStreamRouteIs(new DownstreamRouteHolder(\n            new List<PlaceholderNameAndValue>\n            {\n                new(\"{username}\", username),\n                new(\"{groupName}\", groupName),\n                new(\"{roleid}\", roleid),\n                new(\"{everything}\", everything),\n            },\n            new RouteBuilder().WithDownstreamRoute(downstreamRoute)\n                .WithUpstreamHttpMethod(withGetMethod)\n                .Build()\n        ));\n        GivenTheDownstreamRequestUriIs($\"http://localhost:5000/WeatherForecast/{roleid}/groups?username={username}&groupName={groupName}&{everything}\");\n        GivenTheServiceProviderConfigIs(new ServiceProviderConfigurationBuilder().Build());\n        GivenTheUrlReplacerWillReturn($\"/account/{username}/groups/{groupName}/roles?roleId={roleid}&{everything}\");\n\n        // Act\n        await WhenICallTheMiddleware();\n\n        // Assert\n        ThenTheDownstreamRequestUriIs($\"http://localhost:5000/account/{username}/groups/{groupName}/roles?roleId={roleid}&{everything}\");\n        ThenTheQueryStringIs($\"?roleId={roleid}&{everything}\");\n    }"
      }
    ]
  },
  {
    "file": "ErrorTests.cs",
    "methods": [
      {
        "name": "should_return_message",
        "body": "{\r\n        var error = new CannotAddDataError(\"message\");\r\n        var result = error.ToString();\r\n        result.ShouldBe(\"message\");\r\n    }"
      }
    ]
  },
  {
    "file": "ExceptionHandlerMiddlewareTests.cs",
    "methods": [
      {
        "name": "NoDownstreamException",
        "body": "{\n        var config = new InternalConfiguration(null, null, null, null, null, null, null, null, null, null);\n\n        this.Given(_ => GivenAnExceptionWillNotBeThrownDownstream())\n            .And(_ => GivenTheConfigurationIs(config))\n            .When(_ => WhenICallTheMiddleware())\n            .Then(_ => ThenTheResponseIsOk())\n            .And(_ => TheAspDotnetRequestIdIsSet())\n            .BDDfy();\n    }"
      },
      {
        "name": "DownstreamException",
        "body": "{\n        var config = new InternalConfiguration(null, null, null, null, null, null, null, null, null, null);\n\n        this.Given(_ => GivenAnExceptionWillBeThrownDownstream())\n            .And(_ => GivenTheConfigurationIs(config))\n            .When(_ => WhenICallTheMiddleware())\n            .Then(_ => ThenTheResponseIsError())\n            .BDDfy();\n    }"
      },
      {
        "name": "ShouldSetRequestId",
        "body": "{\n        var config = new InternalConfiguration(null, null, null, \"requestidkey\", null, null, null, null, null, null);\n\n        this.Given(_ => GivenAnExceptionWillNotBeThrownDownstream())\n            .And(_ => GivenTheConfigurationIs(config))\n            .When(_ => WhenICallTheMiddlewareWithTheRequestIdKey(\"requestidkey\", \"1234\"))\n            .Then(_ => ThenTheResponseIsOk())\n            .And(_ => TheRequestIdIsSet(\"RequestId\", \"1234\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "ShouldSetAspDotNetRequestId",
        "body": "{\n        var config = new InternalConfiguration(null, null, null, null, null, null, null, null, null, null);\n\n        this.Given(_ => GivenAnExceptionWillNotBeThrownDownstream())\n            .And(_ => GivenTheConfigurationIs(config))\n            .When(_ => WhenICallTheMiddlewareWithTheRequestIdKey(\"requestidkey\", \"1234\"))\n            .Then(_ => ThenTheResponseIsOk())\n            .And(_ => TheAspDotnetRequestIdIsSet())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_throw_exception_if_config_provider_throws",
        "body": "{\n        this.Given(_ => GivenAnExceptionWillNotBeThrownDownstream())\n           .And(_ => GivenTheConfigThrows())\n           .When(_ => WhenICallTheMiddlewareWithTheRequestIdKey(\"requestidkey\", \"1234\"))\n           .Then(_ => ThenAnExceptionIsThrown())\n           .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "EurekaMiddlewareConfigurationProviderTests.cs",
    "methods": [
      {
        "name": "ShouldNotBuild",
        "body": "{\n        var configRepo = new Mock<IInternalConfigurationRepository>();\n        configRepo.Setup(x => x.Get())\n            .Returns(new OkResponse<IInternalConfiguration>(new InternalConfiguration(null, null, null, null, null, null, null, null, null, null)));\n        var services = new ServiceCollection();\n        services.AddSingleton(configRepo.Object);\n        var sp = services.BuildServiceProvider(true);\n        var provider = EurekaMiddlewareConfigurationProvider.Get(new ApplicationBuilder(sp));\n        provider.Status.ShouldBe(TaskStatus.RanToCompletion);\n    }"
      },
      {
        "name": "ShouldBuild",
        "body": "{\n        var serviceProviderConfig = new ServiceProviderConfigurationBuilder().WithType(\"eureka\").Build();\n        var client = new Mock<IDiscoveryClient>();\n        var configRepo = new Mock<IInternalConfigurationRepository>();\n        configRepo.Setup(x => x.Get())\n            .Returns(new OkResponse<IInternalConfiguration>(new InternalConfiguration(null, null, serviceProviderConfig, null, null, null, null, null, null, null)));\n        var services = new ServiceCollection();\n        services.AddSingleton(configRepo.Object);\n        services.AddSingleton(client.Object);\n        var sp = services.BuildServiceProvider(true);\n        var provider = EurekaMiddlewareConfigurationProvider.Get(new ApplicationBuilder(sp));\n        provider.Status.ShouldBe(TaskStatus.RanToCompletion);\n    }"
      }
    ]
  },
  {
    "file": "EurekaProviderFactoryTests.cs",
    "methods": [
      {
        "name": "should_not_get",
        "body": "{\r\n        var config = new ServiceProviderConfigurationBuilder().Build();\r\n        var sp = new ServiceCollection().BuildServiceProvider(true);\r\n        Should.Throw<NullReferenceException>(() =>\n            EurekaProviderFactory.Get(sp, config, null));\r\n    }"
      },
      {
        "name": "should_get",
        "body": "{\r\n        var config = new ServiceProviderConfigurationBuilder().WithType(\"eureka\").Build();\r\n        var client = new Mock<IDiscoveryClient>();\r\n        var services = new ServiceCollection();\r\n        services.AddSingleton(client.Object);\r\n        var sp = services.BuildServiceProvider(true);\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithServiceName(string.Empty)\r\n            .Build();\r\n        var provider = EurekaProviderFactory.Get(sp, config, route);\r\n        provider.ShouldBeOfType<Provider.Eureka.Eureka>();\r\n    }"
      }
    ]
  },
  {
    "file": "EurekaServiceDiscoveryProviderTests.cs",
    "methods": [
      {
        "name": "should_return_empty_services",
        "body": "{\r\n        this.When(_ => WhenIGet())\r\n            .Then(_ => ThenTheCountIs(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_service_from_client",
        "body": "{\r\n        var instances = new List<IServiceInstance>\r\n        {\r\n            new EurekaService(_serviceId, \"somehost\", 801, false, new Uri(\"http://somehost:801\"), new Dictionary<string, string>()),\r\n        };\r\n\r\n        this.Given(_ => GivenThe(instances))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheCountIs(1))\r\n            .And(_ => ThenTheClientIsCalledCorrectly())\r\n            .And(_ => ThenTheServiceIsMapped())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_services_from_client",
        "body": "{\r\n        var instances = new List<IServiceInstance>\r\n        {\r\n            new EurekaService(_serviceId, \"somehost\", 801, false, new Uri(\"http://somehost:801\"), new Dictionary<string, string>()),\r\n            new EurekaService(_serviceId, \"somehost\", 801, false, new Uri(\"http://somehost:801\"), new Dictionary<string, string>()),\r\n        };\r\n\r\n        this.Given(_ => GivenThe(instances))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheCountIs(2))\r\n            .And(_ => ThenTheClientIsCalledCorrectly())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "OcelotBuilderExtensionsTests.cs",
    "methods": [
      {
        "name": "should_set_up_cache_manager",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => WhenISetUpCacheManager())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .And(x => OnlyOneVersionOfEachCacheIsRegistered())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "FileUnitTest.cs",
    "methods": []
  },
  {
    "file": "AddHeadersToRequestClaimToThingTests.cs",
    "methods": [
      {
        "name": "should_add_headers_to_downstreamRequest",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n\n        this.Given(\n            x => x.GivenConfigurationHeaderExtractorProperties(new List<ClaimToThing>\n            {\n                new(\"header-key\", string.Empty, string.Empty, 0),\n            }))\n            .Given(x => x.GivenClaims(claims))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIAddHeadersToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenTheHeaderIsAdded())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_existing_headers_on_request",
        "body": "{\n        this.Given(\n            x => x.GivenConfigurationHeaderExtractorProperties(new List<ClaimToThing>\n            {\n                new(\"header-key\", string.Empty, string.Empty, 0),\n            }))\n            .Given(x => x.GivenClaims(new List<Claim>\n            {\n                new(\"test\", \"data\"),\n            }))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .And(x => x.GivenThatTheRequestContainsHeader(\"header-key\", \"initial\"))\n            .When(x => x.WhenIAddHeadersToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenTheHeaderIsAdded())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error",
        "body": "{\n        this.Given(\n           x => x.GivenConfigurationHeaderExtractorProperties(new List<ClaimToThing>\n           {\n                new(string.Empty, string.Empty, string.Empty, 0),\n           }))\n           .Given(x => x.GivenClaims(new List<Claim>()))\n           .And(x => x.GivenTheClaimParserReturns(new ErrorResponse<string>(new List<Error>\n           {\n               new AnyError(),\n           })))\n           .When(x => x.WhenIAddHeadersToTheRequest())\n           .Then(x => x.ThenTheResultIsError())\n           .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "AddHeadersToRequestPlainTests.cs",
    "methods": [
      {
        "name": "should_log_error_if_cannot_find_placeholder",
        "body": "{\r\n        _placeholders.Setup(x => x.Get(It.IsAny<string>())).Returns(new ErrorResponse<string>(new AnyError()));\r\n\r\n        this.Given(_ => GivenHttpRequestWithoutHeaders())\r\n            .When(_ => WhenAddingHeader(\"X-Forwarded-For\", \"{RemoteIdAddress}\"))\r\n            .Then(_ => ThenAnErrorIsLogged(\"X-Forwarded-For\", \"{RemoteIdAddress}\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_add_placeholder_to_downstream_request",
        "body": "{\r\n        _placeholders.Setup(x => x.Get(It.IsAny<string>())).Returns(new OkResponse<string>(\"replaced\"));\r\n\r\n        this.Given(_ => GivenHttpRequestWithoutHeaders())\r\n            .When(_ => WhenAddingHeader(\"X-Forwarded-For\", \"{RemoteIdAddress}\"))\r\n            .Then(_ => ThenTheHeaderGetsTakenOverToTheRequestHeaders(\"replaced\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_add_plain_text_header_to_downstream_request",
        "body": "{\r\n        this.Given(_ => GivenHttpRequestWithoutHeaders())\r\n            .When(_ => WhenAddingHeader(\"X-Custom-Header\", \"PlainValue\"))\r\n            .Then(_ => ThenTheHeaderGetsTakenOverToTheRequestHeaders())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_overwrite_existing_header_with_added_header",
        "body": "{\r\n        this.Given(_ => GivenHttpRequestWithHeader(\"X-Custom-Header\", \"This should get overwritten\"))\r\n            .When(_ => WhenAddingHeader(\"X-Custom-Header\", \"PlainValue\"))\r\n            .Then(_ => ThenTheHeaderGetsTakenOverToTheRequestHeaders())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "AddHeadersToResponseTests.cs",
    "methods": [
      {
        "name": "should_add_header",
        "body": "{\n        var addHeaders = new List<AddHeader>\n        {\n            new(\"Laura\", \"Tom\"),\n        };\n\n        this.Given(_ => GivenAResponseMessage())\n            .And(_ => GivenTheAddHeaders(addHeaders))\n            .When(_ => WhenIAdd())\n            .And(_ => ThenTheHeaderIsReturned(\"Laura\", \"Tom\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_add_trace_id_placeholder",
        "body": "{\n        var addHeaders = new List<AddHeader>\n        {\n            new(\"Trace-Id\", \"{TraceId}\"),\n        };\n\n        var traceId = \"123\";\n\n        this.Given(_ => GivenAResponseMessage())\n            .And(_ => GivenTheTraceIdIs(traceId))\n            .And(_ => GivenTheAddHeaders(addHeaders))\n            .When(_ => WhenIAdd())\n            .Then(_ => ThenTheHeaderIsReturned(\"Trace-Id\", traceId))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_add_trace_id_placeholder_and_normal",
        "body": "{\n        var addHeaders = new List<AddHeader>\n        {\n            new(\"Trace-Id\", \"{TraceId}\"),\n            new(\"Tom\", \"Laura\"),\n        };\n\n        var traceId = \"123\";\n\n        this.Given(_ => GivenAResponseMessage())\n            .And(_ => GivenTheTraceIdIs(traceId))\n            .And(_ => GivenTheAddHeaders(addHeaders))\n            .When(_ => WhenIAdd())\n            .Then(_ => ThenTheHeaderIsReturned(\"Trace-Id\", traceId))\n            .Then(_ => ThenTheHeaderIsReturned(\"Tom\", \"Laura\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_do_nothing_and_log_error",
        "body": "{\n        var addHeaders = new List<AddHeader>\n        {\n            new(\"Trace-Id\", \"{TraceId}\"),\n        };\n\n        this.Given(_ => GivenAResponseMessage())\n            .And(_ => GivenTheTraceIdErrors())\n            .And(_ => GivenTheAddHeaders(addHeaders))\n            .When(_ => WhenIAdd())\n            .Then(_ => ThenTheHeaderIsNotAdded(\"Trace-Id\"))\n            .And(_ => ThenTheErrorIsLogged())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToHeadersMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_add_headers_to_request_correctly",
        "body": "{\n        var downstreamRoute = new Ocelot.DownstreamRouteFinder.DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                        .WithDownstreamPathTemplate(\"any old string\")\n                        .WithClaimsToHeaders(new List<ClaimToThing>\n                        {\n                            new(\"UserId\", \"Subject\", string.Empty, 0),\n                        })\n                        .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                        .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => x.GivenTheAddHeadersToDownstreamRequestReturnsOk())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheAddHeadersToRequestIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "HttpContextRequestHeaderReplacerTests.cs",
    "methods": [
      {
        "name": "should_replace_headers",
        "body": "{\r\n        var context = new DefaultHttpContext();\r\n        context.Request.Headers.Append(\"test\", \"test\");\r\n\r\n        var fAndRs = new List<HeaderFindAndReplace> { new(\"test\", \"test\", \"chiken\", 0) };\r\n\r\n        this.Given(x => GivenTheFollowingHttpRequest(context))\r\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\r\n            .When(x => WhenICallTheReplacer())\r\n            .Then(x => ThenTheHeadersAreReplaced())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_replace_headers",
        "body": "{\r\n        var context = new DefaultHttpContext();\r\n        context.Request.Headers.Append(\"test\", \"test\");\r\n\r\n        var fAndRs = new List<HeaderFindAndReplace>();\r\n\r\n        this.Given(x => GivenTheFollowingHttpRequest(context))\r\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\r\n            .When(x => WhenICallTheReplacer())\r\n            .Then(x => ThenTheHeadersAreNotReplaced())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HttpHeadersTransformationMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_pre_and_post_header_transforms",
        "body": "{\n        this.Given(x => GivenTheFollowingRequest())\n            .And(x => GivenTheDownstreamRequestIs())\n            .And(x => GivenTheRouteHasPreFindAndReplaceSetUp())\n            .And(x => GivenTheHttpResponseMessageIs())\n            .When(x => WhenICallTheMiddleware())\n            .Then(x => ThenTheIHttpContextRequestHeaderReplacerIsCalledCorrectly())\n            .Then(x => ThenAddHeadersToRequestIsCalledCorrectly())\n            .And(x => ThenTheIHttpResponseHeaderReplacerIsCalledCorrectly())\n            .And(x => ThenAddHeadersToResponseIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "HttpResponseHeaderReplacerTests.cs",
    "methods": [
      {
        "name": "should_replace_headers",
        "body": "{\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"test\", new List<string> {\"test\"}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace> { new(\"test\", \"test\", \"chiken\", 0) };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeadersAreReplaced())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_replace_headers",
        "body": "{\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"test\", new List<string> {\"test\"}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>();\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeadersAreNotReplaced())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_downstream_base_url_with_ocelot_base_url",
        "body": "{\n        const string downstreamUrl = \"http://downstream.com/\";\n\n        var request =\n            new HttpRequestMessage(HttpMethod.Get, \"http://test.com\") { RequestUri = new System.Uri(downstreamUrl) };\n\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Location\", new List<string> {downstreamUrl}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>\n        {\n            new(\"Location\", \"{DownstreamBaseUrl}\", \"http://ocelot.com/\", 0),\n        };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheRequestIs(request))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeaderShouldBe(\"Location\", \"http://ocelot.com/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_downstream_base_url_with_ocelot_base_url_with_port",
        "body": "{\n        const string downstreamUrl = \"http://downstream.com/\";\n\n        var request =\n            new HttpRequestMessage(HttpMethod.Get, \"http://test.com\") { RequestUri = new System.Uri(downstreamUrl) };\n\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Location\", new List<string> {downstreamUrl}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>\n        {\n            new(\"Location\", \"{DownstreamBaseUrl}\", \"http://ocelot.com:123/\", 0),\n        };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheRequestIs(request))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeaderShouldBe(\"Location\", \"http://ocelot.com:123/\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_downstream_base_url_with_ocelot_base_url_and_path",
        "body": "{\n        const string downstreamUrl = \"http://downstream.com/test/product\";\n\n        var request =\n            new HttpRequestMessage(HttpMethod.Get, \"http://test.com\") { RequestUri = new System.Uri(downstreamUrl) };\n\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Location\", new List<string> {downstreamUrl}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>\n        {\n            new(\"Location\", \"{DownstreamBaseUrl}\", \"http://ocelot.com/\", 0),\n        };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheRequestIs(request))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeaderShouldBe(\"Location\", \"http://ocelot.com/test/product\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_downstream_base_url_with_ocelot_base_url_with_path_and_port",
        "body": "{\n        const string downstreamUrl = \"http://downstream.com/test/product\";\n\n        var request =\n            new HttpRequestMessage(HttpMethod.Get, \"http://test.com\") { RequestUri = new System.Uri(downstreamUrl) };\n\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Location\", new List<string> {downstreamUrl}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>\n        {\n            new(\"Location\", \"{DownstreamBaseUrl}\", \"http://ocelot.com:123/\", 0),\n        };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheRequestIs(request))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeaderShouldBe(\"Location\", \"http://ocelot.com:123/test/product\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_downstream_base_url_and_port_with_ocelot_base_url",
        "body": "{\n        const string downstreamUrl = \"http://downstream.com:123/test/product\";\n\n        var request =\n            new HttpRequestMessage(HttpMethod.Get, \"http://test.com\") { RequestUri = new System.Uri(downstreamUrl) };\n\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Location\", new List<string> {downstreamUrl}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>\n        {\n            new(\"Location\", \"{DownstreamBaseUrl}\", \"http://ocelot.com/\", 0),\n        };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheRequestIs(request))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeaderShouldBe(\"Location\", \"http://ocelot.com/test/product\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_downstream_base_url_and_port_with_ocelot_base_url_and_port",
        "body": "{\n        const string downstreamUrl = \"http://downstream.com:123/test/product\";\n\n        var request =\n            new HttpRequestMessage(HttpMethod.Get, \"http://test.com\") { RequestUri = new System.Uri(downstreamUrl) };\n\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.Accepted,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Location\", new List<string> {downstreamUrl}),\n            }, string.Empty);\n\n        var fAndRs = new List<HeaderFindAndReplace>\n        {\n            new(\"Location\", \"{DownstreamBaseUrl}\", \"http://ocelot.com:321/\", 0),\n        };\n\n        this.Given(x => GivenTheHttpResponse(response))\n            .And(x => GivenTheRequestIs(request))\n            .And(x => GivenTheFollowingHeaderReplacements(fAndRs))\n            .When(x => WhenICallTheReplacer())\n            .Then(x => ThenTheHeaderShouldBe(\"Location\", \"http://ocelot.com:321/test/product\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "RemoveHeadersTests.cs",
    "methods": [
      {
        "name": "should_remove_header",
        "body": "{\r\n        var headers = new List<Header>\r\n        {\r\n            new(\"Transfer-Encoding\", new List<string> {\"chunked\"}),\r\n        };\r\n\r\n        this.Given(x => x.GivenAHttpContext(headers))\r\n            .When(x => x.WhenIRemoveTheHeaders())\r\n            .Then(x => x.TheHeaderIsNoLongerInTheContext())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ClaimParserTests.cs",
    "methods": [
      {
        "name": "can_parse_claims_dictionary_access_string_returning_value_to_function",
        "body": "{\r\n        this.Given(x => x.GivenAClaimOf(new Claim(\"CustomerId\", \"1234\")))\r\n            .And(x => x.GivenTheKeyIs(\"CustomerId\"))\r\n            .When(x => x.WhenICallTheParser())\r\n            .Then(x => x.ThenTheResultIs(new OkResponse<string>(\"1234\")))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_error_response_when_cannot_find_requested_claim",
        "body": "{\r\n        this.Given(x => x.GivenAClaimOf(new Claim(\"BallsId\", \"1234\")))\r\n            .And(x => x.GivenTheKeyIs(\"CustomerId\"))\r\n            .When(x => x.WhenICallTheParser())\r\n            .Then(x => x.ThenTheResultIs(new ErrorResponse<string>(new List<Error>\r\n            {\r\n                new CannotFindClaimError($\"Cannot find claim for key: {_key}\"),\r\n            })))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "can_parse_claims_dictionary_access_string_using_delimiter_and_retuning_at_correct_index",
        "body": "{\r\n        this.Given(x => x.GivenAClaimOf(new Claim(\"Subject\", \"registered|4321\")))\r\n            .And(x => x.GivenTheDelimiterIs(\"|\"))\r\n            .And(x => x.GivenTheIndexIs(1))\r\n            .And(x => x.GivenTheKeyIs(\"Subject\"))\r\n            .When(x => x.WhenICallTheParser())\r\n            .Then(x => x.ThenTheResultIs(new OkResponse<string>(\"4321\")))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_error_response_if_index_too_large",
        "body": "{\r\n        this.Given(x => x.GivenAClaimOf(new Claim(\"Subject\", \"registered|4321\")))\r\n            .And(x => x.GivenTheDelimiterIs(\"|\"))\r\n            .And(x => x.GivenTheIndexIs(24))\r\n            .And(x => x.GivenTheKeyIs(\"Subject\"))\r\n            .When(x => x.WhenICallTheParser())\r\n            .Then(x => x.ThenTheResultIs(new ErrorResponse<string>(new List<Error>\r\n            {\r\n                new CannotFindClaimError($\"Cannot find claim for key: {_key}, delimiter: {_delimiter}, index: {_index}\"),\r\n            })))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_error_response_if_index_too_small",
        "body": "{\r\n        this.Given(x => x.GivenAClaimOf(new Claim(\"Subject\", \"registered|4321\")))\r\n            .And(x => x.GivenTheDelimiterIs(\"|\"))\r\n            .And(x => x.GivenTheIndexIs(-1))\r\n            .And(x => x.GivenTheKeyIs(\"Subject\"))\r\n            .When(x => x.WhenICallTheParser())\r\n            .Then(x => x.ThenTheResultIs(new ErrorResponse<string>(new List<Error>\r\n            {\r\n                new CannotFindClaimError($\"Cannot find claim for key: {_key}, delimiter: {_delimiter}, index: {_index}\"),\r\n            })))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ConfigAwarePlaceholdersTests.cs",
    "methods": [
      {
        "name": "should_return_value_from_underlying_placeholders",
        "body": "{\n        var baseUrl = \"http://www.bbc.co.uk\";\n        const string key = \"{BaseUrl}\";\n\n        _basePlaceholders.Setup(x => x.Get(key)).Returns(new OkResponse<string>(baseUrl));\n        var result = _placeholders.Get(key);\n        result.Data.ShouldBe(baseUrl);\n    }"
      },
      {
        "name": "should_return_value_from_config_with_same_name_as_placeholder_if_underlying_placeholder_not_found",
        "body": "{\n        const string expected = \"http://foo-bar.co.uk\";\n        const string key = \"{BaseUrl}\";\n\n        _basePlaceholders.Setup(x => x.Get(key)).Returns(new ErrorResponse<string>(new FakeError()));\n        var result = _placeholders.Get(key);\n        result.Data.ShouldBe(expected);\n    }"
      },
      {
        "name": "should_call_underyling_when_added",
        "body": "{\n        const string key = \"{Test}\";\n        Func<Response<string>> func = () => new OkResponse<string>(\"test)\");\n        _placeholders.Add(key, func);\n        _basePlaceholders.Verify(p => p.Add(key, func), Times.Once);\n    }"
      },
      {
        "name": "should_call_underyling_when_removed",
        "body": "{\n        const string key = \"{Test}\";\n        _placeholders.Remove(key);\n        _basePlaceholders.Verify(p => p.Remove(key), Times.Once);\n    }"
      }
    ]
  },
  {
    "file": "HttpDataRepositoryTests.cs",
    "methods": [
      {
        "name": "get_returns_correct_key_from_http_context",
        "body": "{\n        this.Given(x => x.GivenAHttpContextContaining(\"key\", \"string\"))\n            .When(x => x.GetIsCalledWithKey<string>(\"key\"))\n            .Then(x => x.ThenTheResultIsAnOkResponse<string>(\"string\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "get_returns_error_response_if_the_key_is_not_found",
        "body": "{\n        this.Given(x => x.GivenAHttpContextContaining(\"key\", \"string\"))\n            .When(x => x.GetIsCalledWithKey<string>(\"keyDoesNotExist\"))\n            .Then(x => x.ThenTheResultIsAnErrorReposnse<string>(\"string1\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_update",
        "body": "{\n        this.Given(x => x.GivenAHttpContextContaining(\"key\", \"string\"))\n            .And(x => x.UpdateIsCalledWith<string>(\"key\", \"new string\"))\n            .When(x => x.GetIsCalledWithKey<string>(\"key\"))\n            .Then(x => x.ThenTheResultIsAnOkResponse<string>(\"new string\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "InMemoryBusTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        var called = false;\n        _bus.Subscribe(x =>\n        {\n            called = true;\n        });\n        _bus.Publish(new object(), 1);\n        await Task.Delay(100);\n        called.ShouldBeTrue();\n    }"
      },
      {
        "name": "should_not_be_publish_yet_as_no_delay_in_caller",
        "body": "{\n        var called = false;\n        _bus.Subscribe(x =>\n        {\n            called = true;\n        });\n        _bus.Publish(new object(), 1);\n        called.ShouldBeFalse();\n    }"
      }
    ]
  },
  {
    "file": "PlaceholdersTests.cs",
    "methods": [
      {
        "name": "should_return_base_url",
        "body": "{\n        var baseUrl = \"http://www.bbc.co.uk\";\n        _finder.Setup(x => x.Find()).Returns(baseUrl);\n        var result = _placeholders.Get(\"{BaseUrl}\");\n        result.Data.ShouldBe(baseUrl);\n    }"
      },
      {
        "name": "should_return_remote_ip_address",
        "body": "{\n        var httpContext = new DefaultHttpContext { Connection = { RemoteIpAddress = IPAddress.Any } };\n        _accessor.Setup(x => x.HttpContext).Returns(httpContext);\n        var result = _placeholders.Get(\"{RemoteIpAddress}\");\n        result.Data.ShouldBe(httpContext.Connection.RemoteIpAddress.ToString());\n    }"
      },
      {
        "name": "should_return_key_does_not_exist",
        "body": "{\n        var result = _placeholders.Get(\"{Test}\");\n        result.IsError.ShouldBeTrue();\n        result.Errors[0].Message.ShouldBe(\"Unable to find placeholder called {Test}\");\n    }"
      },
      {
        "name": "should_return_downstream_base_url_when_port_is_not_80_or_443",
        "body": "{\n        var httpRequest = new HttpRequestMessage();\n        httpRequest.RequestUri = new Uri(\"http://www.bbc.co.uk\");\n        var request = new DownstreamRequest(httpRequest);\n        var result = _placeholders.Get(\"{DownstreamBaseUrl}\", request);\n        result.Data.ShouldBe(\"http://www.bbc.co.uk/\");\n    }"
      },
      {
        "name": "should_return_downstream_base_url_when_port_is_80_or_443",
        "body": "{\n        var httpRequest = new HttpRequestMessage();\n        httpRequest.RequestUri = new Uri(\"http://www.bbc.co.uk:123\");\n        var request = new DownstreamRequest(httpRequest);\n        var result = _placeholders.Get(\"{DownstreamBaseUrl}\", request);\n        result.Data.ShouldBe(\"http://www.bbc.co.uk:123/\");\n    }"
      },
      {
        "name": "should_return_key_does_not_exist_for_http_request_message",
        "body": "{\n        var request = new DownstreamRequest(new HttpRequestMessage(HttpMethod.Get, \"http://west.com\"));\n        var result = _placeholders.Get(\"{Test}\", request);\n        result.IsError.ShouldBeTrue();\n        result.Errors[0].Message.ShouldBe(\"Unable to find placeholder called {Test}\");\n    }"
      },
      {
        "name": "should_return_trace_id",
        "body": "{\n        var traceId = \"123\";\n        _repo.Setup(x => x.Get<string>(\"TraceId\")).Returns(new OkResponse<string>(traceId));\n        var result = _placeholders.Get(\"{TraceId}\");\n        result.Data.ShouldBe(traceId);\n    }"
      },
      {
        "name": "should_return_ok_when_added",
        "body": "{\n        var result = _placeholders.Add(\"{Test}\", () => new OkResponse<string>(\"test\"));\n        result.IsError.ShouldBeFalse();\n    }"
      },
      {
        "name": "should_return_ok_when_removed",
        "body": "{\n        var result = _placeholders.Add(\"{Test}\", () => new OkResponse<string>(\"test\"));\n        result = _placeholders.Remove(\"{Test}\");\n        result.IsError.ShouldBeFalse();\n    }"
      },
      {
        "name": "should_return_error_when_added",
        "body": "{\n        var result = _placeholders.Add(\"{Test}\", () => new OkResponse<string>(\"test\"));\n        result = _placeholders.Add(\"{Test}\", () => new OkResponse<string>(\"test\"));\n        result.IsError.ShouldBeTrue();\n        result.Errors[0].Message.ShouldBe(\"Unable to add placeholder: {Test}, placeholder already exists\");\n    }"
      },
      {
        "name": "should_return_error_when_removed",
        "body": "{\n        var result = _placeholders.Remove(\"{Test}\");\n        result.IsError.ShouldBeTrue();\n        result.Errors[0].Message.ShouldBe(\"Unable to remove placeholder: {Test}, placeholder does not exists\");\n    }"
      },
      {
        "name": "should_return_upstreamHost",
        "body": "{\n        var upstreamHost = \"UpstreamHostA\";\n        var httpContext = new DefaultHttpContext();\n        httpContext.Request.Headers.Append(\"Host\", upstreamHost);\n        _accessor.Setup(x => x.HttpContext).Returns(httpContext);\n        var result = _placeholders.Get(\"{UpstreamHost}\");\n        result.Data.ShouldBe(upstreamHost);\n    }"
      },
      {
        "name": "should_return_error_when_finding_upstbecause_Host_not_set",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        _accessor.Setup(x => x.HttpContext).Returns(httpContext);\n        var result = _placeholders.Get(\"{UpstreamHost}\");\n        result.IsError.ShouldBeTrue();\n    }"
      },
      {
        "name": "should_return_error_when_finding_upstream_host_because_exception_thrown",
        "body": "{\n        _accessor.Setup(x => x.HttpContext).Throws(new Exception());\n        var result = _placeholders.Get(\"{UpstreamHost}\");\n        result.IsError.ShouldBeTrue();\n    }"
      }
    ]
  },
  {
    "file": "ScopesAuthorizerTests.cs",
    "methods": [
      {
        "name": "should_return_ok_if_no_allowed_scopes",
        "body": "{\n        this.Given(_ => GivenTheFollowing(new ClaimsPrincipal()))\n        .And(_ => GivenTheFollowing(new List<string>()))\n        .When(_ => WhenIAuthorize())\n        .Then(_ => ThenTheFollowingIsReturned(new OkResponse<bool>(true)))\n        .BDDfy();\n    }"
      },
      {
        "name": "should_return_ok_if_null_allowed_scopes",
        "body": "{\n        this.Given(_ => GivenTheFollowing(new ClaimsPrincipal()))\n        .And(_ => GivenTheFollowing((List<string>)null))\n        .When(_ => WhenIAuthorize())\n        .Then(_ => ThenTheFollowingIsReturned(new OkResponse<bool>(true)))\n        .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_if_claims_parser_returns_error",
        "body": "{\n        var fakeError = new FakeError();\n        this.Given(_ => GivenTheFollowing(new ClaimsPrincipal()))\n        .And(_ => GivenTheParserReturns(new ErrorResponse<List<string>>(fakeError)))\n        .And(_ => GivenTheFollowing(new List<string> { \"doesntmatter\" }))\n        .When(_ => WhenIAuthorize())\n        .Then(_ => ThenTheFollowingIsReturned(new ErrorResponse<bool>(fakeError)))\n        .BDDfy();\n    }"
      },
      {
        "name": "should_match_scopes_and_return_ok_result",
        "body": "{\n        var claimsPrincipal = new ClaimsPrincipal();\n        var allowedScopes = new List<string> { \"someScope\" };\n\n        this.Given(_ => GivenTheFollowing(claimsPrincipal))\n        .And(_ => GivenTheParserReturns(new OkResponse<List<string>>(allowedScopes)))\n        .And(_ => GivenTheFollowing(allowedScopes))\n        .When(_ => WhenIAuthorize())\n        .Then(_ => ThenTheFollowingIsReturned(new OkResponse<bool>(true)))\n        .BDDfy();\n    }"
      },
      {
        "name": "should_not_match_scopes_and_return_error_result",
        "body": "{\n        var fakeError = new FakeError();\n        var claimsPrincipal = new ClaimsPrincipal();\n        var allowedScopes = new List<string> { \"someScope\" };\n        var userScopes = new List<string> { \"anotherScope\" };\n\n        this.Given(_ => GivenTheFollowing(claimsPrincipal))\n        .And(_ => GivenTheParserReturns(new OkResponse<List<string>>(userScopes)))\n        .And(_ => GivenTheFollowing(allowedScopes))\n        .When(_ => WhenIAuthorize())\n        .Then(_ => ThenTheFollowingIsReturned(new ErrorResponse<bool>(fakeError)))\n        .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "StringExtensionsTests.cs",
    "methods": [
      {
        "name": "should_trim_start",
        "body": "{\n        var test = \"/string\";\n\n        test = test.TrimStart(\"/\");\n\n        test.ShouldBe(\"string\");\n    }"
      },
      {
        "name": "should_return_source",
        "body": "{\n        var test = \"string\";\n\n        test = test.LastCharAsForwardSlash();\n\n        test.ShouldBe(\"string/\");\n    }"
      }
    ]
  },
  {
    "file": "KubeProviderFactoryTests.cs",
    "methods": [
      {
        "name": "should_return_KubeServiceDiscoveryProvider",
        "body": "{\n            var provider = KubernetesProviderFactory.Get(_provider, new ServiceProviderConfiguration(\"kube\", \"localhost\", 443, \"\", \"\", 1,\"dev\"), \"\");\n            provider.ShouldBeOfType<Kube>();\n        }"
      }
    ]
  },
  {
    "file": "KubeServiceBuilderTests.cs",
    "methods": [
      {
        "name": "Cstor_NotNullArgs_ObjCreated",
        "body": "{\n        // Arrange\n        factory.Setup(x => x.CreateLogger<KubeServiceBuilder>()).Verifiable();\n\n        // Act\n        sut = new KubeServiceBuilder(factory.Object, serviceCreator.Object);\n\n        // Assert\n        Assert.NotNull(sut);\n        factory.Verify(x => x.CreateLogger<KubeServiceBuilder>(), Times.Once());\n    }"
      }
    ]
  },
  {
    "file": "KubeServiceCreatorTests.cs",
    "methods": [
      {
        "name": "Cstor_NullArg_ThrownException",
        "body": "{\n        // Arrange, Act, Assert\n        Assert.Throws<ArgumentNullException>(\"factory\",\n            () => sut = new KubeServiceCreator(null));\n    }"
      },
      {
        "name": "Cstor_NotNullArg_ObjCreated",
        "body": "{\n        // Arrange\n        factory.Setup(x => x.CreateLogger<KubeServiceCreator>()).Verifiable();\n\n        // Act\n        sut = new KubeServiceCreator(factory.Object);\n\n        // Assert\n        Assert.NotNull(sut);\n        factory.Verify(x => x.CreateLogger<KubeServiceCreator>(), Times.Once());\n    }"
      },
      {
        "name": "Create_ValidArgs_HappyPath",
        "body": "{\n        // Arrange\n        var arg1 = new KubeRegistryConfiguration()\n        {\n            KubeNamespace = nameof(KubeServiceCreatorTests),\n            KeyOfServiceInK8s = nameof(Create_ValidArgs_HappyPath),\n            Scheme = \"happy\", //nameof(HttpScheme.Http),\n        };\n        var arg2 = new EndpointsV1()\n        {\n            ApiVersion = \"v1\",\n            Metadata = new()\n            {\n                Namespace = nameof(KubeServiceCreatorTests),\n                Name = nameof(Create_ValidArgs_HappyPath),\n                Uid = Guid.NewGuid().ToString(),\n            },\n        };\n        var arg3 = new EndpointSubsetV1();\n        arg3.Addresses.Add(new()\n        {\n            Ip = \"8.8.8.8\",\n            NodeName = \"google\",\n            Hostname = \"dns.google\",\n        });\n        var ports = new List<EndpointPortV1>\n        {\n            new() { Name = nameof(HttpScheme.Http), Port = 80 },\n            new() { Name = \"happy\", Port = 888 },\n        };\n        arg3.Ports.AddRange(ports);\n        arg2.Subsets.Add(arg3);\n        Arrange();\n\n        // Act\n        var actual = sut.Create(arg1, arg2, arg3);\n\n        // Assert\n        Assert.NotNull(actual);\n        Assert.NotEmpty(actual);\n        var service = actual.SingleOrDefault();\n        Assert.NotNull(service);\n        Assert.Equal(nameof(Create_ValidArgs_HappyPath), service.Name);\n        Assert.Equal(\"happy\", service.HostAndPort.Scheme);\n        Assert.Equal(888, service.HostAndPort.DownstreamPort);\n        Assert.Equal(\"8.8.8.8\", service.HostAndPort.DownstreamHost);\n        logger.Verify(x => x.LogDebug(It.IsAny<Func<string>>()),\n            Times.Once());\n    }"
      }
    ]
  },
  {
    "file": "KubeTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var given = GivenClientAndProvider(out var serviceBuilder);\n        serviceBuilder.Setup(x => x.BuildServices(It.IsAny<KubeRegistryConfiguration>(), It.IsAny<EndpointsV1>()))\n            .Returns(new Service[] { new(nameof(Should_return_service_from_k8s), new(\"localhost\", 80), string.Empty, string.Empty, Array.Empty<string>()) });\n\n        var endpoints = GivenEndpoints();\n        using var kubernetes = GivenThereIsAFakeKubeServiceDiscoveryProvider(\n            given.ClientOptions.ApiEndPoint.ToString(),\n            given.ProviderOptions.KubeNamespace,\n            given.ProviderOptions.KeyOfServiceInK8s,\n            endpoints,\n            out Lazy<string> receivedToken);\n\n        // Act\n        var services = await given.Provider.GetAsync();\n\n        // Assert\n        services.ShouldNotBeNull().Count.ShouldBe(1);\n        receivedToken.Value.ShouldBe($\"Bearer {nameof(Should_return_service_from_k8s)}\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var given = GivenClientAndProvider(out var serviceBuilder);\n        var manualResetEvent = new ManualResetEvent(false);\n        serviceBuilder.Setup(x => x.BuildServices(It.IsAny<KubeRegistryConfiguration>(), It.IsAny<EndpointsV1>()))\n            .Returns(() =>\n            {\n                manualResetEvent.WaitOne();\n                return new Service[] { new(nameof(Should_return_single_service_from_k8s_during_concurrent_calls), new(\"localhost\", 80), string.Empty, string.Empty, Array.Empty<string>()) };\n            });\n\n        var endpoints = GivenEndpoints();\n        using var kubernetes = GivenThereIsAFakeKubeServiceDiscoveryProvider(\n            given.ClientOptions.ApiEndPoint.ToString(),\n            given.ProviderOptions.KubeNamespace,\n            given.ProviderOptions.KeyOfServiceInK8s,\n            endpoints,\n            out Lazy<string> receivedToken);\n\n        // Act\n        var services = new List<Service>();\n        async Task WhenIGetTheServices() => services = await given.Provider.GetAsync();\n        var getServiceTasks = Task.WhenAll(\n            WhenIGetTheServices(),\n            WhenIGetTheServices());\n        manualResetEvent.Set();\n        await getServiceTasks;\n\n        // Assert\n        receivedToken.Value.ShouldBe($\"Bearer {nameof(Should_return_single_service_from_k8s_during_concurrent_calls)}\");\n        services.ShouldNotBeNull().Count.ShouldBe(1);\n        services.ShouldAllBe(s => s != null);\n    }"
      }
    ]
  },
  {
    "file": "KubernetesProviderFactoryTests.cs",
    "methods": []
  },
  {
    "file": "OcelotBuilderExtensionsTests.cs",
    "methods": [
      {
        "name": "should_set_up_cache_manager",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => WhenISetUpCacheManager())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .And(x => OnlyOneVersionOfEachCacheIsRegistered())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "PollKubeTests.cs",
    "methods": [
      {
        "name": "Should_return_service_from_kube",
        "body": "{\n        var service = new Service(string.Empty, new ServiceHostAndPort(string.Empty, 0), string.Empty, string.Empty, new List<string>());\n\n        this.Given(x => GivenKubeReturns(service))\n            .When(x => WhenIGetTheServices(1))\n            .Then(x => ThenTheCountIs(1))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "CookieStickySessionsCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_instance_of_expected_load_balancer_type",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"myType\", \"myKey\", 1000))\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenARoute(route))\r\n            .When(x => x.WhenIGetTheLoadBalancer())\r\n            .Then(x => x.ThenTheLoadBalancerIsReturned<CookieStickySessions>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_expected_name",
        "body": "{\r\n        this.When(x => x.WhenIGetTheLoadBalancerTypeName())\r\n            .Then(x => x.ThenTheLoadBalancerTypeIs(\"CookieStickySessions\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "CookieStickySessionsTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        GivenTheLoadBalancerReturns();\n        GivenTheDownstreamRequestHasSessionId(\"321\");\n        GivenIHackAMessageInWithAPastExpiry();\n        await WhenILease();\n        WhenTheMessagesAreProcessed();\n        ThenTheLoadBalancerIsCalled();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        GivenTheLoadBalancerReturns();\n        GivenTheDownstreamRequestHasSessionId(\"321\");\n        await WhenILease();\n        ThenTheHostAndPortIsNotNull();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        GivenTheLoadBalancerReturnsSequence();\n        GivenTheDownstreamRequestHasSessionId(\"321\");\n        await WhenILeaseTwiceInARow();\n        ThenTheFirstAndSecondResponseAreTheSame();\n        ThenTheStickySessionWillTimeout();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        GivenTheLoadBalancerReturnsSequence();\n        await WhenIMakeTwoRequetsWithDifferentSessionValues();\n        ThenADifferentHostAndPortIsReturned();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        Arrange();\n        GivenTheLoadBalancerReturnsError();\n        await WhenILease();\n        ThenAnErrorIsReturned();\n    }"
      },
      {
        "name": "Should_release",
        "body": "{\n        _stickySessions.Release(new ServiceHostAndPort(string.Empty, 0));\n    }"
      }
    ]
  },
  {
    "file": "DelegateInvokingLoadBalancerCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_expected_name",
        "body": "{\n        this.When(x => x.WhenIGetTheLoadBalancerTypeName())\n            .Then(x => x.ThenTheLoadBalancerTypeIs(\"FakeLoadBalancer\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_result_of_specified_creator_func",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenTheLoadBalancerIsReturned<FakeLoadBalancer>())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => x.GivenTheCreatorFuncThrows())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenAnErrorIsReturned())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "LeastConnectionCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_instance_of_expected_load_balancer_type",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithServiceName(\"myService\")\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenARoute(route))\r\n            .When(x => x.WhenIGetTheLoadBalancer())\r\n            .Then(x => x.ThenTheLoadBalancerIsReturned<LeastConnection>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_expected_name",
        "body": "{\r\n        this.When(x => x.WhenIGetTheLoadBalancerTypeName())\r\n            .Then(x => x.ThenTheLoadBalancerTypeIs(\"LeastConnection\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "LeastConnectionTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        var serviceName = \"products\";\n\n        var availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.2\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        _services = availableServices;\n        _leastConnection = new LeastConnection(() => Task.FromResult(_services), serviceName);\n\n        var tasks = new Task[100];\n\n        for (var i = 0; i < tasks.Length; i++)\n        {\n            tasks[i] = LeaseDelayAndRelease();\n        }\n\n        await Task.WhenAll(tasks);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var serviceName = \"products\";\n\n        var availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.2\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        _leastConnection = new LeastConnection(() => Task.FromResult(availableServices), serviceName);\n\n        var hostAndPortOne = await _leastConnection.LeaseAsync(_httpContext);\n        hostAndPortOne.Data.DownstreamHost.ShouldBe(\"127.0.0.1\");\n        var hostAndPortTwo = await _leastConnection.LeaseAsync(_httpContext);\n        hostAndPortTwo.Data.DownstreamHost.ShouldBe(\"127.0.0.2\");\n        _leastConnection.Release(hostAndPortOne.Data);\n        _leastConnection.Release(hostAndPortTwo.Data);\n\n        availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        hostAndPortOne = await _leastConnection.LeaseAsync(_httpContext);\n        hostAndPortOne.Data.DownstreamHost.ShouldBe(\"127.0.0.1\");\n        hostAndPortTwo = await _leastConnection.LeaseAsync(_httpContext);\n        hostAndPortTwo.Data.DownstreamHost.ShouldBe(\"127.0.0.1\");\n        _leastConnection.Release(hostAndPortOne.Data);\n        _leastConnection.Release(hostAndPortTwo.Data);\n\n        availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.2\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        hostAndPortOne = await _leastConnection.LeaseAsync(_httpContext);\n        hostAndPortOne.Data.DownstreamHost.ShouldBe(\"127.0.0.1\");\n        hostAndPortTwo = await _leastConnection.LeaseAsync(_httpContext);\n        hostAndPortTwo.Data.DownstreamHost.ShouldBe(\"127.0.0.2\");\n        _leastConnection.Release(hostAndPortOne.Data);\n        _leastConnection.Release(hostAndPortTwo.Data);\n    }"
      },
      {
        "name": "Should_get_next_url",
        "body": "{\n        var serviceName = \"products\";\n\n        var hostAndPort = new ServiceHostAndPort(\"localhost\", 80);\n\n        var availableServices = new List<Service>\n        {\n            new(serviceName, hostAndPort, string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        this.Given(x => x.GivenAHostAndPort(hostAndPort))\n        .And(x => x.GivenTheLoadBalancerStarts(availableServices, serviceName))\n        .When(x => x.WhenIGetTheNextHostAndPort())\n        .Then(x => x.ThenTheNextHostAndPortIsReturned())\n        .BDDfy();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var serviceName = \"products\";\n\n        var availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.2\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.3\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        _services = availableServices;\n        _leastConnection = new LeastConnection(() => Task.FromResult(_services), serviceName);\n\n        var response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[0].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[1].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[2].HostAndPort.DownstreamHost);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var serviceName = \"products\";\n\n        var availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.2\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        _services = availableServices;\n        _leastConnection = new LeastConnection(() => Task.FromResult(_services), serviceName);\n\n        var response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[0].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[1].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[0].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[1].HostAndPort.DownstreamHost);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var serviceName = \"products\";\n\n        var availableServices = new List<Service>\n        {\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.1\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n            new(serviceName, new ServiceHostAndPort(\"127.0.0.2\", 80), string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        _services = availableServices;\n        _leastConnection = new LeastConnection(() => Task.FromResult(_services), serviceName);\n\n        var response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[0].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[1].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[0].HostAndPort.DownstreamHost);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[1].HostAndPort.DownstreamHost);\n\n        //release this so 2 should have 1 connection and we should get 2 back as our next host and port\n        _leastConnection.Release(availableServices[1].HostAndPort);\n\n        response = await _leastConnection.LeaseAsync(_httpContext);\n\n        response.Data.DownstreamHost.ShouldBe(availableServices[1].HostAndPort.DownstreamHost);\n    }"
      },
      {
        "name": "Should_return_error_if_services_are_null",
        "body": "{\n        var serviceName = \"products\";\n\n        var hostAndPort = new ServiceHostAndPort(\"localhost\", 80);\n        this.Given(x => x.GivenAHostAndPort(hostAndPort))\n         .And(x => x.GivenTheLoadBalancerStarts(null, serviceName))\n         .When(x => x.WhenIGetTheNextHostAndPort())\n         .Then(x => x.ThenErrorIsReturned<ServicesAreNullError>())\n         .BDDfy();\n    }"
      },
      {
        "name": "Should_return_error_if_services_are_empty",
        "body": "{\n        var serviceName = \"products\";\n\n        var hostAndPort = new ServiceHostAndPort(\"localhost\", 80);\n        this.Given(x => x.GivenAHostAndPort(hostAndPort))\n         .And(x => x.GivenTheLoadBalancerStarts(new List<Service>(), serviceName))\n         .When(x => x.WhenIGetTheNextHostAndPort())\n         .Then(x => x.ThenErrorIsReturned<ServicesAreNullError>())\n         .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "LoadBalancerFactoryTests.cs",
    "methods": [
      {
        "name": "should_return_no_load_balancer_by_default",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => GivenAServiceProviderConfig(new ServiceProviderConfigurationBuilder().Build()))\n            .And(x => x.GivenTheServiceProviderFactoryReturns())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenTheLoadBalancerIsReturned<FakeNoLoadBalancer>())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_matching_load_balancer",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeLoadBalancerTwo\", string.Empty, 0))\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => GivenAServiceProviderConfig(new ServiceProviderConfigurationBuilder().Build()))\n            .And(x => x.GivenTheServiceProviderFactoryReturns())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenTheLoadBalancerIsReturned<FakeLoadBalancerTwo>())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_response_if_cannot_find_load_balancer_creator",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"DoesntExistLoadBalancer\", string.Empty, 0))\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => GivenAServiceProviderConfig(new ServiceProviderConfigurationBuilder().Build()))\n            .And(x => x.GivenTheServiceProviderFactoryReturns())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenAnErrorResponseIsReturned())\n            .And(x => x.ThenTheErrorMessageIsCorrect())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_response_if_creator_errors",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"BrokenLoadBalancer\", string.Empty, 0))\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => GivenAServiceProviderConfig(new ServiceProviderConfigurationBuilder().Build()))\n            .And(x => x.GivenTheServiceProviderFactoryReturns())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenAnErrorResponseIsReturned())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_call_service_provider",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeLoadBalancerOne\", string.Empty, 0))\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => GivenAServiceProviderConfig(new ServiceProviderConfigurationBuilder().Build()))\n            .And(x => x.GivenTheServiceProviderFactoryReturns())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenTheServiceProviderIsCalledCorrectly())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_response_when_call_to_service_provider_fails",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeLoadBalancerOne\", string.Empty, 0))\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        this.Given(x => x.GivenARoute(route))\n            .And(x => GivenAServiceProviderConfig(new ServiceProviderConfigurationBuilder().Build()))\n            .And(x => x.GivenTheServiceProviderFactoryFails())\n            .When(x => x.WhenIGetTheLoadBalancer())\n            .Then(x => x.ThenAnErrorResponseIsReturned())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "LoadBalancerHouseTests.cs",
    "methods": [
      {
        "name": "should_store_load_balancer_on_first_request",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerKey(\"test\")\n            .Build();\n\n        this.Given(x => x.GivenThereIsALoadBalancer(route, new FakeLoadBalancer()))\n            .Then(x => x.ThenItIsAdded())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_store_load_balancer_on_second_request",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeLoadBalancer\", string.Empty, 0))\n            .WithLoadBalancerKey(\"test\")\n            .Build();\n\n        this.Given(x => x.GivenThereIsALoadBalancer(route, new FakeLoadBalancer()))\n            .When(x => x.WhenWeGetTheLoadBalancer(route))\n            .Then(x => x.ThenItIsReturned())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_store_load_balancers_by_key",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeLoadBalancer\", string.Empty, 0))\n            .WithLoadBalancerKey(\"test\")\n            .Build();\n\n        var routeTwo = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeRoundRobinLoadBalancer\", string.Empty, 0))\n            .WithLoadBalancerKey(\"testtwo\")\n            .Build();\n\n        this.Given(x => x.GivenThereIsALoadBalancer(route, new FakeLoadBalancer()))\n            .And(x => x.GivenThereIsALoadBalancer(routeTwo, new FakeRoundRobinLoadBalancer()))\n            .When(x => x.WhenWeGetTheLoadBalancer(route))\n            .Then(x => x.ThenTheLoadBalancerIs<FakeLoadBalancer>())\n            .When(x => x.WhenWeGetTheLoadBalancer(routeTwo))\n            .Then(x => x.ThenTheLoadBalancerIs<FakeRoundRobinLoadBalancer>())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_if_exception",
        "body": "{\n        var route = new DownstreamRouteBuilder().Build();\n\n        this.When(x => x.WhenWeGetTheLoadBalancer(route))\n        .Then(x => x.ThenAnErrorIsReturned())\n        .BDDfy();\n    }"
      },
      {
        "name": "should_get_new_load_balancer_if_route_load_balancer_has_changed",
        "body": "{\n        var route = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"FakeLoadBalancer\", string.Empty, 0))\n            .WithLoadBalancerKey(\"test\")\n            .Build();\n\n        var routeTwo = new DownstreamRouteBuilder()\n            .WithLoadBalancerOptions(new LoadBalancerOptions(\"LeastConnection\", string.Empty, 0))\n            .WithLoadBalancerKey(\"test\")\n            .Build();\n\n        this.Given(x => x.GivenThereIsALoadBalancer(route, new FakeLoadBalancer()))\n            .When(x => x.WhenWeGetTheLoadBalancer(route))\n            .Then(x => x.ThenTheLoadBalancerIs<FakeLoadBalancer>())\n            .When(x => x.WhenIGetTheRouteWithTheSameKeyButDifferentLoadBalancer(routeTwo))\n            .Then(x => x.ThenTheLoadBalancerIs<LeastConnection>())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "LoadBalancerMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_scoped_data_repository_correctly",
        "body": "{\n        var downstreamRoute = new DownstreamRouteBuilder()\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build();\n\n        var serviceProviderConfig = new ServiceProviderConfigurationBuilder()\n            .Build();\n\n        this.Given(x => x.GivenTheDownStreamUrlIs(\"http://my.url/abc?q=123\"))\n            .And(x => GivenTheConfigurationIs(serviceProviderConfig))\n            .And(x => x.GivenTheDownStreamRouteIs(downstreamRoute, new List<Ocelot.DownstreamRouteFinder.UrlMatcher.PlaceholderNameAndValue>()))\n            .And(x => x.GivenTheLoadBalancerHouseReturns())\n            .And(x => x.GivenTheLoadBalancerReturns())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheDownstreamUrlIsReplacedWith(\"http://127.0.0.1:80/abc?q=123\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_set_pipeline_error_if_cannot_get_load_balancer",
        "body": "{\n        var downstreamRoute = new DownstreamRouteBuilder()\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build();\n\n        var serviceProviderConfig = new ServiceProviderConfigurationBuilder()\n            .Build();\n\n        this.Given(x => x.GivenTheDownStreamUrlIs(\"http://my.url/abc?q=123\"))\n            .And(x => GivenTheConfigurationIs(serviceProviderConfig))\n            .And(x => x.GivenTheDownStreamRouteIs(downstreamRoute, new List<Ocelot.DownstreamRouteFinder.UrlMatcher.PlaceholderNameAndValue>()))\n            .And(x => x.GivenTheLoadBalancerHouseReturnsAnError())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenAnErrorStatingLoadBalancerCouldNotBeFoundIsSetOnPipeline())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_set_pipeline_error_if_cannot_get_least",
        "body": "{\n        var downstreamRoute = new DownstreamRouteBuilder()\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build();\n\n        var serviceProviderConfig = new ServiceProviderConfigurationBuilder()\n           .Build();\n\n        this.Given(x => x.GivenTheDownStreamUrlIs(\"http://my.url/abc?q=123\"))\n            .And(x => GivenTheConfigurationIs(serviceProviderConfig))\n            .And(x => x.GivenTheDownStreamRouteIs(downstreamRoute, new List<Ocelot.DownstreamRouteFinder.UrlMatcher.PlaceholderNameAndValue>()))\n            .And(x => x.GivenTheLoadBalancerHouseReturns())\n            .And(x => x.GivenTheLoadBalancerReturnsAnError())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenAnErrorStatingHostAndPortCouldNotBeFoundIsSetOnPipeline())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_set_scheme",
        "body": "{\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build();\n\n        var serviceProviderConfig = new ServiceProviderConfigurationBuilder()\n            .Build();\n\n        this.Given(x => x.GivenTheDownStreamUrlIs(\"http://my.url/abc?q=123\"))\n            .And(x => GivenTheConfigurationIs(serviceProviderConfig))\n            .And(x => x.GivenTheDownStreamRouteIs(downstreamRoute, new List<Ocelot.DownstreamRouteFinder.UrlMatcher.PlaceholderNameAndValue>()))\n            .And(x => x.GivenTheLoadBalancerHouseReturns())\n            .And(x => x.GivenTheLoadBalancerReturnsOk())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenAnHostAndPortIsSetOnPipeline())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "LoadBalancerOptionsTests.cs",
    "methods": [
      {
        "name": "should_default_to_no_load_balancer",
        "body": "{\n        var options = new LoadBalancerOptionsBuilder().Build();\n        options.Type.ShouldBe(nameof(NoLoadBalancer));\n    }"
      }
    ]
  },
  {
    "file": "NoLoadBalancerCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_instance_of_expected_load_balancer_type",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenARoute(route))\r\n            .When(x => x.WhenIGetTheLoadBalancer())\r\n            .Then(x => x.ThenTheLoadBalancerIsReturned<NoLoadBalancer>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_expected_name",
        "body": "{\r\n        this.When(x => x.WhenIGetTheLoadBalancerTypeName())\r\n            .Then(x => x.ThenTheLoadBalancerTypeIs(\"NoLoadBalancer\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "NoLoadBalancerTests.cs",
    "methods": [
      {
        "name": "should_return_host_and_port",
        "body": "{\n        var hostAndPort = new ServiceHostAndPort(\"127.0.0.1\", 80);\n\n        var services = new List<Service>\n        {\n            new(\"product\", hostAndPort, string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        this.Given(x => x.GivenServices(services))\n            .When(x => x.WhenIGetTheNextHostAndPort())\n            .Then(x => x.ThenTheHostAndPortIs(hostAndPort))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_if_no_services",
        "body": "{\n        this.When(x => x.WhenIGetTheNextHostAndPort())\n            .Then(x => x.ThenThereIsAnError())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_if_no_services_then_when_services_available_return_host_and_port",
        "body": "{\n        var hostAndPort = new ServiceHostAndPort(\"127.0.0.1\", 80);\n\n        var services = new List<Service>\n        {\n            new(\"product\", hostAndPort, string.Empty, string.Empty, Array.Empty<string>()),\n        };\n\n        this.Given(_ => WhenIGetTheNextHostAndPort())\n            .And(_ => ThenThereIsAnError())\n            .And(_ => GivenServices(services))\n            .When(_ => WhenIGetTheNextHostAndPort())\n            .Then(_ => ThenTheHostAndPortIs(hostAndPort))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_if_null_services",
        "body": "{\n        this.Given(x => x.GivenServicesAreNull())\n            .When(x => x.WhenIGetTheNextHostAndPort())\n            .Then(x => x.ThenThereIsAnError())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "RoundRobinCreatorTests.cs",
    "methods": [
      {
        "name": "should_return_instance_of_expected_load_balancer_type",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenARoute(route))\r\n            .When(x => x.WhenIGetTheLoadBalancer())\r\n            .Then(x => x.ThenTheLoadBalancerIsReturned<RoundRobin>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_expected_name",
        "body": "{\r\n        this.When(x => x.WhenIGetTheLoadBalancerTypeName())\r\n            .Then(x => x.ThenTheLoadBalancerTypeIs(\"RoundRobin\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "RoundRobinTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        var services = GivenServices();\n        var roundRobin = GivenLoadBalancer(services);\n\n        var response0 = await WhenIGetTheNextAddressAsync(roundRobin);\n        var response1 = await WhenIGetTheNextAddressAsync(roundRobin);\n        var response2 = await WhenIGetTheNextAddressAsync(roundRobin);\n\n        response0.Data.ShouldNotBeNull().ShouldBe(services[0].HostAndPort);\n        response1.Data.ShouldNotBeNull().ShouldBe(services[1].HostAndPort);\n        response2.Data.ShouldNotBeNull().ShouldBe(services[2].HostAndPort);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var services = GivenServices();\n        var roundRobin = GivenLoadBalancer(services);\n        var stopWatch = Stopwatch.StartNew();\n        while (stopWatch.ElapsedMilliseconds < 1000)\n        {\n            var response0 = await WhenIGetTheNextAddressAsync(roundRobin);\n            var response1 = await WhenIGetTheNextAddressAsync(roundRobin);\n            var response2 = await WhenIGetTheNextAddressAsync(roundRobin);\n\n            response0.Data.ShouldNotBeNull().ShouldBe(services[0].HostAndPort);\n            response1.Data.ShouldNotBeNull().ShouldBe(services[1].HostAndPort);\n            response2.Data.ShouldNotBeNull().ShouldBe(services[2].HostAndPort);\n        }\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var invalidServices = new List<Service> { null };\n        var roundRobin = GivenLoadBalancer(invalidServices);\n        var response = await WhenIGetTheNextAddressAsync(roundRobin);\n        ThenServicesAreNullErrorIsReturned(response);\n    }"
      }
    ]
  },
  {
    "file": "OcelotDiagnosticListenerTests.cs",
    "methods": [
      {
        "name": "should_trace_middleware_started",
        "body": "{\n        this.Given(_ => GivenAMiddlewareName())\n            .When(_ => WhenMiddlewareStartedCalled())\n            .Then(_ => ThenTheLogIs($\"MiddlewareStarting: {_name}; {_httpContext.Request.Path}\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_trace_middleware_finished",
        "body": "{\n        this.Given(_ => GivenAMiddlewareName())\n            .When(_ => WhenMiddlewareFinishedCalled())\n            .Then(_ => ThenTheLogIs($\"MiddlewareFinished: {_name}; {_httpContext.Response.StatusCode}\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_trace_middleware_exception",
        "body": "{\n        this.Given(_ => GivenAMiddlewareName())\n            .And(_ => GivenAException(new Exception(\"oh no\")))\n            .When(_ => WhenMiddlewareExceptionCalled())\n            .Then(_ => ThenTheLogIs($\"MiddlewareException: {_name}; {_exception.Message};\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OcelotLoggerTests.cs",
    "methods": [
      {
        "name": "Should_log_trace",
        "body": "{\n        _logger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(\n            \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\",\n            LogLevel.Trace);\n    }"
      },
      {
        "name": "Should_log_info",
        "body": "{\n        _logger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(\n            \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\",\n            LogLevel.Information);\n    }"
      },
      {
        "name": "Should_log_warning",
        "body": "{\n        _logger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(\n            \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\",\n            LogLevel.Warning);\n    }"
      },
      {
        "name": "Should_log_error",
        "body": "{\n        _logger.LogError(() => $\"a message from {_a} to {_b}\", _ex);\n\n        ThenLevelIsLogged(\n            \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\",\n            LogLevel.Error, _ex);\n    }"
      },
      {
        "name": "Should_log_critical",
        "body": "{\n        _logger.LogCritical(() => $\"a message from {_a} to {_b}\", _ex);\n\n        ThenLevelIsLogged(\n            \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\",\n            LogLevel.Critical, _ex);\n    }"
      },
      {
        "name": "If_minimum_log_level_not_set_then_log_is_called_for_information_and_above",
        "body": "{\n        var mockedILogger = MockLogger(null);\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      },
      {
        "name": "If_minimum_log_level_set_to_none_then_log_method_is_never_called",
        "body": "{\n        var mockedILogger = MockLogger(LogLevel.None);\n\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      },
      {
        "name": "If_minimum_log_level_set_to_trace_then_log_is_called_for_trace_and_above",
        "body": "{\n        var mockedILogger = MockLogger(LogLevel.Trace);\n\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      },
      {
        "name": "String_func_is_never_called_when_log_level_is_disabled",
        "body": "{\n        var mockedFunc = new Mock<Func<string>>();\n        mockedFunc.Setup(x => x.Invoke()).Returns(\"test\").Verifiable();\n        var mockedILogger = MockLogger(LogLevel.None);\n        var repo = new Mock<IRequestScopedDataRepository>();\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogTrace(mockedFunc.Object);\n\n        mockedFunc.Verify(x => x.Invoke(), Times.Never);\n    }"
      },
      {
        "name": "String_func_is_called_once_when_log_level_is_enabled",
        "body": "{\n        var mockedFunc = new Mock<Func<string>>();\n        mockedFunc.Setup(x => x.Invoke()).Returns(\"test\").Verifiable();\n        var mockedILogger = MockLogger(LogLevel.Information);\n        var repo = new Mock<IRequestScopedDataRepository>();\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogInformation(mockedFunc.Object);\n\n        mockedFunc.Verify(x => x.Invoke(), Times.Once);\n    }"
      },
      {
        "name": "If_minimum_log_level_set_to_debug_then_log_is_called_for_debug_and_above",
        "body": "{\n        var mockedILogger = MockLogger(LogLevel.Debug);\n\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      },
      {
        "name": "If_minimum_log_level_set_to_warning_then_log_is_called_for_warning_and_above",
        "body": "{\n        var mockedILogger = MockLogger(LogLevel.Warning);\n\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      },
      {
        "name": "If_minimum_log_level_set_to_error_then_log_is_called_for_error_and_above",
        "body": "{\n        var mockedILogger = MockLogger(LogLevel.Error);\n\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      },
      {
        "name": "If_minimum_log_level_set_to_critical_then_log_is_called_for_critical_and_above",
        "body": "{\n        var mockedILogger = MockLogger(LogLevel.Critical);\n\n        var repo = new Mock<IRequestScopedDataRepository>();\n\n        var currentLogger = new OcelotLogger(mockedILogger.Object, repo.Object);\n\n        currentLogger.LogDebug(() => $\"a message from {_a} to {_b}\");\n        var expected = \"requestId: No RequestId, previousRequestId: No PreviousRequestId, message: 'a message from tom to laura'\";\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Debug);\n\n        currentLogger.LogTrace(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Trace);\n\n        currentLogger.LogInformation(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Information);\n\n        currentLogger.LogWarning(() => $\"a message from {_a} to {_b}\");\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Warning);\n\n        var testException = new Exception(\"test\");\n\n        currentLogger.LogError(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsNotLogged(mockedILogger, expected, LogLevel.Error, testException);\n\n        currentLogger.LogCritical(() => $\"a message from {_a} to {_b}\", testException);\n\n        ThenLevelIsLogged(mockedILogger, expected, LogLevel.Critical, testException);\n    }"
      }
    ]
  },
  {
    "file": "BaseUrlFinderTests.cs",
    "methods": [
      {
        "name": "should_use_default_base_url",
        "body": "{\r\n        this.When(x => WhenIFindTheUrl())\r\n            .Then(x => ThenTheUrlIs(\"http://localhost:5000\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_memory_config_base_url",
        "body": "{\r\n        this.Given(x => GivenTheMemoryBaseUrlIs(\"http://baseurlfromconfig.com:5181\"))\r\n            .When(x => WhenIFindTheUrl())\r\n            .Then(x => ThenTheUrlIs(\"http://baseurlfromconfig.com:5181\"))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_use_file_config_base_url",
        "body": "{\r\n        this.Given(x => GivenTheMemoryBaseUrlIs(\"http://localhost:7000\"))\r\n            .And(x => GivenTheFileBaseUrlIs(\"http://baseurlfromconfig.com:5181\"))\r\n            .When(x => WhenIFindTheUrl())\r\n            .Then(x => ThenTheUrlIs(\"http://baseurlfromconfig.com:5181\"))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "OcelotPipelineExtensionsTests.cs",
    "methods": [
      {
        "name": "should_set_up_pipeline",
        "body": "{\n        this.Given(_ => GivenTheDepedenciesAreSetUp())\n             .When(_ => WhenIBuild())\n             .Then(_ => ThenThePipelineIsBuilt())\n             .BDDfy();\n    }"
      },
      {
        "name": "should_expand_pipeline",
        "body": "{\n        this.Given(_ => GivenTheDepedenciesAreSetUp())\n             .When(_ => WhenIExpandBuild())\n             .Then(_ => ThenThePipelineIsBuilt())\n             .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OcelotPiplineBuilderTests.cs",
    "methods": [
      {
        "name": "should_build_generic",
        "body": "{\n        this.When(x => WhenIUseAGeneric())\n            .Then(x => ThenTheGenericIsInThePipeline())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_build_func",
        "body": "{\n        this.When(x => WhenIUseAFunc())\n            .Then(x => ThenTheFuncIsInThePipeline())\n            .BDDfy();\n    }"
      },
      {
        "name": "Middleware_Multi_Parameters_Invoke",
        "body": "{\n        var provider = _services.BuildServiceProvider(true);\n        IApplicationBuilder builder = new ApplicationBuilder(provider);\n        builder = builder.UseMiddleware<MultiParametersInvokeMiddleware>();\n        var del = builder.Build();\n        del.Invoke(_httpContext);\n    }"
      }
    ]
  },
  {
    "file": "DefinedAggregatorProviderTests.cs",
    "methods": [
      {
        "name": "should_find_aggregator",
        "body": "{\r\n        var route = new RouteBuilder()\r\n            .WithAggregator(\"TestDefinedAggregator\")\r\n            .Build();\r\n\r\n        this.Given(_ => GivenDefinedAggregator())\r\n            .And(_ => GivenRoute(route))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheAggregatorIsReturned())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_not_find_aggregator",
        "body": "{\r\n        var route = new RouteBuilder()\r\n            .WithAggregator(\"TestDefinedAggregator\")\r\n            .Build();\r\n\r\n        this.Given(_ => GivenNoDefinedAggregator())\r\n            .And(_ => GivenRoute(route))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenAnErrorIsReturned())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "MultiplexingMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_multiplex",
        "body": "{\n        var route = GivenDefaultRoute(2);\n        this.Given(x => GivenTheFollowing(route))\n            .When(x => WhenIMultiplex())\n            .Then(x => ThePipelineIsCalled(2))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_multiplex",
        "body": "{\n        var route = new RouteBuilder().WithDownstreamRoute(new DownstreamRouteBuilder().Build()).Build();\n\n        this.Given(x => GivenTheFollowing(route))\n            .When(x => WhenIMultiplex())\n            .Then(x => ThePipelineIsCalled(1))\n            .BDDfy();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var route = new DownstreamRouteBuilder().Build();\r\n\n        // Arrange\n        GivenUser(\"test\", \"Copy\", nameof(CreateThreadContextAsync_CopyUser_ToTarget));\n\n        // Act\n        var method = _middleware.GetType().GetMethod(\"CreateThreadContextAsync\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var actual = await (Task<HttpContext>)method.Invoke(_middleware, new object[] { _httpContext, route });\n\n        // Assert\n        AssertUsers(actual);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Create\n        HttpContext actualContext = null;\n        _middleware = new MultiplexingMiddleware(NextMe, loggerFactory.Object, factory.Object);\n        Task NextMe(HttpContext context)\n        {\n            actualContext = context;\n            return Next(context);\n        }\n\n        // Arrange\n        GivenUser(\"test\", \"Invoke\", nameof(Invoke_ContextUser_ForwardedToDownstreamContext));\n        GivenTheFollowing(GivenDefaultRoute(2));\n\n        // Act\n        await WhenIMultiplex();\n\n        // Assert\n        ThePipelineIsCalled(2);\n        AssertUsers(actualContext);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        _middleware = new MultiplexingMiddleware(NextMe, loggerFactory.Object, factory.Object);\n        Task NextMe(HttpContext context)\n        {\n            Assert.Equal(_httpContext, context);\n            return Next(context);\n        }\n\n        // Arrange\n        GivenUser(\"test\", \"Invoke\", nameof(Should_Not_Copy_Context_If_One_Downstream_Route));\n        GivenTheFollowing(GivenDefaultRoute(1));\n\n        // Act\n        await WhenIMultiplex();\n\n        // Assert\n        ThePipelineIsCalled(1);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var mock = MockMiddlewareFactory(null, null);\n\n        _middleware = mock.Object;\n\n        // Arrange\n        GivenUser(\"test\", \"Invoke\", nameof(Should_Call_ProcessSingleRoute_Once_If_One_Downstream_Route));\n        GivenTheFollowing(GivenDefaultRoute(1));\n\n        // Act\n        await WhenIMultiplex();\n\n        // Assert\n        mock.Protected().Verify<Task>(\"ProcessSingleRouteAsync\", Times.Once(),\n            ItExpr.IsAny<HttpContext>(),\n            ItExpr.IsAny<DownstreamRoute>());\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var mock = MockMiddlewareFactory(null, null);\n\n        // Arrange\n        GivenUser(\"test\", \"Invoke\", nameof(Should_Not_Call_ProcessSingleRoute_Or_Map_If_No_Route));\n        GivenTheFollowing(GivenDefaultRoute(0));\n\n        // Act\n        await WhenIMultiplex();\n\n        // Assert\n        mock.Protected().Verify<Task>(\"ProcessSingleRouteAsync\", Times.Never(),\n            ItExpr.IsAny<HttpContext>(),\n            ItExpr.IsAny<DownstreamRoute>());\n\n        mock.Protected().Verify<Task>(\"MapAsync\", Times.Never(),\n            ItExpr.IsAny<HttpContext>(),\n            ItExpr.IsAny<Route>(),\n            ItExpr.IsAny<List<HttpContext>>());\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var mock = MockMiddlewareFactory(null, AggregateRequestDelegateFactory());\n\n        // Arrange\n        GivenUser(\"test\", \"Invoke\", nameof(If_Using_3_Routes_WithAggregator_ProcessSingleRoute_Is_Never_Called_Map_Once_And_Pipeline_3_Times));\n        GivenTheFollowing(GivenRoutesWithAggregator());\n\n        // Act\n        await WhenIMultiplex();\n\n        mock.Protected().Verify<Task>(\"ProcessSingleRouteAsync\", Times.Never(),\n            ItExpr.IsAny<HttpContext>(),\n            ItExpr.IsAny<DownstreamRoute>());\n\n        mock.Protected().Verify<Task>(\"MapAsync\", Times.Once(),\n            ItExpr.IsAny<HttpContext>(),\n            ItExpr.IsAny<Route>(),\n            ItExpr.IsAny<List<HttpContext>>());\n\n        ThePipelineIsCalled(3);\n    }"
      }
    ]
  },
  {
    "file": "ResponseAggregatorFactoryTests.cs",
    "methods": [
      {
        "name": "should_return_simple_json_aggregator",
        "body": "{\r\n        var route = new RouteBuilder()\r\n            .Build();\r\n\r\n        this.Given(_ => GivenRoute(route))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheAggregatorIs<SimpleJsonResponseAggregator>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_user_defined_aggregator",
        "body": "{\r\n        var route = new RouteBuilder()\r\n            .WithAggregator(\"doesntmatter\")\r\n            .Build();\r\n\r\n        this.Given(_ => GivenRoute(route))\r\n            .When(_ => WhenIGet())\r\n            .Then(_ => ThenTheAggregatorIs<UserDefinedResponseAggregator>())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "SimpleJsonResponseAggregatorTests.cs",
    "methods": [
      {
        "name": "should_aggregate_n_responses_and_set_response_content_on_upstream_context_withConfig",
        "body": "{\n        var commentsDownstreamRoute = new DownstreamRouteBuilder().WithKey(\"Comments\").Build();\n\n        var userDetailsDownstreamRoute = new DownstreamRouteBuilder().WithKey(\"UserDetails\")\n            .WithUpstreamPathTemplate(new UpstreamPathTemplate(string.Empty, 0, false, \"/v1/users/{userId}\"))\n            .Build();\n\n        var downstreamRoutes = new List<DownstreamRoute>\n        {\n            commentsDownstreamRoute,\n            userDetailsDownstreamRoute,\n        };\n\n        var route = new RouteBuilder()\n            .WithDownstreamRoutes(downstreamRoutes)\n            .WithAggregateRouteConfig(new List<AggregateRouteConfig>\n            {\n                new(){RouteKey = \"UserDetails\",JsonPath = \"$[*].writerId\",Parameter = \"userId\"},\n            })\n            .Build();\n\n        var commentsResponseContent = @\"[{string.Emptyidstring.Empty:1,string.EmptywriterIdstring.Empty:1,string.EmptypostIdstring.Empty:1,string.Emptytextstring.Empty:string.Emptytext1string.Empty},{string.Emptyidstring.Empty:2,string.EmptywriterIdstring.Empty:2,string.EmptypostIdstring.Empty:2,string.Emptytextstring.Empty:string.Emptytext2string.Empty},{string.Emptyidstring.Empty:3,string.EmptywriterIdstring.Empty:2,string.EmptypostIdstring.Empty:1,string.Emptytextstring.Empty:string.Emptytext21string.Empty}]\";\n\n        var commentsDownstreamContext = new DefaultHttpContext();\n        commentsDownstreamContext.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(commentsResponseContent, Encoding.UTF8, \"application/json\"), HttpStatusCode.OK, new EditableList<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n        commentsDownstreamContext.Items.UpsertDownstreamRoute(commentsDownstreamRoute);\n\n        var userDetailsResponseContent = @\"[{string.Emptyidstring.Empty:1,string.EmptyfirstNamestring.Empty:string.Emptyabolfazlstring.Empty,string.EmptylastNamestring.Empty:string.Emptyrajabpourstring.Empty},{string.Emptyidstring.Empty:2,string.EmptyfirstNamestring.Empty:string.Emptyrezastring.Empty,string.EmptylastNamestring.Empty:string.Emptyrezaeistring.Empty}]\";\n        var userDetailsDownstreamContext = new DefaultHttpContext();\n        userDetailsDownstreamContext.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(userDetailsResponseContent, Encoding.UTF8, \"application/json\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n        userDetailsDownstreamContext.Items.UpsertDownstreamRoute(userDetailsDownstreamRoute);\n\n        var downstreamContexts = new List<HttpContext> { commentsDownstreamContext, userDetailsDownstreamContext };\n\n        var expected = \"{\\\"Comments\\\":\" + commentsResponseContent + \",\\\"UserDetails\\\":\" + userDetailsResponseContent + \"}\";\n\n        this.Given(x => GivenTheUpstreamContext(new DefaultHttpContext()))\n            .And(x => GivenTheRoute(route))\n            .And(x => GivenTheDownstreamContext(downstreamContexts))\n            .When(x => WhenIAggregate())\n            .Then(x => ThenTheContentIs(expected))\n            .And(x => ThenTheContentTypeIs(\"application/json\"))\n            .And(x => ThenTheReasonPhraseIs(\"cannot return from aggregate..which reason phrase would you use?\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_aggregate_n_responses_and_set_response_content_on_upstream_context",
        "body": "{\n        var billDownstreamRoute = new DownstreamRouteBuilder().WithKey(\"Bill\").Build();\n\n        var georgeDownstreamRoute = new DownstreamRouteBuilder().WithKey(\"George\").Build();\n\n        var downstreamRoutes = new List<DownstreamRoute>\n        {\n            billDownstreamRoute,\n            georgeDownstreamRoute,\n        };\n\n        var route = new RouteBuilder()\n            .WithDownstreamRoutes(downstreamRoutes)\n            .Build();\n\n        var billDownstreamContext = new DefaultHttpContext();\n        billDownstreamContext.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Bill says hi\"), HttpStatusCode.OK, new EditableList<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n        billDownstreamContext.Items.UpsertDownstreamRoute(billDownstreamRoute);\n\n        var georgeDownstreamContext = new DefaultHttpContext();\n        georgeDownstreamContext.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"George says hi\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n        georgeDownstreamContext.Items.UpsertDownstreamRoute(georgeDownstreamRoute);\n\n        var downstreamContexts = new List<HttpContext> { billDownstreamContext, georgeDownstreamContext };\n\n        var expected = \"{\\\"Bill\\\":Bill says hi,\\\"George\\\":George says hi}\";\n\n        this.Given(x => GivenTheUpstreamContext(new DefaultHttpContext()))\n            .And(x => GivenTheRoute(route))\n            .And(x => GivenTheDownstreamContext(downstreamContexts))\n            .When(x => WhenIAggregate())\n            .Then(x => ThenTheContentIs(expected))\n            .And(x => ThenTheContentTypeIs(\"application/json\"))\n            .And(x => ThenTheReasonPhraseIs(\"cannot return from aggregate..which reason phrase would you use?\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error_if_any_downstreams_have_errored",
        "body": "{\n        var billDownstreamRoute = new DownstreamRouteBuilder().WithKey(\"Bill\").Build();\n\n        var georgeDownstreamRoute = new DownstreamRouteBuilder().WithKey(\"George\").Build();\n\n        var downstreamRoutes = new List<DownstreamRoute>\n        {\n            billDownstreamRoute,\n            georgeDownstreamRoute,\n        };\n\n        var route = new RouteBuilder()\n            .WithDownstreamRoutes(downstreamRoutes)\n            .Build();\n\n        var billDownstreamContext = new DefaultHttpContext();\n        billDownstreamContext.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Bill says hi\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n        billDownstreamContext.Items.UpsertDownstreamRoute(billDownstreamRoute);\n\n        var georgeDownstreamContext = new DefaultHttpContext();\n        georgeDownstreamContext.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Error\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n        georgeDownstreamContext.Items.UpsertDownstreamRoute(georgeDownstreamRoute);\n\n        georgeDownstreamContext.Items.SetError(new AnyError());\n\n        var downstreamContexts = new List<HttpContext> { billDownstreamContext, georgeDownstreamContext };\n\n        var expected = \"Error\";\n\n        this.Given(x => GivenTheUpstreamContext(new DefaultHttpContext()))\n            .And(x => GivenTheRoute(route))\n            .And(x => GivenTheDownstreamContext(downstreamContexts))\n            .When(x => WhenIAggregate())\n            .Then(x => ThenTheContentIs(expected))\n            .And(x => ThenTheErrorIsMapped())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "UserDefinedResponseAggregatorTests.cs",
    "methods": [
      {
        "name": "should_call_aggregator",
        "body": "{\n        var route = new RouteBuilder().Build();\n\n        var context = new DefaultHttpContext();\n\n        var contextA = new DefaultHttpContext();\n        contextA.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Tom\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n\n        var contextB = new DefaultHttpContext();\n        contextB.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Laura\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n\n        var contexts = new List<HttpContext>\n        {\n            contextA,\n            contextB,\n        };\n\n        this.Given(_ => GivenTheProviderReturnsAggregator())\n            .And(_ => GivenRoute(route))\n            .And(_ => GivenContexts(contexts))\n            .And(_ => GivenContext(context))\n            .When(_ => WhenIAggregate())\n            .Then(_ => ThenTheProviderIsCalled())\n            .And(_ => ThenTheContentIsCorrect())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_find_aggregator",
        "body": "{\n        var route = new RouteBuilder().Build();\n\n        var context = new DefaultHttpContext();\n\n        var contextA = new DefaultHttpContext();\n        contextA.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Tom\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n\n        var contextB = new DefaultHttpContext();\n        contextB.Items.UpsertDownstreamResponse(new DownstreamResponse(new StringContent(\"Laura\"), HttpStatusCode.OK, new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\"));\n\n        var contexts = new List<HttpContext>\n        {\n            contextA,\n            contextB,\n        };\n\n        this.Given(_ => GivenTheProviderReturnsError())\n            .And(_ => GivenRoute(route))\n            .And(_ => GivenContexts(contexts))\n            .And(_ => GivenContext(context))\n            .When(_ => WhenIAggregate())\n            .Then(_ => ThenTheProviderIsCalled())\n            .And(_ => ThenTheErrorIsReturned())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "OcelotBuilderExtensionsTests.cs",
    "methods": [
      {
        "name": "should_set_up_cache_manager",
        "body": "{\n        this.Given(x => WhenISetUpOcelotServices())\n            .When(x => WhenISetUpCacheManager())\n            .Then(x => ThenAnExceptionIsntThrown())\n            .And(x => OnlyOneVersionOfEachCacheIsRegistered())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "PollyQoSResiliencePipelineProviderTests.cs",
    "methods": [
      {
        "name": "ShouldBuild",
        "body": "{\n        // Arrange\n        var options = new QoSOptionsBuilder()\n            .WithTimeoutValue(1000) // 10ms, minimum required by Polly\n            .WithExceptionsAllowedBeforeBreaking(2) // 2 is the minimum required by Polly\n            .WithDurationOfBreak(QoSOptions.LowBreakDuration + 1) // 0.5s, minimum required by Polly\n            .Build();\n        var route = new DownstreamRouteBuilder()\n            .WithQosOptions(options)\n            .Build();\n        var loggerFactoryMock = new Mock<IOcelotLoggerFactory>();\n        var registry = new ResiliencePipelineRegistry<OcelotResiliencePipelineKey>();\n        var provider = new PollyQoSResiliencePipelineProvider(loggerFactoryMock.Object, registry);\n\n        // Act\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n\n        // Assert\n        resiliencePipeline.ShouldNotBeNull();\n        resiliencePipeline.ShouldBeOfType<ResiliencePipeline<HttpResponseMessage>>();\n        resiliencePipeline.ShouldNotBe(ResiliencePipeline<HttpResponseMessage>.Empty);\n    }"
      },
      {
        "name": "ShouldNotBuild_ReturnedEmpty",
        "body": "{\n        // Arrange\n        var options = new QoSOptionsBuilder().Build(); // empty options\n        var route = new DownstreamRouteBuilder()\n            .WithQosOptions(options)\n            .Build();\n        var loggerFactoryMock = new Mock<IOcelotLoggerFactory>();\n        var registry = new ResiliencePipelineRegistry<OcelotResiliencePipelineKey>();\n        var provider = new PollyQoSResiliencePipelineProvider(loggerFactoryMock.Object, registry);\n\n        // Act\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n\n        // Assert\n        resiliencePipeline.ShouldNotBeNull();\n        resiliencePipeline.ShouldBeOfType<ResiliencePipeline<HttpResponseMessage>>();\n        resiliencePipeline.ShouldBe(ResiliencePipeline<HttpResponseMessage>.Empty);\n    }"
      },
      {
        "name": "Should_return_same_circuit_breaker_for_given_route",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route1 = GivenDownstreamRoute(\"/\");\n        var route2 = GivenDownstreamRoute(\"/\");\n\n        // Act\n        var resiliencePipeline1 = provider.GetResiliencePipeline(route1);\n        var resiliencePipeline2 = provider.GetResiliencePipeline(route2);\n\n        // Assert\n        resiliencePipeline1.ShouldBe(resiliencePipeline2);\n\n        // Act 2\n        var resiliencePipeline3 = provider.GetResiliencePipeline(route1);\n\n        // Assert 2\n        resiliencePipeline3.ShouldBe(resiliencePipeline1);\n        resiliencePipeline3.ShouldBe(resiliencePipeline2);\n    }"
      },
      {
        "name": "Should_return_different_circuit_breaker_for_two_different_routes",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route1 = GivenDownstreamRoute(\"/\");\n        var route2 = GivenDownstreamRoute(\"/test\");\n\n        // Act\n        var resiliencePipeline1 = provider.GetResiliencePipeline(route1);\n        var resiliencePipeline2 = provider.GetResiliencePipeline(route2);\n\n        // Assert\n        resiliencePipeline1.ShouldNotBe(resiliencePipeline2);\n    }"
      },
      {
        "name": "ShouldBuild_ContainsTwoStrategies",
        "body": "{\n        var pollyQoSResiliencePipelineProvider = GivenProvider();\n\n        var route = GivenDownstreamRoute(\"/\");\n        var resiliencePipeline = pollyQoSResiliencePipelineProvider.GetResiliencePipeline(route);\n        resiliencePipeline.ShouldNotBeNull();\n\n        var descriptor = resiliencePipeline.GetPipelineDescriptor();\n        descriptor.ShouldNotBeNull();\n        descriptor.Strategies.Count.ShouldBe(2);\n        descriptor.Strategies[0].Options.ShouldBeOfType<CircuitBreakerStrategyOptions<HttpResponseMessage>>();\n        descriptor.Strategies[1].Options.ShouldBeOfType<TimeoutStrategyOptions>();\n    }"
      },
      {
        "name": "Should_build_and_contains_one_policy_when_with_exceptions_allowed_before_breaking_is_zero",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route = GivenDownstreamRoute(\"/\", true); // get route with 0 exceptions allowed before breaking\n\n        // Act\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var descriptor = resiliencePipeline.GetPipelineDescriptor();\n\n        // Assert\n        resiliencePipeline.ShouldNotBeNull();\n        descriptor.ShouldNotBeNull();\n        descriptor.Strategies.Count.ShouldBe(1);\n        descriptor.Strategies.Single().Options.ShouldBeOfType<TimeoutStrategyOptions>();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        const int timeOut = 1000;\n        var route = GivenDownstreamRoute(\"/\", false, timeOut);\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.OK);\n        var cancellationTokenSource = new CancellationTokenSource();\n\n        // Assert\n        await Assert.ThrowsAsync<TimeoutRejectedException>(async () =>\n\n            // Act\n            await resiliencePipeline.ExecuteAsync(async (cancellationToken) =>\n            {\n                await Task.Delay(timeOut + 500, cancellationToken); // add 500ms to make sure it's timed out\n                return response;\n            },\n            cancellationTokenSource.Token));\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        const int timeOut = 1000;\n        var route = GivenDownstreamRoute(\"/\", false, timeOut);\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.OK);\n        var cancellationTokenSource = new CancellationTokenSource();\n\n        // Act\n        await resiliencePipeline.ExecuteAsync(async cancellationToken =>\n        {\n            await Task.Delay(timeOut - 100, cancellationToken); // subtract 100ms to make sure it's not timed out\n            return response;\n        }, cancellationTokenSource.Token);\n\n        // Assert\n        Assert.True(response.IsSuccessStatusCode);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route = GivenDownstreamRoute(\"/\");\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.OK);\n\n        // Act, Assert\n        Assert.Equal(HttpStatusCode.OK, (await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response))).StatusCode);\n        Assert.Equal(HttpStatusCode.OK, (await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response))).StatusCode);\n        Assert.Equal(HttpStatusCode.OK, (await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response))).StatusCode);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route = GivenDownstreamRoute(\"/\");\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.InternalServerError);\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n\n        // Act, Assert\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n\n        await Task.Delay(200);\n\n        // Act, Assert 2\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route = GivenDownstreamRoute(\"/\");\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.InternalServerError);\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n\n        // Act, Assert\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n\n        await Task.Delay(6000);\n\n        // Act 2\n        var response2 = await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n\n        // Assert 2\n        Assert.Equal(HttpStatusCode.InternalServerError, response2.StatusCode);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route = GivenDownstreamRoute(\"/\");\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.InternalServerError);\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n\n        // Act, Assert\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n\n        await Task.Delay(6000);\n\n        // Act, Assert 2\n        Assert.Equal(HttpStatusCode.InternalServerError, (await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response))).StatusCode);\n\n        // Act, Assert 3\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var provider = GivenProvider();\n        var route = GivenDownstreamRoute(\"/\");\n        var resiliencePipeline = provider.GetResiliencePipeline(route);\n        var response = new HttpResponseMessage(HttpStatusCode.InternalServerError);\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n\n        // Act, Assert\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n\n        await Task.Delay(10000);\n\n        // Act, Assert 2\n        var response2 = new HttpResponseMessage(HttpStatusCode.OK);\n        Assert.Equal(HttpStatusCode.OK, (await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response2))).StatusCode);\n\n        // Act, Assert 3\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n        await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response));\n        await Assert.ThrowsAsync<BrokenCircuitException>(async () =>\n            await resiliencePipeline.ExecuteAsync((_) => ValueTask.FromResult(response)));\n    }"
      }
    ]
  },
  {
    "file": "PollyResiliencePipelineDelegatingHandlerTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var fakeResponse = new HttpResponseMessage(HttpStatusCode.NoContent);\n        fakeResponse.Headers.Add(\"X-Xunit\", nameof(SendAsync_OnePolicy));\n\n        // setup the inner handler for PollyResiliencePipelineDelegatingHandler\n        var innerHandler = new Mock<DelegatingHandler>();\n        innerHandler.Protected()\n            .Setup<Task<HttpResponseMessage>>(\"SendAsync\", ItExpr.IsAny<HttpRequestMessage>(), ItExpr.IsAny<CancellationToken>())\n            .ReturnsAsync(fakeResponse);\n        _sut.InnerHandler = innerHandler.Object;\n\n        // setup the resilience pipeline eg: retry policy\n        var resiliencePipeline = new ResiliencePipelineBuilder<HttpResponseMessage>()\n            .AddRetry(new RetryStrategyOptions<HttpResponseMessage>\n            {\n                ShouldHandle = new PredicateBuilder<HttpResponseMessage>().Handle<Exception>(),\n            })\n            .Build();\n\n        _pollyQoSResiliencePipelineProviderMock\n            .Setup(x => x.GetResiliencePipeline(It.IsAny<DownstreamRoute>()))\n            .Returns(resiliencePipeline);\n\n        var httpContext = new Mock<HttpContext>();\n        httpContext\n            .Setup(x => x.RequestServices.GetService(typeof(IPollyQoSResiliencePipelineProvider<HttpResponseMessage>)))\n            .Returns(_pollyQoSResiliencePipelineProviderMock.Object);\n\n        _contextAccessorMock\n            .Setup(x => x.HttpContext)\n            .Returns(httpContext.Object);\n\n        // Act\n        var actual = await InvokeAsync(\"SendAsync\");\n\n        // Assert\n        ShouldHaveXunitHeaderWithNoContent(actual, nameof(SendAsync_OnePolicy));\n\n        // TODO: do more checks\n        // check that the pipeline provider was called only once\n        _pollyQoSResiliencePipelineProviderMock\n            .Verify(a => a.GetResiliencePipeline(It.IsAny<DownstreamRoute>()), times: Times.Once);\n        _pollyQoSResiliencePipelineProviderMock\n            .VerifyNoOtherCalls();\n\n        // this check has no sense anymore\n        //method.DeclaringType.Name.ShouldBe(\"IAsyncPolicy`1\");\n        //method.DeclaringType.ShouldNotBeOfType<AsyncPolicyWrap>();\n    }"
      }
    ]
  },
  {
    "file": "AddQueriesToRequestTests.cs",
    "methods": [
      {
        "name": "should_add_new_queries_to_downstream_request",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"query-key\", string.Empty, string.Empty, 0),\n            }))\n            .Given(x => x.GivenClaims(claims))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIAddQueriesToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenTheQueryIsAdded())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_add_new_queries_to_downstream_request_and_preserve_other_queries",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"query-key\", string.Empty, string.Empty, 0),\n            }))\n            .Given(x => x.GivenClaims(claims))\n            .And(x => GivenTheDownstreamRequestHasQueryString(\"?test=1&test=2\"))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIAddQueriesToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenTheQueryIsAdded())\n            .And(x => TheTheQueryStringIs(\"?test=1&test=2&query-key=value\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_replace_existing_queries_on_downstream_request",
        "body": "{\n        var claims = new List<Claim>\n        {\n            new(\"test\", \"data\"),\n        };\n\n        this.Given(\n            x => x.GivenAClaimToThing(new List<ClaimToThing>\n            {\n                new(\"query-key\", string.Empty, string.Empty, 0),\n            }))\n            .And(x => x.GivenClaims(claims))\n            .And(x => x.GivenTheDownstreamRequestHasQueryString(\"query-key\", \"initial\"))\n            .And(x => x.GivenTheClaimParserReturns(new OkResponse<string>(\"value\")))\n            .When(x => x.WhenIAddQueriesToTheRequest())\n            .Then(x => x.ThenTheResultIsSuccess())\n            .And(x => x.ThenTheQueryIsAdded())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_error",
        "body": "{\n        this.Given(\n           x => x.GivenAClaimToThing(new List<ClaimToThing>\n           {\n                new(string.Empty, string.Empty, string.Empty, 0),\n           }))\n           .Given(x => x.GivenClaims(new List<Claim>()))\n           .And(x => x.GivenTheClaimParserReturns(new ErrorResponse<string>(new List<Error>\n           {\n               new AnyError(),\n           })))\n           .When(x => x.WhenIAddQueriesToTheRequest())\n           .Then(x => x.ThenTheResultIsError())\n           .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ClaimsToQueryStringMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_add_queries_correctly",
        "body": "{\n        var downstreamRoute = new Ocelot.DownstreamRouteFinder.DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithClaimsToQueries(new List<ClaimToThing>\n                    {\n                        new(\"UserId\", \"Subject\", string.Empty, 0),\n                    })\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => x.GivenTheAddHeadersToRequestReturnsOk())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheAddQueriesToRequestIsCalledCorrectly())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "RateLimitingMiddlewareTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        const long limit = 3L;\n        var upstreamTemplate = new UpstreamPathTemplateBuilder()\n            .Build();\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithEnableRateLimiting(true)\n            .WithRateLimitOptions(new(\n                enableRateLimiting: true,\n                clientIdHeader: \"ClientId\",\n                getClientWhitelist: () => new List<string>(),\n                disableRateLimitHeaders: false,\n                quotaExceededMessage: \"Exceeding!\",\n                rateLimitCounterPrefix: string.Empty,\n                new RateLimitRule(\"1s\", 100.0D, limit),\n                (int)HttpStatusCode.TooManyRequests))\n            .WithUpstreamHttpMethod(new() { \"Get\" })\n            .WithUpstreamPathTemplate(upstreamTemplate)\n            .Build();\n        var route = new RouteBuilder()\n            .WithDownstreamRoute(downstreamRoute)\n            .WithUpstreamHttpMethod(new() { \"Get\" })\n            .Build();\n        var downstreamRouteHolder = new _DownstreamRouteHolder_(new(), route);\n\n        // Act, Assert\n        await WhenICallTheMiddlewareMultipleTimes(limit, downstreamRouteHolder);\n        _downstreamResponses.ForEach(dsr => dsr.ShouldBeNull());\n\n        // Act, Assert: the next request should fail\n        await WhenICallTheMiddlewareMultipleTimes(3, downstreamRouteHolder);\n        _downstreamResponses.ShouldNotBeNull();\n        for (int i = 0; i < _downstreamResponses.Count; i++)\n        {\n            var response = _downstreamResponses[i].ShouldNotBeNull();\n            response.StatusCode.ShouldBe(HttpStatusCode.TooManyRequests, $\"Downstream Response no is {i}\");\n            var body = await response.Content.ReadAsStringAsync();\n            body.ShouldBe(\"Exceeding!\");\n        }\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        var route = new RouteBuilder()\n            .WithDownstreamRoute(new DownstreamRouteBuilder()\n                .WithEnableRateLimiting(true)\n                .WithRateLimitOptions(new(\n                    enableRateLimiting: true,\n                    clientIdHeader: \"ClientId\",\n                    getClientWhitelist: () => new List<string> { \"ocelotclient2\" },\n                    disableRateLimitHeaders: false,\n                    quotaExceededMessage: \"Exceeding!\",\n                    rateLimitCounterPrefix: string.Empty,\n                    new RateLimitRule(\"1s\", 100.0D, 3),\n                    (int)HttpStatusCode.TooManyRequests))\n                .WithUpstreamHttpMethod(new() { \"Get\" })\n                .Build())\n            .WithUpstreamHttpMethod(new() { \"Get\" })\n            .Build();\n        var downstreamRoute = new _DownstreamRouteHolder_(new(), route);\n\n        // Act\n        await WhenICallTheMiddlewareWithWhiteClient(downstreamRoute);\n\n        // Assert\n        _downstreamResponses.ForEach(dsr => dsr.ShouldBeNull());\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        // Arrange\n        const long limit = 100L;\n        var upstreamTemplate = new UpstreamPathTemplateBuilder()\n            .Build();\n        var downstreamRoute = new DownstreamRouteBuilder()\n            .WithEnableRateLimiting(true)\n            .WithRateLimitOptions(new(\n                enableRateLimiting: true,\n                clientIdHeader: \"ClientId\",\n                getClientWhitelist: () => new List<string>(),\n                disableRateLimitHeaders: false,\n                quotaExceededMessage: \"Exceeding!\",\n                rateLimitCounterPrefix: string.Empty,\n                new RateLimitRule(\"1s\", 30.0D, limit), // bug scenario\n                (int)HttpStatusCode.TooManyRequests))\n            .WithUpstreamHttpMethod(new() { \"Get\" })\n            .WithUpstreamPathTemplate(upstreamTemplate)\n            .Build();\n        var route = new RouteBuilder()\n            .WithDownstreamRoute(downstreamRoute)\n            .WithUpstreamHttpMethod(new() { \"Get\" })\n            .Build();\n        var downstreamRouteHolder = new _DownstreamRouteHolder_(new(), route);\n\n        // Act, Assert: 100 requests must be successful\n        var contexts = await WhenICallTheMiddlewareMultipleTimes(limit, downstreamRouteHolder); // make 100 requests, but not exceed the limit\n        _downstreamResponses.ForEach(dsr => dsr.ShouldBeNull());\n        contexts.ForEach(ctx =>\n        {\n            ctx.ShouldNotBeNull();\n            ctx.Items.Errors().ShouldNotBeNull().ShouldBeEmpty(); // no errors\n            ctx.Response.StatusCode.ShouldBe((int)HttpStatusCode.OK); // not 429 aka TooManyRequests\n        });\n\n        // Act, Assert: the next 101st request should fail\n        contexts = await WhenICallTheMiddlewareMultipleTimes(1, downstreamRouteHolder);\n        _downstreamResponses.ShouldNotBeNull();\n        var ds = _downstreamResponses.SingleOrDefault().ShouldNotBeNull();\n        ds.StatusCode.ShouldBe(HttpStatusCode.TooManyRequests, $\"Downstream Response no {limit + 1}\");\n        var body = await ds.Content.ReadAsStringAsync();\n        body.ShouldBe(\"Exceeding!\");\n        contexts[0].Items.Errors().ShouldNotBeNull().ShouldNotBeEmpty(); // having errors\n        contexts[0].Items.Errors().Single().HttpStatusCode.ShouldBe((int)HttpStatusCode.TooManyRequests);\n    }"
      }
    ]
  },
  {
    "file": "RateLimitingTests.cs",
    "methods": [
      {
        "name": "Count_NoEntry_StartCounting",
        "body": "{\n        // Arrange\n        RateLimitCounter? arg1 = null; // No Entry\n        RateLimitRule arg2 = null;\n\n        // Act\n        RateLimitCounter actual = _sut.Count(arg1, arg2);\n\n        // Assert\n        Assert.Equal(1L, actual.TotalRequests);\n        Assert.True(DateTime.UtcNow - actual.StartedAt < TimeSpan.FromSeconds(1.0D));\n    }"
      },
      {
        "name": "Count_EntryHasNotExpired_IncrementedRequestCount",
        "body": "{\n        // Arrange\n        long total = 2;\n        RateLimitCounter? arg1 = new RateLimitCounter(DateTime.UtcNow, null, total); // entry has not expired\n        RateLimitRule arg2 = new(\"1s\", 1.0D, total + 1); // with not exceeding limit\n\n        // Act\n        RateLimitCounter actual = _sut.Count(arg1, arg2);\n\n        // Assert\n        Assert.Equal(total + 1, actual.TotalRequests); // incremented request count\n        Assert.Equal(arg1.Value.StartedAt, actual.StartedAt); // starting point has not changed\n    }"
      },
      {
        "name": "Count_EntryHasNotExpiredAndExceedingLimit_IncrementedRequestCountWithRenewedStartMoment",
        "body": "{\n        // Arrange\n        long total = 2;\n        RateLimitCounter? arg1 = new RateLimitCounter(DateTime.UtcNow, null, total); // entry has not expired\n        RateLimitRule arg2 = new(\"1s\", 1.0D, 1L);\n\n        // Act\n        RateLimitCounter actual = _sut.Count(arg1, arg2);\n\n        // Assert\n        Assert.Equal(total + 1, actual.TotalRequests); // incremented request count\n        Assert.InRange(actual.StartedAt, arg1.Value.StartedAt, DateTime.UtcNow); // starting point has renewed and it is between StartedAt and Now\n    }"
      },
      {
        "name": "Count_RateLimitExceeded_StartedCounting",
        "body": "{\n        // Arrange\n        long total = 3, limit = total - 1;\n        TimeSpan periodTimespan = TimeSpan.FromSeconds(1.0D);\n        DateTime startedAt = DateTime.UtcNow.AddSeconds(-2.0), // 2 secs ago\n            exceededAt = startedAt + periodTimespan; // 1 second ago\n        RateLimitCounter? arg1 = new RateLimitCounter(startedAt, exceededAt, total); // Entry has expired\n        RateLimitRule arg2 = new(\"1s\", periodTimespan.TotalSeconds, limit); // rate limit exceeded\n\n        // Act\n        RateLimitCounter actual = _sut.Count(arg1, arg2);\n\n        // Assert\n        Assert.Equal(1L, actual.TotalRequests); // started counting, the counter was changed\n        Assert.InRange(actual.StartedAt, arg1.Value.ExceededAt.Value, DateTime.UtcNow); // starting point has renewed and it is between exceededAt and Now\n    }"
      },
      {
        "name": "Count_RateLimitNotExceededAndPeriodIsElapsed_StartedCountingByDefault",
        "body": "{\n        // Arrange\n        long total = 3, limit = 3;\n        RateLimitCounter? arg1 = new RateLimitCounter(DateTime.UtcNow.AddSeconds(-2.0), null, total); // Entry has expired\n        RateLimitRule arg2 = new(\"1s\", 1.0D, limit); // Rate limit not exceeded\n\n        // Act\n        RateLimitCounter actual = _sut.Count(arg1, arg2);\n\n        // Assert\n        Assert.Equal(1L, actual.TotalRequests); // started counting\n        Assert.True(DateTime.UtcNow - actual.StartedAt < TimeSpan.FromSeconds(1.0D)); // started now\n    }"
      },
      {
        "name": "ProcessRequest_RateLimitExceededAndBanPeriodElapsed_StartedCounting",
        "body": "{\n        // Arrange\n        const double periodTimespan = 2.0D;\n        const int millisecondsBeforeAfterEnding = 100; // current processing time of unit test should not take more 100 ms\n        DateTime now = DateTime.UtcNow,\n            startedAt = now.AddSeconds(-3).AddMilliseconds(millisecondsBeforeAfterEnding);\n        DateTime? exceededAt = null;\n        long totalRequests = 2L;\n        TimeSpan expiration = TimeSpan.Zero;\n\n        var (identity, options) = SetupProcessRequest(\"3s\", periodTimespan, totalRequests,\n            () => new RateLimitCounter(startedAt, exceededAt, totalRequests),\n            (value) => expiration = value);\n\n        // Act 1\n        var counter = _sut.ProcessRequest(identity, options);\n\n        // Assert 1\n        Assert.Equal(3L, counter.TotalRequests); // old counting -> 3\n        Assert.Equal(startedAt, counter.StartedAt); // starting point was not changed\n        Assert.NotNull(counter.ExceededAt); // exceeded\n        Assert.Equal(DateTime.UtcNow.Second, counter.ExceededAt.Value.Second); // exceeded now, in the same second\n\n        // Arrange 2\n        TimeSpan shift = TimeSpan.FromSeconds(periodTimespan); // don't wait, just move to future\n        startedAt = counter.StartedAt - shift; // move to past\n        exceededAt = counter.ExceededAt - shift; // move to past\n        totalRequests = counter.TotalRequests; // 3\n\n        // Act 2\n        var actual = _sut.ProcessRequest(identity, options);\n\n        // Assert\n        Assert.Equal(1L, actual.TotalRequests); // started counting\n        Assert.InRange(actual.StartedAt, now, DateTime.UtcNow); // starting point has renewed and it is between test starting and Now\n        Assert.Null(actual.ExceededAt);\n        _storage.Verify(x => x.Remove(It.IsAny<string>()),\n            Times.Never()); // Once()? Seems Remove is never called because of renewing\n        _storage.Verify(x => x.Get(It.IsAny<string>()),\n            Times.Exactly(2));\n        _storage.Verify(x => x.Set(It.IsAny<string>(), It.IsAny<RateLimitCounter>(), It.IsAny<TimeSpan>()),\n            Times.Exactly(2));\n        Assert.Equal(TimeSpan.FromSeconds(3), expiration);\n    }"
      },
      {
        "name": "ProcessRequest_PeriodTimespanValueIsGreaterThanPeriod_ExpectedBehaviorAndExpirationInPeriod",
        "body": "{\n        // Arrange: user scenario\n        const string period = \"1s\";\n        const double periodTimespan = 30.0D; // seconds\n        const long limit = 100L, requestsPerSecond = 20L;\n\n        // Arrange: setup\n        DateTime? startedAt = null;\n        TimeSpan expiration = TimeSpan.Zero;\n        long total = 1L, count = requestsPerSecond;\n        RateLimitCounter? current = null;\n        var (identity, options) = SetupProcessRequest(period, periodTimespan, limit,\n            () => current,\n            (value) => expiration = value);\n\n        // Arrange 20 requests per period (1 sec)\n        var periodSeconds = TimeSpan.FromSeconds(double.Parse(period[0].ToString()));\n        var periodMilliseconds = periodSeconds.TotalMilliseconds;\n        int delay = (int)((periodMilliseconds - 200) / requestsPerSecond); // 20 requests per 1 second\n\n        while (count > 0L)\n        {\n            // Act\n            var actual = _sut.ProcessRequest(identity, options);\n\n            // life hack for the 1st request\n            if (count == requestsPerSecond)\n            {\n                startedAt = actual.StartedAt; // for the 1st request get expected value\n            }\n\n            // Assert\n            Assert.True(actual.TotalRequests < limit);\n            actual.TotalRequests.ShouldBe(total++, $\"Count is {count}\");\n            Assert.Equal(startedAt, actual.StartedAt); // starting point is not changed\n            Assert.Null(actual.ExceededAt); // no exceeding at all\n            Assert.Equal(periodSeconds, expiration); // expiration in the period\n\n            // Arrange: next micro test\n            current = actual;\n            Thread.Sleep(delay);\n            count--;\n        }\n        \n        Assert.NotEqual(TimeSpan.FromSeconds(periodTimespan), expiration); // Not ban period expiration\n        Assert.Equal(periodSeconds, expiration); // last 20th request was in counting period\n    }"
      }
    ]
  },
  {
    "file": "ScopedRequestDataRepositoryTests.cs",
    "methods": [
      {
        "name": "should_add_item",
        "body": "{\r\n        this.Given(x => x.GivenIHaveAnItemToAdd(\"blahh\", new[] { 1, 2, 3, 4 }))\r\n            .When(x => x.WhenIAddTheItem())\r\n            .Then(x => x.ThenTheItemIsAdded())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_get_item",
        "body": "{\r\n        this.Given(x => x.GivenThereIsAnItemInTheContext(\"chest\"))\r\n            .When(x => x.WhenIGetTheItem())\r\n            .Then(x => x.ThenTheItemIsReturned())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRequestCreatorTests.cs",
    "methods": [
      {
        "name": "should_create_downstream_request",
        "body": "{\n        var request = new HttpRequestMessage(HttpMethod.Get, \"http://www.test.com\");\n        var content = new StringContent(\"test\");\n        request.Content = content;\n\n        this.Given(_ => GivenTheFrameworkIs(string.Empty))\n            .And(_ => GivenTheRequestIs(request))\n            .When(_ => WhenICreate())\n            .Then(_ => ThenTheDownstreamRequestHasABody())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_remove_body_for_http_methods",
        "body": "{\n        var methods = new List<HttpMethod> { HttpMethod.Get, HttpMethod.Head, HttpMethod.Delete, HttpMethod.Trace };\n        var request = new HttpRequestMessage(HttpMethod.Get, \"http://www.test.com\");\n        var content = new StringContent(\"test\");\n        request.Content = content;\n\n        methods.ForEach(m =>\n        {\n            this.Given(_ => GivenTheFrameworkIs(\".NET Framework\"))\n                .And(_ => GivenTheRequestIs(request))\n                .When(_ => WhenICreate())\n                .Then(_ => ThenTheDownstreamRequestDoesNotHaveABody())\n                .BDDfy();\n        });\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRequestInitialiserMiddlewareTests.cs",
    "methods": [
      {
        "name": "Should_handle_valid_httpRequest",
        "body": "{\n        this.Given(_ => GivenTheHttpContextContainsARequest())\n            .And(_ => GivenTheMapperWillReturnAMappedRequest())\n            .When(_ => WhenTheMiddlewareIsInvoked())\n            .Then(_ => ThenTheContexRequestIsMappedToADownstreamRequest())\n            .And(_ => ThenTheDownstreamRequestIsStored())\n            .And(_ => ThenTheNextMiddlewareIsInvoked())\n            .And(_ => ThenTheDownstreamRequestMethodIs(\"GET\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_downstream_route_method_to_downstream_request",
        "body": "{\n        this.Given(_ => GivenTheHttpContextContainsARequest())\n            .And(_ => GivenTheMapperWillReturnAMappedRequest())\n            .When(_ => WhenTheMiddlewareIsInvoked())\n            .Then(_ => ThenTheContexRequestIsMappedToADownstreamRequest())\n            .And(_ => ThenTheDownstreamRequestIsStored())\n            .And(_ => ThenTheNextMiddlewareIsInvoked())\n            .And(_ => ThenTheDownstreamRequestMethodIs(\"GET\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_handle_mapping_failure",
        "body": "{\n        this.Given(_ => GivenTheHttpContextContainsARequest())\n            .And(_ => GivenTheMapperWillReturnAnError())\n            .When(_ => WhenTheMiddlewareIsInvoked())\n            .And(_ => ThenTheDownstreamRequestIsNotStored())\n            .And(_ => ThenAPipelineErrorIsStored())\n            .And(_ => ThenTheNextMiddlewareIsNotInvoked())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DownstreamRequestTests.cs",
    "methods": [
      {
        "name": "should_have_question_mark_with_question_mark_prefixed",
        "body": "{\n        var httpRequestMessage = new HttpRequestMessage();\n        httpRequestMessage.RequestUri = new Uri(\"https://example.com/a?b=c\");\n        var downstreamRequest = new DownstreamRequest(httpRequestMessage);\n        var result = downstreamRequest.ToHttpRequestMessage();\n        result.RequestUri.Query.ShouldBe(\"?b=c\");\n    }"
      }
    ]
  },
  {
    "file": "RequestMapperTests.cs",
    "methods": [
      {
        "name": "Should_map_request_without_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIGetUrlOnTheApiGateway(\"/\"))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";;\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_content_length",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new StringContent(\"This is some content\")))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"20;;This is some content\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_empty_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new StringContent(\"\")))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\"0;;\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_chunked_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new ChunkedContent(\"This \", \"is some content\")))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";chunked;This is some content\"))\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_map_request_with_empty_chunked_content",
        "body": "{\n        var port = PortFinder.GetRandomPort();\n        var route = GivenRoute(port, HttpMethods.Post);\n        var configuration = GivenConfiguration(route);\n\n        this.Given(x => x.GivenThereIsAServiceRunningOn(DownstreamUrl(port), \"/\", HttpStatusCode.OK))\n            .And(x => GivenThereIsAConfiguration(configuration))\n            .And(x => GivenOcelotIsRunning())\n            .When(x => WhenIPostUrlOnTheApiGateway(\"/\", new ChunkedContent()))\n            .Then(x => ThenTheStatusCodeShouldBe(HttpStatusCode.OK))\n            .And(x => ThenTheResponseBodyShouldBe(\";chunked;\"))\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "StreamHttpContentTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        var sut = StreamHttpContentFactory();\n        using var stream = new MemoryStream();\n        await sut.CopyToAsync(stream);\n\n        stream.Position = 0;\n        var result = Encoding.UTF8.GetString(stream.ToArray());\n        result.ShouldBe(PayLoad);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var bytes = Encoding.UTF8.GetBytes(PayLoad);\n        using var inputStream = new MemoryStream(bytes);\n        using var outputStream = new MemoryStream();\n        await CopyAsyncTest(\n            new StreamHttpContent(_httpContext),\n            new object[] { inputStream, outputStream, StreamHttpContent.UnknownLength, false, CancellationToken.None });\n        inputStream.Position = 0;\n        outputStream.Position = 0;\n        var result = Encoding.UTF8.GetString(outputStream.ToArray());\n        result.ShouldBe(PayLoad);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var bytes = Encoding.UTF8.GetBytes(PayLoad);\n        using var inputStream = new MemoryStream(bytes);\n        using var outputStream = new MemoryStream();\n        await CopyAsyncTest(\n            new StreamHttpContent(_httpContext),\n            new object[] { inputStream, outputStream, bytes.Length, false, CancellationToken.None });\n        inputStream.Position = 0;\n        outputStream.Position = 0;\n        var result = Encoding.UTF8.GetString(outputStream.ToArray());\n        result.ShouldBe(PayLoad);\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var bytes = Encoding.UTF8.GetBytes(PayLoad);\n        using var inputStream = new MemoryStream(bytes);\n        using var outputStream = new MemoryStream();\n        await Assert.ThrowsAsync<InvalidOperationException>(async () =>\n            await CopyAsyncTest(\n                new StreamHttpContent(_httpContext),\n                new object[] { inputStream, outputStream, 10, false, CancellationToken.None }));\n    }"
      }
    ]
  },
  {
    "file": "RequestIdMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_pass_down_request_id_from_upstream_request",
        "body": "{\n        var downstreamRoute = new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithRequestIdKey(\"LSRequestId\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n            .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n            .Build());\n\n        var requestId = Guid.NewGuid().ToString();\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => GivenThereIsNoGlobalRequestId())\n            .And(x => x.GivenTheRequestIdIsAddedToTheRequest(\"LSRequestId\", requestId))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheTraceIdIs(requestId))\n            .BDDfy();\n    }"
      },
      {
        "name": "should_add_request_id_when_not_on_upstream_request",
        "body": "{\n        var downstreamRoute = new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithRequestIdKey(\"LSRequestId\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => GivenThereIsNoGlobalRequestId())\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheTraceIdIsAnything())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_add_request_id_scoped_repo_for_logging_later",
        "body": "{\n        var downstreamRoute = new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithRequestIdKey(\"LSRequestId\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        var requestId = Guid.NewGuid().ToString();\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => GivenThereIsNoGlobalRequestId())\n            .And(x => x.GivenTheRequestIdIsAddedToTheRequest(\"LSRequestId\", requestId))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheTraceIdIs(requestId))\n            .And(x => ThenTheRequestIdIsSaved())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_update_request_id_scoped_repo_for_logging_later",
        "body": "{\n        var downstreamRoute = new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithRequestIdKey(\"LSRequestId\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        var requestId = Guid.NewGuid().ToString();\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => GivenTheRequestIdWasSetGlobally())\n            .And(x => x.GivenTheRequestIdIsAddedToTheRequest(\"LSRequestId\", requestId))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheTraceIdIs(requestId))\n            .And(x => ThenTheRequestIdIsUpdated())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_update_if_global_request_id_is_same_as_re_route_request_id",
        "body": "{\n        var downstreamRoute = new DownstreamRouteHolder(new List<PlaceholderNameAndValue>(),\n            new RouteBuilder()\n                .WithDownstreamRoute(new DownstreamRouteBuilder()\n                    .WithDownstreamPathTemplate(\"any old string\")\n                    .WithRequestIdKey(\"LSRequestId\")\n                    .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                    .Build())\n                .WithUpstreamHttpMethod(new List<string> { \"Get\" })\n                .Build());\n\n        var requestId = \"alreadyset\";\n\n        this.Given(x => x.GivenTheDownStreamRouteIs(downstreamRoute))\n            .And(x => GivenTheRequestIdWasSetGlobally())\n            .And(x => x.GivenTheRequestIdIsAddedToTheRequest(\"LSRequestId\", requestId))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenTheTraceIdIs(requestId))\n            .And(x => ThenTheRequestIdIsNotUpdated())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "DelegatingHandlerHandlerProviderFactoryTests.cs",
    "methods": [
      {
        "name": "should_follow_ordering_add_specifics",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithDelegatingHandlers(new List<string>\r\n            {\r\n                \"FakeDelegatingHandler\",\r\n                \"FakeDelegatingHandlerTwo\",\r\n            })\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandlerThree, FakeDelegatingHandlerFour>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(6))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerThree>(0))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerFour>(1))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(2))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerTwo>(3))\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(4))\r\n            .And(x => ThenHandlerAtPositionIs<FakeQoSHandler>(5))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_follow_ordering_order_specifics_and_globals",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithDelegatingHandlers(new List<string>\r\n            {\r\n                \"FakeDelegatingHandlerTwo\",\r\n                \"FakeDelegatingHandler\",\r\n                \"FakeDelegatingHandlerFour\",\r\n            })\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandlerFour, FakeDelegatingHandlerThree>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(6))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerThree>(0)) //first because global not in config\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerTwo>(1)) //first from config\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(2)) //second from config\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerFour>(3)) //third from config (global)\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(4))\r\n            .And(x => ThenHandlerAtPositionIs<FakeQoSHandler>(5))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_follow_ordering_order_specifics",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithDelegatingHandlers(new List<string>\r\n            {\r\n                \"FakeDelegatingHandlerTwo\",\r\n                \"FakeDelegatingHandler\",\r\n            })\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandlerThree, FakeDelegatingHandlerFour>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(6))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerThree>(0))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerFour>(1))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerTwo>(2))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(3))\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(4))\r\n            .And(x => ThenHandlerAtPositionIs<FakeQoSHandler>(5))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_follow_ordering_order_and_only_add_specifics_in_config",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithDelegatingHandlers(new List<string>\r\n            {\r\n                \"FakeDelegatingHandler\",\r\n            })\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandlerThree, FakeDelegatingHandlerFour>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(5))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerThree>(0))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerFour>(1))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(2))\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(3))\r\n            .And(x => ThenHandlerAtPositionIs<FakeQoSHandler>(4))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_follow_ordering_dont_add_specifics",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(4))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(0))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerTwo>(1))\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(2))\r\n            .And(x => ThenHandlerAtPositionIs<FakeQoSHandler>(3))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_apply_re_route_specific",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, false, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithDelegatingHandlers(new List<string>\r\n            {\r\n                \"FakeDelegatingHandler\",\r\n                \"FakeDelegatingHandlerTwo\",\r\n            })\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(2))\r\n            .And(x => ThenTheDelegatesAreAddedCorrectly())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_all_from_all_routes_provider_and_qos",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, false, true, int.MaxValue, DefaultPooledConnectionLifeTime))\n            .WithLoadBalancerKey(string.Empty)\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(3))\r\n            .And(x => ThenTheDelegatesAreAddedCorrectly())\r\n            .And(x => ThenItIsQosHandler(2))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_provider_with_no_delegates",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, false, true, int.MaxValue, DefaultPooledConnectionLifeTime))\n            .WithLoadBalancerKey(string.Empty)\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheServiceProviderReturnsNothing())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenNoDelegatesAreInTheProvider())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_provider_with_qos_delegate",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, false, true, int.MaxValue, DefaultPooledConnectionLifeTime))\n            .WithLoadBalancerKey(string.Empty)\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheServiceProviderReturnsNothing())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(1))\r\n            .And(x => ThenItIsQosHandler(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_return_provider_with_qos_delegate_when_timeout_value_set",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, false, true, int.MaxValue, DefaultPooledConnectionLifeTime))\n            .WithLoadBalancerKey(string.Empty)\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturns(new FakeQoSHandler()))\r\n            .And(x => GivenTheServiceProviderReturnsNothing())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(1))\r\n            .And(x => ThenItIsQosHandler(0))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_log_error_and_return_no_qos_provider_delegate_when_qos_factory_returns_error",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturnsError())\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(4))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(0))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerTwo>(1))\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(2))\r\n            .And(x => ThenHandlerAtPositionIs<NoQosDelegatingHandler>(3))\r\n            .And(_ => ThenTheWarningIsLogged())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_log_error_and_return_no_qos_provider_delegate_when_qos_factory_returns_null",
        "body": "{\r\n        var qosOptions = new QoSOptionsBuilder()\r\n            .WithTimeoutValue(1)\r\n            .WithDurationOfBreak(1)\r\n            .WithExceptionsAllowedBeforeBreaking(1)\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithQosOptions(qosOptions)\r\n            .WithHttpHandlerOptions(new HttpHandlerOptions(true, true, true, true, int.MaxValue, DefaultPooledConnectionLifeTime))\r\n            .WithLoadBalancerKey(string.Empty)\r\n            .Build();\r\n\r\n        this.Given(x => GivenTheFollowingRequest(route))\r\n            .And(x => GivenTheQosFactoryReturnsNull())\r\n            .And(x => GivenTheTracingFactoryReturns())\r\n            .And(x => GivenTheServiceProviderReturnsGlobalDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .And(x => GivenTheServiceProviderReturnsSpecificDelegatingHandlers<FakeDelegatingHandler, FakeDelegatingHandlerTwo>())\r\n            .When(x => WhenIGet())\r\n            .Then(x => ThenThereIsDelegatesInProvider(4))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandler>(0))\r\n            .And(x => ThenHandlerAtPositionIs<FakeDelegatingHandlerTwo>(1))\r\n            .And(x => ThenHandlerAtPositionIs<FakeTracingHandler>(2))\r\n            .And(x => ThenHandlerAtPositionIs<NoQosDelegatingHandler>(3))\r\n            .And(_ => ThenTheWarningIsLogged())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "HttpExceptionToErrorMapperTests.cs",
    "methods": [
      {
        "name": "Should_return_default_error_because_mappers_are_null",
        "body": "{\n        var error = _mapper.Map(new Exception());\n\n        error.ShouldBeOfType<UnableToCompleteRequestError>();\n    }"
      },
      {
        "name": "Should_return_request_canceled",
        "body": "{\n        var error = _mapper.Map(new OperationCanceledException());\n\n        error.ShouldBeOfType<RequestCanceledError>();\n    }"
      },
      {
        "name": "Should_return_ConnectionToDownstreamServiceError",
        "body": "{\n        var error = _mapper.Map(new HttpRequestException());\n\n        error.ShouldBeOfType<ConnectionToDownstreamServiceError>();\n    }"
      },
      {
        "name": "Should_return_request_canceled_for_subtype",
        "body": "{\n        var error = _mapper.Map(new SomeException());\n\n        error.ShouldBeOfType<RequestCanceledError>();\n    }"
      },
      {
        "name": "Should_return_error_from_mapper",
        "body": "{\n        IDictionary<Type, Func<Exception, Error>> errorMapping = new Dictionary<Type, Func<Exception, Error>>\n        {\n            {typeof(TaskCanceledException), e => new AnyError()},\n        };\n\n        _services.AddSingleton(errorMapping);\n\n        var provider = _services.BuildServiceProvider(true);\n\n        _mapper = new HttpExceptionToErrorMapper(provider);\n\n        var error = _mapper.Map(new TaskCanceledException());\n\n        error.ShouldBeOfType<AnyError>();\n    }"
      }
    ]
  },
  {
    "file": "HttpRequesterMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_call_services_correctly",
        "body": "{\r\n        this.Given(x => x.GivenTheRequestIs())\r\n            .And(x => x.GivenTheRequesterReturns(new OkResponse<HttpResponseMessage>(new HttpResponseMessage(HttpStatusCode.OK))))\r\n            .When(x => x.WhenICallTheMiddleware())\r\n            .Then(x => x.ThenTheDownstreamResponseIsSet())\r\n            .Then(x => InformationIsLogged())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_set_error",
        "body": "{\r\n        this.Given(x => x.GivenTheRequestIs())\r\n            .And(x => x.GivenTheRequesterReturns(new ErrorResponse<HttpResponseMessage>(new AnyError())))\r\n            .When(x => x.WhenICallTheMiddleware())\r\n            .Then(x => x.ThenTheErrorIsSet())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "should_log_downstream_internal_server_error",
        "body": "{\r\n        this.Given(x => x.GivenTheRequestIs())\r\n                .And(x => x.GivenTheRequesterReturns(\r\n                    new OkResponse<HttpResponseMessage>(new HttpResponseMessage(HttpStatusCode.InternalServerError))))\r\n            .When(x => x.WhenICallTheMiddleware())\r\n            .Then(x => x.WarningIsLogged())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "MessageInvokerPoolTests.cs",
    "methods": [
      {
        "name": "If_calling_the_same_downstream_route_twice_should_return_the_same_message_invoker",
        "body": "{\n        this.Given(x => x.GivenADownstreamRoute(\"/super-test\"))\n            .And(x => x.AndAHandlerFactory())\n            .And(x => x.GivenAMessageInvokerPool())\n            .When(x => x.WhenGettingMessageInvokerTwice())\n            .Then(x => x.ThenTheInvokersShouldBeTheSame())\n            .BDDfy();\n    }"
      },
      {
        "name": "If_calling_two_different_downstream_routes_should_return_different_message_invokers",
        "body": "{\n        this.Given(x => x.GivenTwoDifferentDownstreamRoutes(\"/super-test\", \"/super-test\"))\n            .And(x => x.AndAHandlerFactory())\n            .And(x => x.GivenAMessageInvokerPool())\n            .When(x => x.WhenGettingMessageInvokerForBothRoutes())\n            .Then(x => x.ThenTheInvokersShouldNotBeTheSame())\n            .BDDfy();\n    }"
      },
      {
        "name": "If_two_delegating_handlers_are_defined_then_these_should_be_call_in_order",
        "body": "{\n        var fakeOne = new FakeDelegatingHandler();\n        var fakeTwo = new FakeDelegatingHandler();\n\n        var handlers = new List<Func<DelegatingHandler>>\n        {\n            () => fakeOne,\n            () => fakeTwo,\n        };\n\n        this.Given(x => GivenTheFactoryReturns(handlers))\n            .And(x => GivenADownstreamRoute(\"/super-test\"))\n            .And(x => GivenAMessageInvokerPool())\n            .And(x => GivenARequest())\n            .When(x => WhenICallTheClient(\"http://www.bbc.co.uk\"))\n            .Then(x => ThenTheFakeAreHandledInOrder(fakeOne, fakeTwo))\n            .And(x => ThenSomethingIsReturned())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_log_if_ignoring_ssl_errors",
        "body": "{\n        var qosOptions = new QoSOptionsBuilder()\n            .Build();\n\n        var route = new DownstreamRouteBuilder()\n            .WithQosOptions(qosOptions)\n            .WithHttpHandlerOptions(new HttpHandlerOptions(false, false, false, true, int.MaxValue, TimeSpan.FromSeconds(90)))\n            .WithLoadBalancerKey(string.Empty)\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder().WithOriginalValue(string.Empty).Build())\n            .WithQosOptions(new QoSOptionsBuilder().Build())\n            .WithDangerousAcceptAnyServerCertificateValidator(true)\n            .Build();\n\n        this.Given(x => GivenTheFactoryReturns(new List<Func<DelegatingHandler>>()))\n            .And(x => GivenAMessageInvokerPool())\n            .And(x => GivenARequest(route))\n            .When(x => WhenICallTheClient(\"http://www.google.com/\"))\n            .Then(x => ThenTheDangerousAcceptAnyServerCertificateValidatorWarningIsLogged())\n            .BDDfy();\n    }"
      },
      {
        "name": "Should_re_use_cookies_from_container",
        "body": "{\n        var qosOptions = new QoSOptionsBuilder()\n            .Build();\n\n        var route = new DownstreamRouteBuilder()\n            .WithQosOptions(qosOptions)\n            .WithHttpHandlerOptions(new HttpHandlerOptions(false, true, false, true, int.MaxValue, TimeSpan.FromSeconds(90)))\n            .WithLoadBalancerKey(string.Empty)\n            .WithUpstreamPathTemplate(new UpstreamPathTemplateBuilder().WithOriginalValue(string.Empty).Build())\n            .WithQosOptions(new QoSOptionsBuilder().Build())\n            .Build();\n\n        this.Given(_ => GivenADownstreamService())\n            .And(x => GivenTheFactoryReturns(new List<Func<DelegatingHandler>>()))\n            .And(x => GivenAMessageInvokerPool())\n            .And(x => GivenARequest(route))\n            .And(_ => WhenICallTheClient(\"http://localhost:5003\"))\n            .And(_ => ThenTheCookieIsSet())\n            .When(_ => WhenICallTheClient(\"http://localhost:5003\"))\n            .Then(_ => ThenTheResponseIsOk())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "QoSFactoryTests.cs",
    "methods": [
      {
        "name": "should_return_error",
        "body": "{\r\n        var downstreamRoute = new DownstreamRouteBuilder().Build();\r\n        var handler = _factory.Get(downstreamRoute);\r\n        handler.IsError.ShouldBeTrue();\r\n        handler.Errors[0].ShouldBeOfType<UnableToFindQoSProviderError>();\r\n    }"
      },
      {
        "name": "should_return_handler",
        "body": "{\r\n        _services = new ServiceCollection();\r\n        DelegatingHandler QosDelegatingHandlerDelegate(DownstreamRoute a, IHttpContextAccessor b, IOcelotLoggerFactory c) => new FakeDelegatingHandler();\r\n        _services.AddSingleton<QosDelegatingHandlerDelegate>(QosDelegatingHandlerDelegate);\r\n        var provider = _services.BuildServiceProvider(true);\r\n        _factory = new QoSFactory(provider, _contextAccessor.Object, _loggerFactory.Object);\r\n        var downstreamRoute = new DownstreamRouteBuilder().Build();\r\n        var handler = _factory.Get(downstreamRoute);\r\n        handler.IsError.ShouldBeFalse();\r\n        handler.Data.ShouldBeOfType<FakeDelegatingHandler>();\r\n    }"
      }
    ]
  },
  {
    "file": "TracingHandlerFactoryTests.cs",
    "methods": [
      {
        "name": "should_return",
        "body": "{\n        var handler = _factory.Get();\n        handler.ShouldBeOfType<OcelotHttpTracingHandler>();\n    }"
      }
    ]
  },
  {
    "file": "ErrorsToHttpStatusCodeMapperTests.cs",
    "methods": [
      {
        "name": "should_return_request_entity_too_large",
        "body": "{\n        ShouldMapErrorsToStatusCode(new() { OcelotErrorCode.PayloadTooLargeError }, HttpStatusCode.RequestEntityTooLarge);\n    }"
      },
      {
        "name": "AuthenticationErrorsHaveHighestPriority",
        "body": "{\r\n        var errors = new List<OcelotErrorCode>\r\n        {\r\n            OcelotErrorCode.CannotAddDataError,\r\n            OcelotErrorCode.CannotFindClaimError,\r\n            OcelotErrorCode.UnauthenticatedError,\r\n            OcelotErrorCode.RequestTimedOutError,\r\n        };\r\n\r\n        ShouldMapErrorsToStatusCode(errors, HttpStatusCode.Unauthorized);\r\n    }"
      },
      {
        "name": "AuthorizationErrorsHaveSecondHighestPriority",
        "body": "{\r\n        var errors = new List<OcelotErrorCode>\r\n        {\r\n            OcelotErrorCode.CannotAddDataError,\r\n            OcelotErrorCode.CannotFindClaimError,\r\n            OcelotErrorCode.RequestTimedOutError,\r\n        };\r\n\r\n        ShouldMapErrorsToStatusCode(errors, HttpStatusCode.Forbidden);\r\n    }"
      },
      {
        "name": "ServiceUnavailableErrorsHaveThirdHighestPriority",
        "body": "{\r\n        var errors = new List<OcelotErrorCode>\r\n        {\r\n            OcelotErrorCode.CannotAddDataError,\r\n            OcelotErrorCode.RequestTimedOutError,\r\n        };\r\n\r\n        ShouldMapErrorsToStatusCode(errors, HttpStatusCode.ServiceUnavailable);\r\n    }"
      },
      {
        "name": "check_we_have_considered_all_errors_in_these_tests",
        "body": "{\r\n        // If this test fails then it's because the number of error codes has changed.\r\n        // You should make the appropriate changes to the test cases here to ensure\r\n        // they cover all the error codes, and then modify this assertion.\r\n        Enum.GetNames(typeof(OcelotErrorCode)).Length.ShouldBe(42, \"Looks like the number of error codes has changed. Do you need to modify ErrorsToHttpStatusCodeMapper?\");\r\n    }"
      }
    ]
  },
  {
    "file": "HttpContextResponderTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.OK,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"Transfer-Encoding\", new List<string> {\"woop\"}),\n            }, \"some reason\");\n\n        await _responder.SetResponseOnHttpContext(httpContext, response);\n        var header = httpContext.Response.Headers[\"Transfer-Encoding\"];\n        header.ShouldBeEmpty();\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        var response = new DownstreamResponse(null, HttpStatusCode.OK,\n            new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\");\n\n        await Should.NotThrowAsync(async () =>\n        {\n            await _responder.SetResponseOnHttpContext(httpContext, response);\n        });\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        var response = new DownstreamResponse(new StringContent(\"test\"), HttpStatusCode.OK,\n            new List<KeyValuePair<string, IEnumerable<string>>>(), \"some reason\");\n\n        await _responder.SetResponseOnHttpContext(httpContext, response);\n        var header = httpContext.Response.Headers[\"Content-Length\"];\n        header.First().ShouldBe(\"4\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.OK,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"test\", new List<string> {\"test\"}),\n            }, \"some reason\");\n\n        await _responder.SetResponseOnHttpContext(httpContext, response);\n        var header = httpContext.Response.Headers[\"test\"];\n        header.First().ShouldBe(\"test\");\n    }"
      },
      {
        "name": "Task",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        var response = new DownstreamResponse(new StringContent(string.Empty), HttpStatusCode.OK,\n            new List<KeyValuePair<string, IEnumerable<string>>>\n            {\n                new(\"test\", new List<string> {\"test\"}),\n            }, \"some reason\");\n\n        await _responder.SetResponseOnHttpContext(httpContext, response);\n        httpContext.Response.HttpContext.Features.Get<IHttpResponseFeature>().ReasonPhrase.ShouldBe(response.ReasonPhrase);\n    }"
      },
      {
        "name": "should_call_without_exception",
        "body": "{\n        var httpContext = new DefaultHttpContext();\n        _responder.SetErrorResponseOnContext(httpContext, 500);\n    }"
      }
    ]
  },
  {
    "file": "ResponderMiddlewareTests.cs",
    "methods": [
      {
        "name": "should_not_return_any_errors",
        "body": "{\n        this.Given(x => x.GivenTheHttpResponseMessageIs(new DownstreamResponse(new HttpResponseMessage())))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenThereAreNoErrors())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_return_any_errors",
        "body": "{\n        this.Given(x => x.GivenTheHttpResponseMessageIs(new DownstreamResponse(new HttpResponseMessage())))\n            .And(x => x.GivenThereArePipelineErrors(new UnableToFindDownstreamRouteError(\"/path\", \"GET\")))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenThereAreNoErrors())\n            .BDDfy();\n    }"
      },
      {
        "name": "should_not_call_responder_when_null_downstream_response",
        "body": "{\n        this._responder.Reset();\n        this.Given(x => x.GivenTheHttpResponseMessageIs(null))\n            .When(x => x.WhenICallTheMiddleware())\n            .Then(x => x.ThenThereAreNoErrors())\n            .Then(x => x._responder.VerifyNoOtherCalls())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "IPSecurityPolicyTests.cs",
    "methods": [
      {
        "name": "Should_No_blocked_Ip_and_allowed_Ip",
        "body": "{\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_blockedIp_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.1\")[0];\n        GivenSetBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_blockedIp_clientIp_Not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.2\")[0];\n        GivenSetBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_allowedIp_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.1\")[0];\n        GivenSetAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_allowedIp_clientIp_Not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.2\")[0];\n        GivenSetAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_cidrNotation_allowed24_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.10.5\")[0];\n        GivenCidr24AllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_cidrNotation_allowed24_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.5\")[0];\n        GivenCidr24AllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_cidrNotation_allowed29_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.10\")[0];\n        GivenCidr29AllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_cidrNotation_blocked24_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.1\")[0];\n        GivenCidr24BlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_cidrNotation_blocked24_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.10.1\")[0];\n        GivenCidr24BlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_range_allowed_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.15\")[0];\n        GivenRangeAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_range_allowed_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.8\")[0];\n        GivenRangeAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_range_blocked_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.5\")[0];\n        GivenRangeBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_range_blocked_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.15\")[0];\n        GivenRangeBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_shortRange_allowed_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.15\")[0];\n        GivenShortRangeAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_shortRange_allowed_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.8\")[0];\n        GivenShortRangeAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_shortRange_blocked_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.5\")[0];\n        GivenShortRangeBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_shortRange_blocked_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.15\")[0];\n        GivenShortRangeBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_ipSubnet_allowed_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.10.15\")[0];\n        GivenIpSubnetAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_ipSubnet_allowed_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.15\")[0];\n        GivenIpSubnetAllowedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_ipSubnet_blocked_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.15\")[0];\n        GivenIpSubnetBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_ipSubnet_blocked_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.10.1\")[0];\n        GivenIpSubnetBlockedIP();\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_exludeAllowedFromBlocked_moreAllowed_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.150\")[0];\n        GivenIpMoreAllowedThanBlocked(false);\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_exludeAllowedFromBlocked_moreAllowed_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.150\")[0];\n        GivenIpMoreAllowedThanBlocked(true);\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_exludeAllowedFromBlocked_moreBlocked_clientIp_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.10\")[0];\n        GivenIpMoreBlockedThanAllowed(false);\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.True(actual.IsError);\n    }"
      },
      {
        "name": "Should_exludeAllowedFromBlocked_moreBlocked_clientIp_not_block",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.10\")[0];\n        GivenIpMoreBlockedThanAllowed(true);\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      },
      {
        "name": "Should_route_config_overrides_global_config",
        "body": "{\n        _context.Connection.RemoteIpAddress = Dns.GetHostAddresses(\"192.168.1.10\")[0];\n        GivenRouteConfigAndGlobalConfig(false);\n        GivenSetDownstreamRoute();\n        var actual = WhenTheSecurityPolicy();\n        Assert.False(actual.IsError);\n    }"
      }
    ]
  },
  {
    "file": "SecurityMiddlewareTests.cs",
    "methods": [
      {
        "name": "Task",
        "body": "{\r\n        // Arrange\r\n        GivenPassingSecurityVerification();\r\n\r\n        // Act\r\n        await _middleware.Invoke(_httpContext);\r\n\r\n        // Assert: security passed\r\n        _httpContext.Items.Errors().Count.ShouldBe(0);\r\n    }"
      },
      {
        "name": "Task",
        "body": "{\r\n        // Arrange\r\n        GivenNotPassingSecurityVerification();\r\n\r\n        // Act\r\n        await _middleware.Invoke(_httpContext);\r\n\r\n        // Assert: security not passed\r\n        _httpContext.Items.Errors().Count.ShouldBeGreaterThan(0);\r\n    }"
      }
    ]
  },
  {
    "file": "ConfigurationServiceProviderTests.cs",
    "methods": [
      {
        "name": "should_return_services",
        "body": "{\r\n        var hostAndPort = new ServiceHostAndPort(\"127.0.0.1\", 80);\r\n\r\n        var services = new List<Service>\r\n        {\r\n            new(\"product\", hostAndPort, string.Empty, string.Empty, Array.Empty<string>()),\r\n        };\r\n\r\n        this.Given(x => x.GivenServices(services))\r\n            .When(x => x.WhenIGetTheService())\r\n            .Then(x => x.ThenTheFollowingIsReturned(services))\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ServiceDiscoveryProviderFactoryTests.cs",
    "methods": [
      {
        "name": "Should_return_no_service_provider",
        "body": "{\r\n        var serviceConfig = new ServiceProviderConfigurationBuilder()\r\n            .Build();\r\n\r\n        var route = new DownstreamRouteBuilder().Build();\r\n\r\n        this.Given(x => x.GivenTheRoute(serviceConfig, route))\r\n            .When(x => x.WhenIGetTheServiceProvider())\r\n            .Then(x => x.ThenTheServiceProviderIs<ConfigurationServiceProvider>())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_list_of_configuration_services",
        "body": "{\r\n        var serviceConfig = new ServiceProviderConfigurationBuilder()\r\n            .Build();\r\n\r\n        var downstreamAddresses = new List<DownstreamHostAndPort>\r\n        {\r\n            new(\"asdf.com\", 80),\r\n            new(\"abc.com\", 80),\r\n        };\r\n\r\n        var route = new DownstreamRouteBuilder().WithDownstreamAddresses(downstreamAddresses).Build();\r\n\r\n        this.Given(x => x.GivenTheRoute(serviceConfig, route))\r\n            .When(x => x.WhenIGetTheServiceProvider())\r\n            .Then(x => x.ThenTheServiceProviderIs<ConfigurationServiceProvider>())\r\n            .Then(x => ThenTheFollowingServicesAreReturned(downstreamAddresses))\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_provider_because_type_matches_reflected_type_from_delegate",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithServiceName(\"product\")\r\n            .WithUseServiceDiscovery(true)\r\n            .Build();\r\n\r\n        var serviceConfig = new ServiceProviderConfigurationBuilder()\r\n            .WithType(nameof(Fake))\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenTheRoute(serviceConfig, route))\r\n            .And(x => GivenAFakeDelegate())\r\n            .When(x => x.WhenIGetTheServiceProvider())\r\n            .Then(x => x.ThenTheDelegateIsCalled())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_not_return_provider_because_type_doesnt_match_reflected_type_from_delegate",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithServiceName(\"product\")\r\n            .WithUseServiceDiscovery(true)\r\n            .Build();\r\n\r\n        var serviceConfig = new ServiceProviderConfigurationBuilder()\r\n            .WithType(\"Wookie\")\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenTheRoute(serviceConfig, route))\r\n            .And(x => GivenAFakeDelegate())\r\n            .When(x => x.WhenIGetTheServiceProvider())\r\n            .Then(x => x.ThenTheResultIsError())\r\n            .BDDfy();\r\n    }"
      },
      {
        "name": "Should_return_service_fabric_provider",
        "body": "{\r\n        var route = new DownstreamRouteBuilder()\r\n            .WithServiceName(\"product\")\r\n            .WithUseServiceDiscovery(true)\r\n            .Build();\r\n\r\n        var serviceConfig = new ServiceProviderConfigurationBuilder()\r\n            .WithType(\"ServiceFabric\")\r\n            .Build();\r\n\r\n        this.Given(x => x.GivenTheRoute(serviceConfig, route))\n            .And(x => GivenAFakeDelegate())\r\n            .When(x => x.WhenIGetTheServiceProvider())\r\n            .Then(x => x.ThenTheServiceProviderIs<ServiceFabricServiceDiscoveryProvider>())\r\n            .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "ServiceFabricServiceDiscoveryProviderTests.cs",
    "methods": [
      {
        "name": "should_return_service_fabric_naming_service",
        "body": "{\n        this.Given(x => GivenTheFollowing())\n            .When(x => WhenIGet())\n            .Then(x => ThenTheServiceFabricNamingServiceIsRetured())\n            .BDDfy();\n    }"
      }
    ]
  },
  {
    "file": "ServiceRegistryTests.cs",
    "methods": [
      {
        "name": "should_register_service",
        "body": "{\r\n        this.Given(x => x.GivenAServiceToRegister(\"product\", \"localhost:5000\", 80))\r\n        .When(x => x.WhenIRegisterTheService())\r\n        .Then(x => x.ThenTheServiceIsRegistered())\r\n        .BDDfy();\r\n    }"
      },
      {
        "name": "should_lookup_service",
        "body": "{\r\n        this.Given(x => x.GivenAServiceIsRegistered(\"product\", \"localhost:600\", 80))\r\n        .When(x => x.WhenILookupTheService(\"product\"))\r\n        .Then(x => x.ThenTheServiceDetailsAreReturned())\r\n        .BDDfy();\r\n    }"
      }
    ]
  },
  {
    "file": "UnitTest.cs",
    "methods": []
  },
  {
    "file": "WebSocketsProxyMiddlewareTests.cs",
    "methods": [
      {
        "name": "ShouldIgnoreAllSslWarningsWhenDangerousAcceptAnyServerCertificateValidatorIsTrue",
        "body": "{\n        List<object> actual = new();\n        this.Given(x => x.GivenPropertyDangerousAcceptAnyServerCertificateValidator(true, actual))\n            .And(x => x.AndDoNotSetupProtocolsAndHeaders())\n            .And(x => x.AndDoNotConnectReally(null))\n            .When(x => x.WhenInvokeWithHttpContext())\n            .Then(x => x.ThenIgnoredAllSslWarnings(actual))\n            .BDDfy();\n    }"
      }
    ]
  }
]