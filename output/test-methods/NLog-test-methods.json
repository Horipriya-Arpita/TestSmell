[
  {
    "file": "SpecialFolderApplicationDataLayoutRenderer.cs",
    "methods": []
  },
  {
    "file": "SpecialFolderCommonApplicationDataLayoutRenderer.cs",
    "methods": []
  },
  {
    "file": "SpecialFolderLayoutRenderer.cs",
    "methods": []
  },
  {
    "file": "SpecialFolderLocalApplicationDataLayoutRenderer.cs",
    "methods": []
  },
  {
    "file": "AutoReloadTests.cs",
    "methods": [
      {
        "name": "TestNoAutoReload",
        "body": "{\n            string config1 = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string config2 = @\"<nlog>\n                        <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                        <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                    </nlog>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string configFilePath = Path.Combine(tempDir, nameof(TestNoAutoReload) + \".nlog\");\n                WriteConfigFile(configFilePath, config1);\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();\n\n                Assert.False(((XmlLoggingConfiguration)logFactory.Configuration).AutoReload);\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, configFilePath, config2, assertDidReload: false);\n\n                logger.Debug(\"bbb\");\n                // Assert that config1 is still loaded.\n                AssertDebugLastMessage(\"bbb\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      },
      {
        "name": "TestAutoReloadOnFileChange",
        "body": "{\n            string config1 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string config2 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string badConfig = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='(${message})' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string configFilePath = Path.Combine(tempDir, nameof(TestAutoReloadOnFileChange) + \".nlog\");\n                WriteConfigFile(configFilePath, config1);\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();\n\n                Assert.True(((XmlLoggingConfiguration)logFactory.Configuration).AutoReload);\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, configFilePath, badConfig, assertDidReload: false);\n\n                logger.Debug(\"bbb\");\n                // Assert that config1 is still loaded.\n                AssertDebugLastMessage(\"bbb\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, configFilePath, config2);\n\n                logger.Debug(\"ccc\");\n                // Assert that config2 is loaded.\n                AssertDebugLastMessage(\"[ccc]\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      },
      {
        "name": "TestAutoReloadOnFileMove",
        "body": "{\n#if !NETFRAMEWORK || MONO\n            if (IsLinux())\n            {\n                Console.WriteLine(\"[SKIP] AutoReloadTests.TestAutoReloadOnFileMove because we are running in Travis\");\n                return;\n            }\n#endif\n\n            string config1 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string config2 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string configFilePath = Path.Combine(tempDir, \"reload.nlog\");\n                WriteConfigFile(configFilePath, config1);\n                string otherFilePath = Path.Combine(tempDir, \"other.nlog\");\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))\n                {\n                    File.Move(configFilePath, otherFilePath);\n                    reloadWaiter.WaitForReload();\n                }\n\n                logger.Debug(\"bbb\");\n                // Assert that config1 is still loaded.\n                AssertDebugLastMessage(\"bbb\", logFactory);\n\n                WriteConfigFile(otherFilePath, config2);\n                using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))\n                {\n                    File.Move(otherFilePath, configFilePath);\n\n                    reloadWaiter.WaitForReload();\n                    Assert.True(reloadWaiter.DidReload);\n                }\n\n                logger.Debug(\"ccc\");\n                // Assert that config2 is loaded.\n                AssertDebugLastMessage(\"[ccc]\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      },
      {
        "name": "TestAutoReloadOnFileCopy",
        "body": "{\n            string config1 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string config2 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                    <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n\n            string tempPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempPath);\n\n                string configFilePath = Path.Combine(tempPath, \"reload.nlog\");\n                WriteConfigFile(configFilePath, config1);\n                string otherFilePath = Path.Combine(tempPath, \"other.nlog\");\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(configFilePath).GetCurrentClassLogger();\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))\n                {\n                    File.Delete(configFilePath);\n                    reloadWaiter.WaitForReload();\n                }\n\n                logger.Debug(\"bbb\");\n                // Assert that config1 is still loaded.\n                AssertDebugLastMessage(\"bbb\", logFactory);\n\n                WriteConfigFile(otherFilePath, config2);\n                using (var reloadWaiter = new ConfigurationReloadWaiter(logFactory))\n                {\n                    File.Copy(otherFilePath, configFilePath);\n                    File.Delete(otherFilePath);\n\n                    reloadWaiter.WaitForReload();\n                    Assert.True(reloadWaiter.DidReload);\n                }\n\n                logger.Debug(\"ccc\");\n                // Assert that config2 is loaded.\n                AssertDebugLastMessage(\"[ccc]\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempPath))\n                    Directory.Delete(tempPath, true);\n            }\n        }"
      },
      {
        "name": "TestIncludedConfigNoReload",
        "body": "{\n            string mainConfig1 = @\"<nlog>\n                  <include file='included.nlog' />\n                  <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string mainConfig2 = @\"<nlog>\n                  <include file='included.nlog' />\n                  <rules><logger name='*' minlevel='Info' writeTo='debug' /></rules>\n                </nlog>\";\n            string includedConfig1 = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                </nlog>\";\n            string includedConfig2 = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                </nlog>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");\n                WriteConfigFile(mainConfigFilePath, mainConfig1);\n\n                string includedConfigFilePath = Path.Combine(tempDir, \"included.nlog\");\n                WriteConfigFile(includedConfigFilePath, includedConfig1);\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2, assertDidReload: false);\n\n                logger.Debug(\"bbb\");\n                // Assert that mainConfig1 is still loaded.\n                AssertDebugLastMessage(\"bbb\", logFactory);\n\n                WriteConfigFile(mainConfigFilePath, mainConfig1);\n                ChangeAndReloadConfigFile(logFactory, includedConfigFilePath, includedConfig2, assertDidReload: false);\n\n                logger.Debug(\"ccc\");\n                // Assert that includedConfig1 is still loaded.\n                AssertDebugLastMessage(\"ccc\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      },
      {
        "name": "TestIncludedConfigReload",
        "body": "{\n            string mainConfig1 = @\"<nlog>\n                  <include file='included.nlog' />\n                  <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string mainConfig2 = @\"<nlog>\n                  <include file='included.nlog' />\n                  <rules><logger name='*' minlevel='Info' writeTo='debug' /></rules>\n                </nlog>\";\n            string includedConfig1 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                </nlog>\";\n            string includedConfig2 = @\"<nlog autoReload='true'>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                </nlog>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");\n                WriteConfigFile(mainConfigFilePath, mainConfig1);\n\n                string includedConfigFilePath = Path.Combine(tempDir, \"included.nlog\");\n                WriteConfigFile(includedConfigFilePath, includedConfig1);\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2, assertDidReload: false);\n\n                logger.Debug(\"bbb\");\n                // Assert that mainConfig1 is still loaded.\n                AssertDebugLastMessage(\"bbb\", logFactory);\n\n                WriteConfigFile(mainConfigFilePath, mainConfig1);\n                ChangeAndReloadConfigFile(logFactory, includedConfigFilePath, includedConfig2);\n\n                logger.Debug(\"ccc\");\n                // Assert that includedConfig2 is loaded.\n                AssertDebugLastMessage(\"[ccc]\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      },
      {
        "name": "TestMainConfigReload",
        "body": "{\n            string mainConfig1 = @\"<nlog autoReload='true'>\n                  <include file='included.nlog' />\n                  <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string mainConfig2 = @\"<nlog autoReload='true'>\n                  <include file='included2.nlog' />\n                  <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string included1Config = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                </nlog>\";\n            string included2Config1 = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                </nlog>\";\n            string included2Config2 = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='(${message})' /></targets>\n                </nlog>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");\n                WriteConfigFile(mainConfigFilePath, mainConfig1);\n\n                string included1ConfigFilePath = Path.Combine(tempDir, \"included.nlog\");\n                WriteConfigFile(included1ConfigFilePath, included1Config);\n\n                string included2ConfigFilePath = Path.Combine(tempDir, \"included2.nlog\");\n                WriteConfigFile(included2ConfigFilePath, included2Config1);\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2);\n\n                logger.Debug(\"bbb\");\n                // Assert that mainConfig2 is loaded (which refers to included2.nlog).\n                AssertDebugLastMessage(\"[bbb]\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, included2ConfigFilePath, included2Config2);\n\n                logger.Debug(\"ccc\");\n                // Assert that included2Config2 is loaded.\n                AssertDebugLastMessage(\"(ccc)\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      },
      {
        "name": "TestMainConfigReloadIncludedConfigNoReload",
        "body": "{\n            string mainConfig1 = @\"<nlog autoReload='true'>\n                  <include file='included.nlog' />\n                  <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string mainConfig2 = @\"<nlog autoReload='true'>\n                  <include file='included2.nlog' />\n                  <rules><logger name='*' minlevel='Debug' writeTo='debug' /></rules>\n                </nlog>\";\n            string included1Config = @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                </nlog>\";\n            string included2Config1 = @\"<nlog autoReload='false'>\n                    <targets><target name='debug' type='Debug' layout='[${message}]' /></targets>\n                </nlog>\";\n            string included2Config2 = @\"<nlog autoReload='false'>\n                    <targets><target name='debug' type='Debug' layout='(${message})' /></targets>\n                </nlog>\";\n\n            string tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n\n            var logFactory = new LogFactory();\n\n            try\n            {\n                Directory.CreateDirectory(tempDir);\n\n                string mainConfigFilePath = Path.Combine(tempDir, \"main.nlog\");\n                WriteConfigFile(mainConfigFilePath, mainConfig1);\n\n                string included1ConfigFilePath = Path.Combine(tempDir, \"included.nlog\");\n                WriteConfigFile(included1ConfigFilePath, included1Config);\n\n                string included2ConfigFilePath = Path.Combine(tempDir, \"included2.nlog\");\n                WriteConfigFile(included2ConfigFilePath, included2Config1);\n\n                var logger = logFactory.Setup().SetupMonitorForAutoReload().LoadConfigurationFromFile(mainConfigFilePath).GetCurrentClassLogger();\n\n                logger.Debug(\"aaa\");\n                AssertDebugLastMessage(\"aaa\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, mainConfigFilePath, mainConfig2);\n\n                logger.Debug(\"bbb\");\n                // Assert that mainConfig2 is loaded (which refers to included2.nlog).\n                AssertDebugLastMessage(\"[bbb]\", logFactory);\n\n                ChangeAndReloadConfigFile(logFactory, included2ConfigFilePath, included2Config2, assertDidReload: false);\n\n                logger.Debug(\"ccc\");\n                // Assert that included2Config1 is still loaded.\n                AssertDebugLastMessage(\"[ccc]\", logFactory);\n            }\n            finally\n            {\n                logFactory.Shutdown();\n\n                if (Directory.Exists(tempDir))\n                    Directory.Delete(tempDir, true);\n            }\n        }"
      }
    ]
  },
  {
    "file": "ColoredConsoleTargetTests.cs",
    "methods": []
  },
  {
    "file": "ConditionEvaluatorTests.cs",
    "methods": [
      {
        "name": "ConditionMethodsTest",
        "body": "{\n            AssertEvaluationResult(true, \"regex-matches('foo', '^foo$')\");\n            AssertEvaluationResult(false, \"regex-matches('foo', '^bar$')\");\n\n            //Check that calling with empty string is equivalent with not passing the parameter\n            AssertEvaluationResult(true, \"regex-matches('foo', '^foo$', '')\");\n            AssertEvaluationResult(false, \"regex-matches('foo', '^bar$', '')\");\n\n            //Check that options are parsed correctly\n            AssertEvaluationResult(true, \"regex-matches('Foo', '^foo$', 'ignorecase')\");\n            AssertEvaluationResult(false, \"regex-matches('Foo', '^foo$')\");\n            AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,multiline')\");\n            AssertEvaluationResult(false, \"regex-matches('foo\\nbar', '^Foo$')\");\n            Assert.Throws<ConditionEvaluationException>(() => AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,nonexistent')\"));\n        }"
      }
    ]
  },
  {
    "file": "RegexReplaceTests.cs",
    "methods": [
      {
        "name": "ReplaceTestWithoutRegEx",
        "body": "{\n            // Arrange\n            SimpleLayout layout = @\"${regex-replace:inner=${message}:searchFor=foo:replaceWith=BAR}\";\n\n            // Act\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));\n\n            // Assert\n            Assert.Equal(\" BAR bar bar BAR bar FOO\", result);\n        }"
      },
      {
        "name": "ReplaceTestIgnoreCaseWithoutRegEx",
        "body": "{\n            // Arrange\n            SimpleLayout layout = @\"${regex-replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true}\";\n\n            // Act\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));\n\n            // Assert\n            Assert.Equal(\" BAR bar bar BAR bar BAR\", result);\n        }"
      },
      {
        "name": "ReplaceTestWholeWordsWithoutRegEx",
        "body": "{\n            // Arrange\n            SimpleLayout layout = @\"${regex-replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true:WholeWords=true}\";\n\n            // Act\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foobar bar FOO\"));\n\n            // Assert\n            Assert.Equal(\" BAR bar bar foobar bar BAR\", result);\n        }"
      },
      {
        "name": "ReplaceTestWithSimpleRegExFromConfig",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <targets>\n        <target name='d1' type='Debug' layout='${regex-replace:inner=${message}:searchFor=\\\\r\\\\n|\\\\s:replaceWith= }' />\n    </targets>\n    <rules>\n      <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />\n    </rules>\n</nlog>\");\n\n            var d1 = configuration.FindTargetByName(\"d1\") as DebugTarget;\n            Assert.NotNull(d1);\n            var layout = d1.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"\\r\\nfoo\\rbar\\nbar\\tbar bar \\n bar\"));\n            Assert.Equal(\" foo bar bar bar bar   bar\", result);\n        }"
      },
      {
        "name": "ReplaceTestWithSimpleRegExFromConfig2",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <variable name=\"\"whitespace\"\" value=\"\"\\\\r\\\\n|\\\\s\"\" />\n    <variable name=\"\"oneLineMessage\"\" value=\"\"${regex-replace:inner=${message}:searchFor=${whitespace}:replaceWith= }\"\" />\n    <targets>\n      <target name=\"\"d1\"\" type=\"\"Debug\"\" layout=\"\"${oneLineMessage}\"\" />\n    </targets>\n    <rules>\n      <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />\n    </rules>\n</nlog>\");\n\n            var d1 = configuration.FindTargetByName(\"d1\") as DebugTarget;\n            Assert.NotNull(d1);\n            var layout = d1.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"\\r\\nfoo\\rbar\\nbar\\tbar bar \\n bar\"));\n            Assert.Equal(\" foo bar bar bar bar   bar\", result);\n        }"
      },
      {
        "name": "ReplaceTestWithComplexRegEx",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n    <variable name=\"\"searchExp\"\"\n              value=\"\"(?&lt;!\\\\d[ -]*)(?\\:(?&lt;digits&gt;\\\\d)[ -]*)\\{8,16\\}(?=(\\\\d[ -]*)\\{3\\}(\\\\d)(?![ -]\\\\d))\"\"\n              />\n\n    <variable name=\"\"message1\"\" value=\"\"${regex-replace:inner=${message}:searchFor=${searchExp}:replaceWith=X:replaceGroupName=digits:ignorecase=true}\"\" />\n\n    <targets>\n      <target name=\"\"d1\"\" type=\"\"Debug\"\" layout=\"\"${message1}\"\" />\n    </targets>\n\n    <rules>\n      <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />\n    </rules>\n</nlog>\").LogFactory;\n\n            var d1 = logFactory.Configuration.FindTargetByName<DebugTarget>(\"d1\");\n            Assert.NotNull(d1);\n            var layout = d1.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n\n            var testCases = new List<Tuple<string, string>>\n            {\n                Tuple.Create(\"1234\", \"1234\"),\n                Tuple.Create(\"1234-5678-1234-5678\", \"XXXX-XXXX-XXXX-5678\"),\n                Tuple.Create(\"1234 5678 1234 5678\", \"XXXX XXXX XXXX 5678\"),\n                Tuple.Create(\"1234567812345678\", \"XXXXXXXXXXXX5678\"),\n                Tuple.Create(\"ABCD-1234-5678-1234-5678\", \"ABCD-XXXX-XXXX-XXXX-5678\"),\n                Tuple.Create(\"1234-5678-1234-5678-ABCD\", \"XXXX-XXXX-XXXX-5678-ABCD\"),\n                Tuple.Create(\"ABCD-1234-5678-1234-5678-ABCD\", \"ABCD-XXXX-XXXX-XXXX-5678-ABCD\"),\n            };\n\n            foreach (var testCase in testCases)\n            {\n                var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", testCase.Item1));\n                Assert.Equal(testCase.Item2, result);\n            }\n        }"
      }
    ]
  },
  {
    "file": "Log4JXmlTests.cs",
    "methods": [
      {
        "name": "Log4JXmlTest",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                .LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <targets>\n                    <target name='debug' type='Debug' layout='${log4jxmlevent:includeCallSite=true:includeSourceInfo=true:includeNdlc=true:includeMdc=true:IncludeNdc=true:includeMdlc=true:IncludeAllProperties=true:ndcItemSeparator=\\:\\::includenlogdata=true:loggerName=${logger}:formattedMessage=${message}}' />\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            ScopeContext.Clear();\n\n            ScopeContext.PushProperty(\"foo1\", \"bar1\");\n            ScopeContext.PushProperty(\"foo2\", \"bar2\");\n            ScopeContext.PushProperty(\"foo3\", \"bar3\");\n\n            ScopeContext.PushNestedState(\"baz1\");\n            ScopeContext.PushNestedState(\"baz2\");\n            ScopeContext.PushNestedState(\"baz3\");\n\n            var logger = logFactory.GetLogger(\"A\");\n            var logEventInfo = LogEventInfo.Create(LogLevel.Debug, \"A\", new Exception(\"Hello Exception\", new Exception(\"Goodbye Exception\")), null, \"some message \\u0014\");\n            logEventInfo.Properties[\"nlogPropertyKey\"] = \"nlogPropertyValue\";\n            logger.Log(logEventInfo);\n            string result = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\").LastMessage;\n            Assert.DoesNotContain(\"dummy\", result);\n\n            string wrappedResult = \"<log4j:dummyRoot xmlns:log4j='http://log4j' xmlns:nlog='http://nlog'>\" + result + \"</log4j:dummyRoot>\";\n\n            Assert.NotEqual(\"\", result);\n            // make sure the XML can be read back and verify some fields\n            StringReader stringReader = new StringReader(wrappedResult);\n\n            var foundsChilds = new Dictionary<string, int>();\n\n            var requiredChilds = new List<string>\n            {\n                \"log4j.event\",\n                \"log4j.message\",\n                \"log4j.NDC\",\n                \"log4j.locationInfo\",\n                \"log4j.properties\",\n                \"log4j.throwable\",\n                \"log4j.data\",\n            };\n\n            using (XmlReader reader = XmlReader.Create(stringReader))\n            {\n\n                while (reader.Read())\n                {\n                    var key = reader.LocalName;\n                    var fullKey = reader.Prefix + \".\" + key;\n                    if (!foundsChilds.ContainsKey(fullKey))\n                    {\n                        foundsChilds[fullKey] = 0;\n                    }\n                    foundsChilds[fullKey]++;\n\n                    if (reader.NodeType == XmlNodeType.Element && reader.Prefix == \"log4j\")\n                    {\n                        switch (reader.LocalName)\n                        {\n                            case \"dummyRoot\":\n                                break;\n\n                            case \"event\":\n                                Assert.Equal(\"DEBUG\", reader.GetAttribute(\"level\"));\n                                Assert.Equal(\"A\", reader.GetAttribute(\"logger\"));\n\n                                var epochStart = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);\n                                long timestamp = Convert.ToInt64(reader.GetAttribute(\"timestamp\"));\n                                var time = epochStart.AddMilliseconds(timestamp);\n                                var now = DateTime.UtcNow;\n                                Assert.True(now.Ticks - time.Ticks < TimeSpan.FromSeconds(3).Ticks);\n\n                                Assert.Equal(Environment.CurrentManagedThreadId.ToString(), reader.GetAttribute(\"thread\"));\n                                break;\n\n                            case \"message\":\n                                reader.Read();\n                                Assert.Equal(\"some message \", reader.Value);\n                                break;\n\n                            case \"NDC\":\n                                reader.Read();\n                                Assert.Equal(\"baz1::baz2::baz3\", reader.Value);\n                                break;\n\n                            case \"locationInfo\":\n                                Assert.Equal(MethodBase.GetCurrentMethod().DeclaringType.FullName, reader.GetAttribute(\"class\"));\n                                Assert.Equal(MethodBase.GetCurrentMethod().Name, reader.GetAttribute(\"method\"));\n                                break;\n\n                            case \"properties\":\n                                break;\n\n                            case \"throwable\":\n                                reader.Read();\n                                Assert.Contains(\"Hello Exception\", reader.Value);\n                                Assert.Contains(\"Goodbye Exception\", reader.Value);\n                                break;\n                            case \"data\":\n                                string name = reader.GetAttribute(\"name\");\n                                string value = reader.GetAttribute(\"value\");\n\n                                switch (name)\n                                {\n                                    case \"log4japp\":\n                                        Assert.Equal(AppDomain.CurrentDomain.FriendlyName + \"(\" + System.Diagnostics.Process.GetCurrentProcess().Id + \")\", value);\n                                        break;\n\n                                    case \"log4jmachinename\":\n                                        Assert.Equal(Environment.MachineName, value);\n                                        break;\n\n                                    case \"foo1\":\n                                        Assert.Equal(\"bar1\", value);\n                                        break;\n\n                                    case \"foo2\":\n                                        Assert.Equal(\"bar2\", value);\n                                        break;\n\n                                    case \"foo3\":\n                                        Assert.Equal(\"bar3\", value);\n                                        break;\n\n                                    case \"nlogPropertyKey\":\n                                        Assert.Equal(\"nlogPropertyValue\", value);\n                                        break;\n\n                                    default:\n                                        Assert.Fail(\"Unknown <log4j:data>: \" + name);\n                                        break;\n                                }\n                                break;\n\n                            default:\n                                throw new NotSupportedException(\"Unknown element: \" + key);\n                        }\n                    }\n                }\n            }\n\n            foreach (var required in requiredChilds)\n            {\n                Assert.True(foundsChilds.ContainsKey(required), $\"{required} not found!\");\n            }\n        }"
      },
      {
        "name": "Log4JXmlEventLayoutParameterTest",
        "body": "{\n            var log4jLayout = new Log4JXmlEventLayout()\n            {\n                Parameters =\n                {\n                    new Log4JXmlEventParameter\n                    {\n                        Name = \"mt\",\n                        Layout = \"${message:raw=true}\",\n                    }\n                },\n            };\n            log4jLayout.Renderer.AppInfo = \"MyApp\";\n            var logEventInfo = new LogEventInfo\n            {\n                LoggerName = \"MyLOgger\",\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56, DateTimeKind.Utc),\n                Level = LogLevel.Info,\n                Message = \"hello, <{0}>\",\n                Parameters = new[] { \"world\" },\n            };\n\n            var threadid = Environment.CurrentManagedThreadId;\n            var machinename = Environment.MachineName;\n            Assert.Equal($\"<log4j:event logger=\\\"MyLOgger\\\" level=\\\"INFO\\\" timestamp=\\\"1262349296000\\\" thread=\\\"{threadid}\\\"><log4j:message>hello, &lt;world&gt;</log4j:message><log4j:properties><log4j:data name=\\\"mt\\\" value=\\\"hello, &lt;{{0}}&gt;\\\" /><log4j:data name=\\\"log4japp\\\" value=\\\"MyApp\\\" /><log4j:data name=\\\"log4jmachinename\\\" value=\\\"{machinename}\\\" /></log4j:properties></log4j:event>\", log4jLayout.Render(logEventInfo));\n        }"
      },
      {
        "name": "BadXmlValueTest",
        "body": "{\n            var sb = new System.Text.StringBuilder();\n\n            var forbidden = new HashSet<int>();\n            int start = 64976; int end = 65007;\n\n            for (int i = start; i <= end; i++)\n            {\n                forbidden.Add(i);\n            }\n\n            forbidden.Add(0xFFFE);\n            forbidden.Add(0xFFFF);\n\n            for (int i = char.MinValue; i <= char.MaxValue; i++)\n            {\n                char c = Convert.ToChar(i);\n                if (char.IsSurrogate(c))\n                {\n                    continue; // skip surrogates\n                }\n\n                if (forbidden.Contains(c))\n                {\n                    continue;\n                }\n\n                sb.Append(c);\n            }\n\n            var badString = sb.ToString();\n\n            var settings = new XmlWriterSettings\n            {\n                Indent = true,\n                ConformanceLevel = ConformanceLevel.Fragment,\n                IndentChars = \"  \",\n            };\n\n            sb.Length = 0;\n            using (XmlWriter xtw = XmlWriter.Create(sb, settings))\n            {\n                xtw.WriteStartElement(\"log4j\", \"event\", \"http:://hello/\");\n                xtw.WriteElementSafeString(\"log4j\", \"message\", \"http:://hello/\", badString);\n                xtw.WriteEndElement();\n                xtw.Flush();\n            }\n\n            string goodString = null;\n            using (XmlReader reader = XmlReader.Create(new StringReader(sb.ToString())))\n            {\n                while (reader.Read())\n                {\n                    if (reader.NodeType == XmlNodeType.Text)\n                    {\n                        if (reader.Value.Contains(\"abc\"))\n                            goodString = reader.Value;\n                    }\n                }\n            }\n\n            Assert.NotNull(goodString);\n            Assert.NotEqual(badString.Length, goodString.Length);\n            Assert.Contains(\"abc\", badString);\n            Assert.Contains(\"abc\", goodString);\n        }"
      }
    ]
  },
  {
    "file": "HttpNetworkSenderTests.cs",
    "methods": [
      {
        "name": "HttpNetworkSenderViaNetworkTargetTest",
        "body": "{\n            // Arrange\n            var networkTarget = new NetworkTarget(\"target1\")\n            {\n                Address = \"http://test.with.mock\",\n                Layout = \"${logger}|${message}|${exception}\",\n                MaxQueueSize = 1234,\n                OnQueueOverflow = NetworkTargetQueueOverflowAction.Block,\n                MaxMessageSize = 0,\n            };\n\n            var webRequestMock = new WebRequestMock();\n            var networkSenderFactoryMock = CreateNetworkSenderFactoryMock(webRequestMock);\n            networkTarget.SenderFactory = networkSenderFactoryMock;\n\n            var logFactory = new LogFactory();\n            var config = new LoggingConfiguration(logFactory);\n            config.AddRuleForAllLevels(networkTarget);\n            logFactory.Configuration = config;\n\n            var logger = logFactory.GetLogger(\"HttpHappyPathTestLogger\");\n\n            // Act\n            logger.Info(\"test message1\");\n            logFactory.Flush();\n\n            // Assert\n            var mock = webRequestMock;\n\n            var requestedString = mock.GetRequestContentAsString();\n\n            Assert.Equal(\"http://test.with.mock/\", mock.RequestedAddress.ToString());\n            Assert.Equal(\"HttpHappyPathTestLogger|test message1|\", requestedString);\n            Assert.Equal(\"POST\", mock.Method);\n\n            networkSenderFactoryMock.Received(1).Create(\"http://test.with.mock\", 1234, NetworkTargetQueueOverflowAction.Block, 0, SslProtocols.None, TimeSpan.Zero, TimeSpan.Zero);\n\n            // Cleanup\n            mock.Dispose();\n        }"
      },
      {
        "name": "HttpNetworkSenderViaNetworkTargetRecoveryTest",
        "body": "{\n            // Arrange\n            var networkTarget = new NetworkTarget(\"target1\")\n            {\n                Address = \"http://test.with.mock\",\n                Layout = \"${logger}|${message}|${exception}\",\n                MaxQueueSize = 1234,\n                OnQueueOverflow = NetworkTargetQueueOverflowAction.Block,\n                MaxMessageSize = 0,\n            };\n\n            var webRequestMock = new WebRequestMock();\n            webRequestMock.FirstRequestMustFail = true;\n            var networkSenderFactoryMock = CreateNetworkSenderFactoryMock(webRequestMock);\n            networkTarget.SenderFactory = networkSenderFactoryMock;\n\n            var logFactory = new LogFactory();\n            var config = new LoggingConfiguration(logFactory);\n            config.AddRuleForAllLevels(networkTarget);\n            logFactory.Configuration = config;\n\n            var logger = logFactory.GetLogger(\"HttpHappyPathTestLogger\");\n\n            // Act\n            logger.Info(\"test message1\");   // Will fail after short delay\n            logger.Info(\"test message2\");   // Will be queued and sent after short delay\n            logFactory.Flush();\n\n            // Assert\n            var mock = webRequestMock;\n\n            var requestedString = mock.GetRequestContentAsString();\n\n            Assert.Equal(\"http://test.with.mock/\", mock.RequestedAddress.ToString());\n            Assert.Equal(\"HttpHappyPathTestLogger|test message2|\", requestedString);\n            Assert.Equal(\"POST\", mock.Method);\n\n            networkSenderFactoryMock.Received(1).Create(\"http://test.with.mock\", 1234, NetworkTargetQueueOverflowAction.Block, 0, SslProtocols.None, TimeSpan.Zero, TimeSpan.Zero); // Only created one HttpNetworkSender\n\n            // Cleanup\n            mock.Dispose();\n        }"
      }
    ]
  },
  {
    "file": "TcpNetworkSenderTests.cs",
    "methods": [
      {
        "name": "TcpHappyPathTest",
        "body": "{\n            foreach (bool async in new[] { false, true })\n            {\n                var sender = new MyTcpNetworkSender(\"tcp://hostname:123\", AddressFamily.Unspecified)\n                {\n                    Async = async,\n                };\n\n                sender.Initialize();\n                byte[] buffer = Encoding.UTF8.GetBytes(\"quick brown fox jumps over the lazy dog\");\n\n                var exceptions = new List<Exception>();\n\n                for (int i = 1; i < 8; i *= 2)\n                {\n                    sender.Send(\n                        buffer, 0, i, ex =>\n                        {\n                            lock (exceptions) exceptions.Add(ex);\n                        });\n                }\n\n                var mre = new ManualResetEvent(false);\n\n                sender.FlushAsync(ex =>\n                    {\n                        lock (exceptions)\n                        {\n                            exceptions.Add(ex);\n                        }\n\n                        mre.Set();\n                    });\n\n                Assert.True(mre.WaitOne(10000), \"Network Flush not completed\");\n\n                var actual = sender.Log.ToString();\n                Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);\n                Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);\n                Assert.Contains(\"connect async to 0.0.0.0:123\", actual);\n                Assert.Contains(\"send async 0 1 'q'\", actual);\n                Assert.Contains(\"send async 0 2 'qu'\", actual);\n                Assert.Contains(\"send async 0 4 'quic'\", actual);\n\n                mre.Reset();\n                for (int i = 1; i < 8; i *= 2)\n                {\n                    sender.Send(\n                        buffer, 0, i, ex =>\n                        {\n                            lock (exceptions) exceptions.Add(ex);\n                        });\n                }\n\n                sender.Close(ex =>\n                    {\n                        lock (exceptions)\n                        {\n                            exceptions.Add(ex);\n                        }\n\n                        mre.Set();\n                    });\n\n                Assert.True(mre.WaitOne(10000), \"Network Close not completed\");\n\n                actual = sender.Log.ToString();\n\n                Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);\n                Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);\n                Assert.Contains(\"connect async to 0.0.0.0:123\", actual);\n                Assert.Contains(\"send async 0 1 'q'\", actual);\n                Assert.Contains(\"send async 0 2 'qu'\", actual);\n                Assert.Contains(\"send async 0 4 'quic'\", actual);\n                Assert.Contains(\"send async 0 1 'q'\", actual);\n                Assert.Contains(\"send async 0 2 'qu'\", actual);\n                Assert.Contains(\"send async 0 4 'quic'\", actual);\n                Assert.Contains(\"close\", actual);\n\n                foreach (var ex in exceptions)\n                {\n                    Assert.Null(ex);\n                }\n            }\n        }"
      },
      {
        "name": "TcpProxyTest",
        "body": "{\n            var sender = new TcpNetworkSender(\"tcp://foo:1234\", AddressFamily.Unspecified);\n            var socket = sender.CreateSocket(\"foo\", AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, TimeSpan.Zero);\n            Assert.IsType<SocketProxy>(socket);\n        }"
      },
      {
        "name": "TcpConnectFailureTest",
        "body": "{\n            var sender = new MyTcpNetworkSender(\"tcp://hostname:123\", AddressFamily.Unspecified)\n            {\n                ConnectFailure = 1,\n                Async = true,\n            };\n\n            sender.Initialize();\n            byte[] buffer = Encoding.UTF8.GetBytes(\"quick brown fox jumps over the lazy dog\");\n\n            var exceptions = new List<Exception>();\n            var allSent = new ManualResetEvent(false);\n\n            for (int i = 1; i < 8; i++)\n            {\n                sender.Send(\n                    buffer, 0, i, ex =>\n                    {\n                        lock (exceptions)\n                        {\n                            exceptions.Add(ex);\n                            if (exceptions.Count == 7)\n                            {\n                                allSent.Set();\n                            }\n                        }\n                    });\n            }\n\n\n            Assert.True(allSent.WaitOne(10000), \"Network Write not completed\");\n\n            var mre = new ManualResetEvent(false);\n            sender.FlushAsync(ex => mre.Set());\n            Assert.True(mre.WaitOne(10000), \"Network Flush not completed\");\n\n            var actual = sender.Log.ToString();\n\n            Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);\n            Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);\n            Assert.Contains(\"connect async to 0.0.0.0:123\", actual);\n            Assert.Contains(\"failed\", actual);\n\n            foreach (var ex in exceptions)\n            {\n                Assert.NotNull(ex);\n            }\n        }"
      },
      {
        "name": "TcpSendFailureTest",
        "body": "{\n            var sender = new MyTcpNetworkSender(\"tcp://hostname:123\", AddressFamily.Unspecified)\n            {\n                SendFailureIn = 3, // will cause failure on 3rd send\n                Async = true,\n            };\n\n            sender.Initialize();\n            byte[] buffer = Encoding.UTF8.GetBytes(\"quick brown fox jumps over the lazy dog\");\n\n            var exceptions = new Exception[9];\n\n            var writeFinished = new ManualResetEvent(false);\n            int remaining = exceptions.Length;\n\n            for (int i = 1; i < 10; i++)\n            {\n                int pos = i - 1;\n\n                sender.Send(\n                    buffer, 0, i, ex =>\n                    {\n                        lock (exceptions)\n                        {\n                            exceptions[pos] = ex;\n                            if (--remaining == 0)\n                            {\n                                writeFinished.Set();\n                            }\n                        }\n                    });\n            }\n\n            var mre = new ManualResetEvent(false);\n            Assert.True(writeFinished.WaitOne(10000), \"Network Write not completed\");\n            sender.Close(ex => mre.Set());\n            Assert.True(mre.WaitOne(10000), \"Network Flush not completed\");\n\n            var actual = sender.Log.ToString();\n            Assert.Contains(\"Parse endpoint address tcp://hostname:123/ Unspecified\", actual);\n            Assert.Contains(\"create socket InterNetwork Stream Tcp\", actual);\n            Assert.Contains(\"connect async to 0.0.0.0:123\", actual);\n            Assert.Contains(\"send async 0 1 'q'\", actual);\n            Assert.Contains(\"send async 0 2 'qu'\", actual);\n            Assert.Contains(\"send async 0 3 'qui'\", actual);\n            Assert.Contains(\"failed\", actual);\n            Assert.Contains(\"close\", actual);\n\n            for (int i = 0; i < exceptions.Length; ++i)\n            {\n                if (i < 2)\n                {\n                    Assert.Null(exceptions[i]);\n                }\n                else\n                {\n                    Assert.NotNull(exceptions[i]);\n                }\n            }\n        }"
      }
    ]
  },
  {
    "file": "UdpNetworkSenderTests.cs",
    "methods": []
  },
  {
    "file": "ApiTests.cs",
    "methods": [
      {
        "name": "PublicEnumsTest",
        "body": "{\n            foreach (Type type in allTypes)\n            {\n                if (!type.IsPublic)\n                {\n                    continue;\n                }\n\n                if (type.IsEnum || type.IsInterface)\n                {\n                    typeUsageCount[type] = 0;\n                }\n            }\n\n            typeUsageCount[typeof(IInstallable)] = 1;\n\n            foreach (Type type in allTypes)\n            {\n                if (type.IsGenericTypeDefinition)\n                {\n                    continue;\n                }\n\n                if (type.BaseType != null)\n                {\n                    IncrementUsageCount(type.BaseType);\n                }\n\n                foreach (var iface in type.GetInterfaces())\n                {\n                    IncrementUsageCount(iface);\n                }\n\n                foreach (var method in type.GetMethods())\n                {\n                    if (method.IsGenericMethodDefinition)\n                    {\n                        continue;\n                    }\n\n                    // Console.WriteLine(\"  {0}\", method.Name);\n                    try\n                    {\n                        IncrementUsageCount(method.ReturnType);\n\n                        foreach (var p in method.GetParameters())\n                        {\n                            IncrementUsageCount(p.ParameterType);\n                        }\n                    }\n                    catch (Exception ex)\n                    {\n                        // this sometimes throws on .NET Compact Framework, but is not fatal\n                        Console.WriteLine(\"EXCEPTION {0}\", ex);\n                    }\n                }\n            }\n\n            var unusedTypes = new List<Type>();\n            StringBuilder sb = new StringBuilder();\n\n            foreach (var kvp in typeUsageCount)\n            {\n                if (kvp.Value == 0)\n                {\n                    Console.WriteLine(\"Type '{0}' is not used.\", kvp.Key);\n                    unusedTypes.Add(kvp.Key);\n                    sb.Append(kvp.Key.FullName).Append('\\n');\n                }\n            }\n\n            Assert.Empty(unusedTypes);\n        }"
      },
      {
        "name": "TypesInInternalNamespaceShouldBeInternalTest",
        "body": "{\n            var excludes = new HashSet<Type>\n            {\n                typeof(NLog.Internal.Xamarin.PreserveAttribute),\n            };\n\n            var notInternalTypes = allTypes\n                .Where(t => t.Namespace != null && t.Namespace.Contains(\".Internal\"))\n                .Where(t => !t.IsNested && (t.IsVisible || t.IsPublic))\n                .Where(n => !excludes.Contains(n))\n                .Select(t => t.FullName)\n                .ToList();\n\n            Assert.Empty(notInternalTypes);\n        }"
      },
      {
        "name": "TryGetRawValue_ThreadAgnostic_Attribute_Required",
        "body": "{\n            foreach (Type type in allTypes)\n            {\n                if (typeof(NLog.Internal.IRawValue).IsAssignableFrom(type) && !type.IsInterface)\n                {\n                    var threadAgnosticAttribute = type.GetCustomAttribute<ThreadAgnosticAttribute>();\n                    Assert.False(threadAgnosticAttribute is null, $\"{type.ToString()} cannot implement IRawValue\");\n                }\n            }\n        }"
      },
      {
        "name": "IStringValueRenderer_AppDomainFixedOutput_Attribute_NotRequired",
        "body": "{\n            foreach (Type type in allTypes)\n            {\n                if (typeof(NLog.Internal.IStringValueRenderer).IsAssignableFrom(type) && !type.IsInterface)\n                {\n                    var appDomainFixedOutputAttribute = type.GetCustomAttribute<AppDomainFixedOutputAttribute>();\n                    Assert.True(appDomainFixedOutputAttribute is null, $\"{type.ToString()} should not implement IStringValueRenderer\");\n                }\n            }\n        }"
      },
      {
        "name": "RequiredConfigOptionMustBeClass",
        "body": "{\n            foreach (Type type in allTypes)\n            {\n                var properties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n                foreach (var prop in properties)\n                {\n                    var requiredParameter = prop.GetCustomAttribute<NLog.Config.RequiredParameterAttribute>();\n                    if (requiredParameter != null)\n                    {\n                        Assert.True(prop.PropertyType.IsClass, type.Name);\n                    }\n                }\n            }\n        }"
      },
      {
        "name": "SingleDefaultConfigOption",
        "body": "{\n            string prevDefaultPropertyName = null;\n\n            foreach (Type type in allTypes)\n            {\n                prevDefaultPropertyName = null;\n\n                var properties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n                foreach (var prop in properties)\n                {\n                    var defaultParameter = prop.GetCustomAttribute<DefaultParameterAttribute>();\n                    if (defaultParameter != null)\n                    {\n                        Assert.True(prevDefaultPropertyName == null, prevDefaultPropertyName?.ToString());\n                        prevDefaultPropertyName = prop.Name;\n                        Assert.True(type.IsSubclassOf(typeof(NLog.LayoutRenderers.LayoutRenderer)), type.ToString());\n                    }\n                }\n            }\n        }"
      },
      {
        "name": "AppDomainFixedOutput_Attribute_EnsureThreadAgnostic",
        "body": "{\n            foreach (Type type in allTypes)\n            {\n                var appDomainFixedOutputAttribute = type.GetCustomAttribute<AppDomainFixedOutputAttribute>();\n                if (appDomainFixedOutputAttribute != null)\n                {\n                    var threadAgnosticAttribute = type.GetCustomAttribute<ThreadAgnosticAttribute>();\n                    Assert.False(threadAgnosticAttribute is null, $\"{type.ToString()} should also have [ThreadAgnostic]\");\n                }\n            }\n        }"
      },
      {
        "name": "WrapperLayoutRenderer_EnsureThreadAgnostic",
        "body": "{\n            foreach (Type type in allTypes)\n            {\n                if (typeof(NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase).IsAssignableFrom(type))\n                {\n                    if (type.IsAbstract || !type.IsPublic)\n                        continue;   // skip non-concrete types, enumerations, and private nested types\n\n                    Assert.True(type.IsDefined(typeof(ThreadAgnosticAttribute), true), $\"{type.ToString()} is missing [ThreadAgnostic] attribute.\");\n                }\n            }\n        }"
      },
      {
        "name": "ValidateLayoutRendererTypeAlias",
        "body": "{\n            // These class-names should be repaired with next major version bump\n            // Do NOT add more incorrect class-names to this exlusion-list\n            HashSet<string> oldFaultyClassNames = new HashSet<string>()\n            {\n                \"GarbageCollectorInfoLayoutRenderer\",\n                \"ScopeContextNestedStatesLayoutRenderer\",\n                \"ScopeContextPropertyLayoutRenderer\",\n                \"ScopeContextTimingLayoutRenderer\",\n                \"ScopeContextIndentLayoutRenderer\",\n                \"TraceActivityIdLayoutRenderer\",\n                \"SpecialFolderApplicationDataLayoutRenderer\",\n                \"SpecialFolderCommonApplicationDataLayoutRenderer\",\n                \"SpecialFolderLocalApplicationDataLayoutRenderer\",\n                \"DirectorySeparatorLayoutRenderer\",\n                \"LiteralWithRawValueLayoutRenderer\",\n                \"LocalIpAddressLayoutRenderer\",\n                \"VariableLayoutRenderer\",\n                \"ObjectPathRendererWrapper\",\n                \"PaddingLayoutRendererWrapper\",\n            };\n\n            foreach (Type type in allTypes)\n            {\n                if (type.IsSubclassOf(typeof(NLog.LayoutRenderers.LayoutRenderer)))\n                {\n                    var layoutRendererAttributes = type.GetCustomAttributes<NLog.LayoutRenderers.LayoutRendererAttribute>()?.ToArray() ?? NLog.Internal.ArrayHelper.Empty<NLog.LayoutRenderers.LayoutRendererAttribute>();\n                    if (layoutRendererAttributes.Length == 0)\n                    {\n                        if (type != typeof(NLog.LayoutRenderers.FuncLayoutRenderer) && type != typeof(NLog.LayoutRenderers.FuncThreadAgnosticLayoutRenderer))\n                        {\n                            Assert.True(type.IsAbstract, $\"{type} without LayoutRendererAttribute must be abstract\");\n                        }\n                    }\n                    else\n                    {\n                        Assert.False(type.IsAbstract, $\"{type} with LayoutRendererAttribute cannot be abstract\");\n\n                        if (!oldFaultyClassNames.Contains(type.Name))\n                        {\n                            if (type.IsSubclassOf(typeof(NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase)))\n                            {\n                                var typeAlias = layoutRendererAttributes.First().Name.Replace(\"-\", \"\");\n                                Assert.Equal(typeAlias + \"LayoutRendererWrapper\", type.Name, StringComparer.OrdinalIgnoreCase);\n                            }\n                            else\n                            {\n                                var typeAlias = layoutRendererAttributes.First().Name.Replace(\"-\", \"\");\n                                Assert.Equal(typeAlias + \"LayoutRenderer\", type.Name, StringComparer.OrdinalIgnoreCase);\n                            }\n                        }\n                    }\n                }\n            }\n        }"
      },
      {
        "name": "ValidateConfigurationItemFactory",
        "body": "{\n            ConfigurationItemFactory.Default = null;    // Reset\n\n            var missingTypes = new List<string>();\n\n            foreach (Type type in allTypes)\n            {\n                if (!type.IsPublic || !type.IsClass || type.IsAbstract)\n                    continue;\n\n                if (typeof(NLog.Targets.Target).IsAssignableFrom(type))\n                {\n                    var configAttribs = type.GetCustomAttributes<NLog.Targets.TargetAttribute>(false);\n                    Assert.NotEmpty(configAttribs);\n\n                    foreach (var configName in configAttribs)\n                    {\n                        if (!ConfigurationItemFactory.Default.TargetFactory.TryCreateInstance(configName.Name, out var target))\n                        {\n                            Console.WriteLine(configName.Name);\n                            missingTypes.Add(configName.Name);\n                        }\n                        else if (type != target.GetType())\n                        {\n                            Console.WriteLine(type.Name);\n                            missingTypes.Add(type.Name);\n                        }\n                    }\n                }\n                else if (typeof(NLog.Layouts.Layout).IsAssignableFrom(type))\n                {\n                    if (type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(NLog.Layouts.Layout<>)))\n                        continue;\n\n                    if (type == typeof(NLog.Layouts.XmlElement))\n                        continue;\n\n                    var configAttribs = type.GetCustomAttributes<NLog.Layouts.LayoutAttribute>(false);\n                    Assert.NotEmpty(configAttribs);\n\n                    foreach (var configName in configAttribs)\n                    {\n                        if (!ConfigurationItemFactory.Default.LayoutFactory.TryCreateInstance(configName.Name, out var layout))\n                        {\n                            Console.WriteLine(configName.Name);\n                            missingTypes.Add(configName.Name);\n                        }\n                        else if (type != layout.GetType())\n                        {\n                            Console.WriteLine(type.Name);\n                            missingTypes.Add(type.Name);\n                        }\n                    }\n                }\n                else if (typeof(NLog.LayoutRenderers.LayoutRenderer).IsAssignableFrom(type))\n                {\n                    if (type == typeof(NLog.LayoutRenderers.FuncLayoutRenderer) || type == typeof(NLog.LayoutRenderers.FuncThreadAgnosticLayoutRenderer))\n                        continue;\n\n                    var configAttribs = type.GetCustomAttributes<NLog.LayoutRenderers.LayoutRendererAttribute>(false);\n                    Assert.NotEmpty(configAttribs);\n\n                    foreach (var configName in configAttribs)\n                    {\n                        if (!ConfigurationItemFactory.Default.LayoutRendererFactory.TryCreateInstance(configName.Name, out var layoutRenderer))\n                        {\n                            Console.WriteLine(configName.Name);\n                            missingTypes.Add(configName.Name);\n                        }\n                        else if (type != layoutRenderer.GetType())\n                        {\n                            Console.WriteLine(type.Name);\n                            missingTypes.Add(type.Name);\n                        }\n                    }\n\n                    if (typeof(NLog.LayoutRenderers.Wrappers.WrapperLayoutRendererBase).IsAssignableFrom(type))\n                    {\n                        var wrapperAttribs = type.GetCustomAttributes<NLog.LayoutRenderers.AmbientPropertyAttribute>(false);\n                        if (wrapperAttribs?.Any() == true)\n                        {\n                            foreach (var ambientName in wrapperAttribs)\n                            {\n                                if (!ConfigurationItemFactory.Default.AmbientRendererFactory.TryCreateInstance(ambientName.Name, out var layoutRenderer))\n                                {\n                                    Console.WriteLine(ambientName.Name);\n                                    missingTypes.Add(ambientName.Name);\n                                }\n                                else if (type != layoutRenderer.GetType())\n                                {\n                                    Console.WriteLine(type.Name);\n                                    missingTypes.Add(type.Name);\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (typeof(NLog.Filters.Filter).IsAssignableFrom(type))\n                {\n                    if (type == typeof(NLog.Filters.WhenMethodFilter))\n                        continue;\n\n                    var configAttribs = type.GetCustomAttributes<NLog.Filters.FilterAttribute>(false);\n                    Assert.NotEmpty(configAttribs);\n\n                    foreach (var configName in configAttribs)\n                    {\n                        if (!ConfigurationItemFactory.Default.FilterFactory.TryCreateInstance(configName.Name, out var filter))\n                        {\n                            Console.WriteLine(configName.Name);\n                            missingTypes.Add(configName.Name);\n                        }\n                        else if (type != filter.GetType())\n                        {\n                            Console.WriteLine(type.Name);\n                            missingTypes.Add(type.Name);\n                        }\n                    }\n                }\n                else if (typeof(NLog.Time.TimeSource).IsAssignableFrom(type))\n                {\n                    var configAttribs = type.GetCustomAttributes<NLog.Time.TimeSourceAttribute>(false);\n                    Assert.NotEmpty(configAttribs);\n\n                    foreach (var configName in configAttribs)\n                    {\n                        if (!ConfigurationItemFactory.Default.TimeSourceFactory.TryCreateInstance(configName.Name, out var timeSource))\n                        {\n                            Console.WriteLine(configName.Name);\n                            missingTypes.Add(configName.Name);\n                        }\n                        else if (type != timeSource.GetType())\n                        {\n                            Console.WriteLine(type.Name);\n                            missingTypes.Add(type.Name);\n                        }\n                    }\n                }\n            }\n\n            Assert.Empty(missingTypes);\n        }"
      }
    ]
  },
  {
    "file": "AsyncHelperTests.cs",
    "methods": [
      {
        "name": "OneTimeOnlyTest1",
        "body": "{\n            var exceptions = new List<Exception>();\n            AsyncContinuation cont = exceptions.Add;\n            cont = AsyncHelpers.PreventMultipleCalls(cont);\n\n            // OneTimeOnly(OneTimeOnly(x)) == OneTimeOnly(x)\n            var cont2 = AsyncHelpers.PreventMultipleCalls(cont);\n            Assert.Same(cont, cont2);\n\n            var sampleException = new ApplicationException(\"some message\");\n\n            cont(null);\n            cont(sampleException);\n            cont(null);\n            cont(sampleException);\n\n            Assert.Single(exceptions);\n            Assert.Null(exceptions[0]);\n        }"
      },
      {
        "name": "OneTimeOnlyTest2",
        "body": "{\n            var exceptions = new List<Exception>();\n            AsyncContinuation cont = exceptions.Add;\n            cont = AsyncHelpers.PreventMultipleCalls(cont);\n\n            var sampleException = new ApplicationException(\"some message\");\n\n            cont(sampleException);\n            cont(null);\n            cont(sampleException);\n            cont(null);\n\n            Assert.Single(exceptions);\n            Assert.Same(sampleException, exceptions[0]);\n        }"
      },
      {
        "name": "OneTimeOnlyExceptionInHandlerTest",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var exceptions = new List<Exception>();\n                var sampleException = new ApplicationException(\"some message\");\n                AsyncContinuation cont = ex => { exceptions.Add(ex); throw sampleException; };\n                cont = AsyncHelpers.PreventMultipleCalls(cont);\n\n                cont(null);\n                cont(null);\n                cont(null);\n\n                Assert.Single(exceptions);\n                Assert.Null(exceptions[0]);\n            }\n        }"
      },
      {
        "name": "OneTimeOnlyExceptionInHandlerTest_RethrowExceptionEnabled",
        "body": "{\n            LogManager.ThrowExceptions = true;\n\n            var exceptions = new List<Exception>();\n            var sampleException = new ApplicationException(\"some message\");\n            AsyncContinuation cont = ex => { exceptions.Add(ex); throw sampleException; };\n            cont = AsyncHelpers.PreventMultipleCalls(cont);\n\n            try\n            {\n                cont(null);\n            }\n            catch { }\n\n            try\n            {\n                cont(null);\n            }\n            catch { }\n            try\n            {\n                cont(null);\n            }\n            catch { }\n\n            Assert.Single(exceptions);\n            Assert.Null(exceptions[0]);\n        }"
      },
      {
        "name": "ContinuationTimeoutTest",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                var resetEvent = new ManualResetEvent(false);\n                var exceptions = new List<Exception>();\n\n                // set up a timer to strike in 1 second\n                var cont = AsyncHelpers.WithTimeout(ex =>\n                {\n                    exceptions.Add(ex);\n                    resetEvent.Set();\n                }, TimeSpan.FromMilliseconds(1));\n\n                resetEvent.WaitOne(TimeSpan.FromSeconds(1));\n\n                // make sure we got timeout exception\n                Assert.Single(exceptions);\n                Assert.IsType<TimeoutException>(exceptions[0]);\n                Assert.Equal(\"Timeout.\", exceptions[0].Message);\n\n                // those will be ignored\n                cont(null);\n                cont(new ApplicationException(\"Some exception\"));\n                cont(null);\n                cont(new ApplicationException(\"Some exception\"));\n\n                Assert.Single(exceptions);\n            });\n        }"
      },
      {
        "name": "ContinuationTimeoutNotHitTest",
        "body": "{\n            var exceptions = new List<Exception>();\n\n            // set up a timer to strike\n            var cont = AsyncHelpers.WithTimeout(AsyncHelpers.PreventMultipleCalls(exceptions.Add), TimeSpan.FromMilliseconds(50));\n\n            // call success quickly, hopefully before the timer comes\n            cont(null);\n\n            // sleep to make sure timer event comes\n            Thread.Sleep(100);\n\n            // make sure we got success, not a timer exception\n            Assert.Single(exceptions);\n            Assert.Null(exceptions[0]);\n\n            // those will be ignored\n            cont(null);\n            cont(new ApplicationException(\"Some exception\"));\n            cont(null);\n            cont(new ApplicationException(\"Some exception\"));\n\n            Assert.Single(exceptions);\n            Assert.Null(exceptions[0]);\n        }"
      },
      {
        "name": "ContinuationErrorTimeoutNotHitTest",
        "body": "{\n            var exceptions = new List<Exception>();\n\n            // set up a timer to strike\n            var cont = AsyncHelpers.WithTimeout(AsyncHelpers.PreventMultipleCalls(exceptions.Add), TimeSpan.FromMilliseconds(50));\n\n            var exception = new ApplicationException(\"Foo\");\n            // call success quickly, hopefully before the timer comes\n            cont(exception);\n\n            // sleep to make sure timer event comes\n            Thread.Sleep(100);\n\n            // make sure we got success, not a timer exception\n            Assert.Single(exceptions);\n            Assert.NotNull(exceptions[0]);\n\n            Assert.Same(exception, exceptions[0]);\n\n            // those will be ignored\n            cont(null);\n            cont(new ApplicationException(\"Some exception\"));\n            cont(null);\n            cont(new ApplicationException(\"Some exception\"));\n\n            Assert.Single(exceptions);\n            Assert.NotNull(exceptions[0]);\n        }"
      },
      {
        "name": "RepeatTest1",
        "body": "{\n            bool finalContinuationInvoked = false;\n            Exception lastException = null;\n\n            AsyncContinuation finalContinuation = ex =>\n                {\n                    finalContinuationInvoked = true;\n                    lastException = ex;\n                };\n\n            int callCount = 0;\n\n            AsyncHelpers.Repeat(10, finalContinuation,\n                cont =>\n                    {\n                        callCount++;\n                        cont(null);\n                    });\n\n            Assert.True(finalContinuationInvoked);\n            Assert.Null(lastException);\n            Assert.Equal(10, callCount);\n        }"
      },
      {
        "name": "RepeatTest2",
        "body": "{\n            bool finalContinuationInvoked = false;\n            Exception lastException = null;\n            Exception sampleException = new ApplicationException(\"Some message\");\n\n            AsyncContinuation finalContinuation = ex =>\n            {\n                finalContinuationInvoked = true;\n                lastException = ex;\n            };\n\n            int callCount = 0;\n\n            AsyncHelpers.Repeat(10, finalContinuation,\n                cont =>\n                {\n                    callCount++;\n                    cont(sampleException);\n                    cont(sampleException);\n                });\n\n            Assert.True(finalContinuationInvoked);\n            Assert.Same(sampleException, lastException);\n            Assert.Equal(1, callCount);\n        }"
      },
      {
        "name": "RepeatTest3",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                bool finalContinuationInvoked = false;\n                Exception lastException = null;\n                Exception sampleException = new ApplicationException(\"Some message\");\n\n                AsyncContinuation finalContinuation = ex =>\n                {\n                    finalContinuationInvoked = true;\n                    lastException = ex;\n                };\n\n                int callCount = 0;\n\n                AsyncHelpers.Repeat(10, finalContinuation,\n                    cont =>\n                    {\n                        callCount++;\n                        throw sampleException;\n                    });\n\n                Assert.True(finalContinuationInvoked);\n                Assert.Same(sampleException, lastException);\n                Assert.Equal(1, callCount);\n            }\n        }"
      },
      {
        "name": "ForEachItemSequentiallyTest1",
        "body": "{\n            bool finalContinuationInvoked = false;\n            Exception lastException = null;\n\n            AsyncContinuation finalContinuation = ex =>\n            {\n                finalContinuationInvoked = true;\n                lastException = ex;\n            };\n\n            int sum = 0;\n            var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };\n\n            AsyncHelpers.ForEachItemSequentially(input, finalContinuation,\n                (i, cont) =>\n                {\n                    sum += i;\n                    cont(null);\n                    cont(null);\n                });\n\n            Assert.True(finalContinuationInvoked);\n            Assert.Null(lastException);\n            Assert.Equal(55, sum);\n        }"
      },
      {
        "name": "ForEachItemSequentiallyTest2",
        "body": "{\n            bool finalContinuationInvoked = false;\n            Exception lastException = null;\n            Exception sampleException = new ApplicationException(\"Some message\");\n\n            AsyncContinuation finalContinuation = ex =>\n            {\n                finalContinuationInvoked = true;\n                lastException = ex;\n            };\n\n            int sum = 0;\n            var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };\n\n            AsyncHelpers.ForEachItemSequentially(input, finalContinuation,\n                (i, cont) =>\n                {\n                    sum += i;\n                    cont(sampleException);\n                    cont(sampleException);\n                });\n\n            Assert.True(finalContinuationInvoked);\n            Assert.Same(sampleException, lastException);\n            Assert.Equal(1, sum);\n        }"
      },
      {
        "name": "ForEachItemSequentiallyTest3",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                bool finalContinuationInvoked = false;\n                Exception lastException = null;\n                Exception sampleException = new ApplicationException(\"Some message\");\n\n                AsyncContinuation finalContinuation = ex =>\n                {\n                    finalContinuationInvoked = true;\n                    lastException = ex;\n                };\n\n                int sum = 0;\n                var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };\n\n                AsyncHelpers.ForEachItemSequentially(input, finalContinuation,\n                    (i, cont) =>\n                    {\n                        sum += i;\n                        throw sampleException;\n                    });\n\n                Assert.True(finalContinuationInvoked);\n                Assert.Same(sampleException, lastException);\n                Assert.Equal(1, sum);\n            }\n        }"
      },
      {
        "name": "ForEachItemInParallelEmptyTest",
        "body": "{\n            int[] items = ArrayHelper.Empty<int>();\n            Exception lastException = null;\n            bool finalContinuationInvoked = false;\n\n            AsyncContinuation continuation = ex =>\n                {\n                    lastException = ex;\n                    finalContinuationInvoked = true;\n                };\n\n            AsyncHelpers.ForEachItemInParallel(items, continuation, (i, cont) => { Assert.Fail(\"Should not be reached\"); });\n            Assert.True(finalContinuationInvoked);\n            Assert.Null(lastException);\n        }"
      },
      {
        "name": "ForEachItemInParallelTest",
        "body": "{\n            var finalContinuationInvoked = new ManualResetEvent(false);\n            Exception lastException = null;\n\n            AsyncContinuation finalContinuation = ex =>\n            {\n                lastException = ex;\n                finalContinuationInvoked.Set();\n            };\n\n            int sum = 0;\n            var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };\n\n            AsyncHelpers.ForEachItemInParallel(input, finalContinuation,\n                (i, cont) =>\n                {\n                    lock (input)\n                    {\n                        sum += i;\n                    }\n\n                    cont(null);\n                    cont(null);\n                });\n\n            finalContinuationInvoked.WaitOne();\n            Assert.Null(lastException);\n            Assert.Equal(55, sum);\n        }"
      },
      {
        "name": "ForEachItemInParallelSingleFailureTest",
        "body": "{\n            using (new InternalLoggerScope())\n            using (new NoThrowNLogExceptions())\n            {\n                InternalLogger.LogLevel = LogLevel.Trace;\n\n                var finalContinuationInvoked = new ManualResetEvent(false);\n                Exception lastException = null;\n\n                AsyncContinuation finalContinuation = ex =>\n                    {\n                        lastException = ex;\n                        finalContinuationInvoked.Set();\n                    };\n\n                int sum = 0;\n                var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };\n\n                AsyncHelpers.ForEachItemInParallel(input, finalContinuation,\n                    (i, cont) =>\n                        {\n\n                            lock (input)\n                            {\n                                sum += i;\n                            }\n\n                            if (i == 7)\n                            {\n                                throw new ApplicationException(\"Some failure.\");\n                            }\n\n                            cont(null);\n                        });\n\n                finalContinuationInvoked.WaitOne();\n                Assert.Equal(55, sum);\n                Assert.NotNull(lastException);\n                Assert.IsType<ApplicationException>(lastException);\n                Assert.Equal(\"Some failure.\", lastException.Message);\n            }\n        }"
      },
      {
        "name": "ForEachItemInParallelMultipleFailuresTest",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var finalContinuationInvoked = new ManualResetEvent(false);\n                Exception lastException = null;\n\n                AsyncContinuation finalContinuation = ex =>\n                {\n                    lastException = ex;\n                    finalContinuationInvoked.Set();\n                };\n\n                int sum = 0;\n                var input = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, };\n\n                AsyncHelpers.ForEachItemInParallel(input, finalContinuation,\n                    (i, cont) =>\n                    {\n                        lock (input)\n                        {\n                            sum += i;\n                        }\n\n                        throw new ApplicationException(\"Some failure.\");\n                    });\n\n                finalContinuationInvoked.WaitOne();\n                Assert.Equal(55, sum);\n                Assert.NotNull(lastException);\n                Assert.IsType<NLogRuntimeException>(lastException);\n                Assert.StartsWith(\"Got multiple exceptions:\\r\\n\", lastException.Message);\n            }\n        }"
      },
      {
        "name": "PrecededByTest1",
        "body": "{\n            int invokedCount1 = 0;\n            int invokedCount2 = 0;\n            int sequence = 7;\n            int invokedCount1Sequence = 0;\n            int invokedCount2Sequence = 0;\n\n            AsyncContinuation originalContinuation = ex =>\n            {\n                invokedCount1++;\n                invokedCount1Sequence = sequence++;\n            };\n\n            AsynchronousAction doSomethingElse = c =>\n            {\n                invokedCount2++;\n                invokedCount2Sequence = sequence++;\n                c(null);\n                c(null);\n            };\n\n            AsyncContinuation cont = AsyncHelpers.PrecededBy(originalContinuation, doSomethingElse);\n            cont(null);\n\n            // make sure doSomethingElse was invoked first\n            // then original continuation\n            Assert.Equal(7, invokedCount2Sequence);\n            Assert.Equal(8, invokedCount1Sequence);\n            Assert.Equal(1, invokedCount1);\n            Assert.Equal(1, invokedCount2);\n        }"
      },
      {
        "name": "PrecededByTest2",
        "body": "{\n            int invokedCount1 = 0;\n            int invokedCount2 = 0;\n            int sequence = 7;\n            int invokedCount1Sequence = 0;\n            int invokedCount2Sequence = 0;\n\n            AsyncContinuation originalContinuation = ex =>\n            {\n                invokedCount1++;\n                invokedCount1Sequence = sequence++;\n            };\n\n            AsynchronousAction doSomethingElse = c =>\n            {\n                invokedCount2++;\n                invokedCount2Sequence = sequence++;\n                c(null);\n                c(null);\n            };\n\n            AsyncContinuation cont = AsyncHelpers.PrecededBy(originalContinuation, doSomethingElse);\n            var sampleException = new ApplicationException(\"Some message.\");\n            cont(sampleException);\n\n            // make sure doSomethingElse was not invoked\n            Assert.Equal(0, invokedCount2Sequence);\n            Assert.Equal(7, invokedCount1Sequence);\n            Assert.Equal(1, invokedCount1);\n            Assert.Equal(0, invokedCount2);\n        }"
      }
    ]
  },
  {
    "file": "ConditionEvaluatorTests.cs",
    "methods": [
      {
        "name": "ConditionMethodsTest",
        "body": "{\n            AssertEvaluationResult(true, \"regex-matches('foo', '^foo$')\");\n            AssertEvaluationResult(false, \"regex-matches('foo', '^bar$')\");\n\n            //Check that calling with empty string is equivalent with not passing the parameter\n            AssertEvaluationResult(true, \"regex-matches('foo', '^foo$', '')\");\n            AssertEvaluationResult(false, \"regex-matches('foo', '^bar$', '')\");\n\n            //Check that options are parsed correctly\n            AssertEvaluationResult(true, \"regex-matches('Foo', '^foo$', 'ignorecase')\");\n            AssertEvaluationResult(false, \"regex-matches('Foo', '^foo$')\");\n            AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,multiline')\");\n            AssertEvaluationResult(false, \"regex-matches('foo\\nbar', '^Foo$')\");\n            Assert.Throws<ConditionEvaluationException>(() => AssertEvaluationResult(true, \"regex-matches('foo\\nbar', '^Foo$', 'ignorecase,nonexistent')\"));\n        }"
      }
    ]
  },
  {
    "file": "ConditionParserTests.cs",
    "methods": [
      {
        "name": "ParseNullText",
        "body": "{\n            Assert.Null(ConditionParser.ParseExpression(null));\n        }"
      },
      {
        "name": "ParseEmptyText",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"\"));\n        }"
      },
      {
        "name": "ImplicitOperatorTest",
        "body": "{\n            ConditionExpression cond = \"true and true\";\n\n            Assert.IsType<ConditionAndExpression>(cond);\n        }"
      },
      {
        "name": "NullLiteralTest",
        "body": "{\n            Assert.Equal(\"null\", ConditionParser.ParseExpression(\"null\").ToString());\n        }"
      },
      {
        "name": "BooleanLiteralTest",
        "body": "{\n            Assert.Equal(\"True\", ConditionParser.ParseExpression(\"true\").ToString());\n            Assert.Equal(\"True\", ConditionParser.ParseExpression(\"tRuE\").ToString());\n            Assert.Equal(\"False\", ConditionParser.ParseExpression(\"false\").ToString());\n            Assert.Equal(\"False\", ConditionParser.ParseExpression(\"fAlSe\").ToString());\n        }"
      },
      {
        "name": "AndTest",
        "body": "{\n            Assert.Equal(\"(True and True)\", ConditionParser.ParseExpression(\"true and true\").ToString());\n            Assert.Equal(\"(True and True)\", ConditionParser.ParseExpression(\"tRuE AND true\").ToString());\n            Assert.Equal(\"(True and True)\", ConditionParser.ParseExpression(\"tRuE && true\").ToString());\n            Assert.Equal(\"((True and True) and True)\", ConditionParser.ParseExpression(\"true and true && true\").ToString());\n            Assert.Equal(\"((True and True) and True)\", ConditionParser.ParseExpression(\"tRuE AND true and true\").ToString());\n            Assert.Equal(\"((True and True) and True)\", ConditionParser.ParseExpression(\"tRuE && true AND true\").ToString());\n        }"
      },
      {
        "name": "OrTest",
        "body": "{\n            Assert.Equal(\"(True or True)\", ConditionParser.ParseExpression(\"true or true\").ToString());\n            Assert.Equal(\"(True or True)\", ConditionParser.ParseExpression(\"tRuE OR true\").ToString());\n            Assert.Equal(\"(True or True)\", ConditionParser.ParseExpression(\"tRuE || true\").ToString());\n            Assert.Equal(\"((True or True) or True)\", ConditionParser.ParseExpression(\"true or true || true\").ToString());\n            Assert.Equal(\"((True or True) or True)\", ConditionParser.ParseExpression(\"tRuE OR true or true\").ToString());\n            Assert.Equal(\"((True or True) or True)\", ConditionParser.ParseExpression(\"tRuE || true OR true\").ToString());\n        }"
      },
      {
        "name": "NotTest",
        "body": "{\n            Assert.Equal(\"(not True)\", ConditionParser.ParseExpression(\"not true\").ToString());\n            Assert.Equal(\"(not (not True))\", ConditionParser.ParseExpression(\"not not true\").ToString());\n            Assert.Equal(\"(not (not (not True)))\", ConditionParser.ParseExpression(\"not not not true\").ToString());\n        }"
      },
      {
        "name": "StringTest",
        "body": "{\n            Assert.Equal(\"''\", ConditionParser.ParseExpression(\"''\").ToString());\n            Assert.Equal(\"'Foo'\", ConditionParser.ParseExpression(\"'Foo'\").ToString());\n            Assert.Equal(\"'Bar'\", ConditionParser.ParseExpression(\"'Bar'\").ToString());\n            Assert.Equal(\"'d'Artagnan'\", ConditionParser.ParseExpression(\"'d''Artagnan'\").ToString());\n\n            var cle = ConditionParser.ParseExpression(\"'${message} ${level}'\") as ConditionLayoutExpression;\n            Assert.NotNull(cle);\n            SimpleLayout sl = cle.Layout as SimpleLayout;\n            Assert.NotNull(sl);\n            Assert.Equal(3, sl.Renderers.Count);\n            Assert.IsType<MessageLayoutRenderer>(sl.Renderers[0]);\n            Assert.IsType<LiteralLayoutRenderer>(sl.Renderers[1]);\n            Assert.IsType<LevelLayoutRenderer>(sl.Renderers[2]);\n\n        }"
      },
      {
        "name": "LogLevelTest",
        "body": "{\n            var result = ConditionParser.ParseExpression(\"LogLevel.Info\") as ConditionLiteralExpression;\n            Assert.NotNull(result);\n            Assert.Same(LogLevel.Info, result.LiteralValue);\n\n            result = ConditionParser.ParseExpression(\"LogLevel.Trace\") as ConditionLiteralExpression;\n            Assert.NotNull(result);\n            Assert.Same(LogLevel.Trace, result.LiteralValue);\n        }"
      },
      {
        "name": "RelationalOperatorTest",
        "body": "{\n            RelationalOperatorTestInner(\"=\", \"==\");\n            RelationalOperatorTestInner(\"==\", \"==\");\n            RelationalOperatorTestInner(\"!=\", \"!=\");\n            RelationalOperatorTestInner(\"<>\", \"!=\");\n            RelationalOperatorTestInner(\"<\", \"<\");\n            RelationalOperatorTestInner(\">\", \">\");\n            RelationalOperatorTestInner(\"<=\", \"<=\");\n            RelationalOperatorTestInner(\">=\", \">=\");\n        }"
      },
      {
        "name": "NumberTest",
        "body": "{\n            var conditionExpression = ConditionParser.ParseExpression(\"3.141592\");\n            Assert.Equal(\"3.141592\", conditionExpression.ToString());\n            Assert.Equal(\"42\", ConditionParser.ParseExpression(\"42\").ToString());\n            Assert.Equal(\"-42\", ConditionParser.ParseExpression(\"-42\").ToString());\n            Assert.Equal(\"-3.141592\", ConditionParser.ParseExpression(\"-3.141592\").ToString());\n        }"
      },
      {
        "name": "ExtraParenthesisTest",
        "body": "{\n            Assert.Equal(\"3.141592\", ConditionParser.ParseExpression(\"(((3.141592)))\").ToString());\n        }"
      },
      {
        "name": "MessageTest",
        "body": "{\n            var result = ConditionParser.ParseExpression(\"message\");\n            Assert.IsType<ConditionMessageExpression>(result);\n            Assert.Equal(\"message\", result.ToString());\n        }"
      },
      {
        "name": "LevelTest",
        "body": "{\n            var result = ConditionParser.ParseExpression(\"level\");\n            Assert.IsType<ConditionLevelExpression>(result);\n            Assert.Equal(\"level\", result.ToString());\n        }"
      },
      {
        "name": "LoggerTest",
        "body": "{\n            var result = ConditionParser.ParseExpression(\"logger\");\n            Assert.IsType<ConditionLoggerNameExpression>(result);\n            Assert.Equal(\"logger\", result.ToString());\n        }"
      },
      {
        "name": "ConditionFunctionTests",
        "body": "{\n            var result = ConditionParser.ParseExpression(\"starts-with(logger, 'x${message}')\") as ConditionMethodExpression;\n            Assert.NotNull(result);\n            Assert.Equal(\"starts-with\", result.MethodName);\n            Assert.Equal(\"starts-with(logger, 'x${message}')\", result.ToString());\n            Assert.Equal(2, result.MethodParameters.Count);\n        }"
      },
      {
        "name": "CustomNLogFactoriesTest",
        "body": "{\n            var configurationItemFactory = new ConfigurationItemFactory();\n            configurationItemFactory.LayoutRendererFactory.RegisterType<FooLayoutRenderer>(\"foo\");\n            configurationItemFactory.ConditionMethodFactory.RegisterDefinition(\"check\", typeof(MyConditionMethods).GetMethod(\"CheckIt\"));\n\n            var result = ConditionParser.ParseExpression(\"check('${foo}')\", configurationItemFactory);\n            Assert.NotNull(result);\n        }"
      },
      {
        "name": "MethodNameWithUnderscores",
        "body": "{\n            var configurationItemFactory = new ConfigurationItemFactory();\n            configurationItemFactory.LayoutRendererFactory.RegisterType<FooLayoutRenderer>(\"foo\");\n            configurationItemFactory.ConditionMethodFactory.RegisterDefinition(\"__check__\", typeof(MyConditionMethods).GetMethod(\"CheckIt\"));\n\n            var result = ConditionParser.ParseExpression(\"__check__('${foo}')\", configurationItemFactory);\n            Assert.NotNull(result);\n        }"
      },
      {
        "name": "UnbalancedParenthesis1Test",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"check(\"));\n        }"
      },
      {
        "name": "UnbalancedParenthesis2Test",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"((1)\"));\n        }"
      },
      {
        "name": "UnbalancedParenthesis3Test",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"(1))\"));\n        }"
      },
      {
        "name": "LogLevelWithoutAName",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"LogLevel.'somestring'\"));\n        }"
      },
      {
        "name": "InvalidNumberWithUnaryMinusTest",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"-a31\"));\n        }"
      },
      {
        "name": "InvalidNumberTest",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"-123.4a\"));\n        }"
      },
      {
        "name": "UnclosedString",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"'Hello world\"));\n        }"
      },
      {
        "name": "UnrecognizedToken",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"somecompletelyunrecognizedtoken\"));\n        }"
      },
      {
        "name": "UnrecognizedPunctuation",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"#\"));\n        }"
      },
      {
        "name": "UnrecognizedUnicodeChar",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"\\u0090\"));\n        }"
      },
      {
        "name": "UnrecognizedUnicodeChar2",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"\\u0015\"));\n        }"
      },
      {
        "name": "UnrecognizedMethod",
        "body": "{\n            Assert.Throws<ConditionParseException>(() => ConditionParser.ParseExpression(\"unrecognized-method()\"));\n        }"
      },
      {
        "name": "TokenizerEOFTest",
        "body": "{\n            var tokenizer = new ConditionTokenizer(new SimpleStringReader(string.Empty));\n            Assert.Throws<ConditionParseException>(() => tokenizer.GetNextToken());\n        }"
      }
    ]
  },
  {
    "file": "ConfigApiTests.cs",
    "methods": [
      {
        "name": "AddTarget_testname",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(\"name1\", new FileTarget { Name = \"File\" });\n            var allTargets = config.AllTargets;\n            Assert.NotNull(allTargets);\n            Assert.Single(allTargets);\n\n            //maybe confusing, but the name of the target is not changed, only the one of the key.\n            Assert.Equal(\"File\", allTargets.First().Name);\n            Assert.NotNull(config.FindTargetByName<FileTarget>(\"name1\"));\n\n            config.RemoveTarget(\"name1\");\n            allTargets = config.AllTargets;\n            Assert.Empty(allTargets);\n        }"
      },
      {
        "name": "AddTarget_WithName_NullNameParam",
        "body": "{\n            var config = new LoggingConfiguration();\n            var ex = Assert.Throws<ArgumentNullException>(() => config.AddTarget(name: null, target: new FileTarget { Name = \"name1\" }));\n            Assert.Equal(\"name\", ex.ParamName);\n        }"
      },
      {
        "name": "AddTarget_WithName_EmptyNameParam",
        "body": "{\n            var config = new LoggingConfiguration();\n            var ex = Assert.Throws<ArgumentException>(() => config.AddTarget(name: \"\", target: new FileTarget { Name = \"name1\" }));\n            Assert.Equal(\"name\", ex.ParamName);\n        }"
      },
      {
        "name": "AddTarget_WithName_NullTargetParam",
        "body": "{\n            var config = new LoggingConfiguration();\n            var ex = Assert.Throws<ArgumentNullException>(() => config.AddTarget(name: \"Name1\", target: null));\n            Assert.Equal(\"target\", ex.ParamName);\n        }"
      },
      {
        "name": "AddTarget_TargetOnly_NullParam",
        "body": "{\n            var config = new LoggingConfiguration();\n            var ex = Assert.Throws<ArgumentNullException>(() => config.AddTarget(target: null));\n            Assert.Equal(\"target\", ex.ParamName);\n        }"
      },
      {
        "name": "AddTarget_TargetOnly_EmptyName",
        "body": "{\n            var config = new LoggingConfiguration();\n            var ex = Assert.Throws<ArgumentException>(() => config.AddTarget(target: new FileTarget { Name = \"\" }));\n            Assert.Equal(\"target\", ex.ParamName);\n        }"
      },
      {
        "name": "AddTarget_testname_param",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(\"name1\", new FileTarget { Name = \"name2\" });\n            var allTargets = config.AllTargets;\n            Assert.NotNull(allTargets);\n            Assert.Single(allTargets);\n\n            //maybe confusing, but the name of the target is not changed, only the one of the key.\n            Assert.Equal(\"name2\", allTargets.First().Name);\n            Assert.NotNull(config.FindTargetByName<FileTarget>(\"name1\"));\n        }"
      },
      {
        "name": "AddTarget_testname_fromtarget",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(new FileTarget { Name = \"name2\" });\n            var allTargets = config.AllTargets;\n            Assert.NotNull(allTargets);\n            Assert.Single(allTargets);\n            Assert.Equal(\"name2\", allTargets.First().Name);\n            Assert.NotNull(config.FindTargetByName<FileTarget>(\"name2\"));\n        }"
      },
      {
        "name": "AddRule_min_max",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(new FileTarget { Name = \"File\" });\n            config.AddRule(LogLevel.Info, LogLevel.Error, \"File\", \"*a\");\n            Assert.NotNull(config.LoggingRules);\n            Assert.Single(config.LoggingRules);\n            var rule1 = config.LoggingRules.FirstOrDefault();\n            Assert.NotNull(rule1);\n            Assert.False(rule1.Final);\n            Assert.Equal(\"*a\", rule1.LoggerNamePattern);\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Fatal));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Error));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Warn));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Info));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Debug));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Trace));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Off));\n        }"
      },
      {
        "name": "AddRule_ruleobject",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(new FileTarget { Name = \"File\" });\n            LoggingRule rule = new LoggingRule(\"testRule\")\n            {\n                LoggerNamePattern = \"testRulePattern\"\n            };\n            rule.EnableLoggingForLevels(LogLevel.Info, LogLevel.Error);\n            rule.Targets.Add(config.FindTargetByName(\"File\"));\n            rule.Final = true;\n            config.AddRule(rule);\n            Assert.NotNull(config.LoggingRules);\n            Assert.Single(config.LoggingRules);\n            var lastRule = config.LoggingRules.LastOrDefault();\n            Assert.Same(rule, lastRule);\n        }"
      },
      {
        "name": "AddRule_all",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(new FileTarget { Name = \"File\" });\n            config.AddRuleForAllLevels(\"File\", \"*a\");\n            Assert.NotNull(config.LoggingRules);\n            Assert.Single(config.LoggingRules);\n            var rule1 = config.LoggingRules.FirstOrDefault();\n            Assert.NotNull(rule1);\n            Assert.False(rule1.Final);\n            Assert.Equal(\"*a\", rule1.LoggerNamePattern);\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Fatal));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Error));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Warn));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Info));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Debug));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Trace));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Off));\n        }"
      },
      {
        "name": "AddRule_onelevel",
        "body": "{\n            var config = new LoggingConfiguration();\n            config.AddTarget(new FileTarget { Name = \"File\" });\n            config.AddRuleForOneLevel(LogLevel.Error, \"File\", \"*a\");\n            Assert.NotNull(config.LoggingRules);\n            Assert.Single(config.LoggingRules);\n            var rule1 = config.LoggingRules.FirstOrDefault();\n            Assert.NotNull(rule1);\n            Assert.False(rule1.Final);\n            Assert.Equal(\"*a\", rule1.LoggerNamePattern);\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Fatal));\n            Assert.True(rule1.IsLoggingEnabledForLevel(LogLevel.Error));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Warn));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Info));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Debug));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Trace));\n            Assert.False(rule1.IsLoggingEnabledForLevel(LogLevel.Off));\n        }"
      },
      {
        "name": "AddRule_with_target",
        "body": "{\n            var config = new LoggingConfiguration();\n            var fileTarget = new FileTarget { Name = \"File\" };\n            config.AddRuleForOneLevel(LogLevel.Error, fileTarget, \"*a\");\n            Assert.NotNull(config.LoggingRules);\n            Assert.Single(config.LoggingRules);\n            config.AddTarget(new FileTarget { Name = \"File\" });\n            var allTargets = config.AllTargets;\n            Assert.NotNull(allTargets);\n            Assert.Single(allTargets);\n            Assert.Equal(\"File\", allTargets.First().Name);\n            Assert.NotNull(config.FindTargetByName<FileTarget>(\"File\"));\n        }"
      },
      {
        "name": "AddRule_missingtarget",
        "body": "{\n            var config = new LoggingConfiguration();\n\n            Assert.Throws<NLogConfigurationException>(() => config.AddRuleForOneLevel(LogLevel.Error, \"File\", \"*a\"));\n        }"
      },
      {
        "name": "CheckAllTargets",
        "body": "{\n            var config = new LoggingConfiguration();\n            var fileTarget = new FileTarget { Name = \"File\", FileName = \"file\" };\n            config.AddRuleForOneLevel(LogLevel.Error, fileTarget, \"*a\");\n\n            config.AddTarget(fileTarget);\n\n            Assert.Single(config.AllTargets);\n            Assert.Equal(fileTarget, config.AllTargets[0]);\n\n            config.InitializeAll();\n\n            Assert.Single(config.AllTargets);\n            Assert.Equal(fileTarget, config.AllTargets[0]);\n        }"
      },
      {
        "name": "LogRuleToStringTest_min",
        "body": "{\n            var target = new FileTarget { Name = \"file1\" };\n            var loggingRule = new LoggingRule(\"*\", LogLevel.Error, target);\n            var s = loggingRule.ToString();\n            Assert.Equal(\"logNamePattern: (:All) levels: [ Error Fatal ] writeTo: [ file1 ]\", s);\n        }"
      },
      {
        "name": "LogRuleToStringTest_minAndMax",
        "body": "{\n            var target = new FileTarget { Name = \"file1\" };\n            var loggingRule = new LoggingRule(\"*\", LogLevel.Debug, LogLevel.Error, target);\n            var s = loggingRule.ToString();\n            Assert.Equal(\"logNamePattern: (:All) levels: [ Debug Info Warn Error ] writeTo: [ file1 ]\", s);\n        }"
      },
      {
        "name": "LogRuleToStringTest_none",
        "body": "{\n            var target = new FileTarget { Name = \"file1\" };\n            var loggingRule = new LoggingRule(\"*\", target);\n            var s = loggingRule.ToString();\n            Assert.Equal(\"logNamePattern: (:All) levels: [ ] writeTo: [ file1 ]\", s);\n        }"
      },
      {
        "name": "LogRuleToStringTest_empty",
        "body": "{\n            var target = new FileTarget { Name = \"file1\" };\n            var loggingRule = new LoggingRule(\"\", target);\n            var s = loggingRule.ToString();\n            Assert.Equal(\"logNamePattern: (:Equals) levels: [ ] writeTo: [ file1 ]\", s);\n        }"
      },
      {
        "name": "LogRuleToStringTest_filter",
        "body": "{\n            var target = new FileTarget { Name = \"file1\" };\n            var loggingRule = new LoggingRule(\"namespace.comp1\", target);\n            var s = loggingRule.ToString();\n            Assert.Equal(\"logNamePattern: (namespace.comp1:Equals) levels: [ ] writeTo: [ file1 ]\", s);\n        }"
      },
      {
        "name": "LogRuleToStringTest_multiple_targets",
        "body": "{\n            var target = new FileTarget { Name = \"file1\" };\n            var target2 = new FileTarget { Name = \"file2\" };\n            var loggingRule = new LoggingRule(\"namespace.comp1\", target);\n            loggingRule.Targets.Add(target2);\n            var s = loggingRule.ToString();\n            Assert.Equal(\"logNamePattern: (namespace.comp1:Equals) levels: [ ] writeTo: [ file1 file2 ]\", s);\n        }"
      },
      {
        "name": "LogRuleSetLoggingLevels_enables",
        "body": "{\n            var rule = new LoggingRule();\n            rule.SetLoggingLevels(LogLevel.Warn, LogLevel.Fatal);\n            Assert.Equal(rule.Levels, new[] { LogLevel.Warn, LogLevel.Error, LogLevel.Fatal });\n        }"
      },
      {
        "name": "LogRuleSetLoggingLevels_disables",
        "body": "{\n            var rule = new LoggingRule();\n            rule.EnableLoggingForLevels(LogLevel.MinLevel, LogLevel.MaxLevel);\n\n            rule.SetLoggingLevels(LogLevel.Warn, LogLevel.Fatal);\n            Assert.Equal(rule.Levels, new[] { LogLevel.Warn, LogLevel.Error, LogLevel.Fatal });\n        }"
      },
      {
        "name": "LogRuleSetLoggingLevels_off",
        "body": "{\n            var rule = new LoggingRule();\n            rule.EnableLoggingForLevels(LogLevel.MinLevel, LogLevel.MaxLevel);\n\n            rule.SetLoggingLevels(LogLevel.Off, LogLevel.Off);\n            Assert.Equal(rule.Levels, ArrayHelper.Empty<LogLevel>());\n        }"
      },
      {
        "name": "LogRuleDisableLoggingLevels",
        "body": "{\n            var rule = new LoggingRule();\n            rule.EnableLoggingForLevels(LogLevel.MinLevel, LogLevel.MaxLevel);\n\n            rule.DisableLoggingForLevels(LogLevel.Warn, LogLevel.Fatal);\n            Assert.Equal(rule.Levels, new[] { LogLevel.Trace, LogLevel.Debug, LogLevel.Info });\n        }"
      },
      {
        "name": "ConfigLogRuleWithName",
        "body": "{\n            var config = new LoggingConfiguration();\n            var rule = new LoggingRule(\"hello\");\n            config.LoggingRules.Add(rule);\n            var ruleLookup = config.FindRuleByName(\"hello\");\n            Assert.Same(rule, ruleLookup);\n            Assert.True(config.RemoveRuleByName(\"hello\"));\n            ruleLookup = config.FindRuleByName(\"hello\");\n            Assert.Null(ruleLookup);\n            Assert.False(config.RemoveRuleByName(\"hello\"));\n        }"
      },
      {
        "name": "FindRuleByName_AfterRename_FindNewOneAndDontFindOld",
        "body": "{\n            // Arrange\n            var config = new LoggingConfiguration();\n            var rule = new LoggingRule(\"hello\");\n            config.LoggingRules.Add(rule);\n\n            // Act\n            var foundRule1 = config.FindRuleByName(\"hello\");\n            foundRule1.RuleName = \"world\";\n            var foundRule2 = config.FindRuleByName(\"hello\");\n            var foundRule3 = config.FindRuleByName(\"world\");\n\n            // Assert\n            Assert.Null(foundRule2);\n            Assert.NotNull(foundRule1);\n            Assert.Same(foundRule1, foundRule3);\n        }"
      },
      {
        "name": "LoggerNameMatcher_None",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(null);\n            Assert.Equal(\"logNamePattern: (:None)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_All",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"*\");\n            Assert.Equal(\"logNamePattern: (:All)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_Empty",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"\");\n            Assert.Equal(\"logNamePattern: (:Equals)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_Equals",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"abc\");\n            Assert.Equal(\"logNamePattern: (abc:Equals)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_StartsWith",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"abc*\");\n            Assert.Equal(\"logNamePattern: (abc:StartsWith)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_EndsWith",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"*abc\");\n            Assert.Equal(\"logNamePattern: (abc:EndsWith)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_Contains",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"*abc*\");\n            Assert.Equal(\"logNamePattern: (abc:Contains)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_MultiplePattern_StarInternal",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"a*bc\");\n            Assert.Equal(\"logNamePattern: (a*bc:MultiplePattern)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_MultiplePattern_QuestionMark",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"a?bc\");\n            Assert.Equal(\"logNamePattern: (a?bc:MultiplePattern)\", matcher.ToString());\n        }"
      },
      {
        "name": "LoggerNameMatcher_MultiplePattern_EscapedChars",
        "body": "{\n            var matcher = LoggerNameMatcher.Create(\"a?b.c.foo.bar\");\n            Assert.Equal(\"logNamePattern: (a?b.c.foo.bar:MultiplePattern)\", matcher.ToString());\n        }"
      }
    ]
  },
  {
    "file": "ConfigurationItemFactoryTests.cs",
    "methods": [
      {
        "name": "ConfigurationItemFactoryTargetTest",
        "body": "{\n            var itemFactory = new ConfigurationItemFactory();\n            itemFactory.TargetFactory.RegisterType<MemoryTarget>(nameof(MemoryTarget));\n            itemFactory.TargetFactory.TryCreateInstance(nameof(MemoryTarget), out var result);\n            Assert.IsType<MemoryTarget>(result);\n        }"
      },
      {
        "name": "ConfigurationItemFactoryFailsTest",
        "body": "{\n            var itemFactory = new ConfigurationItemFactory();\n            var ex = Assert.ThrowsAny<Exception>(() => itemFactory.GetTargetFactory().CreateInstance(\"Memory-Target\") as MemoryTarget);\n            Assert.Contains(\"Memory-Target\", ex.Message);\n\n            itemFactory.GetTargetFactory().RegisterDefinition(nameof(MemoryTarget), typeof(MemoryTarget));\n            var result = itemFactory.GetTargetFactory().CreateInstance(\"Memory-Target\");\n            Assert.IsType<MemoryTarget>(result);\n        }"
      },
      {
        "name": "ConfigurationItemFactorySimpleTest",
        "body": "{\n            var itemFactory = new ConfigurationItemFactory();\n            itemFactory.RegisterType<DebugTarget>();\n            itemFactory.TargetFactory.TryCreateInstance(\"Debug\", out var result);\n            Assert.NotNull(result);\n        }"
      }
    ]
  },
  {
    "file": "CultureInfoTests.cs",
    "methods": [
      {
        "name": "WhenInvariantCultureDefinedThenDefaultCultureIsInvariantCulture",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(\"<nlog useInvariantCulture='true'></nlog>\");\n\n            Assert.Equal(CultureInfo.InvariantCulture, configuration.DefaultCultureInfo);\n        }"
      },
      {
        "name": "DifferentConfigurations_UseDifferentDefaultCulture",
        "body": "{\n            var currentCulture = CultureInfo.CurrentCulture;\n            try\n            {\n                // set the current thread culture to be definitely different from the InvariantCulture\n                Thread.CurrentThread.CurrentCulture = GetCultureInfo(\"de-DE\");\n\n                var configurationTemplate = @\"<nlog useInvariantCulture='{0}'>\n<targets>\n    <target name='debug' type='Debug' layout='${{message}}' />\n</targets>\n<rules>\n    <logger name='*' writeTo='debug'/>\n</rules>\n</nlog>\";\n\n                // configuration with current culture\n                var logFactory1 = new LogFactory();\n                var configuration1 = XmlLoggingConfiguration.CreateFromXmlString(string.Format(configurationTemplate, false), logFactory1);\n                Assert.Null(configuration1.DefaultCultureInfo);\n                logFactory1.Configuration = configuration1;\n\n                // configuration with invariant culture\n                var logFactory2 = new LogFactory();\n                var configuration2 = XmlLoggingConfiguration.CreateFromXmlString(string.Format(configurationTemplate, true), logFactory2);\n                Assert.Equal(CultureInfo.InvariantCulture, configuration2.DefaultCultureInfo);\n                logFactory2.Configuration = configuration2;\n\n                Assert.NotEqual(configuration1.DefaultCultureInfo, configuration2.DefaultCultureInfo);\n\n                var testNumber = 3.14;\n                var testDate = DateTime.Now;\n                const string formatString = \"{0},{1:d}\";\n\n                AssertMessageFormattedWithCulture(logFactory1, CultureInfo.CurrentCulture, formatString, testNumber, testDate);\n                AssertMessageFormattedWithCulture(logFactory2, CultureInfo.InvariantCulture, formatString, testNumber, testDate);\n            }\n            finally\n            {\n                // restore current thread culture\n                Thread.CurrentThread.CurrentCulture = currentCulture;\n            }\n        }"
      },
      {
        "name": "EventPropRendererCultureTest",
        "body": "{\n            string cultureName = \"de-DE\";\n            string expected = \"1,23\";   // with decimal comma\n\n            var logEventInfo = CreateLogEventInfo(cultureName);\n            logEventInfo.Properties[\"ADouble\"] = 1.23;\n\n            var renderer = new EventPropertiesLayoutRenderer();\n            renderer.Item = \"ADouble\";\n            string output = renderer.Render(logEventInfo);\n\n            Assert.Equal(expected, output);\n        }"
      },
      {
        "name": "ProcessInfoLayoutRendererCultureTest",
        "body": "{\n            string cultureName = \"de-DE\";\n            string expected = \".\";   // dot as date separator (01.10.2008)\n            string output = string.Empty;\n\n            var logEventInfo = CreateLogEventInfo(cultureName);\n\n            if (IsLinux())\n            {\n                Console.WriteLine(\"[SKIP] CultureInfoTests.ProcessInfoLayoutRendererCultureTest because we are running in Travis\");\n            }\n            else\n            {\n                var renderer = new ProcessInfoLayoutRenderer();\n                renderer.Property = ProcessInfoProperty.StartTime;\n                renderer.Format = \"d\";\n                output = renderer.Render(logEventInfo);\n\n                Assert.Contains(expected, output);\n                Assert.DoesNotContain(\"/\", output);\n                Assert.DoesNotContain(\"-\", output);\n            }\n\n            var renderer2 = new ProcessInfoLayoutRenderer();\n            renderer2.Property = ProcessInfoProperty.PriorityClass;\n            renderer2.Format = \"d\";\n            output = renderer2.Render(logEventInfo);\n            Assert.True(output.Length >= 1);\n            Assert.Contains(output[0], \"012345678\");\n        }"
      },
      {
        "name": "AllEventPropRendererCultureTest",
        "body": "{\n            string cultureName = \"de-DE\";\n            string expected = \"ADouble=1,23\";   // with decimal comma\n\n            var logEventInfo = CreateLogEventInfo(cultureName);\n            logEventInfo.Properties[\"ADouble\"] = 1.23;\n\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            string output = renderer.Render(logEventInfo);\n\n            Assert.Equal(expected, output);\n        }"
      },
      {
        "name": "ExceptionTest",
        "body": "{\n            var target = new MemoryTarget { Layout = @\"${exception:format=tostring}\" };\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(target);\n            }).GetCurrentClassLogger();\n\n            try\n            {\n                throw new InvalidOperationException();\n            }\n            catch (Exception ex)\n            {\n                Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"en-US\", false);\n                Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-US\", false);\n                logger.Error(ex, \"\");\n\n#if NETFRAMEWORK\n                Thread.CurrentThread.CurrentUICulture = new CultureInfo(\"de-DE\", false);\n                Thread.CurrentThread.CurrentCulture = new CultureInfo(\"de-DE\", false);\n#endif\n                logger.Error(ex, \"\");\n\n                Assert.Equal(2, target.Logs.Count);\n                Assert.NotNull(target.Logs[0]);\n                Assert.NotNull(target.Logs[1]);\n                Assert.Equal(target.Logs[0], target.Logs[1]);\n            }\n        }"
      }
    ]
  },
  {
    "file": "ExtensionTests.cs",
    "methods": [
      {
        "name": "ExtensionTest1",
        "body": "{\n            Assert.NotNull(typeof(FooLayout));\n\n            var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n    <extensions>\n        <add assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />\n    </extensions>\n\n    <targets>\n        <target name='t' type='MyTarget' />\n        <target name='d1' type='Debug' layout='${foo}' />\n        <target name='d2' type='Debug'>\n            <layout type='FooLayout' x='1'>\n            </layout>\n        </target>\n    </targets>\n\n    <rules>\n      <logger name='*' writeTo='t'>\n        <filters>\n           <whenFoo x='44' action='Log' />\n        </filters>\n      </logger>\n    </rules>\n</nlog>\").LogFactory.Configuration;\n\n            Target myTarget = configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");\n            var layout = d1Target.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n            Assert.Single(layout.Renderers);\n            Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);\n\n            var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");\n            Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);\n\n            Assert.Single(configuration.LoggingRules[0].Filters);\n            Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);\n        }"
      },
      {
        "name": "ExtensionTest2",
        "body": "{\n            var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n    <extensions>\n        <add assembly='\" + extensionAssemblyName1 + @\"' />\n    </extensions>\n\n    <targets>\n        <target name='t' type='MyTarget' />\n        <target name='d1' type='Debug' layout='${foo}' />\n        <target name='d2' type='Debug'>\n            <layout type='FooLayout' x='1'>\n            </layout>\n        </target>\n    </targets>\n\n    <rules>\n      <logger name='*' writeTo='t'>\n        <filters>\n           <whenFoo x='44' action='Ignore' />\n           <when condition='myrandom(10)==3' action='Log' />\n        </filters>\n      </logger>\n    </rules>\n</nlog>\").LogFactory.Configuration;\n\n            Target myTarget = configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");\n            var layout = d1Target.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n            Assert.Single(layout.Renderers);\n            Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);\n\n            var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");\n            Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);\n\n            Assert.Equal(2, configuration.LoggingRules[0].Filters.Count);\n            Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);\n            var cbf = configuration.LoggingRules[0].Filters[1] as ConditionBasedFilter;\n            Assert.NotNull(cbf);\n            Assert.Equal(\"(myrandom(10) == 3)\", cbf.Condition.ToString());\n        }"
      },
      {
        "name": "ExtensionWithPrefixLoadTwiceTest",
        "body": "{\n            var configuration = new LogFactory().Setup().SetupExtensions(ext => ext.RegisterAssembly(extensionAssemblyName1))\n                .LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n    <extensions>\n        <add assembly='\" + extensionAssemblyName1 + @\"' prefix='twice' />\n    </extensions>\n\n    <targets>\n        <target name='t' type='twice.MyTarget' />\n        <target name='d1' type='Debug' layout='${foo}' />\n        <target name='d2' type='Debug'>\n            <layout type='twice.FooLayout' x='1'>\n            </layout>\n        </target>\n    </targets>\n\n    <rules>\n      <logger name='*' writeTo='t'>\n        <filters>\n           <whenFoo x='44' action='Ignore' />\n           <when condition='myrandom(10)==3' action='Log' />\n        </filters>\n      </logger>\n    </rules>\n</nlog>\").LogFactory.Configuration;\n\n            Target myTarget = configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");\n            var layout = d1Target.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n            Assert.Single(layout.Renderers);\n            Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);\n\n            var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");\n            Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);\n\n            Assert.Equal(2, configuration.LoggingRules[0].Filters.Count);\n            Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);\n            var cbf = configuration.LoggingRules[0].Filters[1] as ConditionBasedFilter;\n            Assert.NotNull(cbf);\n            Assert.Equal(\"(myrandom(10) == 3)\", cbf.Condition.ToString());\n        }"
      },
      {
        "name": "ExtensionWithPrefixTest",
        "body": "{\n            var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n    <extensions>\n        <add prefix='myprefix' assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />\n    </extensions>\n\n    <targets>\n        <target name='t' type='myprefix.MyTarget' />\n        <target name='d1' type='Debug' layout='${myprefix.foo}' />\n        <target name='d2' type='Debug'>\n            <layout type='myprefix.FooLayout' x='1'>\n            </layout>\n        </target>\n    </targets>\n\n    <rules>\n      <logger name='*' writeTo='t'>\n        <filters>\n           <myprefix.whenFoo x='44' action='Log' />\n        </filters>\n      </logger>\n    </rules>\n</nlog>\").LogFactory.Configuration;\n\n            Target myTarget = configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");\n            var layout = d1Target.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n            Assert.Single(layout.Renderers);\n            Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);\n\n            var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");\n            Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);\n\n            Assert.Single(configuration.LoggingRules[0].Filters);\n            Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);\n        }"
      },
      {
        "name": "ExtensionTest4",
        "body": "{\n            Assert.NotNull(typeof(FooLayout));\n\n            var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n    <extensions>\n        <add type='\" + typeof(MyTarget).AssemblyQualifiedName + @\"' />\n        <add type='\" + typeof(FooLayout).AssemblyQualifiedName + @\"' />\n        <add type='\" + typeof(FooLayoutRenderer).AssemblyQualifiedName + @\"' />\n        <add type='\" + typeof(WhenFooFilter).AssemblyQualifiedName + @\"' />\n    </extensions>\n\n    <targets>\n        <target name='t' type='MyTarget' />\n        <target name='d1' type='Debug' layout='${foo}' />\n        <target name='d2' type='Debug'>\n            <layout type='FooLayout' x='1'>\n            </layout>\n        </target>\n    </targets>\n\n    <rules>\n      <logger name='*' writeTo='t'>\n        <filters>\n           <whenFoo x='44' action='Log' />\n        </filters>\n      </logger>\n    </rules>\n</nlog>\").LogFactory.Configuration;\n\n            Target myTarget = configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");\n            var layout = d1Target.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n            Assert.Single(layout.Renderers);\n            Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);\n\n            var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");\n            Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);\n\n            Assert.Single(configuration.LoggingRules[0].Filters);\n            Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);\n        }"
      },
      {
        "name": "RegisterNamedTypeLessTest",
        "body": "{\n            Assert.NotNull(typeof(FooLayout));\n            var configurationItemFactory = new ConfigurationItemFactory();\n            configurationItemFactory.GetLayoutFactory().RegisterNamedType(\"foo\", typeof(FooLayout).ToString() + \",\" + typeof(FooLayout).Assembly.GetName().Name);\n            Assert.NotNull(configurationItemFactory.LayoutFactory.CreateInstance(\"foo\"));\n        }"
      },
      {
        "name": "ExtensionTest_extensions_not_top_and_used",
        "body": "{\n            Assert.NotNull(typeof(FooLayout));\n\n            var configuration = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n\n    <targets>\n        <target name='t' type='MyTarget' />\n        <target name='d1' type='Debug' layout='${foo}' />\n        <target name='d2' type='Debug'>\n            <layout type='FooLayout' x='1'>\n            </layout>\n        </target>\n    </targets>\n\n    <rules>\n      <logger name='*' writeTo='t'>\n        <filters>\n           <whenFoo x='44' action='Log' />\n        </filters>\n      </logger>\n    </rules>\n\n    <extensions>\n        <add assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />\n    </extensions>\n\n</nlog>\").LogFactory.Configuration;\n\n            Target myTarget = configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"MyExtensionNamespace.MyTarget\", myTarget.GetType().FullName);\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d1\");\n            var layout = d1Target.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n            Assert.Single(layout.Renderers);\n            Assert.Equal(\"MyExtensionNamespace.FooLayoutRenderer\", layout.Renderers[0].GetType().FullName);\n\n            var d2Target = (DebugTarget)configuration.FindTargetByName(\"d2\");\n            Assert.Equal(\"MyExtensionNamespace.FooLayout\", d2Target.Layout.GetType().FullName);\n\n            Assert.Single(configuration.LoggingRules[0].Filters);\n            Assert.Equal(\"MyExtensionNamespace.WhenFooFilter\", configuration.LoggingRules[0].Filters[0].GetType().FullName);\n        }"
      },
      {
        "name": "ExtensionShouldThrowNLogConfiguratonExceptionWhenRegisteringInvalidType",
        "body": "{\n            var configXml = @\"\n<nlog throwConfigExceptions='true'>\n    <extensions>\n                <add type='some_type_that_doesnt_exist'/>\n</extensions>\n</nlog>\";\n            Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(configXml));\n        }"
      },
      {
        "name": "ExtensionShouldThrowNLogConfiguratonExceptionWhenRegisteringInvalidAssembly",
        "body": "{\n            var configXml = @\"\n<nlog throwConfigExceptions='true'>\n    <extensions>\n        <add assembly='some_assembly_that_doesnt_exist'/>\n    </extensions>\n</nlog>\";\n            Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(configXml));\n        }"
      },
      {
        "name": "ExtensionShouldThrowNLogConfiguratonExceptionWhenRegisteringInvalidAssemblyFile",
        "body": "{\n            var configXml = @\"\n<nlog throwConfigExceptions='true'>\n    <extensions>\n                <add assemblyfile='some_file_that_doesnt_exist'/>\n</extensions>\n</nlog>\";\n            Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(configXml));\n        }"
      },
      {
        "name": "ExtensionShouldNotThrowWhenRegisteringInvalidTypeIfThrowConfigExceptionsFalse",
        "body": "{\n            var configXml = @\"\n<nlog throwConfigExceptions='false'>\n    <extensions>\n                <add type='some_type_that_doesnt_exist'/>\n                <add assembly='NLog'/>\n</extensions>\n</nlog>\";\n            var result = XmlLoggingConfiguration.CreateFromXmlString(configXml);\n            Assert.NotNull(result);\n        }"
      },
      {
        "name": "ExtensionShouldNotThrowWhenRegisteringInvalidAssemblyIfThrowConfigExceptionsFalse",
        "body": "{\n            var configXml = @\"\n<nlog throwConfigExceptions='false'>\n    <extensions>\n        <add assembly='some_assembly_that_doesnt_exist'/>\n    </extensions>\n</nlog>\";\n            var result = XmlLoggingConfiguration.CreateFromXmlString(configXml);\n            Assert.NotNull(result);\n        }"
      },
      {
        "name": "ExtensionShouldNotThrowWhenRegisteringInvalidAssemblyFileIfThrowConfigExceptionsFalse",
        "body": "{\n            var configXml = @\"\n<nlog throwConfigExceptions='false'>\n    <extensions>\n                <add assemblyfile='some_file_that_doesnt_exist'/>\n</extensions>\n</nlog>\";\n            var result = XmlLoggingConfiguration.CreateFromXmlString(configXml);\n            Assert.NotNull(result);\n        }"
      },
      {
        "name": "CustomXmlNamespaceTest",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true' xmlns:foo='http://bar'>\n    <targets>\n        <target name='d' type='foo:Debug' />\n    </targets>\n</nlog>\");\n\n            var d1Target = (DebugTarget)configuration.FindTargetByName(\"d\");\n            Assert.NotNull(d1Target);\n        }"
      },
      {
        "name": "Extension_should_be_auto_loaded_when_following_NLog_dll_format",
        "body": "{\n            var fileLocations = AssemblyExtensionLoader.GetAutoLoadingFileLocations().ToArray();\n            Assert.NotEmpty(fileLocations);\n            Assert.NotNull(fileLocations[0].Key);\n            Assert.NotNull(fileLocations[0].Value); // Primary search location is NLog-assembly\n            Assert.Equal(fileLocations.Length, fileLocations.Select(f => f.Key).Distinct().Count());\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true' autoLoadExtensions='true'>\n<targets>\n    <target name='t' type='AutoLoadTarget' />\n</targets>\n\n<rules>\n    <logger name='*' writeTo='t' />\n</rules>\n</nlog>\").LogFactory;\n\n            var autoLoadedTarget = logFactory.Configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"NLogAutloadExtension.AutoLoadTarget\", autoLoadedTarget.GetType().ToString());\n        }"
      },
      {
        "name": "ExtensionTypeWithAssemblyNameCanLoad",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog throwExceptions='true'>\n<targets>\n    <target name='t' type='AutoLoadTarget,  NLogAutoLoadExtension' />\n</targets>\n<rules>\n    <logger name='*' writeTo='t' />\n</rules>\n</nlog>\").LogFactory;\n\n            var autoLoadedTarget = logFactory.Configuration.FindTargetByName(\"t\");\n            Assert.Equal(\"NLogAutloadExtension.AutoLoadTarget\", autoLoadedTarget.GetType().ToString());\n        }"
      },
      {
        "name": "ImplicitConversionOperatorTest",
        "body": "{\n            var config = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog throwExceptions='true'>\n    <extensions>\n        <add assemblyFile='\" + GetExtensionAssemblyFullPath() + @\"' />\n    </extensions>\n                <targets>\n                    <target name='myTarget' type='MyTarget' layout='123' />\n                </targets>\n                <rules>\n                    <logger name='*' level='Debug' writeTo='myTarget' />\n                </rules>\n            </nlog>\");\n\n            var target = config.FindTargetByName<MyTarget>(\"myTarget\");\n            Assert.NotNull(target);\n            Assert.Equal(123, target.Layout.X);\n        }"
      },
      {
        "name": "LoadExtensionFromAppDomain",
        "body": "{\n            try\n            {\n                LoadManuallyLoadedExtensionDll();\n\n                InternalLogger.LogLevel = LogLevel.Trace;\n                var writer = new StringWriter();\n                InternalLogger.LogWriter = writer;\n\n                var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <extensions>\n        <add assembly='Manually-Loaded-Extension' />\n    </extensions>\n\n    <targets>\n        <target name='t' type='ManuallyLoadedTarget' />\n    </targets>\n</nlog>\");\n\n                // We get Exception for normal Assembly-Load only in net452.\n#if NETFRAMEWORK && !MONO\n                var logs = writer.ToString();\n                Assert.Contains(\"Try find 'Manually-Loaded-Extension' in current domain\", logs);\n#endif\n\n                // Was AssemblyLoad successful?\n                var autoLoadedTarget = configuration.FindTargetByName(\"t\");\n                Assert.Equal(\"ManuallyLoadedExtension.ManuallyLoadedTarget\", autoLoadedTarget.GetType().FullName);\n            }\n            finally\n            {\n                InternalLogger.Reset();\n            }\n        }"
      },
      {
        "name": "FullyQualifiedExtensionTest",
        "body": "{\n            // Arrange\n\n            LoadManuallyLoadedExtensionDll();\n\n            // Act\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"<nlog throwConfigExceptions='true'>\n                <targets>\n                    <target name='t' type='ManuallyLoadedTarget, Manually-Loaded-Extension' />\n                </targets>\n            </nlog>\").LogFactory;\n\n\n            // Assert\n            Assert.NotNull(logFactory.Configuration.FindTargetByName(\"t\"));\n        }"
      }
    ]
  },
  {
    "file": "IncludeTests.cs",
    "methods": [
      {
        "name": "IncludeTest",
        "body": "{\n            LogManager.ThrowExceptions = true;\n            var includeAttrValue = @\"included.nlog\";\n            IncludeTest_inner(includeAttrValue, GetTempDir());\n        }"
      },
      {
        "name": "IncludeWildcardTest_relative",
        "body": "{\n            var includeAttrValue = @\"*.nlog\";\n            IncludeTest_inner(includeAttrValue, GetTempDir());\n        }"
      },
      {
        "name": "IncludeWildcardTest_absolute",
        "body": "{\n            var includeAttrValue = @\"*.nlog\";\n            var tempPath = GetTempDir();\n            includeAttrValue = Path.Combine(tempPath, includeAttrValue);\n            IncludeTest_inner(includeAttrValue, tempPath);\n        }"
      },
      {
        "name": "IncludeNotExistingTest",
        "body": "{\n            LogManager.ThrowConfigExceptions = true;\n            string tempPath = GetTempDir();\n            Directory.CreateDirectory(tempPath);\n\n            using (StreamWriter fs = File.CreateText(Path.Combine(tempPath, \"main.nlog\")))\n            {\n                fs.Write(@\"<nlog>\n                <include file='included.nlog' />\n            </nlog>\");\n            }\n\n            string fileToLoad = Path.Combine(tempPath, \"main.nlog\");\n\n            try\n            {\n                Assert.Throws<NLogConfigurationException>(() => new XmlLoggingConfiguration(fileToLoad));\n            }\n            finally\n            {\n                if (Directory.Exists(tempPath))\n                    Directory.Delete(tempPath, true);\n            }\n        }"
      },
      {
        "name": "IncludeNotExistingIgnoredTest",
        "body": "{\n            var tempPath = GetTempDir();\n            Directory.CreateDirectory(tempPath);\n\n            var config = @\"<nlog>\n                <include file='included-notpresent.nlog' ignoreErrors='true' />\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\";\n\n            CreateConfigFile(tempPath, \"main.nlog\", config);\n\n            string fileToLoad = Path.Combine(tempPath, \"main.nlog\");\n            try\n            {\n                LogManager.Configuration = new XmlLoggingConfiguration(fileToLoad);\n                LogManager.GetLogger(\"A\").Debug(\"aaa\");\n                AssertDebugLastMessage(\"debug\", \"aaa\");\n            }\n            finally\n            {\n                if (Directory.Exists(tempPath))\n                    Directory.Delete(tempPath, true);\n            }\n        }"
      },
      {
        "name": "IncludeNotExistingIgnoredTest_DoesNotThrow",
        "body": "{\n            LogManager.ThrowExceptions = true;\n            var tempPath = GetTempDir();\n            Directory.CreateDirectory(tempPath);\n\n            var config = @\"<nlog>\n                <include file='included-notpresent.nlog' ignoreErrors='true' />\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\";\n\n            CreateConfigFile(tempPath, \"main.nlog\", config);\n            string fileToLoad = Path.Combine(tempPath, \"main.nlog\");\n\n            var ex = Record.Exception(() => new XmlLoggingConfiguration(fileToLoad));\n            Assert.Null(ex);\n        }"
      }
    ]
  },
  {
    "file": "InternalLoggingTests.cs",
    "methods": [
      {
        "name": "InternalLoggingConfigTest1",
        "body": "{\n            InternalLoggingConfigTest(LogLevel.Trace, true, true, LogLevel.Warn, true, true, @\"c:\\temp\\nlog\\file.txt\", true);\n        }"
      },
      {
        "name": "InternalLoggingConfigTest2",
        "body": "{\n            InternalLoggingConfigTest(LogLevel.Error, false, false, LogLevel.Info, false, false, @\"c:\\temp\\nlog\\file2.txt\", false);\n        }"
      },
      {
        "name": "InternalLoggingConfigTes3",
        "body": "{\n            InternalLoggingConfigTest(LogLevel.Info, false, false, LogLevel.Trace, false, null, @\"c:\\temp\\nlog\\file3.txt\", true);\n        }"
      },
      {
        "name": "InternalLoggingConfigTestDefaults",
        "body": "{\n            using (new InternalLoggerScope(true))\n            {\n                InternalLogger.LogLevel = LogLevel.Error;\n                InternalLogger.LogToConsole = true;\n                InternalLogger.LogToConsoleError = true;\n                LogManager.GlobalThreshold = LogLevel.Fatal;\n                LogManager.ThrowExceptions = true;\n                LogManager.ThrowConfigExceptions = null;\n                LogManager.AutoShutdown = true;\n\n                XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog>\n</nlog>\");\n\n                Assert.Same(LogLevel.Error, InternalLogger.LogLevel);\n                Assert.True(InternalLogger.LogToConsole);\n                Assert.True(InternalLogger.LogToConsoleError);\n                Assert.Same(LogLevel.Fatal, LogManager.GlobalThreshold);\n                Assert.True(LogManager.ThrowExceptions);\n                Assert.Null(LogManager.ThrowConfigExceptions);\n                Assert.True(LogManager.AutoShutdown);\n            }\n        }"
      },
      {
        "name": "InternalLoggingConfig_off_should_be_off",
        "body": "{\n            using (new InternalLoggerScope())\n            {\n                var sb = new StringBuilder();\n                var stringWriter = new StringWriter(sb);\n                InternalLogger.LogWriter = stringWriter;\n                InternalLogger.LogLevel = LogLevel.Info;\n                string wrongFileName = \"WRONG/***[]???////WRONG\";\n                LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString($@\"<?xml version='1.0' encoding='utf-8' ?>\n    <nlog internalLogFile='{wrongFileName}'\n          internalLogLevel='Off'\n          throwExceptions='true' >\n\n      <targets>\n        <target name='logfile' type='File' fileName='WRONG'  />\n      </targets>\n\n      <rules>\n        <logger name='*' writeTo='logfile' />\n      </rules>\n    </nlog>\n    \");\n\n                Assert.Equal(\"\", sb.ToString());\n                Assert.Equal(LogLevel.Off, InternalLogger.LogLevel);\n                Assert.False(InternalLogger.ExceptionThrowWhenWriting);\n            }\n        }"
      },
      {
        "name": "InternalLoggingInvalidFormatString",
        "body": "{\n            using (new InternalLoggerScope())\n            {\n                var sb = new StringBuilder();\n                var stringWriter = new StringWriter(sb);\n                InternalLogger.LogWriter = stringWriter;\n                InternalLogger.LogLevel = LogLevel.Info;\n\n                var invalidFormatString = \"Invalid String.Format({Message})\";\n                InternalLogger.Warn(invalidFormatString, \"Oops\");\n                Assert.Contains(invalidFormatString, sb.ToString());\n            }\n        }"
      }
    ]
  },
  {
    "file": "PropertyTypeConverterTests.cs",
    "methods": [
      {
        "name": "Convert_IntToNullableIntTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(123, typeof(int?), null, null);\n\n            // Assert\n            // int is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<int>(result);\n            Assert.Equal(123, resultTyped);\n        }"
      },
      {
        "name": "Convert_NullableIntToIntTest",
        "body": "{\n            // Act\n            var result = _sut.Convert((int?)123, typeof(int), null, null);\n\n            // Assert\n            // int is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<int>(result);\n            Assert.Equal(123, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToIntTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123\", typeof(int), null, null);\n\n            // Assert\n            var resultTyped = Assert.IsType<int>(result);\n            Assert.Equal(123, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToNullableIntTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123\", typeof(int?), null, null);\n\n            // Assert\n            // int is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<int>(result);\n            Assert.Equal(123, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToDecimalTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123.2\", typeof(decimal), null, CultureInfo.InvariantCulture);\n\n            // Assert\n            var resultTyped = Assert.IsType<decimal>(result);\n            Assert.Equal(123.2M, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToDecimalWithCultureTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123,2\", typeof(decimal), null, new CultureInfo(\"NL-nl\"));\n\n            // Assert\n            var resultTyped = Assert.IsType<decimal>(result);\n            Assert.Equal(123.2M, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToNullableDecimalTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123.2\", typeof(decimal?), null, CultureInfo.InvariantCulture);\n\n            // Assert\n            // decimal is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<decimal>(result);\n            Assert.Equal(123.2M, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToDoubleTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123.2\", typeof(double), null, CultureInfo.InvariantCulture);\n\n            // Assert\n            var resultTyped = Assert.IsType<double>(result);\n            Assert.Equal(123.2, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToDoubleWithCultureTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123,2\", typeof(double), null, new CultureInfo(\"NL-nl\"));\n\n            // Assert\n            var resultTyped = Assert.IsType<double>(result);\n            Assert.Equal(123.2, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToNullableDoubleTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123.2\", typeof(double?), null, CultureInfo.InvariantCulture);\n\n            // Assert\n            // double is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<double>(result);\n            Assert.Equal(123.2, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToShortTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123\", typeof(short), null, CultureInfo.InvariantCulture);\n\n            // Assert\n            var resultTyped = Assert.IsType<short>(result);\n            Assert.Equal(123, resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToNullableShortTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(\"123\", typeof(short), null, CultureInfo.InvariantCulture);\n\n            // Assert\n            // short is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<short>(result);\n            Assert.Equal(123, resultTyped);\n        }"
      },
      {
        "name": "Convert_FormattableToStringTest",
        "body": "{\n            // Act\n            var result = _sut.Convert(123, typeof(string), \"D4\", null);\n\n            // Assert\n            var resultTyped = Assert.IsType<string>(result);\n            Assert.Equal(\"0123\", resultTyped);\n        }"
      },
      {
        "name": "Convert_NullableFormattableToStringTest",
        "body": "{\n            // Arrange\n            int? nullableInt = 123;\n\n            // Act\n            var result = _sut.Convert(nullableInt, typeof(string), \"D4\", null);\n\n            // Assert\n            var resultTyped = Assert.IsType<string>(result);\n            Assert.Equal(\"0123\", resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToDatetimeWithFormat",
        "body": "{\n            // Arrange\n\n            // Act\n            var result = _sut.Convert(\"2019\", typeof(DateTime), \"yyyy\", null);\n\n            // Assert\n            var resultTyped = Assert.IsType<DateTime>(result);\n            Assert.Equal(new DateTime(2019, 1, 1), resultTyped);\n        }"
      },
      {
        "name": "Convert_StringToNullableDatetimeWithFormat",
        "body": "{\n            // Arrange\n\n            // Act\n            var result = _sut.Convert(\"2019\", typeof(DateTime?), \"yyyy\", null);\n\n            // Assert\n            // datetime is correct here, see https://stackoverflow.com/questions/785358/nullable-type-is-not-a-nullable-type\n            var resultTyped = Assert.IsType<DateTime>(result);\n            Assert.Equal(new DateTime(2019, 1, 1), resultTyped);\n        }"
      }
    ]
  },
  {
    "file": "ServiceRepositoryTests.cs",
    "methods": [
      {
        "name": "SideBySideLogFactoryExternalInterfaceTest",
        "body": "{\n            // Arrange\n            var logFactory1 = new LogFactory();\n            const string name1 = \"name1\";\n            logFactory1.ServiceRepository.RegisterService(typeof(IMyPrettyInterface), new MyPrettyImplementation() { Test = name1 });\n\n            var logFactory2 = new LogFactory();\n            const string name2 = \"name2\";\n            logFactory2.ServiceRepository.RegisterService(typeof(IMyPrettyInterface), new MyPrettyImplementation { Test = name2 });\n\n            // Act\n            var logFactoryService1 = logFactory1.ServiceRepository.ResolveService<IMyPrettyInterface>();\n            var logFactoryService2 = logFactory2.ServiceRepository.ResolveService<IMyPrettyInterface>();\n\n            // Assert\n            Assert.Equal(name1, logFactoryService1.ToString());\n            Assert.Equal(name2, logFactoryService2.ToString());\n        }"
      },
      {
        "name": "SideBySideLogFactoryInternalInterfaceTest",
        "body": "{\n            // Arrange\n            var logFactory1 = new LogFactory();\n            const string name1 = \"name1\";\n            InitializeLogFactoryJsonConverter(logFactory1, name1, out var logger1, out var target1);\n\n            var logFactory2 = new LogFactory();\n            const string name2 = \"name2\";\n            InitializeLogFactoryJsonConverter(logFactory2, name2, out var logger2, out var target2);\n\n            // Act\n            logger1.Info(\"Hello {user}\", \"Kenny\");\n            logger2.Info(\"Hello {user}\", \"Kenny\");\n\n            // Assert\n            Assert.Equal(\"Kenny\" + \"_\" + name1, target1.LastMessage);\n            Assert.Equal(\"Kenny\" + \"_\" + name2, target2.LastMessage);\n        }"
      },
      {
        "name": "HandleDelayedInjectDependenciesFailure",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                // Arrange\n                var logFactory = new LogFactory();\n                logFactory.ThrowConfigExceptions = true;\n                var logConfig = new LoggingConfiguration(logFactory);\n                var logTarget = new TargetWithMissingDependency() { Name = \"NeedDependency\" };\n                logConfig.AddRuleForAllLevels(logTarget);\n\n                // Act\n                logFactory.Configuration = logConfig;\n                logFactory.GetLogger(\"Test\").Info(\"Test\");\n\n                // Assert\n                Assert.Null(logTarget.LastLogEvent);\n            }\n        }"
      },
      {
        "name": "HandleDelayedInjectDependenciesSuccess",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                // Arrange\n                var logFactory = new LogFactory();\n                logFactory.ThrowConfigExceptions = true;\n                var logConfig = new LoggingConfiguration(logFactory);\n                var logTarget = new TargetWithMissingDependency() { Name = \"NeedDependency\" };\n                logConfig.AddRuleForAllLevels(logTarget);\n\n                // Act\n                logFactory.Configuration = logConfig;\n                logFactory.GetLogger(\"Test\").Info(\"Test\");\n                logFactory.ServiceRepository.RegisterSingleton<IMisingDependencyClass>(new MisingDependencyClass());\n                logFactory.GetLogger(\"Test\").Info(\"Test Again\");\n\n                // Assert\n                Assert.NotNull(logTarget.LastLogEvent);\n            }\n        }"
      },
      {
        "name": "HandleLayoutRendererDependency",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().SetupExtensions(ext =>\n            {\n                ext.RegisterLayoutRenderer<LayoutRendererUsingDependency>();\n                ext.RegisterServiceProvider(new ExternalServiceRepository(t => t == typeof(IMisingDependencyClass) ? new MisingDependencyClass() : null));\n            }).LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(new MemoryTarget() { Layout = \"${NeedDependency}\" });\n            }).LogFactory;\n\n            // Act\n            logFactory.GetLogger(\"Test\").Info(\"Test\");\n\n            // Assert\n            Assert.Equal(\"Success\", (logFactory.Configuration.AllTargets[0] as MemoryTarget).Logs[0]);\n        }"
      },
      {
        "name": "ResolveShouldCheckExternalServiceProvider",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().SetupExtensions(ext =>\n            {\n                ext.RegisterSingletonService<IMyPrettyInterface>(new MyPrettyImplementation());\n                ext.RegisterSingletonService(typeof(IMyPrettyInterface), new MyPrettyImplementation());\n                ext.RegisterServiceProvider(new ExternalServiceRepository(t => t == typeof(IMisingDependencyClass) ? new MisingDependencyClass() : null));\n            }).LogFactory;\n\n            // Act\n            var missingDependency = logFactory.ServiceRepository.ResolveService<IMisingDependencyClass>(false);\n            var otherDependency = logFactory.ServiceRepository.ResolveService<IMyPrettyInterface>(false);\n\n            // Assert\n            Assert.NotNull(missingDependency);\n            Assert.NotNull(otherDependency);\n        }"
      }
    ]
  },
  {
    "file": "TimeConfigurationTests.cs",
    "methods": [
      {
        "name": "DefaultTimeSourceTest",
        "body": "{\n            Assert.IsType<FastLocalTimeSource>(TimeSource.Current);\n            XmlLoggingConfiguration.CreateFromXmlString(\"<nlog />\");\n            Assert.IsType<FastLocalTimeSource>(TimeSource.Current);\n        }"
      },
      {
        "name": "AccurateLocalTest",
        "body": "{\n            TestTimeSourceConfiguration<AccurateLocalTimeSource>(\"AccurateLocal\");\n        }"
      },
      {
        "name": "AccurateUtcTest",
        "body": "{\n            TestTimeSourceConfiguration<AccurateUtcTimeSource>(\"AccurateUTC\");\n        }"
      },
      {
        "name": "FastLocalTest",
        "body": "{\n            TestTimeSourceConfiguration<FastLocalTimeSource>(\"FastLocal\");\n        }"
      },
      {
        "name": "FastUtcTest",
        "body": "{\n            TestTimeSourceConfiguration<FastUtcTimeSource>(\"FastUTC\");\n        }"
      }
    ]
  },
  {
    "file": "VariableTests.cs",
    "methods": [
      {
        "name": "VariablesTest_string_expanding",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n  <variable name='test' value='hello'/>\n  <targets>\n    <target type='File' name='test' ArchiveDateFormat='${test}'/>\n  </targets>\n</nlog>\");\n\n            var target = configuration.FindTargetByName(\"test\") as FileTarget;\n            Assert.NotNull(target);\n            //dont change the ${test} as it isn't a Layout\n            Assert.NotEqual(typeof(Layout), target.ArchiveDateFormat.GetType());\n            Assert.Equal(\"hello\", target.ArchiveDateFormat);\n        }"
      },
      {
        "name": "VariablesTest_WriteTo_expanding",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n  <variable name='test' value='test_target'/>\n  <targets>\n    <target type='Debug' name='test_target' />\n  </targets>\n    <rules>\n      <logger writeTo='${test}' />\n    </rules>\n</nlog>\");\n\n            var target = configuration.FindTargetByName(\"test_target\");\n            Assert.NotNull(target);\n\n            Assert.Single(configuration.LoggingRules);\n            Assert.Single(configuration.LoggingRules[0].Targets);\n            Assert.Same(target, configuration.LoggingRules[0].Targets.First());\n        }"
      },
      {
        "name": "VariablesTest_minLevel_maxLevel_expanding",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <variable name='test1' value='info'/>\n    <variable name='test2' value='warn'/>\n    <rules>\n      <logger minLevel='${test1}' maxLevel='${test2}' final='true' />\n    </rules>\n</nlog>\");\n\n            var rule = configuration.LoggingRules[0];\n            Assert.NotNull(rule);\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Trace));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Debug));\n            Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Info));\n            Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Warn));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Error));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Fatal));\n        }"
      },
      {
        "name": "VariablesTest_Level_expanding",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n   <variable name='test' value='debug'/>\n    <rules>\n      <logger level='${test}' final='true' />\n    </rules>\n</nlog>\");\n\n            var rule = configuration.LoggingRules[0];\n            Assert.NotNull(rule);\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Trace));\n            Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Debug));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Info));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Warn));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Error));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Fatal));\n        }"
      },
      {
        "name": "VariablesTest_Levels_expanding",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n   <variable name='test' value='debug,fatal'/>\n    <rules>\n      <logger levels='${test}' final='true' />\n    </rules>\n</nlog>\");\n\n            var rule = configuration.LoggingRules[0];\n            Assert.NotNull(rule);\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Trace));\n            Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Debug));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Info));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Warn));\n            Assert.False(rule.IsLoggingEnabledForLevel(LogLevel.Error));\n            Assert.True(rule.IsLoggingEnabledForLevel(LogLevel.Fatal));\n        }"
      },
      {
        "name": "Xml_configuration_returns_defined_variables",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <variables>\n        <variable name='prefix' value='[[' />\n        <variable name='suffix' value=']]' />\n    </variables>\n</nlog>\");\n\n            var nullEvent = LogEventInfo.CreateNullEvent();\n\n            // Act & Assert\n            Assert.Equal(\"[[\", configuration.Variables[\"prefix\"].Render(nullEvent));\n            Assert.Equal(\"]]\", configuration.Variables[\"suffix\"].Render(nullEvent));\n        }"
      },
      {
        "name": "Xml_configuration_with_inner_returns_defined_variables",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <variable name='prefix'><layout><![CDATA[\nnewline\n]]></layout></variable>\n    <variable name='suffix'><layout>]]</layout></variable>\n</nlog>\");\n\n            var nullEvent = LogEventInfo.CreateNullEvent();\n\n            // Act & Assert\n            Assert.Equal(\"\\nnewline\\n\", configuration.Variables[\"prefix\"].Render(nullEvent).Replace(\"\\r\", \"\"));\n            Assert.Equal(\"]]\", configuration.Variables[\"suffix\"].Render(nullEvent));\n        }"
      },
      {
        "name": "Xml_configuration_with_innerLayouts_returns_defined_variables",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <variable name='myJson'  >\n        <layout type='JsonLayout'>\n            <attribute name='short date' layout='${shortdate}' />\n            <attribute name='message' layout='${message}' />\n        </layout>\n    </variable>\n</nlog>\");\n\n            // Act & Assert\n            var jsonLayout = Assert.IsType<JsonLayout>(configuration.Variables[\"myJson\"]);\n            Assert.Equal(2, jsonLayout.Attributes.Count);\n            Assert.Equal(\"short date\", jsonLayout.Attributes[0].Name);\n            Assert.NotNull(jsonLayout.Attributes[0].Layout);\n        }"
      },
      {
        "name": "Xml_configuration_with_inner_returns_defined_variables_withValueElement",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <variable name='prefix'>\n\n<value><![CDATA[\nnewline\n]]></value>\n\n</variable>\n    <variable name='suffix'><value>]]</value></variable>\n</nlog>\");\n\n            var nullEvent = LogEventInfo.CreateNullEvent();\n\n            // Act & Assert\n            Assert.Equal(\"\\nnewline\\n\", configuration.Variables[\"prefix\"].Render(nullEvent).Replace(\"\\r\", \"\"));\n            Assert.Equal(\"]]\", configuration.Variables[\"suffix\"].Render(nullEvent));\n        }"
      },
      {
        "name": "Xml_configuration_variableWithInnerAndAttribute_attributeHasPrecedence",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog>\n    <variable name='var1' value='1'><value>2</value></variable>\n</nlog>\");\n                var nullEvent = LogEventInfo.CreateNullEvent();\n\n                // Act & Assert\n                Assert.Equal(\"1\", configuration.Variables[\"var1\"].Render(nullEvent));\n            }\n        }"
      },
      {
        "name": "NLogConfigurationExceptionShouldThrown_WhenVariableNodeIsWrittenToWrongPlace",
        "body": "{\n            LogManager.ThrowConfigExceptions = true;\n            const string configurationString_VariableNodeIsInnerTargets =\n                    @\"<nlog>\n\t                        <targets>\n\t\t\t                    <variable name='variableOne' value='${longdate:universalTime=True}Z | ${message}'/>\n                    \t\t\t<target name='d1' type='Debug' layout='${variableOne}' />\n\t                        </targets>\n                            <rules>\n\t\t\t                    <logger name='*' minlevel='Debug' writeTo='d1'/>\n                            </rules>\n                    </nlog>\";\n\n\n            const string configurationString_VariableNodeIsAfterTargets =\n                    @\"<nlog>\n\t                        <targets>\n\t\t\t                    <target name='d1' type='Debug' layout='${variableOne}' />\n\t                        </targets>\n                            <variable name='variableOne' value='${longdate:universalTime=True}Z | ${message}'/>\n                            <rules>\n\t\t\t                    <logger name='*' minlevel='Debug' writeTo='d1'/>\n                            </rules>\n                    </nlog>\";\n\n            NLogConfigurationException nlogConfEx_ForInnerTargets = Assert.Throws<NLogConfigurationException>(\n                () => XmlLoggingConfiguration.CreateFromXmlString(configurationString_VariableNodeIsInnerTargets)\n                );\n\n            NLogConfigurationException nlogConfExForAfterTargets = Assert.Throws<NLogConfigurationException>(\n                () => XmlLoggingConfiguration.CreateFromXmlString(configurationString_VariableNodeIsAfterTargets)\n                );\n        }"
      }
    ]
  },
  {
    "file": "XmlConfigTests.cs",
    "methods": [
      {
        "name": "ParseNLogOptionsDefaultTest",
        "body": "{\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n\n                Assert.False(config.AutoReload);\n                Assert.Equal(\"\", InternalLogger.LogFile);\n                Assert.False(InternalLogger.LogToConsole);\n                Assert.False(InternalLogger.LogToConsoleError);\n                Assert.True(InternalLogger.IncludeTimestamp);\n                Assert.Null(InternalLogger.LogWriter);\n                Assert.Equal(LogLevel.Off, InternalLogger.LogLevel);\n            }\n        }"
      },
      {
        "name": "ParseNLogOptionsTest",
        "body": "{\n            using (new InternalLoggerScope())\n            {\n                using (new NoThrowNLogExceptions())\n                {\n                    var xml = \"<nlog logfile='test.txt' internalLogIncludeTimestamp='false' internalLogToConsole='true' internalLogToConsoleError='true'></nlog>\";\n                    var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n\n                    Assert.False(config.AutoReload);\n                    Assert.Equal(\"\", InternalLogger.LogFile);\n                    Assert.True(InternalLogger.LogToConsole);\n                    Assert.True(InternalLogger.LogToConsoleError);\n                    Assert.False(InternalLogger.IncludeTimestamp);\n                    Assert.Null(InternalLogger.LogWriter);\n                    Assert.Equal(LogLevel.Info, InternalLogger.LogLevel);\n                }\n            }\n        }"
      },
      {
        "name": "ParseNLogInternalLoggerPathTest",
        "body": "{\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${CurrentDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(System.IO.Directory.GetCurrentDirectory(), InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${BaseDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(AppDomain.CurrentDomain.BaseDirectory, InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${TempDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(System.IO.Path.GetTempPath(), InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${ProcessDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(Path.GetDirectoryName(CurrentProcessPath), InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${CommonApplicationDataDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${UserApplicationDataDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var xml = \"<nlog internalLogFile='${UserLocalApplicationDataDir}test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                Assert.Contains(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), InternalLogger.LogFile);\n            }\n\n            using (new InternalLoggerScope())\n            {\n                var userName = Environment.GetEnvironmentVariable(\"USERNAME\") ?? string.Empty;\n                var xml = \"<nlog internalLogFile='%USERNAME%_test.txt'></nlog>\";\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n                if (!string.IsNullOrEmpty(userName))\n                    Assert.Contains(userName, InternalLogger.LogFile);\n            }\n        }"
      },
      {
        "name": "InvalidInternalLogLevel_shouldNotSetLevel",
        "body": "{\n            using (new InternalLoggerScope())\n            using (new NoThrowNLogExceptions())\n            {\n                // Arrange\n                InternalLogger.LogLevel = LogLevel.Error;\n                var xml = @\"<nlog  internalLogLevel='bogus' >\n                    </nlog>\";\n\n                // Act\n                XmlLoggingConfiguration.CreateFromXmlString(xml);\n\n                // Assert\n                Assert.Equal(LogLevel.Error, InternalLogger.LogLevel);\n            }\n        }"
      },
      {
        "name": "InvalidNLogAttributeValues_shouldNotBreakLogging",
        "body": "{\n            using (new InternalLoggerScope())\n            using (new NoThrowNLogExceptions())\n            {\n                // Arrange\n                var xml = @\"<nlog internalLogLevel='oops' globalThreshold='noooos'>\n                        <targets>\n                            <target name='debug' type='Debug' layout='${message}' />\n                        </targets>\n                        <rules>\n                            <logger name='*' minlevel='debug' appendto='debug' />\n                         </rules>\n                    </nlog>\";\n\n                var logFactory = new LogFactory();\n                var config = XmlLoggingConfiguration.CreateFromXmlString(xml, logFactory);\n                logFactory.Configuration = config;\n                var logger = logFactory.GetLogger(\"InvalidInternalLogLevel_shouldNotBreakLogging\");\n\n                // Act\n                logger.Debug(\"message 1\");\n\n                // Assert\n                logFactory.AssertDebugLastMessage(\"message 1\");\n            }\n        }"
      },
      {
        "name": "XmlConfig_ParseUtf8Encoding_WithoutHyphen",
        "body": "{\n            // Arrange\n            var xml = @\"<nlog>\n                    <targets>\n                        <target name='file' type='File' encoding='utf8' layout='${message}' fileName='hello.txt' />\n                    </targets>\n                    <rules>\n                        <logger name='*' minlevel='debug' appendto='file' />\n                    </rules>\n                </nlog>\";\n            var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n\n            Assert.Single(config.AllTargets);\n            Assert.Equal(System.Text.Encoding.UTF8, (config.AllTargets[0] as NLog.Targets.FileTarget)?.Encoding);\n        }"
      },
      {
        "name": "XmlConfig_ParseFilter_WithoutAttributes",
        "body": "{\n            // Arrange\n            var xml = @\"<nlog>\n                    <targets>\n                        <target name='debug' type='Debug' layout='${message}' />\n                    </targets>\n                    <rules>\n                        <logger name='*' minlevel='debug' appendto='debug' filterDefaultAction='ignore'>\n                            <filters defaultAction='log'>\n                                <whenContains />\n                            </filters>\n                        </logger>\n                    </rules>\n                </nlog>\";\n\n            var config = XmlLoggingConfiguration.CreateFromXmlString(xml);\n            Assert.Single(config.LoggingRules);\n            Assert.Single(config.LoggingRules[0].Filters);\n        }"
      },
      {
        "name": "RulesBeforeTargetsTest",
        "body": "{\n            LoggingConfiguration c = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <rules>\n                    <logger name='*' minLevel='Info' writeTo='d1' />\n                </rules>\n\n                <targets>\n                    <target name='d1' type='Debug' />\n                </targets>\n            </nlog>\");\n\n            Assert.Single(c.LoggingRules);\n            var rule = c.LoggingRules[0];\n            Assert.Equal(\"*\", rule.LoggerNamePattern);\n            Assert.Equal(4, rule.Levels.Count);\n            Assert.Contains(LogLevel.Info, rule.Levels);\n            Assert.Contains(LogLevel.Warn, rule.Levels);\n            Assert.Contains(LogLevel.Error, rule.Levels);\n            Assert.Contains(LogLevel.Fatal, rule.Levels);\n            Assert.Single(rule.Targets);\n            Assert.Same(c.FindTargetByName(\"d1\"), rule.Targets[0]);\n            Assert.False(rule.Final);\n            Assert.Empty(rule.Filters);\n        }"
      },
      {
        "name": "LowerCaseParserTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='debug' layout='${level}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='info' appendto='debug'>\n                        <filters defaultAction='log'>\n                            <whencontains layout='${message}' substring='msg' action='ignore' />\n                        </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            logger.Fatal(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Fatal));\n\n            logger.Error(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Error));\n\n            logger.Warn(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Warn));\n\n            logger.Info(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));\n\n            logger.Debug(\"message\");\n            logger.Debug(\"msg\");\n            logger.Info(\"msg\");\n            logger.Warn(\"msg\");\n            logger.Error(\"msg\");\n            logger.Fatal(\"msg\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));\n        }"
      },
      {
        "name": "UpperCaseParserTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <TARGETS><TARGET NAME='DEBUG' TYPE='DEBUG' LAYOUT='${LEVEL}' /></TARGETS>\n                <RULES>\n                    <LOGGER NAME='*' MINLEVEL='INFO' APPENDTO='DEBUG'>\n                        <FILTERS DEFAULTACTION='LOG'>\n                            <WHENCONTAINS LAYOUT='${MESSAGE}' SUBSTRING='msg' ACTION='IGNORE' />\n                        </FILTERS>\n                    </LOGGER>\n                </RULES>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            logger.Fatal(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Fatal));\n\n            logger.Error(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Error));\n\n            logger.Warn(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Warn));\n\n            logger.Info(\"message\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));\n\n            logger.Debug(\"message\");\n            logger.Debug(\"msg\");\n            logger.Info(\"msg\");\n            logger.Warn(\"msg\");\n            logger.Error(\"msg\");\n            logger.Fatal(\"msg\");\n            logFactory.AssertDebugLastMessage(nameof(LogLevel.Info));\n        }"
      },
      {
        "name": "ShouldWriteLogsOnDuplicateAttributeTest",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                    <nlog>\n                        <targets><target name='debug' type='debug' layout='${message}' /></targets>\n                        <rules>\n                            <logger name='*' minlevel='info' minLevel='info' appendto='debug'>\n                               <filters defaultAction='log'>\n                                    <whencontains layout='${message}' substring='msg' action='ignore' />\n                                </filters>\n                            </logger>\n                        </rules>\n                    </nlog>\").LogFactory;\n\n                var logger = logFactory.GetLogger(\"A\");\n                string expectedMesssage = \"some message\";\n                logger.Info(expectedMesssage);\n                logFactory.AssertDebugLastMessage(expectedMesssage);\n            }\n        }"
      },
      {
        "name": "ShoudThrowExceptionOnDuplicateAttributeWhenOptionIsEnabledTest",
        "body": "{\n            Assert.Throws<NLogConfigurationException>(() =>\n            {\n                new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets><target name='debug' type='debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='info' minLevel='info' appendto='debug'>\n                           <filters defaultAction='log'>\n                                <whencontains layout='${message}' substring='msg' action='ignore' />\n                            </filters>\n                        </logger>\n                    </rules>\n                </nlog>\");\n            });\n\n            Assert.Throws<NLogConfigurationException>(() =>\n            {\n                new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwConfigExceptions='true'>\n                    <targets><target name='debug' type='debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='info' minLevel='info' appendto='debug'>\n                           <filters defaultAction='log'>\n                                <whencontains layout='${message}' substring='msg' action='ignore' />\n                            </filters>\n                        </logger>\n                    </rules>\n                </nlog>\");\n            });\n        }"
      }
    ]
  },
  {
    "file": "ConfigFileLocatorTests.cs",
    "methods": [
      {
        "name": "GetCandidateConfigTest",
        "body": "{\n            var candidateConfigFilePaths = XmlLoggingConfiguration.GetCandidateConfigFilePaths();\n            Assert.NotNull(candidateConfigFilePaths);\n            var count = candidateConfigFilePaths.Count();\n            Assert.NotEqual(0, count);\n        }"
      },
      {
        "name": "GetCandidateConfigTest_list_is_readonly",
        "body": "{\n            Assert.Throws<NotSupportedException>(() =>\n            {\n                var list = new List<string> { \"c:\\\\global\\\\temp.config\" };\n                XmlLoggingConfiguration.SetCandidateConfigFilePaths(list);\n                var candidateConfigFilePaths = XmlLoggingConfiguration.GetCandidateConfigFilePaths();\n                var list2 = candidateConfigFilePaths as IList;\n                list2.Add(\"test\");\n            });\n        }"
      },
      {
        "name": "SetCandidateConfigTest",
        "body": "{\n            var list = new List<string> { \"c:\\\\global\\\\temp.config\" };\n            XmlLoggingConfiguration.SetCandidateConfigFilePaths(list);\n            Assert.Single(XmlLoggingConfiguration.GetCandidateConfigFilePaths());\n            //no side effects\n            list.Add(\"c:\\\\global\\\\temp2.config\");\n            Assert.Single(XmlLoggingConfiguration.GetCandidateConfigFilePaths());\n        }"
      },
      {
        "name": "ResetCandidateConfigTest",
        "body": "{\n            var countBefore = XmlLoggingConfiguration.GetCandidateConfigFilePaths().Count();\n            var list = new List<string> { \"c:\\\\global\\\\temp.config\" };\n            XmlLoggingConfiguration.SetCandidateConfigFilePaths(list);\n            Assert.Single(XmlLoggingConfiguration.GetCandidateConfigFilePaths());\n            XmlLoggingConfiguration.ResetCandidateConfigFilePath();\n            Assert.Equal(countBefore, XmlLoggingConfiguration.GetCandidateConfigFilePaths().Count());\n        }"
      },
      {
        "name": "LoadConfigFile_EmptyEnvironment_UseCurrentDirectory",
        "body": "{\n            // Arrange\n            var appEnvMock = new AppEnvironmentMock(f => true, f => null);\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n\n            // Act\n            var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();\n\n            // Assert loading from current-directory and from nlog-assembly-directory\n            if (NLog.Internal.PlatformDetector.IsWin32)\n                Assert.Equal(2, result.Count);  // Case insensitive\n            Assert.Equal(\"NLog.config\", result.First(), StringComparer.OrdinalIgnoreCase);\n            Assert.Contains(\"NLog.dll.nlog\", result.Last(), StringComparison.OrdinalIgnoreCase);\n        }"
      },
      {
        "name": "LoadConfigFile_NetCoreUnpublished_UseEntryDirectory",
        "body": "{\n            // Arrange\n            var tmpDir = Path.GetTempPath();\n            var appEnvMock = new AppEnvironmentMock(f => true, f => null)\n            {\n                AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),\n#if NETFRAMEWORK\n                AppDomainConfigurationFile = Path.Combine(tmpDir, \"EntryDir\", \"Entry.exe.config\"),\n#else\n                AppDomainConfigurationFile = string.Empty,                  // NetCore style\n#endif\n                CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"dotnet.exe\"),  // NetCore dotnet.exe\n                EntryAssemblyLocation = Path.Combine(tmpDir, \"EntryDir\"),\n                EntryAssemblyFileName = \"Entry.dll\"\n            };\n\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n\n            // Act\n            var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();\n\n            // Assert base-directory + entry-directory + nlog-assembly-directory\n            AssertResult(tmpDir, \"EntryDir\", \"EntryDir\", \"Entry\", result);\n        }"
      },
      {
        "name": "LoadConfigFile_NetCorePublished_UseBaseDirectory",
        "body": "{\n            // Arrange\n            var tmpDir = Path.GetTempPath();\n            var appEnvMock = new AppEnvironmentMock(f => true, f => null)\n            {\n                AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),\n#if NETFRAMEWORK\n                AppDomainConfigurationFile = Path.Combine(tmpDir, \"BaseDir\", \"Entry.exe.config\"),\n#else\n                AppDomainConfigurationFile = string.Empty,                  // .NET 6 single-publish-style\n               \n#endif\n                CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"),\n                EntryAssemblyLocation = string.Empty,                       // .NET 6 single-publish-style\n                EntryAssemblyFileName = \"Entry.dll\",\n            };\n\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n\n            // Act\n            var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();\n\n            // Assert base-directory + process-directory + nlog-assembly-directory\n            AssertResult(tmpDir, \"BaseDir\", null, \"Entry\", result);\n        }"
      },
      {
        "name": "LoadConfigFile_NetCorePublished_UseProcessDirectory",
        "body": "{\n            // Arrange\n            var tmpDir = Path.GetTempPath();\n            var appEnvMock = new AppEnvironmentMock(f => true, f => null)\n            {\n                AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),\n#if NETFRAMEWORK\n                AppDomainConfigurationFile = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe.config\"),\n#else\n                AppDomainConfigurationFile = string.Empty,                  // NetCore style                \n#endif\n                CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"),    // NetCore published exe\n                EntryAssemblyLocation = Path.Combine(tmpDir, \"ProcessDir\"),\n                EntryAssemblyFileName = \"Entry.dll\"\n            };\n\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n\n            // Act\n            var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();\n\n            // Assert base-directory + process-directory + nlog-assembly-directory\n            AssertResult(tmpDir, \"ProcessDir\", \"ProcessDir\", \"Entry\", result);\n        }"
      },
      {
        "name": "LoadConfigFile_NetCoreSingleFilePublish_IgnoreTempDirectory",
        "body": "{\n            // Arrange\n            var tmpDir = Path.GetTempPath();\n            var appEnvMock = new AppEnvironmentMock(f => true, f => null)\n            {\n                AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),\n#if NETFRAMEWORK\n                AppDomainConfigurationFile = Path.Combine(tmpDir, \"TempProcessDir\", \"Entry.exe.config\"),\n#else\n                AppDomainConfigurationFile = string.Empty,                  // NetCore style\n#endif\n                CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"),    // NetCore published exe\n                EntryAssemblyLocation = Path.Combine(tmpDir, \"TempProcessDir\"),\n                UserTempFilePath = Path.Combine(tmpDir, \"TempProcessDir\"),\n                EntryAssemblyFileName = \"Entry.dll\"\n            };\n\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n\n            // Act\n            var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();\n\n            // Assert base-directory + process-directory + nlog-assembly-directory\n#if !NETFRAMEWORK\n            Assert.Equal(Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe.nlog\"), result.First(), StringComparer.OrdinalIgnoreCase);\n#endif\n            AssertResult(tmpDir, \"TempProcessDir\", \"ProcessDir\", \"Entry\", result);\n        }"
      },
      {
        "name": "LoadConfigFile_NetCoreSingleFilePublish_IgnoreTmpDirectory",
        "body": "{\n            // Arrange\n            var tmpDir = \"/var/tmp/\";\n            var appEnvMock = new AppEnvironmentMock(f => true, f => null)\n            {\n                AppDomainBaseDirectory = Path.Combine(tmpDir, \"BaseDir\"),\n#if NETFRAMEWORK\n                AppDomainConfigurationFile = Path.Combine(tmpDir, \"TempProcessDir\", \"Entry.exe.config\"),\n#else\n                AppDomainConfigurationFile = string.Empty,                  // NetCore style           \n#endif\n                CurrentProcessFilePath = Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe\"),    // NetCore published exe\n                EntryAssemblyLocation = Path.Combine(tmpDir, \"TempProcessDir\"),\n                UserTempFilePath = \"/tmp/\",\n                EntryAssemblyFileName = \"Entry.dll\"\n            };\n\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n\n            // Act\n            var result = fileLoader.GetDefaultCandidateConfigFilePaths().ToList();\n\n            // Assert base-directory + process-directory + nlog-assembly-directory\n#if !NETFRAMEWORK\n            Assert.Equal(Path.Combine(tmpDir, \"ProcessDir\", \"Entry.exe.nlog\"), result.First(), StringComparer.OrdinalIgnoreCase);\n#endif\n            AssertResult(tmpDir, \"TempProcessDir\", \"ProcessDir\", \"Entry\", result);\n        }"
      },
      {
        "name": "ValueWithVariableMustNotCauseInfiniteRecursion",
        "body": "{\n            // Header will be printed during initialization, before config fully loaded, verify config is not loaded again\n            var nlogConfigXml = @\"<nlog throwExceptions='true'>\n                <variable name='hello' value='header' />\n                <targets>\n                    <target name='debug' type='DebugSystem' header='${var:hello}' />\n                </targets>\n                <rules>\n                    <logger name='*' minLevel='trace' writeTo='debug' />\n                </rules>\n            </nlog>\";\n\n            // Arrange\n            var appEnvMock = new AppEnvironmentMock(f => true, f => throw new NLogConfigurationException(\"Never allow loading config\"));\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n            var logFactory = new LogFactory(fileLoader).Setup().LoadConfigurationFromXml(nlogConfigXml).LogFactory;\n\n            // Assert\n            Assert.NotNull(logFactory.Configuration.FindTargetByName(\"debug\"));\n        }"
      },
      {
        "name": "CandidateConfigurationFileOnlyLoadedInitially",
        "body": "{\n            // Arrange\n            var intialLoad = true;\n            var appEnvMock = new AppEnvironmentMock(f => true, f =>\n            {\n                if (intialLoad)\n                    throw new System.IO.IOException(\"File not found\");  // Non-fatal mock failure\n                else\n                    throw new NLogConfigurationException(\"Never allow loading config\"); // Fatal mock failure\n            });\n            var fileLoader = new LoggingConfigurationFileLoader(appEnvMock);\n            var logFactory = new LogFactory(fileLoader);\n\n            // Act\n            var firstLogger = logFactory.GetLogger(\"FirstLogger\");\n            var configuration = logFactory.Configuration;\n            intialLoad = false; // Change mock to fail fatally, if trying to load NLog config again\n            var secondLogger = logFactory.GetLogger(\"SecondLogger\");\n\n            // Assert\n            Assert.Null(configuration);\n        }"
      },
      {
        "name": "MissingConfigFileTest",
        "body": "{\n            string output = RunTest();\n            Assert.Equal(missingConfigOutput, output);\n        }"
      },
      {
        "name": "NLogDotConfigTest",
        "body": "{\n            File.WriteAllText(Path.Combine(_tempDirectory, \"NLog.config\"), nlogConfigContents);\n            string output = RunTest();\n            Assert.Equal(nlogConfigOutput, output);\n        }"
      },
      {
        "name": "NLogDotDllDotNLogTest",
        "body": "{\n            File.WriteAllText(Path.Combine(_tempDirectory, \"NLog.dll.nlog\"), nlogDllNLogContents);\n            string output = RunTest();\n            Assert.Equal(nlogDllNLogOutput, output);\n        }"
      },
      {
        "name": "NLogDotDllDotNLogInDirectoryWithSpaces",
        "body": "{\n            File.WriteAllText(Path.Combine(_tempDirectory, \"NLog.dll.nlog\"), nlogDllNLogContents);\n            string output = RunTest();\n            Assert.Equal(nlogDllNLogOutput, output);\n        }"
      },
      {
        "name": "AppDotConfigTest",
        "body": "{\n            File.WriteAllText(Path.Combine(_tempDirectory, \"ConfigFileLocator.exe.config\"), appConfigContents);\n            string output = RunTest();\n            Assert.Equal(appConfigOutput, output);\n        }"
      },
      {
        "name": "AppDotNLogTest",
        "body": "{\n            File.WriteAllText(Path.Combine(_tempDirectory, \"ConfigFileLocator.exe.nlog\"), appNLogContents);\n            string output = RunTest();\n            Assert.Equal(appNLogOutput, output);\n        }"
      },
      {
        "name": "PrecedenceTest",
        "body": "{\n            var precedence = new[]\n                                 {\n                                     new\n                                         {\n                                             File = \"ConfigFileLocator.exe.config\",\n                                             Contents = appConfigContents,\n                                             Output = appConfigOutput\n                                         },\n                                     new\n                                         {\n                                             File = \"ConfigFileLocator.exe.nlog\",\n                                             Contents = appNLogContents,\n                                             Output = appNLogOutput\n                                         },\n                                     new\n                                         {\n                                             File = \"NLog.config\",\n                                             Contents = nlogConfigContents,\n                                             Output = nlogConfigOutput\n                                         },\n                                     new\n                                         {\n                                             File = \"NLog.dll.nlog\",\n                                             Contents = nlogDllNLogContents,\n                                             Output = nlogDllNLogOutput\n                                         },\n                                 };\n            // deploy all files\n            foreach (var p in precedence)\n            {\n                File.WriteAllText(Path.Combine(_tempDirectory, p.File), p.Contents);\n            }\n\n            string output;\n\n            // walk files in precedence order and delete config files\n            foreach (var p in precedence)\n            {\n                output = RunTest();\n                Assert.Equal(p.Output, output);\n                File.Delete(Path.Combine(_tempDirectory, p.File));\n            }\n\n            output = RunTest();\n            Assert.Equal(missingConfigOutput, output);\n        }"
      }
    ]
  },
  {
    "file": "GlobalDiagnosticsContextTests.cs",
    "methods": [
      {
        "name": "GDCTest1",
        "body": "{\n            GlobalDiagnosticsContext.Clear();\n            Assert.False(GlobalDiagnosticsContext.Contains(\"foo\"));\n            Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo\"));\n            Assert.False(GlobalDiagnosticsContext.Contains(\"foo2\"));\n            Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo2\"));\n            Assert.Empty(GlobalDiagnosticsContext.GetNames());\n\n            GlobalDiagnosticsContext.Set(\"foo\", \"bar\");\n            GlobalDiagnosticsContext.Set(\"foo2\", \"bar2\");\n\n            Assert.True(GlobalDiagnosticsContext.Contains(\"foo\"));\n            Assert.Equal(\"bar\", GlobalDiagnosticsContext.Get(\"foo\"));\n            Assert.Equal(2, GlobalDiagnosticsContext.GetNames().Count);\n\n            GlobalDiagnosticsContext.Remove(\"foo\");\n            Assert.False(GlobalDiagnosticsContext.Contains(\"foo\"));\n            Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo\"));\n\n            Assert.True(GlobalDiagnosticsContext.Contains(\"foo2\"));\n            Assert.Equal(\"bar2\", GlobalDiagnosticsContext.Get(\"foo2\"));\n\n            Assert.Single(GlobalDiagnosticsContext.GetNames());\n\n            Assert.Null(GlobalDiagnosticsContext.GetObject(\"foo3\"));\n            Assert.Equal(string.Empty, GlobalDiagnosticsContext.Get(\"foo3\", null));\n\n            GlobalDiagnosticsContext.Set(\"foo3\", new { One = 1 });\n            Assert.NotNull(GlobalDiagnosticsContext.Get(\"foo3\", null));\n        }"
      }
    ]
  },
  {
    "file": "MappedDiagnosticsContextTests.cs",
    "methods": [
      {
        "name": "MDCTest1",
        "body": "{\n            List<Exception> exceptions = new List<Exception>();\n            ManualResetEvent mre = new ManualResetEvent(false);\n            int counter = 100;\n            int remaining = counter;\n\n            for (int i = 0; i < counter; ++i)\n            {\n                ThreadPool.QueueUserWorkItem(\n                    s =>\n                        {\n                            try\n                            {\n                                MappedDiagnosticsContext.Clear();\n                                Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));\n                                Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));\n                                Assert.False(MappedDiagnosticsContext.Contains(\"foo2\"));\n                                Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo2\"));\n                                Assert.Empty(MappedDiagnosticsContext.GetNames());\n\n                                MappedDiagnosticsContext.Set(\"foo\", \"bar\");\n                                MappedDiagnosticsContext.Set(\"foo2\", \"bar2\");\n\n                                Assert.True(MappedDiagnosticsContext.Contains(\"foo\"));\n                                Assert.Equal(\"bar\", MappedDiagnosticsContext.Get(\"foo\"));\n                                Assert.Equal(2, MappedDiagnosticsContext.GetNames().Count);\n\n                                MappedDiagnosticsContext.Remove(\"foo\");\n                                Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));\n                                Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));\n\n                                Assert.True(MappedDiagnosticsContext.Contains(\"foo2\"));\n                                Assert.Equal(\"bar2\", MappedDiagnosticsContext.Get(\"foo2\"));\n\n                                Assert.Single(MappedDiagnosticsContext.GetNames());\n                                Assert.True(MappedDiagnosticsContext.GetNames().Contains(\"foo2\"));\n\n                                Assert.Null(MappedDiagnosticsContext.GetObject(\"foo3\"));\n                                MappedDiagnosticsContext.Set(\"foo3\", new { One = 1 });\n                            }\n                            catch (Exception exception)\n                            {\n                                lock (exceptions)\n                                {\n                                    exceptions.Add(exception);\n                                }\n                            }\n                            finally\n                            {\n                                if (Interlocked.Decrement(ref remaining) == 0)\n                                {\n                                    mre.Set();\n                                }\n                            }\n                        });\n            }\n\n            mre.WaitOne();\n            StringBuilder exceptionsMessage = new StringBuilder();\n            foreach (var ex in exceptions)\n            {\n                if (exceptionsMessage.Length > 0)\n                {\n                    exceptionsMessage.Append(\"\\r\\n\");\n                }\n\n                exceptionsMessage.Append(ex.ToString());\n            }\n\n            Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());\n        }"
      },
      {
        "name": "MDCTest2",
        "body": "{\n            List<Exception> exceptions = new List<Exception>();\n            ManualResetEvent mre = new ManualResetEvent(false);\n            int counter = 100;\n            int remaining = counter;\n\n            for (int i = 0; i < counter; ++i)\n            {\n                ThreadPool.QueueUserWorkItem(\n                    s =>\n                    {\n                        try\n                        {\n                            MappedDiagnosticsContext.Clear();\n                            Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));\n                            Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));\n                            Assert.False(MappedDiagnosticsContext.Contains(\"foo2\"));\n                            Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo2\"));\n\n                            MappedDiagnosticsContext.Set(\"foo\", \"bar\");\n                            MappedDiagnosticsContext.Set(\"foo2\", \"bar2\");\n\n                            Assert.True(MappedDiagnosticsContext.Contains(\"foo\"));\n                            Assert.Equal(\"bar\", MappedDiagnosticsContext.Get(\"foo\"));\n\n                            MappedDiagnosticsContext.Remove(\"foo\");\n                            Assert.False(MappedDiagnosticsContext.Contains(\"foo\"));\n                            Assert.Equal(string.Empty, MappedDiagnosticsContext.Get(\"foo\"));\n\n                            Assert.True(MappedDiagnosticsContext.Contains(\"foo2\"));\n                            Assert.Equal(\"bar2\", MappedDiagnosticsContext.Get(\"foo2\"));\n\n                            Assert.Null(MappedDiagnosticsContext.GetObject(\"foo3\"));\n                        }\n                        catch (Exception ex)\n                        {\n                            lock (exceptions)\n                            {\n                                exceptions.Add(ex);\n                            }\n                        }\n                        finally\n                        {\n                            if (Interlocked.Decrement(ref remaining) == 0)\n                            {\n                                mre.Set();\n                            }\n                        }\n                    });\n            }\n\n            mre.WaitOne();\n            StringBuilder exceptionsMessage = new StringBuilder();\n            foreach (var ex in exceptions)\n            {\n                if (exceptionsMessage.Length > 0)\n                {\n                    exceptionsMessage.Append(\"\\r\\n\");\n                }\n\n                exceptionsMessage.Append(ex.ToString());\n            }\n\n            Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());\n        }"
      },
      {
        "name": "timer_cannot_inherit_mappedcontext",
        "body": "{\n            object getObject = null;\n            string getValue = null;\n\n            var mre = new ManualResetEvent(false);\n            Timer thread = new Timer((s) =>\n            {\n                try\n                {\n                    getObject = MappedDiagnosticsContext.GetObject(\"DoNotExist\");\n                    getValue = MappedDiagnosticsContext.Get(\"DoNotExistEither\");\n                }\n                finally\n                {\n                    mre.Set();\n                }\n            });\n            thread.Change(0, Timeout.Infinite);\n            mre.WaitOne();\n            Assert.Null(getObject);\n            Assert.Empty(getValue);\n        }"
      },
      {
        "name": "disposable_removes_item",
        "body": "{\n            const string itemNotRemovedKey = \"itemNotRemovedKey\";\n            const string itemRemovedKey = \"itemRemovedKey\";\n\n            MappedDiagnosticsContext.Clear();\n            MappedDiagnosticsContext.Set(itemNotRemovedKey, \"itemNotRemoved\");\n            using (MappedDiagnosticsContext.SetScoped(itemRemovedKey, \"itemRemoved\"))\n            {\n                Assert.Equal(MappedDiagnosticsContext.GetNames(), new[] { itemNotRemovedKey, itemRemovedKey });\n            }\n\n            Assert.Equal(MappedDiagnosticsContext.GetNames(), new[] { itemNotRemovedKey });\n        }"
      },
      {
        "name": "dispose_is_idempotent",
        "body": "{\n            const string itemKey = \"itemKey\";\n\n            MappedDiagnosticsContext.Clear();\n            IDisposable disposable = MappedDiagnosticsContext.SetScoped(itemKey, \"item1\");\n\n            disposable.Dispose();\n            Assert.False(MappedDiagnosticsContext.Contains(itemKey));\n\n            //This item shouldn't be removed since it is not the disposable one\n            MappedDiagnosticsContext.Set(itemKey, \"item2\");\n            disposable.Dispose();\n\n            Assert.True(MappedDiagnosticsContext.Contains(itemKey));\n        }"
      }
    ]
  },
  {
    "file": "MappedDiagnosticsLogicalContextTests.cs",
    "methods": [
      {
        "name": "given_item_exists_when_getting_item_should_return_item_for_objecttype_2",
        "body": "{\n            string key = \"testKey1\";\n            object value = 5;\n\n            MappedDiagnosticsLogicalContext.Set(key, value);\n\n            string expected = \"5\";\n            string actual = MappedDiagnosticsLogicalContext.Get(key);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "given_item_exists_when_getting_item_should_return_item_for_objecttype",
        "body": "{\n            string key = \"testKey2\";\n            object value = DateTime.Now;\n\n            MappedDiagnosticsLogicalContext.Set(key, value);\n\n            object actual = MappedDiagnosticsLogicalContext.GetObject(key);\n            Assert.Equal(value, actual);\n        }"
      },
      {
        "name": "given_no_item_exists_when_getting_item_should_return_null",
        "body": "{\n            Assert.Null(MappedDiagnosticsLogicalContext.GetObject(\"itemThatShouldNotExist\"));\n        }"
      },
      {
        "name": "given_no_item_exists_when_getting_item_should_return_empty_string",
        "body": "{\n            Assert.Empty(MappedDiagnosticsLogicalContext.Get(\"itemThatShouldNotExist\"));\n        }"
      },
      {
        "name": "given_item_exists_when_getting_item_should_return_item",
        "body": "{\n            const string key = \"Key\";\n            const string item = \"Item\";\n            MappedDiagnosticsLogicalContext.Set(key, item);\n\n            Assert.Equal(item, MappedDiagnosticsLogicalContext.Get(key));\n        }"
      },
      {
        "name": "given_item_does_not_exist_when_setting_item_should_contain_item",
        "body": "{\n            const string key = \"Key\";\n            const string item = \"Item\";\n\n            MappedDiagnosticsLogicalContext.Set(key, item);\n\n            Assert.True(MappedDiagnosticsLogicalContext.Contains(key));\n        }"
      },
      {
        "name": "given_item_exists_when_setting_item_should_not_throw",
        "body": "{\n            const string key = \"Key\";\n            const string item = \"Item\";\n            MappedDiagnosticsLogicalContext.Set(key, item);\n\n            var exRecorded = Record.Exception(() => MappedDiagnosticsLogicalContext.Set(key, item));\n            Assert.Null(exRecorded);\n        }"
      },
      {
        "name": "given_item_exists_when_setting_item_should_update_item",
        "body": "{\n            const string key = \"Key\";\n            const string item = \"Item\";\n            const string newItem = \"NewItem\";\n            MappedDiagnosticsLogicalContext.Set(key, item);\n\n            MappedDiagnosticsLogicalContext.Set(key, newItem);\n\n            Assert.Equal(newItem, MappedDiagnosticsLogicalContext.Get(key));\n        }"
      },
      {
        "name": "given_no_item_exists_when_getting_items_should_return_empty_collection",
        "body": "{\n            Assert.Empty(MappedDiagnosticsLogicalContext.GetNames());\n        }"
      },
      {
        "name": "given_item_exists_when_getting_items_should_return_that_item",
        "body": "{\n            const string key = \"Key\";\n            MappedDiagnosticsLogicalContext.Set(key, \"Item\");\n\n            Assert.Single(MappedDiagnosticsLogicalContext.GetNames());\n            Assert.True(MappedDiagnosticsLogicalContext.GetNames().Contains(\"Key\"));\n\n        }"
      },
      {
        "name": "given_item_exists_after_removing_item_when_getting_items_should_not_contain_item",
        "body": "{\n            const string keyThatRemains1 = \"Key1\";\n            const string keyThatRemains2 = \"Key2\";\n            const string keyThatIsRemoved = \"KeyR\";\n\n            MappedDiagnosticsLogicalContext.Set(keyThatRemains1, \"7\");\n            MappedDiagnosticsLogicalContext.Set(keyThatIsRemoved, 7);\n            MappedDiagnosticsLogicalContext.Set(keyThatRemains2, 8);\n\n            MappedDiagnosticsLogicalContext.Remove(keyThatIsRemoved);\n\n            Assert.Equal(2, MappedDiagnosticsLogicalContext.GetNames().Count);\n            Assert.False(MappedDiagnosticsLogicalContext.GetNames().Contains(keyThatIsRemoved));\n        }"
      },
      {
        "name": "given_item_does_not_exist_when_checking_if_context_contains_should_return_false",
        "body": "{\n            Assert.False(MappedDiagnosticsLogicalContext.Contains(\"keyForItemThatDoesNotExist\"));\n        }"
      },
      {
        "name": "given_item_exists_when_checking_if_context_contains_should_return_true",
        "body": "{\n            const string key = \"Key\";\n            MappedDiagnosticsLogicalContext.Set(key, \"Item\");\n\n            Assert.True(MappedDiagnosticsLogicalContext.Contains(key));\n        }"
      },
      {
        "name": "given_item_exists_when_removing_item_should_not_contain_item",
        "body": "{\n            const string keyForItemThatShouldExist = \"Key\";\n            const string itemThatShouldExist = \"Item\";\n            MappedDiagnosticsLogicalContext.Set(keyForItemThatShouldExist, itemThatShouldExist);\n\n            MappedDiagnosticsLogicalContext.Remove(keyForItemThatShouldExist);\n\n            Assert.False(MappedDiagnosticsLogicalContext.Contains(keyForItemThatShouldExist));\n        }"
      },
      {
        "name": "given_item_does_not_exist_when_removing_item_should_not_throw",
        "body": "{\n            const string keyForItemThatShouldExist = \"Key\";\n\n            var exRecorded = Record.Exception(() => MappedDiagnosticsLogicalContext.Remove(keyForItemThatShouldExist));\n            Assert.Null(exRecorded);\n        }"
      },
      {
        "name": "given_item_does_not_exist_when_clearing_should_not_throw",
        "body": "{\n            var exRecorded = Record.Exception(() => MappedDiagnosticsLogicalContext.Clear());\n            Assert.Null(exRecorded);\n        }"
      },
      {
        "name": "given_item_exists_when_clearing_should_not_contain_item",
        "body": "{\n            const string key = \"Key\";\n            MappedDiagnosticsLogicalContext.Set(key, \"Item\");\n\n            MappedDiagnosticsLogicalContext.Clear();\n\n            Assert.False(MappedDiagnosticsLogicalContext.Contains(key));\n        }"
      },
      {
        "name": "given_multiple_threads_running_asynchronously_when_setting_and_getting_values_should_return_thread_specific_values",
        "body": "{\n            const string key = \"Key\";\n            const string valueForLogicalThread1 = \"ValueForTask1\";\n            const string valueForLogicalThread2 = \"ValueForTask2\";\n            const string valueForLogicalThread3 = \"ValueForTask3\";\n\n\n            MappedDiagnosticsLogicalContext.Clear(true);\n\n            var task1 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.Set(key, valueForLogicalThread1);\n                return MappedDiagnosticsLogicalContext.Get(key);\n            });\n\n            var task2 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.Set(key, valueForLogicalThread2);\n                return MappedDiagnosticsLogicalContext.Get(key);\n            });\n\n            var task3 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.Set(key, valueForLogicalThread3);\n                return MappedDiagnosticsLogicalContext.Get(key);\n            });\n\n            Task.WaitAll(task1, task2, task3);\n\n            Assert.Equal(valueForLogicalThread1, task1.Result);\n            Assert.Equal(valueForLogicalThread2, task2.Result);\n            Assert.Equal(valueForLogicalThread3, task3.Result);\n        }"
      },
      {
        "name": "parent_thread_assigns_different_values_to_childs",
        "body": "{\n            const string parentKey = \"ParentKey\";\n            const string parentValueForLogicalThread1 = \"Parent1\";\n            const string parentValueForLogicalThread2 = \"Parent2\";\n\n            const string childKey = \"ChildKey\";\n            const string valueForChildThread1 = \"Child1\";\n            const string valueForChildThread2 = \"Child2\";\n\n            MappedDiagnosticsLogicalContext.Clear(true);\n            var exitAllTasks = new ManualResetEvent(false);\n\n            MappedDiagnosticsLogicalContext.Set(parentKey, parentValueForLogicalThread1);\n\n            var task1 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.Set(childKey, valueForChildThread1);\n                exitAllTasks.WaitOne();\n                return MappedDiagnosticsLogicalContext.Get(parentKey) + \",\" + MappedDiagnosticsLogicalContext.Get(childKey);\n            });\n\n            MappedDiagnosticsLogicalContext.Set(parentKey, parentValueForLogicalThread2);\n\n            var task2 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.Set(childKey, valueForChildThread2);\n                exitAllTasks.WaitOne();\n                return MappedDiagnosticsLogicalContext.Get(parentKey) + \",\" + MappedDiagnosticsLogicalContext.Get(childKey);\n            });\n\n            exitAllTasks.Set();\n            Task.WaitAll(task1, task2);\n\n            Assert.Equal(parentValueForLogicalThread1 + \",\" + valueForChildThread1, task1.Result);\n            Assert.Equal(parentValueForLogicalThread2 + \",\" + valueForChildThread2, task2.Result);\n        }"
      },
      {
        "name": "timer_cannot_inherit_mappedcontext",
        "body": "{\n            const string parentKey = nameof(timer_cannot_inherit_mappedcontext);\n            const string parentValueForLogicalThread1 = \"Parent1\";\n\n            object getObject = null;\n            string getValue = null;\n\n            var mre = new ManualResetEvent(false);\n            Timer thread = new Timer((s) =>\n            {\n                try\n                {\n                    getObject = MappedDiagnosticsLogicalContext.GetObject(parentKey);\n                    getValue = MappedDiagnosticsLogicalContext.Get(parentKey);\n                }\n                finally\n                {\n                    mre.Set();\n                }\n            });\n\n            MappedDiagnosticsLogicalContext.Clear(true);\n            MappedDiagnosticsLogicalContext.Set(parentKey, parentValueForLogicalThread1);\n\n            thread.Change(0, Timeout.Infinite);\n            mre.WaitOne();\n\n            Assert.Null(getObject);\n            Assert.Empty(getValue);\n        }"
      },
      {
        "name": "disposable_removes_item",
        "body": "{\n            const string itemNotRemovedKey = \"itemNotRemovedKey\";\n            const string itemRemovedKey = \"itemRemovedKey\";\n\n            MappedDiagnosticsLogicalContext.Clear();\n            MappedDiagnosticsLogicalContext.Set(itemNotRemovedKey, \"itemNotRemoved\");\n            using (MappedDiagnosticsLogicalContext.SetScoped(itemRemovedKey, \"itemRemoved\"))\n            {\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, itemRemovedKey });\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });\n        }"
      },
      {
        "name": "dispose_is_idempotent",
        "body": "{\n            const string itemKey = \"itemKey\";\n\n            MappedDiagnosticsLogicalContext.Clear();\n            IDisposable disposable = MappedDiagnosticsLogicalContext.SetScoped(itemKey, \"item1\");\n\n            disposable.Dispose();\n            Assert.False(MappedDiagnosticsLogicalContext.Contains(itemKey));\n\n            //This item shouldn't be removed since it is not the disposable one\n            MappedDiagnosticsLogicalContext.Set(itemKey, \"item2\");\n            disposable.Dispose();\n\n            Assert.True(MappedDiagnosticsLogicalContext.Contains(itemKey));\n        }"
      },
      {
        "name": "disposable_multiple_items",
        "body": "{\n            const string itemNotRemovedKey = \"itemNotRemovedKey\";\n            const string item1Key = \"item1Key\";\n            const string item2Key = \"item2Key\";\n            const string item3Key = \"item3Key\";\n            const string item4Key = \"item4Key\";\n\n            MappedDiagnosticsLogicalContext.Clear();\n            MappedDiagnosticsLogicalContext.Set(itemNotRemovedKey, \"itemNotRemoved\");\n            using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n            {\n                new KeyValuePair<string, object>(item1Key, \"1\"),\n                new KeyValuePair<string, object>(item2Key, \"2\")\n            }))\n            {\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, item1Key, item2Key });\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });\n\n            using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n            {\n                new KeyValuePair<string, object>(item1Key, \"1\"),\n                new KeyValuePair<string, object>(item2Key, \"2\"),\n                new KeyValuePair<string, object>(item3Key, \"3\"),\n                new KeyValuePair<string, object>(item4Key, \"4\")\n            }))\n            {\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, item1Key, item2Key, item3Key, item4Key });\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });\n        }"
      },
      {
        "name": "disposable_multiple_items_with_restore",
        "body": "{\n            const string itemNotRemovedKey = \"itemNotRemovedKey\";\n            const string item1Key = \"item1Key\";\n            const string item2Key = \"item2Key\";\n            const string item3Key = \"item3Key\";\n            const string item4Key = \"item4Key\";\n\n            MappedDiagnosticsLogicalContext.Clear();\n            MappedDiagnosticsLogicalContext.Set(itemNotRemovedKey, \"itemNotRemoved\");\n            using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n            {\n                new KeyValuePair<string, object>(item1Key, \"1\"),\n                new KeyValuePair<string, object>(item2Key, \"2\")\n            }))\n            {\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey, item1Key, item2Key });\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });\n\n            using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n            {\n                new KeyValuePair<string, object>(item1Key, \"1\"),\n                new KeyValuePair<string, object>(item2Key, \"2\"),\n                new KeyValuePair<string, object>(item3Key, \"3\"),\n                new KeyValuePair<string, object>(item4Key, \"4\")\n            }))\n            {\n                using (var itemRemover = MappedDiagnosticsLogicalContext.SetScoped(new[]\n                {\n                    new KeyValuePair<string, object>(item1Key, \"111\")\n                }))\n                {\n                    Assert.Equal(\"111\", MappedDiagnosticsLogicalContext.Get(item1Key));\n                }\n\n                using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n                {\n                    new KeyValuePair<string, object>(item1Key, \"01\"),\n                    new KeyValuePair<string, object>(item2Key, \"02\"),\n                    new KeyValuePair<string, object>(item3Key, \"03\"),\n                    new KeyValuePair<string, object>(item4Key, \"04\")\n                }))\n                {\n                    Assert.Equal(\"itemNotRemoved\", MappedDiagnosticsLogicalContext.Get(itemNotRemovedKey));\n                    Assert.Equal(\"01\", MappedDiagnosticsLogicalContext.Get(item1Key));\n                    Assert.Equal(\"02\", MappedDiagnosticsLogicalContext.Get(item2Key));\n                    Assert.Equal(\"03\", MappedDiagnosticsLogicalContext.Get(item3Key));\n                    Assert.Equal(\"04\", MappedDiagnosticsLogicalContext.Get(item4Key));\n                }\n\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[]\n                {\n                    itemNotRemovedKey, item1Key, item2Key, item3Key, item4Key\n                });\n\n                Assert.Equal(\"itemNotRemoved\", MappedDiagnosticsLogicalContext.Get(itemNotRemovedKey));\n                Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(item1Key));\n                Assert.Equal(\"2\", MappedDiagnosticsLogicalContext.Get(item2Key));\n                Assert.Equal(\"3\", MappedDiagnosticsLogicalContext.Get(item3Key));\n                Assert.Equal(\"4\", MappedDiagnosticsLogicalContext.Get(item4Key));\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { itemNotRemovedKey });\n        }"
      },
      {
        "name": "disposable_fast_clear_multiple_items",
        "body": "{\n            const string item1Key = \"item1Key\";\n            const string item2Key = \"item2Key\";\n            const string item3Key = \"item3Key\";\n            const string item4Key = \"item4Key\";\n\n            MappedDiagnosticsLogicalContext.Clear();\n            using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n            {\n                new KeyValuePair<string, object>(item1Key, \"1\"),\n                new KeyValuePair<string, object>(item2Key, \"2\")\n            }))\n            {\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { item1Key, item2Key });\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), ArrayHelper.Empty<string>());\n\n            using (MappedDiagnosticsLogicalContext.SetScoped(new[]\n            {\n                new KeyValuePair<string, object>(item1Key, \"1\"),\n                new KeyValuePair<string, object>(item2Key, \"2\"),\n                new KeyValuePair<string, object>(item3Key, \"3\"),\n                new KeyValuePair<string, object>(item4Key, \"4\")\n            }))\n            {\n                Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), new[] { item1Key, item2Key, item3Key, item4Key });\n            }\n\n            Assert.Equal(MappedDiagnosticsLogicalContext.GetNames(), ArrayHelper.Empty<string>());\n        }"
      },
      {
        "name": "given_multiple_set_invocations_mdlc_persists_only_last_value",
        "body": "{\n            const string key = \"key\";\n\n            MappedDiagnosticsLogicalContext.Set(key, \"1\");\n\n            Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key));\n\n            MappedDiagnosticsLogicalContext.Set(key, 2);\n            MappedDiagnosticsLogicalContext.Set(key, \"3\");\n\n            Assert.Equal(\"3\", MappedDiagnosticsLogicalContext.Get(key));\n\n            MappedDiagnosticsLogicalContext.Remove(key);\n\n            Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));\n        }"
      },
      {
        "name": "given_multiple_setscoped_with_restore_invocations_mdlc_persists_all_values",
        "body": "{\n            const string key = \"key\";\n\n            using (MappedDiagnosticsLogicalContext.SetScoped(key, \"1\"))\n            {\n                Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key));\n\n                using (MappedDiagnosticsLogicalContext.SetScoped(key, 2))\n                {\n                    Assert.Equal(2.ToString(), MappedDiagnosticsLogicalContext.Get(key));\n\n                    using (MappedDiagnosticsLogicalContext.SetScoped(key, null))\n                    {\n                        Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));\n                    }\n\n                    Assert.Equal(2.ToString(), MappedDiagnosticsLogicalContext.Get(key));\n                }\n\n                Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key));\n            }\n\n            Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));\n        }"
      },
      {
        "name": "given_multiple_multikey_setscoped_with_restore_invocations_mdlc_persists_all_values",
        "body": "{\n            const string key1 = \"key1\";\n            const string key2 = \"key2\";\n            const string key3 = \"key3\";\n\n            using (MappedDiagnosticsLogicalContext.SetScoped(key1, \"1\"))\n            {\n                Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));\n\n                using (MappedDiagnosticsLogicalContext.SetScoped(key2, 2))\n                {\n                    using (MappedDiagnosticsLogicalContext.SetScoped(key3, 3))\n                    {\n                        using (MappedDiagnosticsLogicalContext.SetScoped(key2, 22))\n                        {\n                            Assert.Equal(22.ToString(), MappedDiagnosticsLogicalContext.Get(key2));\n                        }\n\n                        Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));\n                        Assert.Equal(2.ToString(), MappedDiagnosticsLogicalContext.Get(key2));\n                        Assert.Equal(3.ToString(), MappedDiagnosticsLogicalContext.Get(key3));\n                    }\n                }\n\n                Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));\n            }\n\n            Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key1)));\n        }"
      },
      {
        "name": "given_multiple_multikey_setscoped_with_restore_invocations_dispose_differs_than_remove",
        "body": "{\n            const string key1 = \"key1\";\n            const string key2 = \"key2\";\n            const string key3 = \"key3\";\n\n            var k1d = MappedDiagnosticsLogicalContext.SetScoped(key1, \"1\");\n\n            Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));\n\n            var k2d = MappedDiagnosticsLogicalContext.SetScoped(key2, 2);\n\n            var k3d = MappedDiagnosticsLogicalContext.SetScoped(key3, 3);\n\n            var k2d2 = MappedDiagnosticsLogicalContext.SetScoped(key2, 22);\n\n            Assert.Equal(22.ToString(), MappedDiagnosticsLogicalContext.Get(key2));\n\n            MappedDiagnosticsLogicalContext.Remove(key2);\n\n            Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));\n            Assert.NotEqual(2.ToString(), MappedDiagnosticsLogicalContext.Get(key2));\n            Assert.Equal(3.ToString(), MappedDiagnosticsLogicalContext.Get(key3));\n\n            MappedDiagnosticsLogicalContext.Remove(key3);\n\n            MappedDiagnosticsLogicalContext.Remove(key2);\n\n            Assert.Equal(\"1\", MappedDiagnosticsLogicalContext.Get(key1));\n\n            MappedDiagnosticsLogicalContext.Remove(key1);\n\n            Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key1)));\n        }"
      },
      {
        "name": "given_multiple_setscoped_with_restore_invocations_set_reset_value_stack",
        "body": "{\n            const string key = \"key\";\n\n            using (MappedDiagnosticsLogicalContext.SetScoped(key, \"1\"))\n            {\n                using (MappedDiagnosticsLogicalContext.SetScoped(key, 2))\n                {\n                    using (MappedDiagnosticsLogicalContext.SetScoped(key, 3))\n                    {\n                        Assert.Equal(3.ToString(), MappedDiagnosticsLogicalContext.Get(key));\n                    }\n\n                    // 'Set' does not reset that history of 'SetScoped'\n                    MappedDiagnosticsLogicalContext.Set(key, \"x\");\n\n                    Assert.Equal(\"x\", MappedDiagnosticsLogicalContext.Get(key));\n\n                }\n                // Disposing will bring back previous value despite being overriden by 'Set'\n\n                Assert.Equal(1.ToString(), MappedDiagnosticsLogicalContext.Get(key));\n            }\n\n            Assert.True(string.IsNullOrEmpty(MappedDiagnosticsLogicalContext.Get(key)));\n        }"
      },
      {
        "name": "given_multiple_threads_running_asynchronously_when_setting_and_getting_values_setscoped_with_restore_should_return_thread_specific_values",
        "body": "{\n            const string key = \"Key\";\n            const string initValue = \"InitValue\";\n            const string valueForLogicalThread1 = \"ValueForTask1\";\n            const string valueForLogicalThread1Next = \"ValueForTask1Next\";\n            const string valueForLogicalThread2 = \"ValueForTask2\";\n            const string valueForLogicalThread3 = \"ValueForTask3\";\n\n            MappedDiagnosticsLogicalContext.Clear(true);\n\n            MappedDiagnosticsLogicalContext.Set(key, initValue);\n            Assert.Equal(initValue, MappedDiagnosticsLogicalContext.Get(key));\n\n            var task1 = Task.Factory.StartNew(async () =>\n            {\n                MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread1);\n                await Task.Delay(0).ConfigureAwait(false);\n                MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread1Next);\n                return MappedDiagnosticsLogicalContext.Get(key);\n            });\n\n            var task2 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread2);\n                return MappedDiagnosticsLogicalContext.Get(key);\n            });\n\n            var task3 = Task.Factory.StartNew(() =>\n            {\n                MappedDiagnosticsLogicalContext.SetScoped(key, valueForLogicalThread3);\n                return MappedDiagnosticsLogicalContext.Get(key);\n            });\n\n            Task.WaitAll(task1, task2, task3);\n\n            Assert.Equal(valueForLogicalThread1Next, task1.Result.Result);\n            Assert.Equal(valueForLogicalThread2, task2.Result);\n            Assert.Equal(valueForLogicalThread3, task3.Result);\n        }"
      }
    ]
  },
  {
    "file": "NestedDiagnosticsContextTests.cs",
    "methods": [
      {
        "name": "NDCTest1",
        "body": "{\n            List<Exception> exceptions = new List<Exception>();\n            ManualResetEvent mre = new ManualResetEvent(false);\n            int counter = 100;\n            int remaining = counter;\n\n            for (int i = 0; i < counter; ++i)\n            {\n                ThreadPool.QueueUserWorkItem(\n                    s =>\n                        {\n                            try\n                            {\n                                NestedDiagnosticsContext.Clear();\n                                Assert.Equal(string.Empty, NestedDiagnosticsContext.TopMessage);\n                                Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());\n                                AssertContents(NestedDiagnosticsContext.GetAllMessages());\n                                using (NestedDiagnosticsContext.Push(\"foo\"))\n                                {\n                                    Assert.Equal(\"foo\", NestedDiagnosticsContext.TopMessage);\n                                    AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"foo\");\n                                    using (NestedDiagnosticsContext.Push(\"bar\"))\n                                    {\n                                        AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"bar\", \"foo\");\n                                        Assert.Equal(\"bar\", NestedDiagnosticsContext.TopMessage);\n                                        NestedDiagnosticsContext.Push(\"baz\");\n                                        AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"baz\", \"bar\", \"foo\");\n                                        Assert.Equal(\"baz\", NestedDiagnosticsContext.TopMessage);\n                                        Assert.Equal(\"baz\", NestedDiagnosticsContext.Pop());\n\n                                        AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"bar\", \"foo\");\n                                        Assert.Equal(\"bar\", NestedDiagnosticsContext.TopMessage);\n                                    }\n\n                                    AssertContents(NestedDiagnosticsContext.GetAllMessages(), \"foo\");\n                                    Assert.Equal(\"foo\", NestedDiagnosticsContext.TopMessage);\n                                }\n\n                                AssertContents(NestedDiagnosticsContext.GetAllMessages());\n                                Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());\n                            }\n                            catch (Exception ex)\n                            {\n                                lock (exceptions)\n                                {\n                                    exceptions.Add(ex);\n                                }\n                            }\n                            finally\n                            {\n                                if (Interlocked.Decrement(ref remaining) == 0)\n                                {\n                                    mre.Set();\n                                }\n                            }\n                        });\n            }\n\n            mre.WaitOne();\n            StringBuilder exceptionsMessage = new StringBuilder();\n            foreach (var ex in exceptions)\n            {\n                if (exceptionsMessage.Length > 0)\n                {\n                    exceptionsMessage.Append(\"\\r\\n\");\n                }\n\n                exceptionsMessage.Append(ex.ToString());\n            }\n\n            Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());\n        }"
      },
      {
        "name": "NDCTest2_object",
        "body": "{\n            List<Exception> exceptions = new List<Exception>();\n            ManualResetEvent mre = new ManualResetEvent(false);\n            int counter = 100;\n            int remaining = counter;\n\n            for (int i = 0; i < counter; ++i)\n            {\n                ThreadPool.QueueUserWorkItem(\n                    s =>\n                    {\n                        try\n                        {\n                            NestedDiagnosticsContext.Clear();\n                            Assert.Null(NestedDiagnosticsContext.TopObject);\n                            Assert.Null(NestedDiagnosticsContext.PopObject());\n                            AssertContents(NestedDiagnosticsContext.GetAllMessages());\n                            using (NestedDiagnosticsContext.Push(\"foo\"))\n                            {\n                                Assert.Equal(\"foo\", NestedDiagnosticsContext.TopObject);\n                                AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"foo\");\n                                using (NestedDiagnosticsContext.Push(\"bar\"))\n                                {\n                                    AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"bar\", \"foo\");\n                                    Assert.Equal(\"bar\", NestedDiagnosticsContext.TopObject);\n                                    NestedDiagnosticsContext.Push(\"baz\");\n                                    AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"baz\", \"bar\", \"foo\");\n                                    Assert.Equal(\"baz\", NestedDiagnosticsContext.TopObject);\n                                    Assert.Equal(\"baz\", NestedDiagnosticsContext.PopObject());\n\n                                    AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"bar\", \"foo\");\n                                    Assert.Equal(\"bar\", NestedDiagnosticsContext.TopObject);\n                                }\n\n                                AssertContents(NestedDiagnosticsContext.GetAllObjects(), \"foo\");\n                                Assert.Equal(\"foo\", NestedDiagnosticsContext.TopObject);\n                            }\n\n                            AssertContents(NestedDiagnosticsContext.GetAllMessages());\n                            Assert.Null(NestedDiagnosticsContext.PopObject());\n                        }\n                        catch (Exception ex)\n                        {\n                            lock (exceptions)\n                            {\n                                exceptions.Add(ex);\n                            }\n                        }\n                        finally\n                        {\n                            if (Interlocked.Decrement(ref remaining) == 0)\n                            {\n                                mre.Set();\n                            }\n                        }\n                    });\n            }\n\n            mre.WaitOne();\n            StringBuilder exceptionsMessage = new StringBuilder();\n            foreach (var ex in exceptions)\n            {\n                if (exceptionsMessage.Length > 0)\n                {\n                    exceptionsMessage.Append(\"\\r\\n\");\n                }\n\n                exceptionsMessage.Append(ex.ToString());\n            }\n\n            Assert.True(exceptions.Count == 0, exceptionsMessage.ToString());\n        }"
      }
    ]
  },
  {
    "file": "ConditionBasedFilterTests.cs",
    "methods": [
      {
        "name": "WhenTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <when condition=\"\"contains(message, '${var:environment}')\"\" action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n            logFactory.Configuration.Variables[\"environment\"] = \"zzz\";  // Veriy that method-parameters are scanned and initialized with active config\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"ZzzZ\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"Zz\");\n            logFactory.AssertDebugLastMessage(\"Zz\");\n        }"
      },
      {
        "name": "WhenLogLevelTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets><target name='debug' type='debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='*' minLevel='Debug' writeTo='debug'>\n                            <filters defaultAction='ignore'>\n                                <when condition=\"\"level >= '${scopeproperty:filterlevel:whenEmpty=Off}'\"\" action='Log' />\n                            </filters>\n                        </logger>\n                    </rules>\n                </nlog>\n            \").LogFactory;\n            var logger = logFactory.GetCurrentClassLogger();\n\n            logger.Fatal(\"Hello Emptiness\");\n            logFactory.AssertDebugLastMessage(\"\");\n\n            using (logger.PushScopeProperty(\"filterLevel\", LogLevel.Warn))\n            {\n                logger.Error(\"Hello can you hear me\");\n                logFactory.AssertDebugLastMessage(\"Hello can you hear me\");\n            }\n        }"
      },
      {
        "name": "WhenExceptionTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets><target name='debug' type='debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='*' minLevel='Debug' writeTo='debug'>\n                            <filters defaultAction='ignore'>\n                                <when condition='exception != null' action='Log' />\n                            </filters>\n                        </logger>\n                    </rules>\n                </nlog>\n            \").LogFactory;\n            var logger = logFactory.GetCurrentClassLogger();\n\n            logger.Fatal(\"Hello missing Exception\");\n            logFactory.AssertDebugLastMessage(\"\");\n\n            logger.Error(new System.Exception(\"Oh no\"), \"Hello with Exception\");\n            logFactory.AssertDebugLastMessage(\"Hello with Exception\");\n        }"
      }
    ]
  },
  {
    "file": "WhenContainsTests.cs",
    "methods": [
      {
        "name": "WhenContainsTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                        <filters defaultAction='log'>\n                            <whenContains layout='${message}' substring='zzz' action='Ignore' />\n                        </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"ZzzZ\");\n            logFactory.AssertDebugLastMessage(\"ZzzZ\");\n\n            Assert.True(logFactory.Configuration.LoggingRules[0].Filters[0] is WhenContainsFilter);\n            var wcf = (WhenContainsFilter)logFactory.Configuration.LoggingRules[0].Filters[0];\n            Assert.IsType<SimpleLayout>(wcf.Layout);\n            Assert.Equal(\"${message}\", ((SimpleLayout)wcf.Layout).Text);\n            Assert.Equal(\"zzz\", wcf.Substring);\n            Assert.Equal(FilterResult.Ignore, wcf.Action);\n        }"
      },
      {
        "name": "WhenContainsInsensitiveTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                        <filters defaultAction='log'>\n                            <whenContains layout='${message}' substring='zzz' action='Ignore' ignoreCase='true' />\n                        </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"ZzzZ\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"aaa\");\n            logFactory.AssertDebugLastMessage(\"aaa\");\n        }"
      },
      {
        "name": "WhenContainsQuoteTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                        <filters defaultAction='log'>\n                            <whenContains layout='${message}' substring='&apos;' action='Ignore' ignoreCase='true' />\n                        </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"'\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"a'a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"aaa\");\n            logFactory.AssertDebugLastMessage(\"aaa\");\n        }"
      },
      {
        "name": "WhenContainsQuoteTestComplex",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                        <filters defaultAction='log'>\n                            <when condition=\"\"contains('${message}', 'Cannot insert the value NULL into column ''Col1')\"\" action=\"\"Log\"\"></when>\n                            <when condition='true' action='Ignore' />\n                        </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            var expectedMessage = \"Cannot insert the value NULL into column 'Col1\";\n            logger.Debug(expectedMessage);\n            logFactory.AssertDebugLastMessage(expectedMessage);\n\n            expectedMessage = \"Cannot insert the value NULL into column 'Col1'\";\n            logger.Debug(expectedMessage);\n            logFactory.AssertDebugLastMessage(expectedMessage);\n\n            expectedMessage = \"Cannot insert the value NULL into column 'COL1'\";\n            logger.Debug(expectedMessage);\n            logFactory.AssertDebugLastMessage(expectedMessage);\n\n            logger.Debug(\"Cannot insert the value NULL into column Col1\");\n            logFactory.AssertDebugLastMessage(expectedMessage);\n\n            logger.Debug(\"Test\");\n            logFactory.AssertDebugLastMessage(expectedMessage);\n        }"
      },
      {
        "name": "WhenContainsFilterActionMustOverrideDefault",
        "body": "{\n            var ex = Assert.Throws<NLogConfigurationException>(() =>\n            {\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug'>\n                            <filters defaultAction='Ignore'>\n                                <whenContains layout='${message}' substring='zzz' action='Ignore' />\n                            </filters>\n                        </logger>\n                    </rules>\n                </nlog>\").LogFactory;\n            });\n            Assert.Contains(\"FilterDefaultAction=Ignore\", ex.InnerException?.Message ?? ex.Message);\n        }"
      }
    ]
  },
  {
    "file": "WhenEqualTests.cs",
    "methods": [
      {
        "name": "WhenEqualTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                    <filters defaultAction='log'>\n                        <whenEqual layout='${message}' compareTo='skipme' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"skipme\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"SkipMe\");\n            logFactory.AssertDebugLastMessage(\"SkipMe\");\n        }"
      },
      {
        "name": "WhenEqualInsensitiveTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                    <filters defaultAction='log'>\n                        <whenEqual layout='${message}' compareTo='skipmetoo' action='Ignore' ignoreCase='true' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"skipMeToo\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"skipmetoo\");\n            logFactory.AssertDebugLastMessage(\"a\");\n        }"
      }
    ]
  },
  {
    "file": "WhenMethodFilterTests.cs",
    "methods": [
      {
        "name": "WhenMethodFilterAPITest",
        "body": "{\n            // Stage\n            var logFactory = new LogFactory();\n            var logger1 = logFactory.GetLogger(\"Hello\");\n            var logger2 = logFactory.GetLogger(\"Goodbye\");\n            var config = new LoggingConfiguration(logFactory);\n            var target = new NLog.Targets.DebugTarget() { Layout = \"${message}\" };\n            config.AddRuleForAllLevels(target);\n            config.LoggingRules.Last().Filters.Add(new WhenMethodFilter((l) => l.LoggerName == logger1.Name ? FilterResult.Ignore : FilterResult.Log));\n            logFactory.Configuration = config;\n\n            // Act 1\n            logger1.Info(\"Hello World\");\n            Assert.Empty(target.LastMessage);\n\n            // Act 2\n            logger2.Info(\"Goodbye World\");\n            Assert.Equal(\"Goodbye World\", target.LastMessage);\n        }"
      }
    ]
  },
  {
    "file": "WhenNotContainsTests.cs",
    "methods": [
      {
        "name": "WhenNotContainsTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                    <filters defaultAction='log'>\n                        <whenNotContains layout='${message}' substring='zzz' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(\"zzz\");\n            logger.Debug(\"ZzzZ\");\n            logFactory.AssertDebugLastMessage(\"zzz\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"zzz\");\n        }"
      },
      {
        "name": "WhenNotContainsInsensitiveTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                    <filters defaultAction='log'>\n                        <whenNotContains layout='${message}' substring='zzz' action='Ignore' ignoreCase='true' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(\"zzz\");\n            logger.Debug(\"ZzzZ\");\n            logFactory.AssertDebugLastMessage(\"ZzzZ\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"ZzzZ\");\n            logger.Debug(\"aaa\");\n            logFactory.AssertDebugLastMessage(\"ZzzZ\");\n        }"
      }
    ]
  },
  {
    "file": "WhenNotEqualTests.cs",
    "methods": [
      {
        "name": "WhenNotEqualTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                    <filters defaultAction='log'>\n                        <whenNotEqual layout='${message}' compareTo='skipme' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"skipme\");\n            logFactory.AssertDebugLastMessage(\"skipme\");\n\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"skipme\");\n\n            logger.Debug(\"SkipMe\");\n            logFactory.AssertDebugLastMessage(\"skipme\");\n        }"
      },
      {
        "name": "WhenNotEqualInsensitiveTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                    <filters defaultAction='log'>\n                        <whenNotEqual layout='${message}' compareTo='skipmetoo' action='Ignore' ignoreCase='true' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"skipMeToo\");\n            logFactory.AssertDebugLastMessage(\"skipMeToo\");\n\n            logger.Debug(\"skipmetoo\");\n            logFactory.AssertDebugLastMessage(\"skipmetoo\");\n\n            logger.Debug(\"dontskipme\");\n            logFactory.AssertDebugLastMessage(\"skipmetoo\");\n\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"skipmetoo\");\n        }"
      }
    ]
  },
  {
    "file": "WhenRepeatedTests.cs",
    "methods": [
      {
        "name": "WhenRepeatedIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${message}' />\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            AssertDebugCounter(\"debug\", 1);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 2);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 2);\n        }"
      },
      {
        "name": "WhenRepeatedIgnoreDualTargetTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${message}' />\n                    <target name='debug2' type='Debug' layout='${message}' />\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug,debug2'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            AssertDebugCounter(\"debug\", 1);\n            AssertDebugCounter(\"debug2\", 1);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 2);\n            AssertDebugCounter(\"debug2\", 2);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 2);\n            AssertDebugCounter(\"debug2\", 2);\n        }"
      },
      {
        "name": "WhenRepeatedLogAfterTimeoutTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' includeFirst='True' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            AssertDebugCounter(\"debug\", 0);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 0);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 0);\n        }"
      },
      {
        "name": "WhenRepeatedTimeoutIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' timeoutSeconds='10' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var defaultTimeSource = Time.TimeSource.Current;\n\n            try\n            {\n                var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);\n\n                Time.TimeSource.Current = timeSource;\n\n                var logger = LogManager.GetLogger(\"A\");\n                logger.Debug(\"a\");\n                AssertDebugCounter(\"debug\", 1);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n\n                logger.Debug(\"b\");\n                AssertDebugCounter(\"debug\", 3);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 4);\n            }\n            finally\n            {\n                Time.TimeSource.Current = defaultTimeSource; // restore default time source\n            }\n        }"
      },
      {
        "name": "WhenRepeatedTimeoutLogAfterTimeoutTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' includeFirst='True' timeoutSeconds='10' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var defaultTimeSource = Time.TimeSource.Current;\n\n            try\n            {\n                var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);\n\n                Time.TimeSource.Current = timeSource;\n\n                var logger = LogManager.GetLogger(\"A\");\n                logger.Debug(\"a\");\n                AssertDebugCounter(\"debug\", 0);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 0);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 0);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 0);\n\n                logger.Debug(\"b\");\n                AssertDebugCounter(\"debug\", 0);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 1);\n            }\n            finally\n            {\n                Time.TimeSource.Current = defaultTimeSource; // restore default time source\n            }\n        }"
      },
      {
        "name": "WhenRepeatedDefaultFilterCountIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' defaultFilterCacheSize='5' timeoutSeconds='10' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var defaultTimeSource = Time.TimeSource.Current;\n\n            try\n            {\n                var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);\n\n                Time.TimeSource.Current = timeSource;\n\n                var logger = LogManager.GetLogger(\"A\");\n                logger.Debug(\"a\");\n                AssertDebugCounter(\"debug\", 1);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                logger.Debug(\"b\");\n                AssertDebugCounter(\"debug\", 3);\n                logger.Debug(\"c\");\n                AssertDebugCounter(\"debug\", 4);\n                logger.Debug(\"d\");\n                AssertDebugCounter(\"debug\", 5);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));\n\n                logger.Debug(\"e\");\n                AssertDebugCounter(\"debug\", 6);\n                logger.Debug(\"f\");\n                AssertDebugCounter(\"debug\", 7);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 7);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));\n\n                for (int i = 0; i < 10; ++i)\n                {\n                    char charCount = (char)('g' + i);\n                    logger.Debug(charCount.ToString());\n                    AssertDebugCounter(\"debug\", 8 + i);\n                }\n\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 18);\n            }\n            finally\n            {\n                Time.TimeSource.Current = defaultTimeSource; // restore default time source\n            }\n        }"
      },
      {
        "name": "WhenRepeatedMaxCacheSizeIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' maxFilterCacheSize='5' defaultFilterCacheSize='5' timeoutSeconds='10' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var defaultTimeSource = Time.TimeSource.Current;\n\n            try\n            {\n                var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);\n\n                Time.TimeSource.Current = timeSource;\n\n                var logger = LogManager.GetLogger(\"A\");\n                logger.Debug(\"a\");\n                AssertDebugCounter(\"debug\", 1);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                logger.Debug(\"b\");\n                AssertDebugCounter(\"debug\", 3);\n                logger.Debug(\"c\");\n                AssertDebugCounter(\"debug\", 4);\n                logger.Debug(\"d\");\n                AssertDebugCounter(\"debug\", 5);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(5));\n\n                logger.Debug(\"e\");\n                AssertDebugCounter(\"debug\", 6);\n                logger.Debug(\"f\");\n                AssertDebugCounter(\"debug\", 7);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 7);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(10));\n\n                for (int i = 0; i < 10; ++i)\n                {\n                    char charCount = (char)('g' + i);\n                    logger.Debug(charCount.ToString());\n                    AssertDebugCounter(\"debug\", 8 + i);\n                }\n\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 18);\n            }\n            finally\n            {\n                Time.TimeSource.Current = defaultTimeSource; // restore default time source\n            }\n        }"
      },
      {
        "name": "WhenRepeatedLevelIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            AssertDebugCounter(\"debug\", 1);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 2);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 2);\n            logger.Error(\"zzz\");\n            AssertDebugCounter(\"debug\", 3);\n            logger.Error(\"zzz\");\n            AssertDebugCounter(\"debug\", 3);\n            logger.Debug(\"zzz\");\n            AssertDebugCounter(\"debug\", 3);\n            logger.Fatal(\"zzz\");\n            AssertDebugCounter(\"debug\", 4);\n        }"
      },
      {
        "name": "WhenRepeatedMaxLengthIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' maxLength='16' optimizeBufferDefaultLength='16' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            AssertDebugCounter(\"debug\", 1);\n            logger.Debug(\"zzzzzzzzzzzzzzzz\");\n            AssertDebugCounter(\"debug\", 2);\n            logger.Debug(\"zzzzzzzzzzzzzzzz\");\n            AssertDebugCounter(\"debug\", 2);\n            logger.Debug(\"zzzzzzzzzzzzzzzzzzzz\");\n            AssertDebugCounter(\"debug\", 2);\n            logger.Debug(\"b\");\n            AssertDebugCounter(\"debug\", 3);\n        }"
      },
      {
        "name": "WhenRepeatedFilterCountPropertyNameIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}${event-properties:item=hits}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' timeoutSeconds='5' filterCountPropertyName='hits' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var defaultTimeSource = Time.TimeSource.Current;\n\n            try\n            {\n                var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);\n\n                Time.TimeSource.Current = timeSource;\n\n                var logger = LogManager.GetLogger(\"A\");\n                logger.Debug(\"a\");\n                AssertDebugCounter(\"debug\", 1);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                AssertDebugLastMessage(\"debug\", \"zzz\");\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n\n                logger.Debug(\"b\");\n                AssertDebugCounter(\"debug\", 3);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 4);\n                AssertDebugLastMessage(\"debug\", \"zzz2\");\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 4);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(12));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 5);\n                AssertDebugLastMessage(\"debug\", \"zzz\");\n            }\n            finally\n            {\n                Time.TimeSource.Current = defaultTimeSource; // restore default time source\n            }\n        }"
      },
      {
        "name": "WhenRepeatedFilterCountAppendFormatIgnoreTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}${event-properties:item=hits}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'>\n                   <filters defaultAction='log'>\n                        <whenRepeated layout='${message}' action='Ignore' timeoutSeconds='5' filterCountMessageAppendFormat=' (Hits: {0})' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\");\n\n            var defaultTimeSource = Time.TimeSource.Current;\n\n            try\n            {\n                var timeSource = new TimeSourceTests.ShiftedTimeSource(DateTimeKind.Local);\n\n                Time.TimeSource.Current = timeSource;\n\n                var logger = LogManager.GetLogger(\"A\");\n                logger.Debug(\"a\");\n                AssertDebugCounter(\"debug\", 1);\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n                AssertDebugLastMessage(\"debug\", \"zzz\");\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 2);\n\n                logger.Debug(\"b\");\n                AssertDebugCounter(\"debug\", 3);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(3));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 4);\n                AssertDebugLastMessage(\"debug\", \"zzz (Hits: 2)\");\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 4);\n\n                timeSource.AddToLocalTime(TimeSpan.FromSeconds(12));\n                logger.Debug(\"zzz\");\n                AssertDebugCounter(\"debug\", 5);\n                AssertDebugLastMessage(\"debug\", \"zzz\");\n            }\n            finally\n            {\n                Time.TimeSource.Current = defaultTimeSource; // restore default time source\n            }\n        }"
      }
    ]
  },
  {
    "file": "LogEventBuilderTests.cs",
    "methods": [
      {
        "name": "TraceWrite",
        "body": "{\n            LogWrite_internal(() => _logger.ForTraceEvent(), LogLevel.Trace);\n        }"
      },
      {
        "name": "DebugWrite",
        "body": "{\n            LogWrite_internal(() => _logger.ForDebugEvent(), LogLevel.Debug);\n        }"
      },
      {
        "name": "InfoWrite",
        "body": "{\n            LogWrite_internal(() => _logger.ForInfoEvent(), LogLevel.Info);\n        }"
      },
      {
        "name": "TraceWriteProperties",
        "body": "{\n            var props = new Dictionary<string, object>\n            {\n                {\"prop1\", \"1\"},\n                {\"prop2\", \"2\"},\n\n            };\n\n            _logger.ForTraceEvent()\n                .Message(\"This is a test fluent message.\")\n                .Properties(props).Log();\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent message.\");\n                expectedEvent.Properties[\"prop1\"] = \"1\";\n                expectedEvent.Properties[\"prop2\"] = \"2\";\n                AssertLastLogEventTarget(expectedEvent);\n            }\n        }"
      },
      {
        "name": "WarnWriteProperties",
        "body": "{\n            var props = new Dictionary<string, object>\n            {\n                {\"prop1\", \"1\"},\n                {\"prop2\", \"2\"},\n\n            };\n\n            _logger.ForWarnEvent()\n                .Message(\"This is a test fluent message.\")\n                .Properties(props).Log();\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Warn, \"logger1\", \"This is a test fluent message.\");\n                expectedEvent.Properties[\"prop1\"] = \"1\";\n                expectedEvent.Properties[\"prop2\"] = \"2\";\n                AssertLastLogEventTarget(expectedEvent);\n            }\n        }"
      },
      {
        "name": "LogWriteProperties",
        "body": "{\n            var props = new Dictionary<string, object>\n            {\n                {\"prop1\", \"1\"},\n                {\"prop2\", \"2\"},\n            };\n\n            // Loop to verify caller-attribute-caching-lookup\n            for (int i = 0; i < 2; ++i)\n            {\n                _logger.ForLogEvent(LogLevel.Fatal)\n                    .Message(\"This is a test fluent message.\")\n                    .Properties(props).Log();\n\n                var expectedEvent = new LogEventInfo(LogLevel.Fatal, \"logger1\", \"This is a test fluent message.\");\n                expectedEvent.Properties[\"prop1\"] = \"1\";\n                expectedEvent.Properties[\"prop2\"] = \"2\";\n                AssertLastLogEventTarget(expectedEvent);\n\n#if !NET35\n                Assert.Equal(GetType().ToString(), _lastLogEventInfo.CallerClassName);\n#endif\n            }\n        }"
      },
      {
        "name": "LogOffWriteProperties",
        "body": "{\n            var props = new Dictionary<string, object>\n            {\n                {\"prop1\", \"1\"},\n                {\"prop2\", \"2\"},\n\n            };\n            var props2 = new Dictionary<string, object>\n            {\n                {\"prop1\", \"4\"},\n                {\"prop2\", \"5\"},\n            };\n\n            _logger.ForLogEvent(LogLevel.Fatal)\n                .Message(\"This is a test fluent message.\")\n                .Properties(props).Log();\n\n            _logger.ForLogEvent(LogLevel.Off)\n                .Message(\"dont log this.\")\n                .Properties(props2).Log();\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Fatal, \"logger1\", \"This is a test fluent message.\");\n                expectedEvent.Properties[\"prop1\"] = \"1\";\n                expectedEvent.Properties[\"prop2\"] = \"2\";\n                AssertLastLogEventTarget(expectedEvent);\n            }\n        }"
      },
      {
        "name": "TraceIfWrite",
        "body": "{\n            _logger.ForTraceEvent()\n                .Message(\"This is a test fluent message.1\")\n                .Property(\"Test\", \"TraceWrite\")\n                .Log();\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent message.1\");\n                expectedEvent.Properties[\"Test\"] = \"TraceWrite\";\n                AssertLastLogEventTarget(expectedEvent);\n            }\n\n            int v = 1;\n            _logger.ForTraceEvent()\n                .Message(\"This is a test fluent WriteIf message '{0}'.\", DateTime.Now.Ticks)\n                .Property(\"Test\", \"TraceWrite\")\n                .Log(v == 1 ? null : LogLevel.Off);\n\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");\n                expectedEvent.Properties[\"Test\"] = \"TraceWrite\";\n                AssertLastLogEventTarget(expectedEvent);\n                AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");\n            }\n\n            _logger.ForTraceEvent()\n                .Message(\"dont write this! '{0}'.\", DateTime.Now.Ticks)\n                .Property(\"Test\", \"TraceWrite\")\n                .Log(LogLevel.Off);\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");\n                expectedEvent.Properties[\"Test\"] = \"TraceWrite\";\n                AssertLastLogEventTarget(expectedEvent);\n                AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");\n            }\n\n            _logger.ForTraceEvent()\n                .Message(\"This is a test fluent WriteIf message '{0}'.\", DateTime.Now.Ticks)\n                .Property(\"Test\", \"TraceWrite\")\n                .Log(v == 1 ? null : LogLevel.Off);\n\n\n            {\n                var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");\n                expectedEvent.Properties[\"Test\"] = \"TraceWrite\";\n                AssertLastLogEventTarget(expectedEvent);\n                AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");\n            }\n\n            _logger.ForTraceEvent()\n                .Message(\"Should Not WriteIf message '{0}'.\", DateTime.Now.Ticks)\n                .Property(\"Test\", \"TraceWrite\")\n                .Log(v > 1 ? null : LogLevel.Off);\n\n            {\n                //previous\n                var expectedEvent = new LogEventInfo(LogLevel.Trace, \"logger1\", \"This is a test fluent WriteIf message '{0}'.\");\n                expectedEvent.Properties[\"Test\"] = \"TraceWrite\";\n                AssertLastLogEventTarget(expectedEvent);\n                AssertDebugLastMessageContains(\"t2\", \"This is a test fluent WriteIf message \");\n            }\n        }"
      },
      {
        "name": "FatalWrite",
        "body": "{\n            LogWriteException_internal((ex) => _logger.ForFatalEvent().Exception(ex), LogLevel.Fatal);\n        }"
      },
      {
        "name": "ErrorWrite",
        "body": "{\n            LogWriteException_internal((ex) => _logger.ForErrorEvent().Exception(ex), LogLevel.Error);\n        }"
      },
      {
        "name": "ExceptionWrite",
        "body": "{\n            LogWriteException_internal((ex) => _logger.ForExceptionEvent(ex), LogLevel.Error);\n        }"
      },
      {
        "name": "LogBuilder_null_lead_to_ArgumentNullException",
        "body": "{\n            var logger = LogManager.GetLogger(\"a\");\n            Assert.Throws<ArgumentNullException>(() => new LogEventBuilder(null, LogLevel.Debug));\n            Assert.Throws<ArgumentNullException>(() => new LogEventBuilder(null));\n            Assert.Throws<ArgumentNullException>(() => new LogEventBuilder(logger, null));\n\n            var logBuilder = new LogEventBuilder(logger);\n            Assert.Throws<ArgumentNullException>(() => logBuilder.Properties(null));\n            Assert.Throws<ArgumentNullException>(() => logBuilder.Property(null, \"b\"));\n        }"
      },
      {
        "name": "LogBuilder_nLogEventInfo",
        "body": "{\n            var d = new DateTime(2015, 01, 30, 14, 30, 5);\n            var logEventInfo = new LogEventBuilder(LogManager.GetLogger(\"a\"), LogLevel.Fatal).TimeStamp(d).LogEvent;\n\n            Assert.Equal(\"a\", logEventInfo.LoggerName);\n            Assert.Equal(LogLevel.Fatal, logEventInfo.Level);\n            Assert.Equal(d, logEventInfo.TimeStamp);\n        }"
      },
      {
        "name": "LogBuilder_exception_only",
        "body": "{\n            var ex = new Exception(\"Exception message1\");\n\n            _logger.ForErrorEvent()\n                .Exception(ex)\n                .Log();\n\n            var expectedEvent = LogEventInfo.Create(LogLevel.Error, \"logger1\", null, ex);\n            AssertLastLogEventTarget(expectedEvent);\n        }"
      },
      {
        "name": "LogBuilder_message_overloadsTest",
        "body": "{\n            LogManager.ThrowExceptions = true;\n\n            _logger.ForDebugEvent();\n\n            _logger.ForDebugEvent()\n              .Message(\"Message with {0} arg\", 1)\n              .Log();\n            AssertDebugLastMessage(\"t2\", \"Message with 1 arg\");\n\n            _logger.ForDebugEvent()\n              .Message(\"Message with {0} args. {1}\", 2, \"YES\")\n              .Log();\n            AssertDebugLastMessage(\"t2\", \"Message with 2 args. YES\");\n\n            _logger.ForDebugEvent()\n              .Message(\"Message with {0} args. {1} {2}\", 3, \":) \", 2)\n              .Log();\n            AssertDebugLastMessage(\"t2\", \"Message with 3 args. :)  2\");\n\n            _logger.ForDebugEvent()\n              .Message(\"Message with {0} args. {1} {2}{3}\", \"more\", \":) \", 2, \"b\")\n              .Log();\n            AssertDebugLastMessage(\"t2\", \"Message with more args. :)  2b\");\n        }"
      },
      {
        "name": "LogBuilder_message_cultureTest",
        "body": "{\n            if (IsLinux())\n            {\n                Console.WriteLine(\"[SKIP] LogBuilderTests.LogBuilder_message_cultureTest because we are running in Travis\");\n                return;\n            }\n\n            LogManager.Configuration.DefaultCultureInfo = GetCultureInfo(\"en-US\");\n\n            _logger.ForDebugEvent()\n             .Message(\"Message with {0} {1} {2} {3}\", 4.1, 4.001, new DateTime(2016, 12, 31), true)\n             .Log();\n            AssertDebugLastMessage(\"t2\", \"Message with 4.1 4.001 12/31/2016 12:00:00 AM True\");\n\n            _logger.ForDebugEvent()\n           .Message(GetCultureInfo(\"nl-nl\"), \"Message with {0} {1} {2} {3}\", 4.1, 4.001, new DateTime(2016, 12, 31), true)\n           .Log();\n            AssertDebugLastMessage(\"t2\", \"Message with 4,1 4,001 31-12-2016 00:00:00 True\");\n        }"
      },
      {
        "name": "LogBuilder_Structured_Logging_Test",
        "body": "{\n            var logEvent = _logger.ForInfoEvent().Property(\"Property1Key\", \"Property1Value\").Message(\"{@message}\", \"My custom message\").LogEvent;\n            Assert.NotEmpty(logEvent.Properties);\n            Assert.Contains(\"message\", logEvent.Properties.Keys);\n            Assert.Contains(\"Property1Key\", logEvent.Properties.Keys);\n        }"
      },
      {
        "name": "LogBuilder_Callsite_Test",
        "body": "{\n            var logEvent = _logger.ForInfoEvent().Callsite(nameof(LogEventInfo.CallerClassName), nameof(LogEventInfo.CallerMemberName), nameof(LogEventInfo.CallerFilePath), 42).LogEvent;\n            Assert.Equal(nameof(LogEventInfo.CallerClassName), logEvent.CallerClassName);\n            Assert.Equal(nameof(LogEventInfo.CallerMemberName), logEvent.CallerMemberName);\n            Assert.Equal(nameof(LogEventInfo.CallerFilePath), logEvent.CallerFilePath);\n            Assert.Equal(42, logEvent.CallerLineNumber);\n        }"
      }
    ]
  },
  {
    "file": "GetLoggerTests.cs",
    "methods": [
      {
        "name": "GetCurrentClassLoggerTest",
        "body": "{\n            var logger = LogManager.GetCurrentClassLogger();\n            Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", logger.Name);\n        }"
      },
      {
        "name": "GetCurrentClassLoggerLambdaTest",
        "body": "{\n            System.Linq.Expressions.Expression<Func<Logger>> sum = () => LogManager.GetCurrentClassLogger();\n            var logger = sum.Compile().Invoke();\n            Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", logger.Name);\n        }"
      },
      {
        "name": "TypedGetLoggerTest",
        "body": "{\n            LogFactory lf = new LogFactory();\n\n            MyLogger l1 = (MyLogger)lf.GetLogger(\"AAA\", typeof(MyLogger));\n            MyLogger l2 = lf.GetLogger<MyLogger>(\"AAA\");\n            Logger l3 = lf.GetLogger(\"AAA\", typeof(Logger));\n            Logger l5 = lf.GetLogger(\"AAA\");\n            Logger l6 = lf.GetLogger(\"AAA\");\n\n            Assert.Same(l1, l2);\n            Assert.Same(l5, l6);\n            Assert.Same(l3, l5);\n\n            Assert.NotSame(l1, l3);\n\n            Assert.Equal(\"AAA\", l1.Name);\n            Assert.Equal(\"AAA\", l3.Name);\n        }"
      },
      {
        "name": "TypedGetCurrentClassLoggerTest",
        "body": "{\n            LogFactory lf = new LogFactory();\n\n            MyLogger l1 = (MyLogger)lf.GetCurrentClassLogger(typeof(MyLogger));\n            MyLogger l2 = lf.GetCurrentClassLogger<MyLogger>();\n            Logger l3 = lf.GetCurrentClassLogger(typeof(Logger));\n\n            Logger l5 = lf.GetCurrentClassLogger();\n            Logger l6 = lf.GetCurrentClassLogger();\n\n            Assert.Same(l1, l2);\n            Assert.Same(l5, l6);\n            Assert.Same(l3, l5);\n\n            Assert.NotSame(l1, l3);\n\n            Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", l1.Name);\n            Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", l3.Name);\n        }"
      },
      {
        "name": "GenericGetLoggerTest",
        "body": "{\n            LogFactory<MyLogger> lf = new LogFactory<MyLogger>();\n\n            MyLogger l1 = lf.GetLogger(\"AAA\");\n            MyLogger l2 = lf.GetLogger(\"AAA\");\n            MyLogger l3 = lf.GetLogger(\"BBB\");\n\n            Assert.Same(l1, l2);\n            Assert.NotSame(l1, l3);\n\n            Assert.Equal(\"AAA\", l1.Name);\n            Assert.Equal(\"BBB\", l3.Name);\n        }"
      },
      {
        "name": "GenericGetCurrentClassLoggerTest",
        "body": "{\n            LogFactory<MyLogger> lf = new LogFactory<MyLogger>();\n\n            MyLogger l1 = lf.GetCurrentClassLogger();\n            MyLogger l2 = lf.GetCurrentClassLogger();\n\n            Assert.Same(l1, l2);\n            Assert.Equal(\"NLog.UnitTests.GetLoggerTests\", l1.Name);\n        }"
      },
      {
        "name": "InvalidLoggerConfiguration_NotThrowsThrowExceptions_NotThrows",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var result = LogManager.GetCurrentClassLogger(typeof(InvalidLogger));\n                Assert.NotNull(result);\n            }\n        }"
      },
      {
        "name": "InvalidLoggerConfiguration_ThrowsThrowExceptions_Throws",
        "body": "{\n            LogManager.ThrowExceptions = true;\n            Assert.Throws<NLogRuntimeException>(() =>\n            {\n                LogManager.GetCurrentClassLogger(typeof(InvalidLogger));\n            });\n        }"
      }
    ]
  },
  {
    "file": "AppDomainPartialTrustTests.cs",
    "methods": [
      {
        "name": "MediumTrustWithExternalClass",
        "body": "{\n            var fileWritePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n            try\n            {\n                int times = 25;\n\n                RunAppDomainTestMethod(fileWritePath, times, true);\n\n                // this also checks that thread-volatile layouts\n                // such as ${threadid} are properly cached and not recalculated\n                // in logging threads.\n\n                var threadID = CurrentManagedThreadId.ToString();\n\n                Assert.False(File.Exists(Path.Combine(fileWritePath, \"Trace.txt\")));\n\n                AssertFileContents(Path.Combine(fileWritePath, \"Debug.txt\"),\n                    StringRepeat(times, \"aaa \" + threadID + \"\\n\"), Encoding.UTF8);\n\n                AssertFileContents(Path.Combine(fileWritePath, \"Info.txt\"),\n                    StringRepeat(times, \"bbb \" + threadID + \"\\n\"), Encoding.UTF8);\n\n                AssertFileContents(Path.Combine(fileWritePath, \"Warn.txt\"),\n                    StringRepeat(times, \"ccc \" + threadID + \"\\n\"), Encoding.UTF8);\n\n                AssertFileContents(Path.Combine(fileWritePath, \"Error.txt\"),\n                    StringRepeat(times, \"ddd \" + threadID + \"\\n\"), Encoding.UTF8);\n\n                AssertFileContents(Path.Combine(fileWritePath, \"Fatal.txt\"),\n                    StringRepeat(times, \"eee \" + threadID + \"\\n\"), Encoding.UTF8);\n\n            }\n            finally\n            {\n                if (Directory.Exists(fileWritePath))\n                    Directory.Delete(fileWritePath, true);\n            }\n        }"
      },
      {
        "name": "MediumTrustWithExternalClassNoAutoFlush",
        "body": "{\n            var fileWritePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());\n            try\n            {\n                int times = 5;\n                RunAppDomainTestMethod(fileWritePath, times, false);\n\n                Assert.False(File.Exists(Path.Combine(fileWritePath, \"Trace.txt\")));\n                Assert.False(File.Exists(Path.Combine(fileWritePath, \"Debug.txt\")));\n                Assert.False(File.Exists(Path.Combine(fileWritePath, \"Warn.txt\")));\n                Assert.False(File.Exists(Path.Combine(fileWritePath, \"Error.txt\")));\n                Assert.False(File.Exists(Path.Combine(fileWritePath, \"Fatal.txt\")));\n            }\n            finally\n            {\n                if (Directory.Exists(fileWritePath))\n                    Directory.Delete(fileWritePath, true);\n            }\n        }"
      }
    ]
  },
  {
    "file": "AsyncLogEventInfoTests.cs",
    "methods": [
      {
        "name": "TestEquals",
        "body": "{\n            var logEvent1 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");\n            AsyncContinuation cont1 = new AsyncContinuation(exception => { });\n            var async1 = new AsyncLogEventInfo(logEvent1, cont1);\n            var async2 = new AsyncLogEventInfo(logEvent1, cont1);\n            Assert.True(async1.Equals(async2));\n            Assert.True(async1 == async2);\n            Assert.False(async1 != async2);\n            Assert.Equal(async1.GetHashCode(), async2.GetHashCode());\n        }"
      },
      {
        "name": "TestNotEquals",
        "body": "{\n            var logEvent1 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");\n            AsyncContinuation cont1 = new AsyncContinuation(exception => { });\n            AsyncContinuation cont2 = new AsyncContinuation(exception => { InternalLogger.Debug(\"test\"); });\n            var async1 = new AsyncLogEventInfo(logEvent1, cont1);\n            var async2 = new AsyncLogEventInfo(logEvent1, cont2);\n            Assert.False(async1.Equals(async2));\n            Assert.False(async1 == async2);\n            Assert.True(async1 != async2);\n\n            //2 delegates will return the same hashcode, https://stackoverflow.com/questions/6624151/why-do-2-delegate-instances-return-the-same-hashcode\n            //and that isn't really bad, so ignore this\n            //   Assert.NotEqual(async1.GetHashCode(), async2.GetHashCode());\n        }"
      },
      {
        "name": "TestNotEquals2",
        "body": "{\n            var logEvent1 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");\n            var logEvent2 = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");\n            AsyncContinuation cont = new AsyncContinuation(exception => { });\n            var async1 = new AsyncLogEventInfo(logEvent1, cont);\n            var async2 = new AsyncLogEventInfo(logEvent2, cont);\n            Assert.False(async1.Equals(async2));\n            Assert.False(async1 == async2);\n            Assert.True(async1 != async2);\n\n            Assert.NotEqual(async1.GetHashCode(), async2.GetHashCode());\n        }"
      }
    ]
  },
  {
    "file": "ConversionHelpersTests.cs",
    "methods": [
      {
        "name": "EnumParse1_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"Foo\", false, TestEnum.Foo, true);\n        }"
      },
      {
        "name": "EnumParse2_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"foo\", false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParseDefault_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"BAR\", false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParseDefault2_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"x\", false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParseBar_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"bar\", false, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParseBar2_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\" bar \", false, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParseBar3_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\" \\r\\nbar \", false, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParse_null_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(null, false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse_emptystring_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(string.Empty, false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse_whitespace_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"   \", false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse_wrongInput_ignoreCaseFalse",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"not enum\", false, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse1_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"Foo\", true, TestEnum.Foo, true);\n        }"
      },
      {
        "name": "EnumParse2_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"foo\", true, TestEnum.Foo, true);\n        }"
      },
      {
        "name": "EnumParseDefault_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"BAR\", true, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParseDefault2_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"x\", true, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParseBar_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"bar\", true, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParseBar2_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\" bar \", true, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParseBar3_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\" \\r\\nbar \", true, TestEnum.bar, true);\n        }"
      },
      {
        "name": "EnumParse_null_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(null, true, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse_emptystring_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(string.Empty, true, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse_whitespace_ignoreCaseTrue",
        "body": "{\n            TestEnumParseCaseIgnoreCaseParam(\"   \", true, TestEnum.Foo, false);\n        }"
      },
      {
        "name": "EnumParse_ArgumentException_ignoreCaseTrue",
        "body": "{\n            double result;\n            Assert.Throws<ArgumentException>(() => ConversionHelpers.TryParseEnum(\"not enum\", true, out result));\n        }"
      }
    ]
  },
  {
    "file": "ExceptionHelperTests.cs",
    "methods": []
  },
  {
    "file": "ExpandoTestDictionary.cs",
    "methods": []
  },
  {
    "file": "FileAppenderCacheTests.cs",
    "methods": [
      {
        "name": "FileAppenderCache_Empty",
        "body": "{\n            FileAppenderCache cache = FileAppenderCache.Empty;\n\n            // An empty FileAppenderCache will have Size = 0 as well as Factory and CreateFileParameters parameters equal to null.\n            Assert.Equal(0, cache.Size);\n            Assert.Null(cache.Factory);\n            Assert.Null(cache.CreateFileParameters);\n        }"
      },
      {
        "name": "FileAppenderCache_Construction",
        "body": "{\n            IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;\n            ICreateFileParameters fileTarget = new FileTarget();\n            FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);\n\n            Assert.Equal(3, cache.Size);\n            Assert.NotNull(cache.Factory);\n            Assert.NotNull(cache.CreateFileParameters);\n        }"
      },
      {
        "name": "FileAppenderCache_Allocate",
        "body": "{\n            // Allocate on an Empty FileAppenderCache.\n            FileAppenderCache emptyCache = FileAppenderCache.Empty;\n            Assert.Throws<NullReferenceException>(() => emptyCache.AllocateAppender(\"file.txt\"));\n\n            // Construct a on non-empty FileAppenderCache.\n            IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;\n            ICreateFileParameters fileTarget = new FileTarget();\n            String tempFile = Path.Combine(\n                    Path.GetTempPath(),\n                    Path.Combine(Guid.NewGuid().ToString(), \"file.txt\")\n            );\n\n            // Allocate an appender.\n            FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);\n            BaseFileAppender appender = cache.AllocateAppender(tempFile);\n\n            //\n            // Note: Encoding is ASSUMED to be Unicode. There is no explicit reference to which encoding will be used\n            //      for the file.\n            //\n\n            // Write, flush the content into the file and release the file.\n            // We need to release the file before invoking AssertFileContents() method.\n            appender.Write(StringToBytes(\"NLog test string.\"));\n            appender.Flush();\n            appender.Close();\n            // Verify the appender has been allocated correctly.\n            AssertFileContents(tempFile, \"NLog test string.\", Encoding.Unicode);\n        }"
      },
      {
        "name": "FileAppenderCache_InvalidateAppender",
        "body": "{\n            // Invoke InvalidateAppender() on an Empty FileAppenderCache.\n            FileAppenderCache emptyCache = FileAppenderCache.Empty;\n            emptyCache.InvalidateAppender(\"file.txt\");\n\n            // Construct a on non-empty FileAppenderCache.\n            IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;\n            ICreateFileParameters fileTarget = new FileTarget();\n            String tempFile = Path.Combine(\n                    Path.GetTempPath(),\n                    Path.Combine(Guid.NewGuid().ToString(), \"file.txt\")\n            );\n\n            // Allocate an appender.\n            FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);\n            BaseFileAppender appender = cache.AllocateAppender(tempFile);\n\n            //\n            // Note: Encoding is ASSUMED to be Unicode. There is no explicit reference to which encoding will be used\n            //      for the file.\n            //\n\n            // Write, flush the content into the file and release the file. This happens through the\n            // InvalidateAppender() method. We need to release the file before invoking AssertFileContents() method.\n            appender.Write(StringToBytes(\"NLog test string.\"));\n            cache.InvalidateAppender(tempFile);\n            // Verify the appender has been allocated correctly.\n            AssertFileContents(tempFile, \"NLog test string.\", Encoding.Unicode);\n        }"
      },
      {
        "name": "FileAppenderCache_CloseAppenders",
        "body": "{\n            // Invoke CloseAppenders() on an Empty FileAppenderCache.\n            FileAppenderCache emptyCache = FileAppenderCache.Empty;\n            emptyCache.CloseAppenders(string.Empty);\n            emptyCache.CloseExpiredAppenders(DateTime.UtcNow);\n\n            IFileAppenderFactory appenderFactory = RetryingMultiProcessFileAppender.TheFactory;\n            ICreateFileParameters fileTarget = new FileTarget();\n            FileAppenderCache cache = new FileAppenderCache(3, appenderFactory, fileTarget);\n            // Invoke CloseAppenders() on non-empty FileAppenderCache - Before allocating any appenders.\n            cache.CloseAppenders(string.Empty);\n\n            // Invoke CloseAppenders() on non-empty FileAppenderCache - After allocating N appenders.\n            cache.AllocateAppender(\"file1.txt\");\n            cache.AllocateAppender(\"file2.txt\");\n            cache.CloseAppenders(string.Empty);\n\n            // Invoke CloseAppenders() on non-empty FileAppenderCache - After allocating N appenders.\n            cache.AllocateAppender(\"file1.txt\");\n            cache.AllocateAppender(\"file2.txt\");\n            cache.CloseAppenders(string.Empty);\n\n            FileAppenderCache cache2 = new FileAppenderCache(3, appenderFactory, fileTarget);\n            // Invoke CloseAppenders() on non-empty FileAppenderCache - Before allocating any appenders.\n            cache2.CloseExpiredAppenders(DateTime.UtcNow);\n\n            // Invoke CloseAppenders() on non-empty FileAppenderCache - After allocating N appenders.\n            cache.AllocateAppender(\"file1.txt\");\n            cache.AllocateAppender(\"file2.txt\");\n            cache.CloseExpiredAppenders(DateTime.UtcNow.AddMinutes(-1));\n\n            var appenderFile1 = cache.InvalidateAppender(\"file1.txt\");\n            Assert.NotNull(appenderFile1);\n            var appenderFile2 = cache.InvalidateAppender(\"file2.txt\");\n            Assert.NotNull(appenderFile2);\n\n            cache.AllocateAppender(\"file3.txt\");\n            cache.AllocateAppender(\"file4.txt\");\n            cache.CloseExpiredAppenders(DateTime.UtcNow.AddMinutes(1));\n\n            var appenderFile3 = cache.InvalidateAppender(\"file3.txt\");\n            Assert.Null(appenderFile3);\n            var appenderFile4 = cache.InvalidateAppender(\"file4.txt\");\n            Assert.Null(appenderFile4);\n        }"
      },
      {
        "name": "FileAppenderCache_GetFileCharacteristics_Single",
        "body": "{\n            IFileAppenderFactory appenderFactory = SingleProcessFileAppender.TheFactory;\n            ICreateFileParameters fileTarget = new FileTarget() { ArchiveNumbering = ArchiveNumberingMode.Date };\n            FileAppenderCache_GetFileCharacteristics(appenderFactory, fileTarget);\n        }"
      },
      {
        "name": "FileAppenderCache_GetFileCharacteristics_Multi",
        "body": "{\n            IFileAppenderFactory appenderFactory = MutexMultiProcessFileAppender.TheFactory;\n            ICreateFileParameters fileTarget = new FileTarget() { ArchiveNumbering = ArchiveNumberingMode.Date, ForceManaged = true };\n            FileAppenderCache_GetFileCharacteristics(appenderFactory, fileTarget);\n        }"
      },
      {
        "name": "FileAppenderCache_GetFileCharacteristics_Windows",
        "body": "{\n            if (NLog.Internal.PlatformDetector.IsWin32)\n            {\n                IFileAppenderFactory appenderFactory = WindowsMultiProcessFileAppender.TheFactory;\n                ICreateFileParameters fileTarget = new FileTarget() { ArchiveNumbering = ArchiveNumberingMode.Date };\n                FileAppenderCache_GetFileCharacteristics(appenderFactory, fileTarget);\n            }\n        }"
      }
    ]
  },
  {
    "file": "FilePathLayoutTests.cs",
    "methods": []
  },
  {
    "file": "GuardTests.cs",
    "methods": [
      {
        "name": "ThrowIfNull_WhenArgumentIsNull_ThrowArgumentNullException",
        "body": "{\n            object argument = null;\n\n            Assert.Throws<ArgumentNullException>(() => Guard.ThrowIfNull(argument));\n        }"
      },
      {
        "name": "ThrowIfNull_WhenArgumentIsNotNull_ReturnArgument",
        "body": "{\n            var argument = \"test\";\n\n            var result = Guard.ThrowIfNull(argument);\n\n            Assert.Equal(argument, result);\n        }"
      },
      {
        "name": "ThrowIfNullOrEmpty_WhenArgumentIsNull_ThrowArgumentNullException",
        "body": "{\n            string argument = null;\n\n            Assert.Throws<ArgumentNullException>(() => Guard.ThrowIfNullOrEmpty(argument));\n        }"
      },
      {
        "name": "ThrowIfNullOrEmpty_WhenArgumentIsEmpty_ThrowArgumentNullException",
        "body": "{\n            var argument = string.Empty;\n\n            Assert.Throws<ArgumentNullException>(() => Guard.ThrowIfNullOrEmpty(argument));\n        }"
      },
      {
        "name": "ThrowIfNullOrEmpty_WhenArgumentIsValid_ReturnArgument",
        "body": "{\n            var argument = \"test\";\n\n            var result = Guard.ThrowIfNull(argument);\n\n            Assert.Equal(argument, result);\n        }"
      }
    ]
  },
  {
    "file": "MruCacheTests.cs",
    "methods": [
      {
        "name": "SimpleCacheAddAndLookupTest",
        "body": "{\n            MruCache<int, string> mruCache = new MruCache<int, string>(100);\n            for (int i = 0; i < 100; ++i)\n                mruCache.TryAddValue(i, i.ToString());\n\n            string value;\n            for (int i = 0; i < 100; ++i)\n            {\n                Assert.True(mruCache.TryGetValue(i, out value));\n                Assert.Equal(i.ToString(), value);\n            }\n\n            Assert.False(mruCache.TryGetValue(101, out value));\n        }"
      },
      {
        "name": "OverflowCacheAndLookupTest",
        "body": "{\n            MruCache<int, string> mruCache = new MruCache<int, string>(100);\n            for (int i = 0; i < 200; ++i)\n                mruCache.TryAddValue(i, i.ToString());\n\n            string value;\n            for (int i = 0; i < 100; ++i)\n            {\n                Assert.False(mruCache.TryGetValue(i, out value));\n            }\n\n            for (int i = 140; i < 200; ++i)\n            {\n                Assert.True(mruCache.TryGetValue(i, out value));\n                Assert.Equal(i.ToString(), value);\n            }\n        }"
      },
      {
        "name": "OverflowVersionCacheAndLookupTest",
        "body": "{\n            string value;\n            MruCache<int, string> mruCache = new MruCache<int, string>(100);\n            for (int i = 0; i < 200; ++i)\n            {\n                mruCache.TryAddValue(i, i.ToString());\n                Assert.True(mruCache.TryGetValue(i, out value));    // No longer a virgin\n                Assert.Equal(i.ToString(), value);\n            }\n\n            for (int i = 0; i < 90; ++i)\n            {\n                Assert.False(mruCache.TryGetValue(i, out value));\n            }\n\n            for (int i = 140; i < 200; ++i)\n            {\n                Assert.True(mruCache.TryGetValue(i, out value));\n                Assert.Equal(i.ToString(), value);\n            }\n        }"
      },
      {
        "name": "OverflowFreshCacheAndLookupTest",
        "body": "{\n            string value;\n            MruCache<int, string> mruCache = new MruCache<int, string>(100);\n            for (int i = 0; i < 200; ++i)\n            {\n                mruCache.TryAddValue(i, i.ToString());\n                Assert.True(mruCache.TryGetValue(i, out value));    // No longer a virgin\n                Assert.Equal(i.ToString(), value);\n            }\n\n            for (int j = 0; j < 2; ++j)\n            {\n                for (int i = 110; i < 200; ++i)\n                {\n                    if (!mruCache.TryGetValue(i, out value))\n                    {\n                        mruCache.TryAddValue(i, i.ToString());\n                        Assert.True(mruCache.TryGetValue(i, out value));\n                    }\n                }\n            }\n\n            for (int i = 300; i < 310; ++i)\n            {\n                mruCache.TryAddValue(i, i.ToString());\n            }\n\n            int cacheCount = 0;\n            for (int i = 110; i < 200; ++i)\n            {\n                if (mruCache.TryGetValue(i, out value))\n                    ++cacheCount;\n            }\n\n            Assert.True(cacheCount > 60);   // See that old cache was not killed\n        }"
      },
      {
        "name": "RecentlyUsedLookupTest",
        "body": "{\n            string value;\n\n            MruCache<int, string> mruCache = new MruCache<int, string>(100);\n            for (int i = 0; i < 200; ++i)\n            {\n                mruCache.TryAddValue(i, i.ToString());\n                for (int j = 0; j < i; j += 10)\n                {\n                    Assert.True(mruCache.TryGetValue(j, out value));\n                    Assert.Equal(j.ToString(), value);\n                }\n            }\n\n            for (int j = 0; j < 100; j += 10)\n            {\n                Assert.True(mruCache.TryGetValue(j, out value));\n                Assert.Equal(j.ToString(), value);\n            }\n\n            for (int i = 170; i < 200; ++i)\n            {\n                Assert.True(mruCache.TryGetValue(i, out value));\n                Assert.Equal(i.ToString(), value);\n            }\n        }"
      }
    ]
  },
  {
    "file": "PlatformDetectorTests.cs",
    "methods": [
      {
        "name": "IsMonoTest",
        "body": "{\n#if MONO\n            Assert.True(PlatformDetector.IsMono);\n#else\n            Assert.False(PlatformDetector.IsMono);\n#endif\n        }"
      },
      {
        "name": "GetCurrentOSTest",
        "body": "{\n            var actual = PlatformDetector.CurrentOS;\n            Assert.NotEqual(RuntimeOS.Unknown, actual);\n        }"
      }
    ]
  },
  {
    "file": "PropertiesDictionaryTests.cs",
    "methods": [
      {
        "name": "DefaultPropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo();\n            IDictionary<object, object> dictionary = logEvent.Properties;\n            Assert.Empty(dictionary);\n            foreach (var item in dictionary)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Keys)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Values)\n                Assert.Fail(\"Should be empty\");\n            Assert.DoesNotContain(\"Hello World\", dictionary);\n            Assert.False(dictionary.ContainsKey(\"Hello World\"));\n            Assert.False(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.False(dictionary.Values.Contains(42));\n            object value;\n            Assert.False(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Null(value);\n            Assert.False(dictionary.Remove(\"Hello World\"));\n            dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);\n            dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Clear();\n        }"
      },
      {
        "name": "EmptyEventPropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo();\n            IDictionary<object, object> dictionary = logEvent.Properties;\n            dictionary.Add(\"Hello World\", 42);\n            Assert.True(dictionary.Remove(\"Hello World\"));\n            Assert.Empty(dictionary);\n            foreach (var item in dictionary)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Keys)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Values)\n                Assert.Fail(\"Should be empty\");\n\n            Assert.DoesNotContain(\"Hello World\", dictionary);\n            Assert.False(dictionary.ContainsKey(\"Hello World\"));\n            Assert.False(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.False(dictionary.Values.Contains(42));\n            object value;\n            Assert.False(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Null(value);\n            Assert.False(dictionary.Remove(\"Hello World\"));\n            dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);\n            dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Clear();\n        }"
      },
      {
        "name": "EmptyMessagePropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, (IList<MessageTemplateParameter>)null);\n            IDictionary<object, object> dictionary = logEvent.Properties;\n            Assert.Empty(dictionary);\n            foreach (var item in dictionary)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Keys)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Values)\n                Assert.Fail(\"Should be empty\");\n            Assert.False(dictionary.ContainsKey(\"Hello World\"));\n            Assert.False(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.False(dictionary.Values.Contains(42));\n            Assert.DoesNotContain(\"Hello World\", dictionary);\n            object value;\n            Assert.False(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Null(value);\n            Assert.False(dictionary.Remove(\"Hello World\"));\n            dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);\n            dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Clear();\n        }"
      },
      {
        "name": "EmptyPropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, (IList<MessageTemplateParameter>)null);\n            IDictionary<object, object> dictionary = logEvent.Properties;\n            dictionary.Add(\"Hello World\", null);\n            Assert.True(dictionary.Remove(\"Hello World\"));\n            Assert.Empty(dictionary);\n            foreach (var item in dictionary)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Keys)\n                Assert.Fail(\"Should be empty\");\n            foreach (var item in dictionary.Values)\n                Assert.Fail(\"Should be empty\");\n            Assert.False(dictionary.ContainsKey(\"Hello World\"));\n            Assert.False(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.False(dictionary.Values.Contains(42));\n            Assert.DoesNotContain(\"Hello World\", dictionary);\n            object value;\n            Assert.False(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Null(value);\n            Assert.False(dictionary.Remove(\"Hello World\"));\n            dictionary.CopyTo(ArrayHelper.Empty<KeyValuePair<object, object>>(), 0);\n            dictionary.Values.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Keys.CopyTo(ArrayHelper.Empty<object>(), 0);\n            dictionary.Clear();\n        }"
      },
      {
        "name": "SingleItemEventPropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo();\n            IDictionary<object, object> dictionary = logEvent.Properties;\n            dictionary.Add(\"Hello World\", 42);\n            Assert.Single(dictionary);\n            foreach (var item in dictionary)\n            {\n                Assert.Equal(\"Hello World\", item.Key);\n                Assert.Equal(42, item.Value);\n            }\n            foreach (var item in dictionary.Keys)\n                Assert.Equal(\"Hello World\", item);\n            foreach (var item in dictionary.Values)\n                Assert.Equal(42, item);\n            AssertContainsInDictionary(dictionary, \"Hello World\", 42);\n            Assert.True(dictionary.ContainsKey(\"Hello World\"));\n            Assert.True(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.True(dictionary.Values.Contains(42));\n            Assert.False(dictionary.ContainsKey(\"Goodbye World\"));\n            Assert.False(dictionary.Keys.Contains(\"Goodbye World\"));\n            Assert.DoesNotContain(\"Goodbye World\", dictionary);\n            object value;\n            Assert.True(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Equal(42, value);\n            Assert.False(dictionary.TryGetValue(\"Goodbye World\", out value));\n            Assert.Null(value);\n            var copyToArray = new KeyValuePair<object, object>[1];\n            dictionary.CopyTo(copyToArray, 0);\n            Assert.Equal(\"Hello World\", copyToArray[0].Key);\n            Assert.Equal(42, copyToArray[0].Value);\n            var copyToValuesArray = new object[1];\n            dictionary.Values.CopyTo(copyToValuesArray, 0);\n            Assert.Equal(42, copyToValuesArray[0]);\n            var copyToKeysArray = new object[1];\n            dictionary.Keys.CopyTo(copyToKeysArray, 0);\n            Assert.Equal(\"Hello World\", copyToKeysArray[0]);\n            Assert.True(dictionary.Remove(\"Hello World\"));\n            Assert.Empty(dictionary);\n            dictionary[\"Hello World\"] = 42;\n            Assert.Single(dictionary);\n            dictionary.Clear();\n            Assert.Empty(dictionary);\n        }"
      },
      {
        "name": "SingleItemMessagePropertiesDictionaryNoLookup",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[] { new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal) });\n            IDictionary<object, object> dictionary = logEvent.Properties;\n            Assert.Single(dictionary);\n            foreach (var item in dictionary)\n            {\n                Assert.Equal(\"Hello World\", item.Key);\n                Assert.Equal(42, item.Value);\n            }\n            foreach (var item in dictionary.Keys)\n                Assert.Equal(\"Hello World\", item);\n            foreach (var item in dictionary.Values)\n                Assert.Equal(42, item);\n\n            var copyToArray = new KeyValuePair<object, object>[1];\n            dictionary.CopyTo(copyToArray, 0);\n            Assert.Equal(\"Hello World\", copyToArray[0].Key);\n            Assert.Equal(42, copyToArray[0].Value);\n            var copyToValuesArray = new object[1];\n            dictionary.Values.CopyTo(copyToValuesArray, 0);\n            Assert.Equal(42, copyToValuesArray[0]);\n            var copyToKeysArray = new object[1];\n            dictionary.Keys.CopyTo(copyToKeysArray, 0);\n            Assert.Equal(\"Hello World\", copyToKeysArray[0]);\n\n            dictionary.Clear();\n            Assert.Empty(dictionary);\n        }"
      },
      {
        "name": "SingleItemMessagePropertiesDictionaryWithLookup",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[] { new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal) });\n            IDictionary<object, object> dictionary = logEvent.Properties;\n\n            Assert.Single(dictionary);\n\n            AssertContainsInDictionary(dictionary, \"Hello World\", 42);\n            Assert.True(dictionary.ContainsKey(\"Hello World\"));\n            Assert.True(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.True(dictionary.Values.Contains(42));\n            Assert.False(dictionary.ContainsKey(\"Goodbye World\"));\n            Assert.False(dictionary.Keys.Contains(\"Goodbye World\"));\n            Assert.DoesNotContain(\"Goodbye World\", dictionary);\n            object value;\n            Assert.True(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Equal(42, value);\n            Assert.False(dictionary.TryGetValue(\"Goodbye World\", out value));\n            Assert.Null(value);\n\n            var copyToArray = new KeyValuePair<object, object>[1];\n            dictionary.CopyTo(copyToArray, 0);\n            Assert.Equal(\"Hello World\", copyToArray[0].Key);\n            Assert.Equal(42, copyToArray[0].Value);\n            var copyToValuesArray = new object[1];\n            dictionary.Values.CopyTo(copyToValuesArray, 0);\n            Assert.Equal(42, copyToValuesArray[0]);\n            var copyToKeysArray = new object[1];\n            dictionary.Keys.CopyTo(copyToKeysArray, 0);\n            Assert.Equal(\"Hello World\", copyToKeysArray[0]);\n\n            dictionary.Clear();\n            Assert.Empty(dictionary);\n        }"
      },
      {
        "name": "MultiItemPropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[] { new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal) });\n            IDictionary<object, object> dictionary = logEvent.Properties;\n\n            dictionary[\"Goodbye World\"] = 666;\n            Assert.Equal(2, dictionary.Count);\n            int i = 0;\n            foreach (var item in dictionary)\n            {\n                switch (i++)\n                {\n                    case 0:\n                        Assert.Equal(\"Hello World\", item.Key);\n                        Assert.Equal(42, item.Value);\n                        break;\n                    case 1:\n                        Assert.Equal(\"Goodbye World\", item.Key);\n                        Assert.Equal(666, item.Value);\n                        break;\n                }\n            }\n            Assert.Equal(2, i);\n\n            i = 0;\n            foreach (var item in dictionary.Keys)\n            {\n                switch (i++)\n                {\n                    case 0:\n                        Assert.Equal(\"Hello World\", item);\n                        break;\n                    case 1:\n                        Assert.Equal(\"Goodbye World\", item);\n                        break;\n                }\n            }\n            Assert.Equal(2, i);\n\n            i = 0;\n            foreach (var item in dictionary.Values)\n            {\n                switch (i++)\n                {\n                    case 0:\n                        Assert.Equal(42, item);\n                        break;\n                    case 1:\n                        Assert.Equal(666, item);\n                        break;\n                }\n            }\n            Assert.True(dictionary.ContainsKey(\"Hello World\"));\n            AssertContainsInDictionary(dictionary, \"Hello World\", 42);\n            Assert.True(dictionary.Keys.Contains(\"Hello World\"));\n            Assert.True(dictionary.Values.Contains(42));\n            Assert.True(dictionary.ContainsKey(\"Goodbye World\"));\n            AssertContainsInDictionary(dictionary, \"Goodbye World\", 666);\n            Assert.True(dictionary.Keys.Contains(\"Goodbye World\"));\n            Assert.True(dictionary.Values.Contains(666));\n            Assert.False(dictionary.Keys.Contains(\"Mad World\"));\n            Assert.False(dictionary.ContainsKey(\"Mad World\"));\n            object value;\n            Assert.True(dictionary.TryGetValue(\"Hello World\", out value));\n            Assert.Equal(42, value);\n            Assert.True(dictionary.TryGetValue(\"Goodbye World\", out value));\n            Assert.Equal(666, value);\n            Assert.False(dictionary.TryGetValue(\"Mad World\", out value));\n            Assert.Null(value);\n            var copyToArray = new KeyValuePair<object, object>[2];\n            dictionary.CopyTo(copyToArray, 0);\n            Assert.Contains(new KeyValuePair<object, object>(\"Hello World\", 42), copyToArray);\n            Assert.Contains(new KeyValuePair<object, object>(\"Goodbye World\", 666), copyToArray);\n            var copyToValuesArray = new object[2];\n            dictionary.Values.CopyTo(copyToValuesArray, 0);\n            Assert.Contains(42, copyToValuesArray);\n            Assert.Contains(666, copyToValuesArray);\n            var copyToKeysArray = new object[2];\n            dictionary.Keys.CopyTo(copyToKeysArray, 0);\n            Assert.Contains(\"Hello World\", copyToKeysArray);\n            Assert.Contains(\"Goodbye World\", copyToKeysArray);\n            Assert.True(dictionary.Remove(\"Goodbye World\"));\n            Assert.Single(dictionary);\n            dictionary[\"Goodbye World\"] = 666;\n            Assert.Equal(2, dictionary.Count);\n            dictionary.Clear();\n            Assert.Empty(dictionary);\n        }"
      },
      {
        "name": "OverrideMessagePropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[]\n            {\n                new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal),\n                new MessageTemplateParameter(\"Goodbye World\", 666, null, CaptureType.Normal)\n            });\n            IDictionary<object, object> dictionary = logEvent.Properties;\n\n            Assert.Equal(42, dictionary[\"Hello World\"]);\n            dictionary[\"Hello World\"] = 999;\n            Assert.Equal(999, dictionary[\"Hello World\"]);\n            Assert.True(dictionary.Values.Contains(999));\n            Assert.True(dictionary.Values.Contains(666));\n            Assert.False(dictionary.Values.Contains(42));\n\n            int i = 0;\n            foreach (var item in dictionary)\n            {\n                switch (i++)\n                {\n                    case 1:\n                        Assert.Equal(\"Hello World\", item.Key);\n                        Assert.Equal(999, item.Value);\n                        break;\n                    case 0:\n                        Assert.Equal(\"Goodbye World\", item.Key);\n                        Assert.Equal(666, item.Value);\n                        break;\n                }\n            }\n            Assert.Equal(2, i);\n\n            i = 0;\n            foreach (var item in dictionary.Keys)\n            {\n                switch (i++)\n                {\n                    case 1:\n                        Assert.Equal(\"Hello World\", item);\n                        break;\n                    case 0:\n                        Assert.Equal(\"Goodbye World\", item);\n                        break;\n                }\n            }\n            Assert.Equal(2, i);\n\n            i = 0;\n            foreach (var item in dictionary.Values)\n            {\n                switch (i++)\n                {\n                    case 1:\n                        Assert.Equal(999, item);\n                        break;\n                    case 0:\n                        Assert.Equal(666, item);\n                        break;\n                }\n            }\n\n            dictionary[\"Goodbye World\"] = 42;\n            i = 0;\n            foreach (var item in dictionary.Keys)\n            {\n                switch (i++)\n                {\n                    case 0:\n                        Assert.Equal(\"Hello World\", item);\n                        break;\n                    case 1:\n                        Assert.Equal(\"Goodbye World\", item);\n                        break;\n                }\n            }\n            Assert.Equal(2, i);\n\n            dictionary.Remove(\"Hello World\");\n            Assert.Single(dictionary);\n            dictionary.Remove(\"Goodbye World\");\n            Assert.Empty(dictionary);\n        }"
      },
      {
        "name": "NonUniqueMessagePropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[]\n            {\n                new MessageTemplateParameter(\"Hello World\", 42, null, CaptureType.Normal),\n                new MessageTemplateParameter(\"Hello World\", 666, null, CaptureType.Normal)\n            });\n            IDictionary<object, object> dictionary = logEvent.Properties;\n\n            Assert.Equal(2, dictionary.Count);\n            Assert.Equal(42, dictionary[\"Hello World\"]);\n            Assert.Equal(666, dictionary[\"Hello World_1\"]);\n\n            foreach (var property in dictionary)\n            {\n                if (property.Value.Equals(42))\n                    Assert.Equal(\"Hello World\", property.Key);\n                else if (property.Value.Equals(666))\n                    Assert.Equal(\"Hello World_1\", property.Key);\n                else\n                    Assert.Null(property.Key);\n            }\n        }"
      },
      {
        "name": "NonUniqueEventPropertiesDictionary",
        "body": "{\n            LogEventInfo logEvent = new LogEventInfo(LogLevel.Info, \"MyLogger\", string.Empty, new[]\n            {\n                new KeyValuePair<object,object>(\"Hello World\", 42),\n                new KeyValuePair<object,object>(\"Hello World\", 666),\n            });\n            IDictionary<object, object> dictionary = logEvent.Properties;\n\n            Assert.Single(dictionary);\n            Assert.Equal(666, dictionary[\"Hello World\"]);   // Last one wins\n        }"
      }
    ]
  },
  {
    "file": "PropertyHelperTests.cs",
    "methods": [
      {
        "name": "AssignArrayPropertyFromStringWillResultInNotSupportedExceptionSomeWhereDeep",
        "body": "{\n            // Arrange\n            var config = @\"\n            <nlog throwExceptions='true'>\n                <targets>\n                  <target name='f' type='File' filename='test.log'>\n                    <layout type='CSVLayout' column='a'>\n                    </layout>\n                  </target>\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='f' />\n                </rules>\n            </nlog>\";\n\n            // Act\n            var ex = Assert.Throws<NLogConfigurationException>(() => XmlLoggingConfiguration.CreateFromXmlString(config));\n\n            // Assert\n            Assert.IsType<NLogConfigurationException>(ex.InnerException);\n            Assert.IsType<NotSupportedException>(ex.InnerException.InnerException);\n            Assert.Contains(\"because property of type array and not scalar value\", ex.InnerException.InnerException.Message);\n        }"
      }
    ]
  },
  {
    "file": "ReadOnlyExpandoTestDictionary.cs",
    "methods": []
  },
  {
    "file": "SimpleStringReaderTests.cs",
    "methods": [
      {
        "name": "DebugView_CurrentState_NegativePosition",
        "body": "{\n            Assert.Throws<IndexOutOfRangeException>(() => new SimpleStringReader(\"abcdef\")\n            {\n                Position = -1,\n            }.CurrentState);\n        }"
      }
    ]
  },
  {
    "file": "SortHelpersTests.cs",
    "methods": [
      {
        "name": "SingleBucketDictionary_NoBucketTest",
        "body": "{\n            SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>();\n            Assert.Empty(dict);\n\n            Assert.Empty(dict);\n            Assert.Equal(0, dict.Count(val => val.Key == \"Bucket1\"));\n\n            foreach (var _ in dict)\n                Assert.False(true);\n\n            Assert.Empty(dict.Keys);\n            foreach (var _ in dict.Keys)\n                Assert.False(true);\n\n            Assert.Empty(dict.Values);\n            foreach (var _ in dict.Values)\n                Assert.False(true);\n\n            IList<string> bucket;\n            Assert.False(dict.TryGetValue(\"Bucket1\", out bucket) || bucket != null);\n            Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);\n            Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);\n\n            Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());\n        }"
      },
      {
        "name": "SingleBucketDictionary_OneBucketEmptyTest",
        "body": "{\n            IList<string> bucket = ArrayHelper.Empty<string>();\n            SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket));\n            Assert.Single(dict);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket), dict);\n\n            Assert.True(dict.ContainsKey(\"Bucket1\"));\n            Assert.False(dict.ContainsKey(string.Empty));\n\n            KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];\n            dict.CopyTo(copyToResult, 0);\n            Assert.Equal(\"Bucket1\", copyToResult[0].Key);\n            Assert.Empty(copyToResult[0].Value);\n\n            Assert.Single(dict);\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));\n\n            foreach (var item in dict)\n            {\n                Assert.Equal(\"Bucket1\", item.Key);\n                Assert.Empty(item.Value);\n            }\n\n            Assert.Single(dict.Keys);\n            foreach (var key in dict.Keys)\n            {\n                Assert.Equal(\"Bucket1\", key);\n            }\n\n            Assert.Single(dict.Values);\n            foreach (var val in dict.Values)\n            {\n                Assert.Empty(val);\n            }\n\n            Assert.Empty(dict[\"Bucket1\"]);\n\n            Assert.True(dict.TryGetValue(\"Bucket1\", out bucket) && bucket.Count == 0);\n            Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);\n            Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);\n            Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());\n        }"
      },
      {
        "name": "SingleBucketDictionary_OneBucketOneItem",
        "body": "{\n            IList<string> bucket = new string[] { \"Bucket1Item1\" };\n            SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket));\n            Assert.Single(dict);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket), dict);\n\n            Assert.True(dict.ContainsKey(\"Bucket1\"));\n            Assert.False(dict.ContainsKey(string.Empty));\n\n            KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];\n            dict.CopyTo(copyToResult, 0);\n            Assert.Equal(\"Bucket1\", copyToResult[0].Key);\n            Assert.Single(copyToResult[0].Value);\n            Assert.Equal(\"Bucket1Item1\", copyToResult[0].Value[0]);\n\n            Assert.Single(dict);\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));\n\n            foreach (var item in dict)\n            {\n                Assert.Equal(\"Bucket1\", item.Key);\n                Assert.Single(item.Value);\n                Assert.Equal(\"Bucket1Item1\", item.Value[0]);\n            }\n\n            Assert.Single(dict.Keys);\n            foreach (var key in dict.Keys)\n            {\n                Assert.Equal(\"Bucket1\", key);\n            }\n\n            Assert.Single(dict.Values);\n            foreach (var val in dict.Values)\n            {\n                Assert.Single(val);\n                Assert.Equal(\"Bucket1Item1\", val[0]);\n            }\n\n            Assert.Single(dict[\"Bucket1\"]);\n            Assert.True(dict.TryGetValue(\"Bucket1\", out bucket) && bucket.Count == 1);\n            Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);\n            Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);\n            Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());\n        }"
      },
      {
        "name": "SingleBucketDictionary_OneBucketTwoItemsTest",
        "body": "{\n            IList<string> bucket = new string[] { \"Bucket1Item1\", \"Bucket1Item2\" };\n            SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket));\n            Assert.Single(dict);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket), dict);\n\n            Assert.True(dict.ContainsKey(\"Bucket1\"));\n            Assert.False(dict.ContainsKey(string.Empty));\n\n            KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];\n            dict.CopyTo(copyToResult, 0);\n            Assert.Equal(\"Bucket1\", copyToResult[0].Key);\n            Assert.Equal(2, copyToResult[0].Value.Count);\n            Assert.Equal(\"Bucket1Item1\", copyToResult[0].Value[0]);\n            Assert.Equal(\"Bucket1Item2\", copyToResult[0].Value[1]);\n\n            Assert.Single(dict);\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));\n\n            foreach (var item in dict)\n            {\n                Assert.Equal(\"Bucket1\", item.Key);\n                Assert.Equal(2, item.Value.Count);\n                Assert.Equal(\"Bucket1Item1\", item.Value[0]);\n                Assert.Equal(\"Bucket1Item2\", item.Value[1]);\n            }\n\n            Assert.Single(dict.Keys);\n            foreach (var key in dict.Keys)\n            {\n                Assert.Equal(\"Bucket1\", key);\n            }\n\n            Assert.Single(dict.Values);\n            foreach (var val in dict.Values)\n            {\n                Assert.Equal(2, val.Count);\n                Assert.Equal(\"Bucket1Item1\", val[0]);\n                Assert.Equal(\"Bucket1Item2\", val[1]);\n            }\n\n            Assert.Equal(2, dict[\"Bucket1\"].Count);\n            Assert.True(dict.TryGetValue(\"Bucket1\", out bucket) && bucket.Count == 2);\n            Assert.False(dict.TryGetValue(string.Empty, out bucket) || bucket != null);\n            Assert.False(dict.TryGetValue(null, out bucket) || bucket != null);\n            Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());\n        }"
      },
      {
        "name": "SingleBucketDictionary_TwoBucketEmptyTest",
        "body": "{\n            IList<string> bucket1 = ArrayHelper.Empty<string>();\n            IList<string> bucket2 = ArrayHelper.Empty<string>();\n            Dictionary<string, IList<string>> buckets = new Dictionary<string, IList<string>>();\n            buckets[\"Bucket1\"] = bucket1;\n            buckets[\"Bucket2\"] = bucket2;\n\n            SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(buckets);\n            Assert.Equal(2, dict.Count);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket1), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket1), dict);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket2\", bucket2), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket2\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket2), dict);\n\n            Assert.True(dict.ContainsKey(\"Bucket1\"));\n            Assert.True(dict.ContainsKey(\"Bucket2\"));\n            Assert.False(dict.ContainsKey(string.Empty));\n\n            KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];\n            dict.CopyTo(copyToResult, 0);\n            Assert.Equal(\"Bucket1\", copyToResult[0].Key);\n            Assert.Equal(\"Bucket2\", copyToResult[1].Key);\n            Assert.Empty(copyToResult[0].Value);\n            Assert.Empty(copyToResult[1].Value);\n\n            Assert.Equal(2, dict.Count());\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket2\"));\n\n            foreach (var item in dict)\n            {\n                Assert.True(item.Key == \"Bucket1\" || item.Key == \"Bucket2\");\n                Assert.Empty(item.Value);\n            }\n\n            Assert.Equal(2, dict.Keys.Count);\n            foreach (var key in dict.Keys)\n            {\n                Assert.True(key == \"Bucket1\" || key == \"Bucket2\");\n            }\n\n            Assert.Equal(2, dict.Values.Count);\n            foreach (var val in dict.Values)\n            {\n                Assert.Empty(val);\n            }\n\n            Assert.Empty(dict[\"Bucket1\"]);\n            Assert.Empty(dict[\"Bucket2\"]);\n            Assert.True(dict.TryGetValue(\"Bucket1\", out bucket1) && bucket1.Count == 0);\n            Assert.True(dict.TryGetValue(\"Bucket2\", out bucket2) && bucket2.Count == 0);\n            Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());\n        }"
      },
      {
        "name": "SingleBucketDictionary_TwoBuckettOneItemTest",
        "body": "{\n            IList<string> bucket1 = new string[] { \"Bucket1Item1\" };\n            IList<string> bucket2 = new string[] { \"Bucket1Item1\" };\n            Dictionary<string, IList<string>> buckets = new Dictionary<string, IList<string>>();\n            buckets[\"Bucket1\"] = bucket1;\n            buckets[\"Bucket2\"] = bucket2;\n\n            SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>> dict = new SortHelpers.ReadOnlySingleBucketDictionary<string, IList<string>>(buckets);\n            Assert.Equal(2, dict.Count);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket1\", bucket1), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket1\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket1), dict);\n\n            Assert.Contains(new KeyValuePair<string, IList<string>>(\"Bucket2\", bucket2), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(\"Bucket2\", null), dict);\n            Assert.DoesNotContain(new KeyValuePair<string, IList<string>>(string.Empty, bucket2), dict);\n\n            Assert.True(dict.ContainsKey(\"Bucket1\"));\n            Assert.True(dict.ContainsKey(\"Bucket2\"));\n            Assert.False(dict.ContainsKey(string.Empty));\n\n            KeyValuePair<string, IList<string>>[] copyToResult = new KeyValuePair<string, IList<string>>[10];\n            dict.CopyTo(copyToResult, 0);\n            Assert.Equal(\"Bucket1\", copyToResult[0].Key);\n            Assert.Equal(\"Bucket2\", copyToResult[1].Key);\n            Assert.Single(copyToResult[0].Value);\n            Assert.Single(copyToResult[1].Value);\n\n            Assert.Equal(2, dict.Count());\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket1\"));\n            Assert.Equal(1, dict.Count(val => val.Key == \"Bucket2\"));\n\n            foreach (var item in dict)\n            {\n                Assert.True(item.Key == \"Bucket1\" || item.Key == \"Bucket2\");\n                Assert.Single(item.Value);\n                Assert.Equal(\"Bucket1Item1\", item.Value[0]);\n            }\n\n            Assert.Equal(2, dict.Keys.Count);\n            foreach (var key in dict.Keys)\n            {\n                Assert.True(key == \"Bucket1\" || key == \"Bucket2\");\n            }\n\n            Assert.Equal(2, dict.Values.Count);\n            foreach (var val in dict.Values)\n            {\n                Assert.Single(val);\n                Assert.Equal(\"Bucket1Item1\", val[0]);\n            }\n\n            Assert.Single(dict[\"Bucket1\"]);\n            Assert.Single(dict[\"Bucket2\"]);\n            Assert.True(dict.TryGetValue(\"Bucket1\", out bucket1) && bucket1.Count == 1);\n            Assert.True(dict.TryGetValue(\"Bucket2\", out bucket2) && bucket2.Count == 1);\n            Assert.Throws<NotSupportedException>(() => dict[string.Empty] = ArrayHelper.Empty<string>());\n        }"
      }
    ]
  },
  {
    "file": "StringBuilderExtTests.cs",
    "methods": []
  },
  {
    "file": "StringBuilderPoolTests.cs",
    "methods": [
      {
        "name": "StringBuilderPoolMaxCapacityTest",
        "body": "{\n            int poolItemCount = 10;\n            NLog.Internal.StringBuilderPool pool = new NLog.Internal.StringBuilderPool(poolItemCount);\n            string mediumPayload = new string('A', 40 * 1024);\n            RecursiveAcquirePoolItems(poolItemCount, pool, mediumPayload, true);        // Verify fast-pool + slow-pool must grow\n            RecursiveAcquirePoolItems(poolItemCount, pool, mediumPayload, false);       // Verify fast-pool + slow-pool has kept their capacity\n\n            string largePayload = new string('A', 400000);\n            RecursiveAcquirePoolItems(poolItemCount, pool, largePayload, true);\n            using (var itemHolder = pool.Acquire())\n            {\n                Assert.Equal(0, itemHolder.Item.Length);\n                Assert.True(largePayload.Length <= itemHolder.Item.Capacity);               // Verify fast-pool has kept its capacity\n                RecursiveAcquirePoolItems(poolItemCount, pool, mediumPayload + \"A\", true);  // Verify slow-pool has reset its capacity\n            }\n        }"
      }
    ]
  },
  {
    "file": "StringHelpersTests.cs",
    "methods": []
  },
  {
    "file": "StringSplitterTests.cs",
    "methods": []
  },
  {
    "file": "UrlHelperTests.cs",
    "methods": []
  },
  {
    "file": "AllEventPropertiesTests.cs",
    "methods": [
      {
        "name": "AllParametersAreSetToDefault",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            var ev = BuildLogEventWithProperties();\n\n            var result = renderer.Render(ev);\n\n            Assert.Equal(\"a=1, hello=world, 17=100\", result);\n        }"
      },
      {
        "name": "CustomSeparator",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            renderer.Separator = \" | \";\n            var ev = BuildLogEventWithProperties();\n\n            var result = renderer.Render(ev);\n\n            Assert.Equal(\"a=1 | hello=world | 17=100\", result);\n        }"
      },
      {
        "name": "CustomFormat",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            renderer.Format = \"[key] is [value]\";\n            var ev = BuildLogEventWithProperties();\n\n            var result = renderer.Render(ev);\n\n            Assert.Equal(\"a is 1, hello is world, 17 is 100\", result);\n        }"
      },
      {
        "name": "NoProperties",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            var ev = new LogEventInfo();\n\n            var result = renderer.Render(ev);\n\n            Assert.Equal(\"\", result);\n        }"
      },
      {
        "name": "EventPropertyFormat",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            var ev = new LogEventInfo(LogLevel.Info, null, null, \"{pi:0}\", new object[] { 3.14159265359 });\n            var result = renderer.Render(ev);\n            Assert.Equal(\"pi=3\", result);\n        }"
      },
      {
        "name": "StructuredLoggingProperties",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            var planetProperties = new System.Collections.Generic.Dictionary<string, object>()\n            {\n                { \"Name\", \"Earth\" },\n                { \"PlanetType\", \"Water-world\" },\n            };\n\n            var ev = new LogEventInfo(LogLevel.Info, null, null, \"Hello Planet {@planet}\", new object[] { planetProperties });\n            var result = renderer.Render(ev);\n            Assert.Equal(@\"planet=\"\"Name\"\"=\"\"Earth\"\", \"\"PlanetType\"\"=\"\"Water-world\"\"\", result);\n        }"
      },
      {
        "name": "IncludeScopeProperties",
        "body": "{\n            var testLayout = new SimpleLayout(\"${all-event-properties:IncludeScopeProperties=true}\");\n\n            var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = testLayout }).WithAsync();\n            }).LogFactory;\n\n            var ev = new LogEventInfo(LogLevel.Info, null, null, \"{pi:0}\", new object[] { 3.14159265359 });\n            using (ScopeContext.PushProperty(\"Figure\", \"Circle\"))\n            {\n                var logger = logFactory.GetLogger(\"B\");\n\n                logger.Debug(ev);\n            }\n\n            var target = logFactory.Configuration.AllTargets.OfType<DebugTarget>().First();\n            logFactory.Shutdown();  // Flush\n\n            var result = target.LastMessage;\n            Assert.Equal(\"pi=3, Figure=Circle\", result);\n        }"
      },
      {
        "name": "TestInvalidCustomFormatWithoutKeyPlaceholder",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            var ex = Assert.Throws<ArgumentException>(() => renderer.Format = \"[key is [value]\");\n            Assert.Equal(\"Invalid format: [key] placeholder is missing.\", ex.Message);\n        }"
      },
      {
        "name": "TestInvalidCustomFormatWithoutValuePlaceholder",
        "body": "{\n            var renderer = new AllEventPropertiesLayoutRenderer();\n            var ex = Assert.Throws<ArgumentException>(() => renderer.Format = \"[key] is [vlue]\");\n            Assert.Equal(\"Invalid format: [value] placeholder is missing.\", ex.Message);\n        }"
      },
      {
        "name": "AllEventWithFluent_without_callerInformation",
        "body": "{\n            //Arrange\n            LogFactory logFactory = new LogFactory()\n                .Setup()\n                .LoadConfiguration(builder =>\n                {\n                    builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = \"${all-event-properties}\" });\n                })\n                .LogFactory;\n\n            //Act\n            logFactory.GetCurrentClassLogger()\n                .WithProperty(\"Test\", \"InfoWrite\")\n                .WithProperty(\"coolness\", \"200%\")\n                .WithProperty(\"a\", \"not b\")\n                .Debug(\"This is a test message '{0}'.\", DateTime.Now.Ticks);\n\n            //Assert\n            logFactory.AssertDebugLastMessage(\"Test=InfoWrite, coolness=200%, a=not b\");\n        }"
      },
      {
        "name": "WithPropertiesTest",
        "body": "{\n            //Arrange\n            LogFactory logFactory = new LogFactory()\n                .Setup()\n                .LoadConfiguration(builder =>\n                {\n                    builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = \"${all-event-properties}\" });\n                })\n                .LogFactory;\n\n            Dictionary<string, object> properties = new Dictionary<string, object>()\n            {\n                {\"TestString\", \"myString\" },\n                {\"TestInt\", 999 }\n            };\n\n            //Act\n            logFactory.GetCurrentClassLogger()\n                .WithProperties(properties)\n                .Debug(\"This is a test message '{0}'.\", DateTime.Now.Ticks);\n\n            //Assert\n            logFactory.AssertDebugLastMessage(\"TestString=myString, TestInt=999\");\n        }"
      },
      {
        "name": "AllEventWithFluent_with_callerInformation",
        "body": "{\n            //Arrange\n            LogFactory logFactory = new LogFactory()\n                .Setup()\n                .LoadConfiguration(builder =>\n                {\n                    builder.ForLogger().WriteTo(new DebugTarget(\"debug\") { Layout = \"${all-event-properties}${callsite}\" });\n                })\n                .LogFactory;\n\n            //Act\n            logFactory.GetCurrentClassLogger()\n                .WithProperty(\"Test\", \"InfoWrite\")\n                .WithProperty(\"coolness\", \"200%\")\n                .WithProperty(\"a\", \"not b\")\n                .Debug(\"This is a test message '{0}'.\", DateTime.Now.Ticks);\n\n            //Assert\n            logFactory.AssertDebugLastMessageContains(nameof(AllEventWithFluent_with_callerInformation));\n            logFactory.AssertDebugLastMessageContains(nameof(AllEventPropertiesTests));\n        }"
      }
    ]
  },
  {
    "file": "AppDomainLayoutRendererTests.cs",
    "methods": [
      {
        "name": "AppDomainTest",
        "body": "{\n            //example: 0003: NLog.UnitTests\n            AssertLayoutRendererOutput(\"${appdomain}\", $\"{id:0000}:{friendlyname}\");\n        }"
      },
      {
        "name": "AppDomainShortFormatTest",
        "body": "{\n            //example: 03\n            AssertLayoutRendererOutput(\"${appdomain:format=short}\", $\"{id:00}\");\n        }"
      },
      {
        "name": "AppDomainTestLongFormatTest",
        "body": "{\n            //example: 0003: NLog.UnitTests\n            AssertLayoutRendererOutput(\"${appdomain:format=long}\", $\"{id:0000}:{friendlyname}\");\n        }"
      },
      {
        "name": "AppDomainTestFriendlyFormatTest",
        "body": "{\n            //example: NLog.UnitTests\n            AssertLayoutRendererOutput(\"${appdomain:format=friendly}\", $\"{friendlyname}\");\n        }"
      },
      {
        "name": "AppDomainCustomFormatTest",
        "body": "{\n            //example: 0003: NLog.UnitTests\n            AssertLayoutRendererOutput(\"${appdomain:format={1\\\\}{0\\\\}}\", string.Format(\"{1}{0}\", id, friendlyname));\n        }"
      }
    ]
  },
  {
    "file": "AppSettingTests.cs",
    "methods": [
      {
        "name": "UseAppSettingTest",
        "body": "{\n            var configurationManager = new MockConfigurationManager();\n            const string expected = \"appSettingTestValue\";\n            configurationManager.AppSettings[\"appSettingTestKey\"] = expected;\n            var appSettingLayoutRenderer = new AppSettingLayoutRenderer\n            {\n                ConfigurationManager = configurationManager,\n                Item = \"appSettingTestKey\",\n            };\n\n            var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            Assert.Equal(expected, rendered);\n        }"
      },
      {
        "name": "AppSettingOverridesDefaultTest",
        "body": "{\n            var configurationManager = new MockConfigurationManager();\n            const string expected = \"appSettingTestValue\";\n            configurationManager.AppSettings[\"appSettingTestKey\"] = expected;\n            var appSettingLayoutRenderer = new AppSettingLayoutRenderer\n            {\n                ConfigurationManager = configurationManager,\n                Item = \"appSettingTestKey\",\n                Default = \"UseDefault\",\n            };\n\n            var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            Assert.Equal(expected, rendered);\n        }"
      },
      {
        "name": "FallbackToDefaultTest",
        "body": "{\n            var configurationManager = new MockConfigurationManager();\n            const string expected = \"UseDefault\";\n            var appSettingLayoutRenderer = new AppSettingLayoutRenderer\n            {\n                ConfigurationManager = configurationManager,\n                Item = \"notFound\",\n                Default = \"UseDefault\",\n            };\n\n            var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            Assert.Equal(expected, rendered);\n        }"
      },
      {
        "name": "NoAppSettingTest",
        "body": "{\n            var configurationManager = new MockConfigurationManager();\n            var appSettingLayoutRenderer = new AppSettingLayoutRenderer\n            {\n                ConfigurationManager = configurationManager,\n                Item = \"notFound\",\n            };\n\n            var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            Assert.Equal(string.Empty, rendered);\n        }"
      },
      {
        "name": "UseConnectionStringTest",
        "body": "{\n            var configurationManager = new MockConfigurationManager();\n            const string expected = \"Hello Connection\";\n            configurationManager.ConnectionStrings[\"myConnection\"] = new ConnectionStringSettings() { ConnectionString = expected };\n            var appSettingLayoutRenderer = new AppSettingLayoutRenderer\n            {\n                ConfigurationManager = configurationManager,\n                Item = \"ConnectionStrings.myConnection\",\n            };\n\n            var rendered = appSettingLayoutRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            Assert.Equal(expected, rendered);\n        }"
      }
    ]
  },
  {
    "file": "AssemblyVersionTests.cs",
    "methods": [
      {
        "name": "EntryAssemblyVersionTest",
        "body": "{\n            var assembly = Assembly.GetEntryAssembly();\n            var assemblyVersion = assembly is null\n                ? $\"Could not find value for entry assembly and version type {nameof(AssemblyVersionType.Assembly)}\"\n                : assembly.GetName().Version.ToString();\n            AssertLayoutRendererOutput(\"${assembly-version}\", assemblyVersion);\n        }"
      },
      {
        "name": "EntryAssemblyVersionDefaultTest",
        "body": "{\n            var assembly = Assembly.GetEntryAssembly();\n            var assemblyVersion = assembly is null\n                ? \"1.2.3.4\"\n                : assembly.GetName().Version.ToString();\n            AssertLayoutRendererOutput(\"${assembly-version:default=1.2.3.4}\", assemblyVersion);\n        }"
      },
      {
        "name": "AssemblyNameVersionTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${assembly-version:NLogAutoLoadExtension}\", \"2.0.0.0\");\n        }"
      },
      {
        "name": "AssemblyNameUnknownVersionTest",
        "body": "{\n            using (new NoThrowNLogExceptions())\n                AssertLayoutRendererOutput(\"${assembly-version:FooBar:default=1.2.3.4}\", \"1.2.3.4\");\n        }"
      },
      {
        "name": "AssemblyNameVersionTypeTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${assembly-version:name=NLogAutoLoadExtension:type=assembly}\", \"2.0.0.0\");\n            AssertLayoutRendererOutput(\"${assembly-version:name=NLogAutoLoadExtension:type=file}\", \"2.0.0.1\");\n            AssertLayoutRendererOutput(\"${assembly-version:name=NLogAutoLoadExtension:type=informational}\", \"2.0.0.2\");\n        }"
      }
    ]
  },
  {
    "file": "BaseDirTests.cs",
    "methods": [
      {
        "name": "BaseDirTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${basedir}\", baseDir);\n        }"
      },
      {
        "name": "BaseDir_FixTempDir_NotRequired",
        "body": "{\n            AssertLayoutRendererOutput(\"${basedir:fixtempdir=true}\", baseDir);\n        }"
      },
      {
        "name": "BaseDirCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${basedir:dir=aaa}\", Path.Combine(baseDir, \"aaa\"));\n        }"
      },
      {
        "name": "BaseDirFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${basedir:file=aaa.txt}\", Path.Combine(baseDir, \"aaa.txt\"));\n        }"
      },
      {
        "name": "BaseDirCurrentProcessTest",
        "body": "{\n            Layout l = \"${basedir:processdir=true}\";\n            var dir = l.Render(LogEventInfo.CreateNullEvent());\n\n            Assert.NotNull(dir);\n            Assert.True(Directory.Exists(dir), $\"dir '{dir}' doesn't exists\");\n            Assert.Equal(Path.GetDirectoryName(CurrentProcessPath), dir);\n        }"
      },
      {
        "name": "BaseDirDirFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${basedir:dir=aaa:file=bbb.txt}\", Path.Combine(baseDir, \"aaa\", \"bbb.txt\"));\n        }"
      },
      {
        "name": "InjectBaseDirAndCheckConfigPathsTest",
        "body": "{\n            string fakeBaseDir = @\"y:\\root\\\";\n            var appEnvironment = new Mocks.AppEnvironmentMock(null, null);\n            appEnvironment.AppDomainBaseDirectory = fakeBaseDir;\n            var baseLayoutRenderer = new NLog.LayoutRenderers.BaseDirLayoutRenderer(appEnvironment);\n\n            // test1\n            Assert.Equal(fakeBaseDir, baseLayoutRenderer.Render(LogEventInfo.CreateNullEvent()));\n        }"
      },
      {
        "name": "BaseDir_FixTempDir_ChoosesProcessDir",
        "body": "{\n            var tempDir = System.IO.Path.GetTempPath();\n            var processPath = CurrentProcessPath;\n\n            var appEnvironment = new Mocks.AppEnvironmentMock(null, null);\n            appEnvironment.AppDomainBaseDirectory = tempDir;\n            appEnvironment.UserTempFilePath = tempDir;\n            appEnvironment.CurrentProcessFilePath = processPath;\n            var baseLayoutRenderer = new NLog.LayoutRenderers.BaseDirLayoutRenderer(appEnvironment);\n\n            // test1\n            Assert.Equal(tempDir, baseLayoutRenderer.Render(LogEventInfo.CreateNullEvent()));\n\n            // test2\n            baseLayoutRenderer.FixTempDir = true;\n            Assert.Equal(Path.GetDirectoryName(processPath), baseLayoutRenderer.Render(LogEventInfo.CreateNullEvent()));\n        }"
      }
    ]
  },
  {
    "file": "CallSiteFileNameLayoutTests.cs",
    "methods": [
      {
        "name": "ShowFileNameOnlyTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=False}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            logger.Debug(\"msg\");\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            var lastMessageArray = lastMessage.Split('|');\n            Assert.Equal(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);\n            Assert.Equal(\"msg\", lastMessageArray[1]);\n        }"
      },
      {
        "name": "CallSiteFileNameNoCaptureStackTraceTest",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-filename:captureStackTrace=False}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            // Act\n            logFactory.GetLogger(\"A\").Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\"|msg\");\n        }"
      },
      {
        "name": "CallSiteFileNameNoCaptureStackTraceWithStackTraceTest",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-filename:captureStackTrace=False}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            // Act\n            var logEvent = new LogEventInfo(LogLevel.Info, null, \"msg\");\n            logEvent.SetStackTrace(new System.Diagnostics.StackTrace(true), 0);\n            logFactory.GetLogger(\"A\").Log(logEvent);\n\n            // Assert\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            var lastMessageArray = lastMessage.Split('|');\n            Assert.Contains(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);\n            Assert.Equal(\"msg\", lastMessageArray[1]);\n        }"
      },
      {
        "name": "ShowFullPathTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=True}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            logger.Debug(\"msg\");\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            var lastMessageArray = lastMessage.Split('|');\n            Assert.Contains(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);\n            Assert.False(lastMessageArray[0].StartsWith(\"CallSiteFileNameLayoutTests.cs\"));\n            Assert.True(Path.IsPathRooted(lastMessageArray[0]));\n            Assert.Equal(\"msg\", lastMessageArray[1]);\n        }"
      },
      {
        "name": "ShowFileNameOnlyAsyncTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=False}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            AsyncMethod(logFactory).Wait();\n\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            var lastMessageArray = lastMessage.Split('|');\n            Assert.Equal(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);\n            Assert.Equal(\"msg\", lastMessageArray[1]);\n        }"
      },
      {
        "name": "ShowFullPathAsyncTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-filename:includeSourcePath=True}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            AsyncMethod(logFactory).Wait();\n\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            var lastMessageArray = lastMessage.Split('|');\n            Assert.Contains(\"CallSiteFileNameLayoutTests.cs\", lastMessageArray[0]);\n            Assert.False(lastMessageArray[0].StartsWith(\"CallSiteFileNameLayoutTests.cs\"));\n            Assert.True(Path.IsPathRooted(lastMessageArray[0]));\n            Assert.Equal(\"msg\", lastMessageArray[1]);\n        }"
      }
    ]
  },
  {
    "file": "CallSiteLineNumberTests.cs",
    "methods": [
      {
        "name": "LineNumberOnlyTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${callsite-linenumber} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n#if DEBUG\n#line 100000\n#endif\n            logger.Debug(\"msg\");\n            var linenumber = GetPrevLineNumber();\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            // There's a difference in handling line numbers between .NET and Mono\n            // We're just interested in checking if it's above 100000\n            Assert.StartsWith(linenumber.ToString(), lastMessage);  // Expect prefix of 10000\n#if DEBUG\n#line default\n#endif\n        }"
      },
      {
        "name": "LineNumberOnlyAsyncTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n        <nlog>\n            <targets><target name='debug' type='Debug' layout='${callsite-linenumber}' /></targets>\n            <rules>\n                <logger name='*' minlevel='Debug' writeTo='debug' />\n            </rules>\n        </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            Func<string> getLastMessage = () => GetDebugLastMessage(\"debug\", logFactory);\n            logger.Debug(\"msg\");\n            var lastMessage = getLastMessage();\n            Assert.NotEqual(0, int.Parse(lastMessage));\n            WriteMessages(logger, getLastMessage).Wait();\n        }"
      },
      {
        "name": "LineNumberNoCaptureStackTraceTest",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n        <nlog>\n            <targets><target name='debug' type='Debug' layout='${callsite-linenumber:captureStackTrace=false} ${message}' /></targets>\n            <rules>\n                <logger name='*' minlevel='Debug' writeTo='debug' />\n            </rules>\n        </nlog>\").LogFactory;\n\n            // Act\n            logFactory.GetLogger(\"A\").Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\" msg\");\n        }"
      },
      {
        "name": "LineNumberNoCaptureStackTraceWithStackTraceTest",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n        <nlog>\n            <targets><target name='debug' type='Debug' layout='${callsite-linenumber:captureStackTrace=false} ${message}' /></targets>\n            <rules>\n                <logger name='*' minlevel='Debug' writeTo='debug' />\n            </rules>\n        </nlog>\").LogFactory;\n\n            // Act\n            var logEvent = new LogEventInfo(LogLevel.Info, null, \"msg\");\n            logEvent.SetStackTrace(new System.Diagnostics.StackTrace(true), 0);\n            logFactory.GetLogger(\"A\").Log(logEvent);\n\n            // Assert\n            logFactory.AssertDebugLastMessageContains(\" msg\");\n            Assert.NotEqual(\" msg\", GetDebugLastMessage(\"debug\", logFactory));\n        }"
      }
    ]
  },
  {
    "file": "CounterTests.cs",
    "methods": [
      {
        "name": "DefaultCounterTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${counter} ${counter}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logger.Info(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 1 1\");\n            logger.Warn(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 2 2\");\n            logger.Error(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 3 3\");\n            logger.Fatal(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 4 4\");\n        }"
      },
      {
        "name": "LayoutCounterTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n\n                <targets><target name='debug' type='Debug' layout='${message} ${counter:sequence=${event-context:item=context1}} ${counter}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n\n            logger.WithProperty(\"context1\", \"seq1\").Info(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 1 1\");\n            logger.WithProperty(\"context1\", \"seq1\").Info(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 2 2\");\n            logger.WithProperty(\"context1\", \"seq2\").Info(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 1 3\");\n            logger.WithProperty(\"context1\", \"seq1\").Info(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 3 4\");\n        }"
      },
      {
        "name": "PresetCounterTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${counter:value=1:increment=3} ${counter}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logger.Info(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 1 1\");\n            logger.Warn(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 4 2\");\n            logger.Error(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 7 3\");\n            logger.Fatal(\"a\");\n            AssertDebugLastMessage(\"debug\", \"a 10 4\");\n        }"
      },
      {
        "name": "NamedCounterTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets>\n                    <target name='debug1' type='Debug' layout='${message} ${counter:sequence=aaa}' />\n                    <target name='debug2' type='Debug' layout='${message} ${counter:sequence=bbb}' />\n                    <target name='debug3' type='Debug' layout='${message} ${counter:sequence=aaa}' />\n                </targets>\n                <rules>\n                    <logger name='debug1' minlevel='Debug' writeTo='debug1' />\n                    <logger name='debug2' minlevel='Debug' writeTo='debug2' />\n                    <logger name='debug3' minlevel='Debug' writeTo='debug3' />\n                </rules>\n            </nlog>\");\n\n            LogManager.GetLogger(\"debug1\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug1\", \"a 1\");\n            LogManager.GetLogger(\"debug2\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug2\", \"a 1\");\n            LogManager.GetLogger(\"debug3\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug3\", \"a 2\");\n        }"
      },
      {
        "name": "CounterRawValueTest",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${counter}\";\n\n            // Act\n            var success1 = l.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var value1);\n            var success2 = l.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var value2);\n\n            // Assert\n            Assert.True(success1, \"success1\");\n            Assert.True(success2, \"success2\");\n            Assert.IsType<long>(value1);\n            Assert.IsType<long>(value2);\n            Assert.Equal(1L, value1);\n            Assert.Equal(2L, value2);\n        }"
      }
    ]
  },
  {
    "file": "CurrentDirTests.cs",
    "methods": [
      {
        "name": "CurrentDirTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${currentdir}\", _currentDir);\n        }"
      },
      {
        "name": "CurrentDirCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${currentdir:dir=aaa}\", Path.Combine(_currentDir, \"aaa\"));\n        }"
      },
      {
        "name": "CurrentDirFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${currentdir:file=aaa.txt}\", Path.Combine(_currentDir, \"aaa.txt\"));\n        }"
      },
      {
        "name": "CurrentDirDirFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${currentdir:dir=aaa:file=bbb.txt}\", Path.Combine(_currentDir, \"aaa\", \"bbb.txt\"));\n        }"
      }
    ]
  },
  {
    "file": "DateTests.cs",
    "methods": [
      {
        "name": "DefaultDateTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${date}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            logFactory.GetLogger(\"d\").Debug(ei);\n            DateTime dt = DateTime.ParseExact(GetDebugLastMessage(\"debug\", logFactory), \"yyyy/MM/dd HH:mm:ss.fff\", CultureInfo.InvariantCulture);\n            DateTime now = ei.TimeStamp;\n\n            Assert.True(Math.Abs((dt - now).TotalSeconds) < 1);\n        }"
      },
      {
        "name": "TimeZoneTest",
        "body": "{\n            var dateLayoutRenderer = new DateLayoutRenderer();\n\n            dateLayoutRenderer.Format = \"yyyy-MM-ddTHH:mmK\";\n\n            var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            var result = dateLayoutRenderer.Render(logEvent);\n\n            var offset = TimeZoneInfo.Local;\n            var offset2 = offset.GetUtcOffset(DateTime.Now);\n\n            if (offset2 >= new TimeSpan(0))\n            {\n                //+00:00, +01:00 etc\n                Assert.Contains($\"+{offset2.Hours:D2}:{offset2.Minutes:D2}\", result);\n            }\n            else\n            {\n                //-01:00, etc\n                Assert.Contains($\"{offset2.Hours:D2}:{offset2.Minutes:D2}\", result);\n            }\n        }"
      },
      {
        "name": "DateFormatExplicitTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${date:format=yyyy-MM-dd}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.GetLogger(\"d\").Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(DateTime.Now.ToString(\"yyyy-MM-dd\"));\n        }"
      },
      {
        "name": "DateFormatDefaultTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${date:\\thh\\:mm\\:ss:UniversalTime=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var dateTimeUtc = DateTime.UtcNow;\n            logFactory.GetLogger(\"d\").Log(new LogEventInfo(LogLevel.Info, null, \"Hello\") { TimeStamp = dateTimeUtc });\n            logFactory.AssertDebugLastMessage(dateTimeUtc.ToString(\"\\thh:mm:ss\", CultureInfo.InvariantCulture));\n        }"
      },
      {
        "name": "DateFormatInvalidTest",
        "body": "{\n            Assert.Throws<NLogConfigurationException>(() =>\n            {\n                new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                    <nlog throwConfigExceptions='true'>\n                        <variable name='logDate' value='${date:format=hh:mm}' />\n                    </nlog>\");\n            });\n        }"
      }
    ]
  },
  {
    "file": "DbNullLayoutRendererTests.cs",
    "methods": [
      {
        "name": "TryGetRawValue_emptyEvent_shouldReturnDbNull",
        "body": "{\n            // Arrange\n            var renderer = new DbNullLayoutRenderer();\n            IRawValue rawValueGetter = renderer;\n\n            // Act\n            var result = rawValueGetter.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var resultValue);\n\n            // Assert\n            Assert.Equal(DBNull.Value, resultValue);\n            Assert.True(result);\n        }"
      }
    ]
  },
  {
    "file": "DirectorySeparatorLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderTest1",
        "body": "{\n            // Arrange\n            var renderer = new DirectorySeparatorLayoutRenderer();\n            var expected = Path.DirectorySeparatorChar.ToString();\n\n            // Act\n            var result = renderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "GetRawValueTest1",
        "body": "{\n            // Arrange\n            IRawValue renderer = new DirectorySeparatorLayoutRenderer();\n            var expected = Path.DirectorySeparatorChar;\n\n            // Act\n            var returnResult = renderer.TryGetRawValue(LogEventInfo.CreateNullEvent(), out var result);\n\n            // Assert\n            Assert.True(returnResult);\n            Assert.Equal(expected, result);\n        }"
      }
    ]
  },
  {
    "file": "EnvironmentTests.cs",
    "methods": [
      {
        "name": "EnvironmentTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${environment:variable=PATH}\", Environment.GetEnvironmentVariable(\"PATH\"));\n        }"
      },
      {
        "name": "EnvironmentSimpleTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${environment:PATH}\", Environment.GetEnvironmentVariable(\"PATH\"));\n        }"
      },
      {
        "name": "Environment_WhenVariableIsLayout_ShouldBeWrittenAsLayout",
        "body": "{\n            Environment.SetEnvironmentVariable(\"NLOGTEST\", \"${level}\");\n            AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST}\", \"Info\");\n            AssertLayoutRendererOutput(\"${environment:NLOGTEST}\", \"Info\");\n        }"
      },
      {
        "name": "Environment_WhenVariableExists_DoNothing",
        "body": "{\n            Environment.SetEnvironmentVariable(\"NLOGTEST\", \"ABC1234\");\n            // Test default value with different variations on variable parameter syntax.\n            AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST:default=5678}\", \"ABC1234\");\n            AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=5678}\", \"ABC1234\");\n        }"
      },
      {
        "name": "Environment_empty",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                AssertLayoutRendererOutput(\"${environment}\", \"\");\n                AssertLayoutRendererOutput(\"${environment:noDefault}\", \"\");\n            }\n        }"
      },
      {
        "name": "Environment_WhenVariableIsLayoutAndExists_DoNothing",
        "body": "{\n            Environment.SetEnvironmentVariable(\"NLOGTEST\", \"${level}\");\n            AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=5678}\", \"Info\");\n        }"
      },
      {
        "name": "Environment_WhenVariableDoesNotExists_UseDefault",
        "body": "{\n            if (Environment.GetEnvironmentVariable(\"NLOGTEST\") != null)\n            {\n                Environment.SetEnvironmentVariable(\"NLOGTEST\", null);\n            }\n\n            // Test default value with different variations on variable parameter syntax.\n            AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST:default=1234}\", \"1234\");\n            AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=5678}\", \"5678\");\n        }"
      },
      {
        "name": "Environment_WhenDefaultEmpty_EmptyString",
        "body": "{\n            if (Environment.GetEnvironmentVariable(\"NLOGTEST\") != null)\n            {\n                Environment.SetEnvironmentVariable(\"NLOGTEST\", null);\n            }\n\n            // Test default value with different variations on variable parameter syntax.\n            AssertLayoutRendererOutput(\"${environment:variable=NLOGTEST:default=}\", \"\");\n            AssertLayoutRendererOutput(\"${environment:NLOGTEST:default=}\", \"\");\n        }"
      }
    ]
  },
  {
    "file": "EnvironmentUserLayoutRendererTests.cs",
    "methods": [
      {
        "name": "EnvironmentUserTest",
        "body": "{\n            var userName = Environment.GetEnvironmentVariable(\"USERNAME\");\n            if (string.IsNullOrEmpty(userName))\n                userName = Environment.GetEnvironmentVariable(\"USER\") ?? string.Empty;\n\n            Layout layout = \"${environment-user}\";\n            var result = layout.Render(LogEventInfo.CreateNullEvent());\n            if (!string.IsNullOrEmpty(userName))\n            {\n                Assert.Equal(userName, result);\n\n                var userDomainName = Environment.GetEnvironmentVariable(\"USERDOMAIN\") ?? string.Empty;\n                if (!string.IsNullOrEmpty(userDomainName))\n                {\n                    layout = \"${environment-user:domain=true}\";\n                    result = layout.Render(LogEventInfo.CreateNullEvent());\n                    Assert.Equal(userDomainName + \"\\\\\" + userName, result);\n                }\n            }\n        }"
      }
    ]
  },
  {
    "file": "EventContextTests.cs",
    "methods": [
      {
        "name": "Test1",
        "body": "{\n            Layout l = \"${event-context:aaa}\";\n            LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");\n\n            // empty\n            Assert.Equal(\"\", l.Render(lei));\n        }"
      },
      {
        "name": "Test2",
        "body": "{\n            Layout l = \"${event-context:aaa}\";\n            LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");\n            lei.Properties[\"aaa\"] = \"bbb\";\n\n            // empty\n            Assert.Equal(\"bbb\", l.Render(lei));\n        }"
      }
    ]
  },
  {
    "file": "EventPropertiesTests.cs",
    "methods": [
      {
        "name": "TestNoProperty",
        "body": "{\n            Layout layout = \"${event-properties:prop1}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"prop1\", \"bbb\");\n            // empty\n            Assert.Equal(\"\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "TestProperty",
        "body": "{\n            Layout layout = \"${event-properties:prop1}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = \"bbb\";\n\n            Assert.Equal(\"bbb\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "TestPropertyAlias",
        "body": "{\n            Layout layout = \"${event-property:prop1}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = \"bbb\";\n\n            Assert.Equal(\"bbb\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "TestNullProperty",
        "body": "{\n            Layout layout = \"${event-properties:prop1}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = null;\n\n            // empty\n            Assert.Equal(\"\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "TestPropertyIgnoreCase",
        "body": "{\n            Layout layout1 = \"${event-property:prop1}\";\n            Layout layout2 = \"${event-property:Prop1}\";\n            Layout layout3 = \"${event-property:PROP1}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"PROP1\"] = \"bbb\";\n\n            Assert.Equal(\"bbb\", layout1.Render(logEvent));\n            Assert.Equal(\"bbb\", layout2.Render(logEvent));\n            Assert.Equal(\"bbb\", layout3.Render(logEvent));\n        }"
      },
      {
        "name": "TestPropertyCaseSensitive",
        "body": "{\n            Layout layout1 = \"${event-property:prop1:ignoreCase=false}\";\n            Layout layout2 = \"${event-property:Prop1:ignoreCase=false}\";\n            Layout layout3 = \"${event-property:PROP1:ignoreCase=false}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"Prop1\"] = \"aaa\";\n            logEvent.Properties[\"PROP1\"] = \"bbb\";\n\n            Assert.Equal(2, logEvent.Properties.Count);\n            Assert.Equal(\"aaa\", logEvent.Properties[\"Prop1\"]);\n            Assert.Equal(\"bbb\", logEvent.Properties[\"PROP1\"]);\n            Assert.Equal(\"\", layout1.Render(logEvent));\n            Assert.Equal(\"aaa\", layout2.Render(logEvent));\n            Assert.Equal(\"bbb\", layout3.Render(logEvent));\n        }"
      },
      {
        "name": "DateTime",
        "body": "{\n            Layout layout = \"${event-properties:prop1}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = new DateTime(2020, 2, 21, 23, 1, 0);\n\n            Assert.Equal(\"02/21/2020 23:01:00\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "DateTimeFormat",
        "body": "{\n            Layout layout = \"${event-properties:prop1:format=yyyy-M-dd}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = new DateTime(2020, 2, 21, 23, 1, 0);\n\n            Assert.Equal(\"2020-2-21\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "DateTimeCulture",
        "body": "{\n            if (IsLinux())\n            {\n                Console.WriteLine(\"[SKIP] EventPropertiesTests.DateTimeCulture because we are running in Travis\");\n                return;\n            }\n\n            Layout layout = \"${event-properties:prop1:culture=nl-NL}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = new DateTime(2020, 11, 21, 23, 1, 0);\n\n            Assert.Equal(\"21-11-2020 23:01:00\", layout.Render(logEvent));\n        }"
      },
      {
        "name": "JsonFormat",
        "body": "{\n            Layout layout = \"${event-properties:prop1:format=@}\";\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message1\");\n            logEvent.Properties[\"prop1\"] = new string[] { \"Hello\", \"World\" };\n            Assert.Equal(\"[\\\"Hello\\\",\\\"World\\\"]\", layout.Render(logEvent));\n        }"
      }
    ]
  },
  {
    "file": "ExceptionDataLayoutRendererTests.cs",
    "methods": [
      {
        "name": "ExceptionWithDataItemIsLoggedTest",
        "body": "{\n            const string exceptionMessage = \"Test exception\";\n            const string exceptionDataKey = \"testkey\";\n            const string exceptionDataValue = \"testvalue\";\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:\" + exceptionDataKey + @\"}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n            Exception ex = new ArgumentException(exceptionMessage);\n            ex.Data.Add(exceptionDataKey, exceptionDataValue);\n\n            logFactory.GetCurrentClassLogger().Error(ex, \"msg\");\n\n            logFactory.AssertDebugLastMessage(\"debug\", exceptionDataValue);\n        }"
      },
      {
        "name": "ExceptionWithOutDataIsNotLoggedTest",
        "body": "{\n            const string exceptionMessage = \"Test exception\";\n            const string exceptionDataKey = \"testkey\";\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:\" + exceptionDataKey + @\"}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            Exception ex = new ArgumentException(exceptionMessage);\n            logFactory.GetCurrentClassLogger().Error(ex, \"msg\");\n\n            logFactory.AssertDebugLastMessage(\"\");\n        }"
      },
      {
        "name": "ExceptionUsingSpecifiedParamLogsProperlyTest",
        "body": "{\n            const string exceptionMessage = \"I don't like nullref exception!\";\n            const string exceptionDataKey = \"testkey\";\n            const string exceptionDataValue = \"testvalue\";\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:item=\" + exceptionDataKey + @\"}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            Exception ex = new ArgumentException(exceptionMessage);\n            ex.Data.Add(exceptionDataKey, exceptionDataValue);\n            logFactory.GetCurrentClassLogger().Error(ex);\n            logFactory.AssertDebugLastMessage(exceptionDataValue);\n        }"
      },
      {
        "name": "BadDataForItemResultsInEmptyValueTest",
        "body": "{\n            const string exceptionMessage = \"I don't like nullref exception!\";\n            const string exceptionDataKey = \"testkey\";\n            const string exceptionDataValue = \"testvalue\";\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:item=@}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            Exception ex = new ArgumentException(exceptionMessage);\n            ex.Data.Add(exceptionDataKey, exceptionDataValue);\n            logFactory.GetCurrentClassLogger().Error(ex);\n            logFactory.AssertDebugLastMessage(\"\");\n        }"
      },
      {
        "name": "NoDatkeyTest",
        "body": "{\n            const string exceptionMessage = \"I don't like nullref exception!\";\n            const string exceptionDataKey = \"testkey\";\n            const string exceptionDataValue = \"testvalue\";\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            Exception ex = new ArgumentException(exceptionMessage);\n            ex.Data.Add(exceptionDataKey, exceptionDataValue);\n            logFactory.GetCurrentClassLogger().Error(ex);\n            logFactory.AssertDebugLastMessage(\"\");\n        }"
      },
      {
        "name": "NoDatkeyUingParamTest",
        "body": "{\n            const string exceptionMessage = \"I don't like nullref exception!\";\n            const string exceptionDataKey = \"testkey\";\n            const string exceptionDataValue = \"testvalue\";\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:item=}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            Exception ex = new ArgumentException(exceptionMessage);\n            ex.Data.Add(exceptionDataKey, exceptionDataValue);\n            logFactory.GetCurrentClassLogger().Error(ex);\n            logFactory.AssertDebugLastMessage(\"\");\n        }"
      },
      {
        "name": "BaseExceptionFlippedTest",
        "body": "{\n            const string exceptionDataKey = \"testkey\";\n            const string exceptionDataValue = \"testvalue\";\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <target name='debug' type='Debug' layout='${exceptiondata:item=\" + exceptionDataKey + @\":BaseException=true}' />\n                </targets>\n                <rules>\n                    <logger minlevel='Info' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            Exception exceptionToTest;\n            try\n            {\n                try\n                {\n                    try\n                    {\n                        var except = new ArgumentException(\"Inner Exception\");\n                        except.Data[exceptionDataKey] = exceptionDataValue;\n                        throw except;\n                    }\n                    catch (Exception exception)\n                    {\n                        throw new System.ArgumentException(\"Wrapper1\", exception);\n                    }\n                }\n                catch (Exception exception)\n                {\n                    throw new ApplicationException(\"Wrapper2\", exception);\n                }\n            }\n            catch (Exception ex)\n            {\n                exceptionToTest = ex;\n            }\n\n            logFactory.GetCurrentClassLogger().Fatal(exceptionToTest, \"msg\");\n\n            logFactory.AssertDebugLastMessage(exceptionDataValue);\n        }"
      }
    ]
  },
  {
    "file": "FileContentsTests.cs",
    "methods": [
      {
        "name": "FileContentUnicodeTest",
        "body": "{\n            string content = \"12345\";\n            string fileName = Guid.NewGuid().ToString(\"N\") + \".txt\";\n            using (StreamWriter sw = new StreamWriter(fileName, false, Encoding.Unicode))\n            {\n                sw.Write(content);\n            }\n\n            AssertLayoutRendererOutput(\"${file-contents:\" + fileName + \":encoding=utf-16}\", content);\n\n            File.Delete(fileName);\n        }"
      },
      {
        "name": "FileContentUTF8Test",
        "body": "{\n            string content = \"12345\";\n            string fileName = Guid.NewGuid().ToString(\"N\") + \".txt\";\n            using (StreamWriter sw = new StreamWriter(fileName, false, Encoding.UTF8))\n            {\n                sw.Write(content);\n            }\n\n            AssertLayoutRendererOutput(\"${file-contents:\" + fileName + \":encoding=utf-8}\", content);\n\n            File.Delete(fileName);\n        }"
      },
      {
        "name": "FileContentTest2",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                AssertLayoutRendererOutput(\"${file-contents:nosuchfile.txt}\", string.Empty);\n            }\n        }"
      }
    ]
  },
  {
    "file": "FuncLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RegisterCustomFuncLayoutRendererTest",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().SetupExtensions(ext => ext.RegisterLayoutRenderer<MyFuncLayoutRenderer>(\"the-answer-new\"))\n                .LoadConfigurationFromXml(@\"<nlog throwExceptions='true'>\n                <targets>\n                    <target name='debug' type='Debug' layout= 'TheAnswer=${the-answer-new:Format=D3}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            // Act\n            var logger = logFactory.GetCurrentClassLogger();\n            logger.Debug(\"test1\");\n\n            // Assert\n            AssertDebugLastMessage(\"debug\", \"TheAnswer=042\", logFactory);\n        }"
      },
      {
        "name": "RegisterCustomFuncLayoutRendererTestOldStyle",
        "body": "{\n            // Arrange\n            var funcLayoutRenderer = new MyFuncLayoutRenderer(\"the-answer-new\");\n\n            // Act\n            var logFactory = new LogFactory().Setup()\n                .SetupExtensions(ext => ext.RegisterLayoutRenderer(funcLayoutRenderer))\n                .LoadConfigurationFromXml(@\"<nlog throwExceptions='true'>\n                <targets>\n                    <target name='debug' type='Debug' layout= 'TheAnswer=${the-answer-new:Format=D3}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetCurrentClassLogger();\n            logger.Debug(\"test1\");\n\n            // Assert\n            AssertDebugLastMessage(\"debug\", \"TheAnswer=042\", logFactory);\n        }"
      }
    ]
  },
  {
    "file": "GDCTests.cs",
    "methods": [
      {
        "name": "GDCTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${gdc:item=myitem} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            GlobalDiagnosticsContext.Set(\"myitem\", \"myvalue\");\n            LogManager.GetLogger(\"A\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug\", \"myvalue a\");\n\n            GlobalDiagnosticsContext.Set(\"myitem\", \"value2\");\n            LogManager.GetLogger(\"A\").Debug(\"b\");\n            AssertDebugLastMessage(\"debug\", \"value2 b\");\n\n            GlobalDiagnosticsContext.Remove(\"myitem\");\n            LogManager.GetLogger(\"A\").Debug(\"c\");\n            AssertDebugLastMessage(\"debug\", \" c\");\n        }"
      },
      {
        "name": "GDCFormatTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${gdc:item=appid:format=@} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            GlobalDiagnosticsContext.Clear();\n            GlobalDiagnosticsContext.Set(\"appid\", new { AppId = 123 });\n            LogManager.GetLogger(\"A\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug\", \"{\\\"AppId\\\":123} a\");\n        }"
      },
      {
        "name": "GDCIgnoreCaseTest",
        "body": "{\n            try\n            {\n                string expectedValue = \"Hello\";\n                GlobalDiagnosticsContext.Clear();\n\n                // Act\n                GlobalDiagnosticsContext.Set(nameof(GDCIgnoreCaseTest), expectedValue);\n\n                // Assert\n                Assert.Equal(expectedValue, GlobalDiagnosticsContext.Get(nameof(GDCIgnoreCaseTest)));\n                Assert.Equal(expectedValue, GlobalDiagnosticsContext.Get(nameof(GDCIgnoreCaseTest).ToLower()));\n            }\n            finally\n            {\n                GlobalDiagnosticsContext.Clear();\n            }\n        }"
      }
    ]
  },
  {
    "file": "GuidLayoutRendererTest.cs",
    "methods": [
      {
        "name": "GuidTest",
        "body": "{\n            GuidLayoutRenderer layoutRenderer = new GuidLayoutRenderer();\n            LogEventInfo logEvent = LogEventInfo.CreateNullEvent();\n            string newGuid1 = layoutRenderer.Render(logEvent);\n            string newGuid2 = layoutRenderer.Render(logEvent);\n            Assert.NotEmpty(newGuid1);\n            Assert.NotEmpty(newGuid2);\n            Assert.NotEqual(newGuid1, newGuid2);\n        }"
      },
      {
        "name": "LogEventGuidTest",
        "body": "{\n            GuidLayoutRenderer layoutRenderer = new GuidLayoutRenderer() { GeneratedFromLogEvent = true };\n            LogEventInfo logEvent1 = LogEventInfo.CreateNullEvent();\n            string newGuid11 = layoutRenderer.Render(logEvent1);\n            string newGuid12 = layoutRenderer.Render(logEvent1);\n            Assert.NotEmpty(newGuid11);\n            Assert.NotEmpty(newGuid12);\n            Assert.Equal(newGuid11, newGuid12);\n            LogEventInfo logEvent2 = LogEventInfo.CreateNullEvent();\n            string newGuid21 = layoutRenderer.Render(logEvent2);\n            string newGuid22 = layoutRenderer.Render(logEvent2);\n            Assert.NotEmpty(newGuid21);\n            Assert.NotEmpty(newGuid22);\n            Assert.Equal(newGuid21, newGuid22);\n            Assert.NotEqual(newGuid11, newGuid22);\n        }"
      }
    ]
  },
  {
    "file": "HostNameLayoutRendererTests.cs",
    "methods": [
      {
        "name": "HostNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${hostname} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            // Get the actual hostname that the code would use\n            string h = Environment.GetEnvironmentVariable(\"HOSTNAME\")\n                ?? System.Net.Dns.GetHostName()\n                ?? Environment.GetEnvironmentVariable(\"COMPUTERNAME\");\n            logFactory.GetLogger(\"A\").Debug(\"a log message\");\n            logFactory.AssertDebugLastMessage(h + \" a log message\");\n        }"
      }
    ]
  },
  {
    "file": "IdentityTests.cs",
    "methods": [
      {
        "name": "IdentityTest1Async",
        "body": "{\n            var oldPrincipal = Thread.CurrentPrincipal;\n\n            try\n            {\n                var logFactory = new LogFactory().Setup()\n                    .SetupExtensions(ext => ext.RegisterTarget<CSharpEventTarget>(\"CSharpEventTarget\"))\n                    .LoadConfigurationFromXml(@\"<?xml version='1.0' encoding='utf-8' ?>\n<nlog xmlns='http://www.nlog-project.org/schemas/NLog.xsd'\n      xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n      internalLogLevel='Debug'\n      throwExceptions='true' >\n\n  <targets async='true'>\n    <target name='target1' xsi:type='CSharpEventTarget' layout='${identity}' />\n  </targets>\n\n  <rules>\n    <logger name='*' writeTo='target1' />\n  </rules>\n</nlog>\n\").LogFactory;\n\n                try\n                {\n                    var continuationHit = new ManualResetEvent(false);\n                    string rendered = null;\n                    var threadId = CurrentManagedThreadId;\n                    var asyncThreadId = threadId;\n                    LogEventInfo lastLogEvent = null;\n\n                    var asyncTarget = logFactory.Configuration.FindTargetByName<AsyncTargetWrapper>(\"target1\");\n                    Assert.NotNull(asyncTarget);\n                    var target = asyncTarget.WrappedTarget as CSharpEventTarget;\n                    Assert.NotNull(target);\n                    target.BeforeWrite += (logevent, rendered1, asyncThreadId1) =>\n                    {\n                        //clear in current thread before write\n                        Thread.CurrentPrincipal = new GenericPrincipal(new GenericIdentity(\"ANOTHER user\", \"type\"), null);\n                    };\n\n                    target.EventWritten += (logevent, rendered1, asyncThreadId1) =>\n                    {\n                        rendered = rendered1;\n                        asyncThreadId = asyncThreadId1;\n                        lastLogEvent = logevent;\n                        continuationHit.Set();\n                    };\n\n                    Thread.CurrentPrincipal = new GenericPrincipal(new GenericIdentity(\"SOMEDOMAIN\\\\SomeUser\", \"CustomAuth\"), new[] { \"Role1\", \"Role2\" });\n\n                    var logger = logFactory.GetCurrentClassLogger();\n                    logger.Debug(\"test write\");\n\n                    Assert.True(continuationHit.WaitOne());\n                    Assert.NotNull(lastLogEvent);\n                    //should be written in another thread.\n                    Assert.NotEqual(threadId, asyncThreadId);\n\n                    Assert.Equal(\"auth:CustomAuth:SOMEDOMAIN\\\\SomeUser\", rendered);\n                }\n                finally\n                {\n                    logFactory.Shutdown();\n                }\n            }\n            finally\n            {\n                InternalLogger.Reset();\n                Thread.CurrentPrincipal = oldPrincipal;\n            }\n        }"
      },
      {
        "name": "IdentityTest2",
        "body": "{\n            var oldPrincipal = Thread.CurrentPrincipal;\n\n            Thread.CurrentPrincipal = new GenericPrincipal(new NotAuthenticatedIdentity(), new[] { \"role1\" });\n            try\n            {\n                var logFactory = new LogFactory().Setup()\n                    .LoadConfigurationFromXml(@\"\n                    <nlog>\n                        <targets><target type='debug' name='debug' layout='${identity}' /></targets>\n                        <rules><logger name='*' writeTo='debug' /></rules>\n                    </nlog>\").LogFactory;\n\n                var debugTarget = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n                logFactory.GetCurrentClassLogger().Info(\"Test Message\");\n                Assert.Equal(1, debugTarget.Counter);\n                Assert.Equal(\"notauth::\", debugTarget.LastMessage);\n            }\n            finally\n            {\n                Thread.CurrentPrincipal = oldPrincipal;\n            }\n        }"
      }
    ]
  },
  {
    "file": "LiteralTests.cs",
    "methods": [
      {
        "name": "LiteralTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='abcd' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"abcd\");\n        }"
      },
      {
        "name": "LiteralExplicitTextTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${literal:text=a\\=\\:\\}b\\t\\nc\\u003ad}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a=:}b\\t\\nc:d\");\n        }"
      },
      {
        "name": "LiteralDefaultTextTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${literal:a\\=\\:\\}b\\t\\nc\\u003ad}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a=:}b\\t\\nc:d\");\n        }"
      }
    ]
  },
  {
    "file": "LocalIpAddressLayoutRendererTests.cs",
    "methods": [
      {
        "name": "LocalIpAddress_CurrentMachine_NotEmpty",
        "body": "{\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer();\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n            Assert.NotEmpty(result);\n        }"
      },
      {
        "name": "LocalIpAddress_RendersSuccessfulIp",
        "body": "{\n            // Arrange\n            var ipString = \"10.0.1.2\";\n\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1)\n                .WithIp(ipString)\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(ipString, result);\n        }"
      },
      {
        "name": "LocalIpAddress_OneInterfaceWithMultipleIps_RendersFirstIp",
        "body": "{\n            // Arrange\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1)\n                .WithIp(\"10.0.1.1\")\n                .WithIp(\"10.0.1.2\")\n                .WithIp(\"10.0.1.3\")\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(\"10.0.1.1\", result);\n        }"
      },
      {
        "name": "LocalIpAddress_SkipsLoopback",
        "body": "{\n            // Arrange\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Loopback, \"F0-E0-D2-C3-B4-A5\")\n                .WithIp(\"1.2.3.4\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1)\n                .WithIp(\"10.0.1.2\")\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(\"10.0.1.2\", result);\n        }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirst",
        "body": "{\n            // Arrange\n\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\")\n                .WithIp(\"10.0.1.1\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1)\n                .WithIp(\"10.0.1.2\")\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(\"10.0.1.1\", result);\n        }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstUp",
        "body": "{\n            // Arrange\n\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\", OperationalStatus.Dormant)\n                .WithIp(\"10.0.1.1\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Up)\n                .WithIp(\"10.0.1.2\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Down)\n                .WithIp(\"10.0.1.3\", \"10.0.1.0\")\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(\"10.0.1.2\", result);\n        }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstWithGatewayUp",
        "body": "{\n            // Arrange\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\", OperationalStatus.Dormant)\n                .WithIp(\"10.0.1.1\", \"10.0.1.0\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Up)\n                .WithIp(\"10.0.1.2\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1, OperationalStatus.Up)\n                .WithIp(\"10.0.1.3\", \"10.0.1.0\")\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(\"10.0.1.3\", result);\n        }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstIpv4",
        "body": "{\n            // Arrange\n            var ipString = \"10.0.1.2\";\n\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\")\n                .WithIp(\"fe80:0:0:0:200:f8ff:fe21:67cf\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1)\n                .WithIp(ipString)\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(ipString, result);\n        }"
      },
      {
        "name": "LocalIpAddress_Multiple_TakesFirstIpv6IfRequested",
        "body": "{\n            // Arrange\n            var ipv6 = \"fe80::200:f8ff:fe21:67cf\";\n\n            var networkInterfaceRetrieverMock = new NetworkInterfaceRetrieverBuilder()\n                .WithInterface(NetworkInterfaceType.Ethernet, \"F0-E0-D2-C3-B4-A5\")\n                .WithIp(\"1.0.10.11\")\n                .WithInterface(NetworkInterfaceType.Ethernet, Mac1)\n                .WithIp(ipv6)\n                .Build();\n\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock)\n            { AddressFamily = AddressFamily.InterNetworkV6 };\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(ipv6, result);\n        }"
      },
      {
        "name": "LocalIpAddress_RetrieverThrowsException_RenderEmptyString",
        "body": "{\n            var networkInterfaceRetrieverMock = Substitute.For<INetworkInterfaceRetriever>();\n            networkInterfaceRetrieverMock.AllNetworkInterfaces.Throws(new Exception(\"oops\"));\n            var ipAddressRenderer = new LocalIpAddressLayoutRenderer(networkInterfaceRetrieverMock);\n\n            // Act\n            var result = ipAddressRenderer.Render(LogEventInfo.CreateNullEvent());\n\n            // Assert\n            Assert.Equal(string.Empty, result);\n        }"
      }
    ]
  },
  {
    "file": "LogLevelTests.cs",
    "methods": [
      {
        "name": "LogLevelTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"Debug a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"Info a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"Warn a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"Error a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"Fatal a\");\n        }"
      },
      {
        "name": "LogLevelUppercaseTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:uppercase=true} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            ILogger logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"DEBUG a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"INFO a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"WARN a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"ERROR a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"FATAL a\");\n        }"
      },
      {
        "name": "LogLevelSingleCharacterTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=FirstCharacter} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"T a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"D a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"I a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"W a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"E a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"F a\");\n        }"
      },
      {
        "name": "LogLevelOrdinalTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=Ordinal} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"0 a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"1 a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"2 a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"3 a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"4 a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"5 a\");\n        }"
      },
      {
        "name": "LogLevelFullNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=FullName} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"Trace a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"Debug a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"Information a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"Warning a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"Error a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"Fatal a\");\n        }"
      },
      {
        "name": "LogLevelTriLetterTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=TriLetter} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"Trc a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"Dbg a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"Inf a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"Wrn a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"Err a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"Ftl a\");\n        }"
      },
      {
        "name": "LogLevelGetTypeCodeTest",
        "body": "{\n            // Arrange\n            var logLevel = LogLevel.Info;\n\n            // Act\n            var result = Convert.GetTypeCode(logLevel);\n\n            // Assert\n            Assert.Equal(TypeCode.Object, result);\n        }"
      }
    ]
  },
  {
    "file": "LoggerNameTests.cs",
    "methods": [
      {
        "name": "LoggerNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${logger} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"A a\");\n        }"
      },
      {
        "name": "LoggerShortNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${logger:ShortName=true} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A.B.C\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"C a\");\n\n            var renderer = new NLog.LayoutRenderers.LoggerNameLayoutRenderer() { ShortName = true };\n            var result = renderer.Render(new LogEventInfo() { LoggerName = logger.Name });\n            Assert.Equal(\"C\", result);\n        }"
      },
      {
        "name": "LoggerShortNameTest2",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${logger:ShortName=true} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"C\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"C a\");\n\n            var renderer = new NLog.LayoutRenderers.LoggerNameLayoutRenderer() { ShortName = true };\n            var result = renderer.Render(new LogEventInfo() { LoggerName = logger.Name });\n            Assert.Equal(\"C\", result);\n        }"
      },
      {
        "name": "LoggerShortNameTest_false",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${logger:ShortName=false} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A.B.C\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"A.B.C a\");\n        }"
      },
      {
        "name": "LoggerPrefixNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${logger:PrefixName=true} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A.B.C\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"A.B a\");\n\n            var layout = new SimpleLayout(\"${logger:PrefixName=true}\");\n            var result = layout.Render(new LogEventInfo() { LoggerName = logger.Name });\n            Assert.Equal(\"A.B\", result);\n        }"
      },
      {
        "name": "LoggerPrefixNameTest2",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${logger:PrefixName=true} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"C\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"C a\");\n\n            var layout = new SimpleLayout(\"${logger:PrefixName=true}\");\n            var result = layout.Render(new LogEventInfo() { LoggerName = logger.Name });\n            Assert.Equal(\"C\", result);\n        }"
      }
    ]
  },
  {
    "file": "LongDateTests.cs",
    "methods": [
      {
        "name": "LongDateTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${longdate}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.GetLogger(\"d\").Debug(\"zzz\");\n            string date = GetDebugLastMessage(\"debug\", logFactory);\n            Assert.Equal(24, date.Length);\n            Assert.Equal('-', date[4]);\n            Assert.Equal('-', date[7]);\n            Assert.Equal(' ', date[10]);\n            Assert.Equal(':', date[13]);\n            Assert.Equal(':', date[16]);\n            Assert.Equal('.', date[19]);\n        }"
      },
      {
        "name": "UniversalTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateLocalTimeSource();\n\n                var dt = new LongDateLayoutRenderer();\n                dt.UniversalTime = true;\n\n                var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(ei.TimeStamp.ToUniversalTime().ToString(\"yyyy-MM-dd HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "LongDateTryGetRawValue",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${longdate:UniversalTime=true}\";\n            var timestamp = DateTime.Now;\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            logEventInfo.TimeStamp = timestamp;\n\n            // Act\n            var success = l.TryGetRawValue(logEventInfo, out var value);\n\n            // Assert\n            Assert.True(success, \"success\");\n            Assert.IsType<DateTime>(value);\n            Assert.Equal(timestamp.ToUniversalTime(), (DateTime)value);\n        }"
      },
      {
        "name": "LocalTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();\n\n                var dt = new LongDateLayoutRenderer();\n                dt.UniversalTime = false;\n\n                var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(ei.TimeStamp.ToLocalTime().ToString(\"yyyy-MM-dd HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "DefaultTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();\n\n                var dt = new LongDateLayoutRenderer();\n\n                var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(ei.TimeStamp.ToString(\"yyyy-MM-dd HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "LongDateWithPaddingPadLeftAlignLeft",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${longdate:padding=5:fixedlength=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.GetLogger(\"d\").Debug(\"zzz\");\n            string date = GetDebugLastMessage(\"debug\", logFactory);\n            Assert.Equal(5, date.Length);\n            Assert.Equal('-', date[4]);\n        }"
      },
      {
        "name": "LongDateWithPaddingPadLeftAlignRight",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${longdate:padding=5:fixedlength=true:alignmentOnTruncation=right}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.GetLogger(\"d\").Debug(\"zzz\");\n            string date = GetDebugLastMessage(\"debug\", logFactory);\n            Assert.Equal(5, date.Length);\n            Assert.Equal('.', date[0]);\n        }"
      },
      {
        "name": "LongDateWithPaddingPadRightAlignLeft",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${longdate:padding=-5:fixedlength=true:alignmentOnTruncation=left}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.GetLogger(\"d\").Debug(\"zzz\");\n            string date = GetDebugLastMessage(\"debug\", logFactory);\n            Assert.Equal(5, date.Length);\n            Assert.Equal('-', date[4]);\n        }"
      },
      {
        "name": "LongDateWithPaddingPadRightAlignRight",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${longdate:padding=-5:fixedlength=true:alignmentOnTruncation=right}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.GetLogger(\"d\").Debug(\"zzz\");\n            string date = GetDebugLastMessage(\"debug\", logFactory);\n            Assert.Equal(5, date.Length);\n            Assert.Equal('.', date[0]);\n        }"
      }
    ]
  },
  {
    "file": "MDCTests.cs",
    "methods": [
      {
        "name": "MDCTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${mdc:item=myitem} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            MappedDiagnosticsContext.Clear();\n            MappedDiagnosticsContext.Set(\"myitem\", \"myvalue\");\n            LogManager.GetLogger(\"A\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug\", \"myvalue a\");\n\n            MappedDiagnosticsContext.Set(\"myitem\", \"value2\");\n            LogManager.GetLogger(\"A\").Debug(\"b\");\n            AssertDebugLastMessage(\"debug\", \"value2 b\");\n\n            MappedDiagnosticsContext.Remove(\"myitem\");\n            LogManager.GetLogger(\"A\").Debug(\"c\");\n            AssertDebugLastMessage(\"debug\", \" c\");\n        }"
      },
      {
        "name": "MDCFormatTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${mdc:item=myitem:format=@} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            MappedDiagnosticsContext.Clear();\n            MappedDiagnosticsContext.Set(\"myitem\", new { RequestId = 123 });\n            LogManager.GetLogger(\"A\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug\", \"{\\\"RequestId\\\":123} a\");\n        }"
      }
    ]
  },
  {
    "file": "MdlcLayoutRendererTests.cs",
    "methods": [
      {
        "name": "MdlcLayoutFormatTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${mdlc:item=myitem:format=@} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            MappedDiagnosticsLogicalContext.Clear();\n            MappedDiagnosticsLogicalContext.Set(\"myitem\", new { RequestId = 123 });\n            LogManager.GetLogger(\"A\").Debug(\"a\");\n            AssertDebugLastMessage(\"debug\", \"{\\\"RequestId\\\":123} a\");\n            MappedDiagnosticsLogicalContext.Clear();\n        }"
      },
      {
        "name": "given_item_does_not_exist_when_rendering_item_and_message_should_render_only_message",
        "body": "{\n            const string message = \"message\";\n            LogManager.GetLogger(\"A\").Debug(message);\n            Assert.Equal(message, _target.LastMessage);\n        }"
      },
      {
        "name": "given_item_exists_when_rendering_item_and_message_should_render_item_and_message",
        "body": "{\n            const string message = \"message\";\n            const string key = \"myitem\";\n            const string item = \"item\";\n\n            MappedDiagnosticsLogicalContext.Set(key, item);\n            LogManager.GetLogger(\"A\").Debug(message);\n\n            Assert.Equal(item + message, _target.LastMessage);\n        }"
      }
    ]
  },
  {
    "file": "MessageTests.cs",
    "methods": [
      {
        "name": "MessageWithoutPaddingTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\"a1\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\"a01/01/2005 00:00:00\");\n        }"
      },
      {
        "name": "MessageRightPaddingTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:padding=3}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"  a\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\" a1\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\"a01/01/2005 00:00:00\");\n        }"
      },
      {
        "name": "MessageFixedLengthRightPaddingLeftAlignmentTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:padding=3:fixedlength=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"  a\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\" a1\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\"a01\");\n        }"
      },
      {
        "name": "MessageFixedLengthRightPaddingRightAlignmentTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:padding=3:fixedlength=true:alignmentOnTruncation=right}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"  a\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\" a1\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\":00\");\n        }"
      },
      {
        "name": "MessageLeftPaddingTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:padding=-3:padcharacter=x}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"axx\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\"a1x\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\"a01/01/2005 00:00:00\");\n        }"
      },
      {
        "name": "MessageFixedLengthLeftPaddingLeftAlignmentTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:padding=-3:padcharacter=x:fixedlength=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"axx\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\"a1x\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\"a01\");\n        }"
      },
      {
        "name": "MessageFixedLengthLeftPaddingRightAlignmentTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:padding=-3:padcharacter=x:fixedlength=true:alignmentOnTruncation=right}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"axx\");\n            logger.Debug(\"a{0}\", 1);\n            logFactory.AssertDebugLastMessage(\"a1x\");\n            logger.Debug(\"a{0}{1}\", 1, \"2\");\n            logFactory.AssertDebugLastMessage(\"a12\");\n            logger.Debug(CultureInfo.InvariantCulture, \"a{0}\", new DateTime(2005, 1, 1));\n            logFactory.AssertDebugLastMessage(\":00\");\n        }"
      },
      {
        "name": "MessageWithExceptionAndCustomSeparatorTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message:withException=true:exceptionSeparator=,}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n\n            var ex = new InvalidOperationException(\"Exception message.\");\n#if !NET35\n            logger.Debug(new AggregateException(ex), \"Foo\");\n#else\n            logger.Debug(ex, \"Foo\");\n#endif\n            logFactory.AssertDebugLastMessage(\"Foo,\" + ex.ToString());\n\n            logger.Debug(ex);\n            logFactory.AssertDebugLastMessage(ex.ToString());\n        }"
      },
      {
        "name": "SingleParameterException_OutputsSingleStackTrace",
        "body": "{\n            // Arrange\n            var logTarget = new NLog.Targets.DebugTarget(\"debug\") { Layout = \"${message}|${exception}\" };\n            var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(logTarget);\n            }).LogFactory;\n\n            var logger = logFactory.GetLogger(\"SingleParameterException\");\n\n            // Act\n            try\n            {\n                logger.Info(\"Hello\");\n                Exception argumentException = new ArgumentException(\"Holy Moly\");\n#if !NET35\n                argumentException = new AggregateException(argumentException);\n#endif\n                throw argumentException;\n            }\n            catch (Exception ex)\n            {\n                logger.Fatal(ex);\n            }\n\n            // Assert\n            Assert.StartsWith(\"System.ArgumentException: Holy Moly|System.ArgumentException\", logTarget.LastMessage);\n        }"
      }
    ]
  },
  {
    "file": "NDCTests.cs",
    "methods": [
      {
        "name": "NDCTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndc} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                    using (NestedDiagnosticsContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma kota c\");\n                        using (NestedDiagnosticsContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"ala ma kota kopytko d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDCTopTestTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndc:topframes=2} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                    using (NestedDiagnosticsContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ma kota c\");\n                        using (NestedDiagnosticsContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"kota kopytko d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ma kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDCTop1TestTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndc:topframes=1} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ma b\");\n                    using (NestedDiagnosticsContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"kota c\");\n                        NestedDiagnosticsContext.Push(\"kopytko\");\n                        LogManager.GetLogger(\"A\").Debug(\"d\");\n                        AssertDebugLastMessage(\"debug\", \"kopytko d\");\n                        Assert.Equal(\"kopytko\", NestedDiagnosticsContext.Pop()); // manual pop\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());\n            Assert.Equal(string.Empty, NestedDiagnosticsContext.TopMessage);\n            NestedDiagnosticsContext.Push(\"zzz\");\n            Assert.Equal(\"zzz\", NestedDiagnosticsContext.TopMessage);\n            NestedDiagnosticsContext.Clear();\n            Assert.Equal(string.Empty, NestedDiagnosticsContext.Pop());\n            Assert.Equal(string.Empty, NestedDiagnosticsContext.TopMessage);\n        }"
      },
      {
        "name": "NDCBottomTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndc:bottomframes=2} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                    using (NestedDiagnosticsContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma c\");\n                        using (NestedDiagnosticsContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"ala ma d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDCSeparatorTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndc:separator=\\:} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala:ma b\");\n                    using (NestedDiagnosticsContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");\n                        using (NestedDiagnosticsContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"ala:ma:kota:kopytko d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala:ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      }
    ]
  },
  {
    "file": "NDLCTests.cs",
    "methods": [
      {
        "name": "NdlcGetAllMessages",
        "body": "{\n            object value = 5;\n\n            NestedDiagnosticsLogicalContext.Clear();\n            var popper = NestedDiagnosticsLogicalContext.Push(value);\n\n            string expected = \"5\";\n            string[] actual = NestedDiagnosticsLogicalContext.GetAllMessages();\n            Assert.Single(actual);\n            Assert.Equal(expected, actual[0]);\n\n            popper.Dispose();\n            actual = NestedDiagnosticsLogicalContext.GetAllMessages();\n            Assert.Empty(actual);\n        }"
      },
      {
        "name": "NDLCTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsLogicalContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                    using (NestedDiagnosticsLogicalContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma kota c\");\n                        using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"ala ma kota kopytko d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDLCTopTestTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc:topframes=2} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsLogicalContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                    using (NestedDiagnosticsLogicalContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ma kota c\");\n                        using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"kota kopytko d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ma kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDLCTop1TestTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc:topframes=1} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsLogicalContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ma b\");\n                    using (NestedDiagnosticsLogicalContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"kota c\");\n                        NestedDiagnosticsLogicalContext.Push(\"kopytko\");\n                        LogManager.GetLogger(\"A\").Debug(\"d\");\n                        AssertDebugLastMessage(\"debug\", \"kopytko d\");\n                        Assert.Equal(\"kopytko\", NestedDiagnosticsLogicalContext.PopObject()); // manual pop\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            Assert.Null(NestedDiagnosticsLogicalContext.Pop()); //inconsistent with NDC - should be string.empty, but for backwardsscomp. Fix in NLog 5\n            NestedDiagnosticsLogicalContext.Push(\"zzz\");\n            NestedDiagnosticsLogicalContext.Push(\"yyy\");\n            Assert.Equal(\"yyy\", NestedDiagnosticsLogicalContext.Pop());\n            NestedDiagnosticsLogicalContext.Clear();\n            Assert.Null(NestedDiagnosticsLogicalContext.Pop()); //inconsistent with NDC - should be string.empty, but for backwardsscomp. Fix in NLog 5\n        }"
      },
      {
        "name": "NDLCBottomTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc:bottomframes=2} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsLogicalContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                    using (NestedDiagnosticsLogicalContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma c\");\n                        using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"ala ma d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala ma c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDLCSeparatorTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc:separator=\\:} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                using (NestedDiagnosticsLogicalContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala:ma b\");\n                    using (NestedDiagnosticsLogicalContext.Push(\"kota\"))\n                    {\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");\n                        using (NestedDiagnosticsLogicalContext.Push(\"kopytko\"))\n                        {\n                            LogManager.GetLogger(\"A\").Debug(\"d\");\n                            AssertDebugLastMessage(\"debug\", \"ala:ma:kota:kopytko d\");\n                        }\n                        LogManager.GetLogger(\"A\").Debug(\"c\");\n                        AssertDebugLastMessage(\"debug\", \"ala:ma:kota c\");\n                    }\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    AssertDebugLastMessage(\"debug\", \"ala:ma b\");\n                }\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n            }\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \" 0\");\n        }"
      },
      {
        "name": "NDLCDeepTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc:topframes=1} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n\n            for (int i = 1; i <= 100; ++i)\n                NestedDiagnosticsLogicalContext.Push(i);\n\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \"100 0\");\n\n            NestedDiagnosticsLogicalContext.PopObject();\n            LogManager.GetLogger(\"A\").Debug(\"1\");\n            AssertDebugLastMessage(\"debug\", \"99 1\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"2\");\n            AssertDebugLastMessage(\"debug\", \" 2\");\n        }"
      },
      {
        "name": "NDLCTimingTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc}|${ndlctiming:CurrentScope=false:ScopeBeginTime=true:Format=yyyy-MM-dd HH\\:mm\\:ss}|${ndlctiming:CurrentScope=false:ScopeBeginTime=false:Format=fff}|${ndlctiming:CurrentScope=true:ScopeBeginTime=true:Format=HH\\:mm\\:ss.fff}|${ndlctiming:CurrentScope=true:ScopeBeginTime=false:Format=fffffff}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            NestedDiagnosticsLogicalContext.Clear();\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \"|||||0\");\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                var measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n                Assert.Equal(6, measurements.Length);\n                Assert.Equal(\"ala\", measurements[0]);\n                Assert.InRange(int.Parse(measurements[2]), 0, 999);\n                Assert.InRange(int.Parse(measurements[4]), 0, 9999999);\n                Assert.Equal(\"a\", measurements[measurements.Length - 1]);\n\n                System.Threading.Thread.Sleep(10);\n\n                LogManager.GetLogger(\"A\").Debug(\"b\");\n                measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n                Assert.Equal(\"ala\", measurements[0]);\n                Assert.InRange(int.Parse(measurements[2]), 10, 999);\n                Assert.InRange(int.Parse(measurements[4]), 100000, 9999999);\n                Assert.Equal(\"b\", measurements[measurements.Length - 1]);\n\n                using (NestedDiagnosticsLogicalContext.Push(\"ma\"))\n                {\n                    LogManager.GetLogger(\"A\").Debug(\"a\");\n                    measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n                    Assert.Equal(6, measurements.Length);\n                    Assert.Equal(\"ala ma\", measurements[0]);\n                    Assert.InRange(int.Parse(measurements[2]), 10, 999);\n                    Assert.InRange(int.Parse(measurements[4]), 0, 9999999);\n                    Assert.Equal(\"a\", measurements[measurements.Length - 1]);\n\n                    System.Threading.Thread.Sleep(10);\n\n                    LogManager.GetLogger(\"A\").Debug(\"b\");\n                    measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n                    Assert.Equal(6, measurements.Length);\n                    Assert.Equal(\"ala ma\", measurements[0]);\n                    Assert.InRange(int.Parse(measurements[2]), 20, 999);\n                    Assert.InRange(int.Parse(measurements[4]), 100000, 9999999);\n                    Assert.Equal(\"b\", measurements[measurements.Length - 1]);\n                }\n\n                LogManager.GetLogger(\"A\").Debug(\"c\");\n                measurements = GetDebugLastMessage(\"debug\").Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n                Assert.Equal(\"ala\", measurements[0]);\n                Assert.InRange(int.Parse(measurements[2]), 20, 999);\n                Assert.InRange(int.Parse(measurements[4]), 200000, 9999999);\n                Assert.Equal(\"c\", measurements[measurements.Length - 1]);\n            }\n\n            LogManager.GetLogger(\"A\").Debug(\"0\");\n            AssertDebugLastMessage(\"debug\", \"|||||0\");\n        }"
      },
      {
        "name": "NDLCAsyncLogging",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc:separator=\\:} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n\n            System.Threading.Tasks.Task task;\n            using (NestedDiagnosticsLogicalContext.Push(\"ala\"))\n            {\n                LogManager.GetLogger(\"A\").Debug(\"a\");\n                AssertDebugLastMessage(\"debug\", \"ala a\");\n                task = System.Threading.Tasks.Task.Run(async () => { await System.Threading.Tasks.Task.Delay(50); LogManager.GetLogger(\"B\").Debug(\"b\"); });\n            }\n            task.Wait();\n            AssertDebugLastMessage(\"debug\", \"ala b\");\n        }"
      }
    ]
  },
  {
    "file": "NLogDirRendererTests.cs",
    "methods": [
      {
        "name": "RenderNLogDir",
        "body": "{\n            Layout layout = \"${nlogdir}\";\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.True(File.Exists(Path.Combine(actual, \"NLog.dll\")), $\"cannot find NLog.dll in '{actual}'\");\n        }"
      },
      {
        "name": "RenderNLogDir_with_file_and_dir",
        "body": "{\n            Layout layout = \"${nlogdir:dir=test:file=file1.txt}\";\n\n            Layout nlogdirLayout = \"${nlogdir}\";\n            var nlogDir = nlogdirLayout.Render(LogEventInfo.CreateNullEvent());\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(Path.Combine(Path.Combine(nlogDir, \"test\" + Path.DirectorySeparatorChar), \"file1.txt\"), actual);\n        }"
      }
    ]
  },
  {
    "file": "ProcessDirTests.cs",
    "methods": [
      {
        "name": "BaseDirCurrentProcessTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${processdir}\", _processDir);\n        }"
      },
      {
        "name": "BaseDirCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${processdir:dir=aaa}\", Path.Combine(_processDir, \"aaa\"));\n        }"
      },
      {
        "name": "BaseDirFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${processdir:file=aaa.txt}\", Path.Combine(_processDir, \"aaa.txt\"));\n        }"
      }
    ]
  },
  {
    "file": "ProcessIdLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderProcessIdLayoutRenderer",
        "body": "{\n            Layout layout = \"${processid}\";\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n            int number;\n            if (!int.TryParse(actual, out number))\n            {\n                Assert.Fail(\"processid is not a number\");\n            }\n\n            Assert.True(number > 0, \"processid is not > 0\");\n        }"
      }
    ]
  },
  {
    "file": "ProcessNameLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderProcessNameLayoutRenderer",
        "body": "{\n            Layout layout = \"${processname}\";\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n\n\n            Assert.NotNull(actual);\n            Assert.True(actual.Length > 0, \"actual.Length > 0\");\n            var lower = actual.ToLower();\n\n            //lowercase\n            var allowedProcessNames = new List<string> { \"vstest.executionengine\", \"xunit\", \"mono-sgen\", \"dotnet\", \"testhost\", \"testhost.x86\", \"testhost.x64\", \"testhost.net452.x86\", \"testhost.net452.x64\", \"testhost.net461.x86\", \"testhost.net461.x64\" };\n\n            Assert.True(allowedProcessNames.Any(p => lower.Contains(p)),\n                $\"validating processname failed. Please add (if correct) '{actual}' to 'allowedProcessNames'\");\n        }"
      },
      {
        "name": "RenderProcessNameLayoutRenderer_fullname",
        "body": "{\n            Layout layout = \"${processname:fullname=true}\";\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n\n\n            Assert.NotNull(actual);\n            Assert.True(actual.Length > 0, \"actual.Length > 0\");\n            Assert.True(File.Exists(actual), \"process not found\");\n        }"
      }
    ]
  },
  {
    "file": "ProcessTimeLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderProcessTimeLayoutRenderer",
        "body": "{\n            var layout = \"${processtime}\";\n            var timestamp = LogEventInfo.ZeroDate;\n            System.Threading.Thread.Sleep(16);\n            var logEvent = new LogEventInfo(LogLevel.Debug, \"logger1\", \"message1\");\n            var time = logEvent.TimeStamp.ToUniversalTime() - timestamp;\n\n            var expected = time.ToString(\"hh\\\\:mm\\\\:ss\\\\.fff\");\n            AssertLayoutRendererOutput(layout, logEvent, expected);\n        }"
      }
    ]
  },
  {
    "file": "ScopeNestedTests.cs",
    "methods": [
      {
        "name": "ScopeNestedTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    logger.Debug(\"b\");\n                }\n            }\n\n            // Assert\n            Assert.Equal(\"ala ma b\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedTopTwoTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:topframes=2} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    using (logger.PushScopeNested(\"kota\"))\n                    {\n                        logger.Debug(\"c\");\n                    }\n                }\n            }\n\n            // Assert\n            Assert.Equal(\"ma kota c\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedTopOneTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:topframes=1} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    using (logger.PushScopeNested(\"kota\"))\n                    {\n                        logger.Debug(\"c\");\n                    }\n                }\n            }\n\n            // Assert\n            Assert.Equal(\"kota c\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedBottomTwoTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:bottomframes=2} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    using (logger.PushScopeNested(\"kota\"))\n                    {\n                        logger.Debug(\"c\");\n                    }\n                }\n            }\n\n            // Assert\n            Assert.Equal(\"ala ma c\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedSeparatorTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:separator=\\:} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    using (logger.PushScopeNested(\"kota\"))\n                    {\n                        logger.Debug(\"c\");\n                    }\n                }\n            }\n\n            // Assert\n            Assert.Equal(\"ala:ma:kota c\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedSinglePropertyTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:format=@}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(new[] { new KeyValuePair<string, object>(\"Hello\", \"World\") }))\n            {\n                logger.Debug(\"c\");\n            }\n\n            // Assert\n            Assert.Equal(\"[ { \\\"Hello\\\": \\\"World\\\" } ]\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedTwoPropertiesTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:format=@}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(new Dictionary<string, object>() { { \"Hello\", 42 }, { \"Unlucky\", 13 } }))\n            {\n                logger.Debug(\"c\");\n            }\n\n            // Assert\n            Assert.Equal(\"[ { \\\"Hello\\\": 42, \\\"Unlucky\\\": 13 } ]\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedTwoPropertiesNewlineTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested:format=@:separator=\\n}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(new Dictionary<string, object>() { { \"Hello\", 42 }, { \"Unlucky\", 13 } }))\n            {\n                logger.Debug(\"c\");\n            }\n\n            // Assert\n            Assert.Equal(string.Format(\"[{0}{{{0}\\\"Hello\\\": 42,{0}\\\"Unlucky\\\": 13{0}}}{0}]\", \"\\n\"), target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedBeginScopeProperties",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopenested}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            var scopeProperties = new Dictionary<string, object>() { { \"Hello\", 42 }, { \"Unlucky\", 13 } };\n            using (ScopeContext.PushNestedState(scopeProperties))\n            {\n                logger.Debug(\"c\");\n            }\n\n            // Assert\n            Assert.Equal(scopeProperties.ToString(), target.LastMessage);   // Avoid enumerating properties, since available from ScopeContext-Properties\n        }"
      },
      {
        "name": "ScopeNestedIndentTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopeindent:_}${scopenested} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    using (logger.PushScopeNested(\"kota\"))\n                    {\n                        logger.Debug(\"c\");\n                    }\n                }\n            }\n\n            // Assert\n            Assert.Equal(\"___ala ma kota c\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopeNestedTimingTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${ndlc}|${scopetiming}|${scopetiming:CurrentScope=false:StartTime=true:Format=yyyy-MM-dd HH\\:mm\\:ss}|${scopetiming:CurrentScope=false:StartTime=false:Format=fff}|${scopetiming:CurrentScope=true:StartTime=true:Format=HH\\:mm\\:ss.fff}|${scopetiming:CurrentScope=true:StartTime=false:Format=fffffff}|${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            logger.Debug(\"0\");\n            string messageNoScope = target.LastMessage;\n            string messageFirstScope;\n            string messageFirstScopeSleep;\n            string messageFirstScopeExit;\n            string messageSecondScope;\n            string messageSecondScopeSleep;\n            Assert.Equal(\"||||||0\", messageNoScope);\n\n            using (logger.PushScopeNested(\"ala\"))\n            {\n                logger.Debug(\"a\");\n                messageFirstScope = target.LastMessage;\n\n                System.Threading.Thread.Sleep(10);\n\n                logger.Debug(\"b\");\n                messageFirstScopeSleep = target.LastMessage;\n\n                using (logger.PushScopeNested(\"ma\"))\n                {\n                    logger.Debug(\"a\");\n                    messageSecondScope = target.LastMessage;\n\n                    System.Threading.Thread.Sleep(10);\n\n                    logger.Debug(\"b\");\n                    messageSecondScopeSleep = target.LastMessage;\n                }\n\n                logger.Debug(\"c\");\n                messageFirstScopeExit = target.LastMessage;\n            }\n\n            // Assert\n            var measurements = messageFirstScope.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n            Assert.Equal(7, measurements.Length);\n            Assert.Equal(\"ala\", measurements[0]);\n            Assert.InRange(double.Parse(measurements[1]), 0, 999);\n            Assert.InRange(int.Parse(measurements[3]), 0, 999);\n            Assert.InRange(int.Parse(measurements[5]), 0, 9999999);\n            Assert.Equal(\"a\", measurements[measurements.Length - 1]);\n\n            measurements = messageFirstScopeSleep.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n            Assert.Equal(7, measurements.Length);\n            Assert.Equal(\"ala\", measurements[0]);\n            Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 10, 999);\n            Assert.InRange(int.Parse(measurements[3]), 10, 999);\n            Assert.InRange(int.Parse(measurements[5]), 100000, 9999999);\n            Assert.Equal(\"b\", measurements[measurements.Length - 1]);\n\n            measurements = messageSecondScope.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n            Assert.Equal(7, measurements.Length);\n            Assert.Equal(\"ala ma\", measurements[0]);\n            Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 10, 999);\n            Assert.InRange(int.Parse(measurements[3]), 10, 999);\n            Assert.InRange(int.Parse(measurements[5]), 0, 9999999);\n            Assert.Equal(\"a\", measurements[measurements.Length - 1]);\n\n            measurements = messageSecondScopeSleep.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n            Assert.Equal(7, measurements.Length);\n            Assert.Equal(\"ala ma\", measurements[0]);\n            Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 20, 999);\n            Assert.InRange(int.Parse(measurements[3]), 20, 999);\n            Assert.InRange(int.Parse(measurements[5]), 100000, 9999999);\n            Assert.Equal(\"b\", measurements[measurements.Length - 1]);\n\n            measurements = messageFirstScopeExit.Split(new[] { '|' }, System.StringSplitOptions.RemoveEmptyEntries);\n            Assert.Equal(7, measurements.Length);\n            Assert.Equal(\"ala\", measurements[0]);\n            Assert.InRange(double.Parse(measurements[1], System.Globalization.CultureInfo.InvariantCulture), 20, 999);\n            Assert.InRange(int.Parse(measurements[3]), 20, 999);\n            Assert.InRange(int.Parse(measurements[5]), 200000, 9999999);\n            Assert.Equal(\"c\", measurements[measurements.Length - 1]);\n        }"
      }
    ]
  },
  {
    "file": "ScopePropertyTests.cs",
    "methods": [
      {
        "name": "ScopePropertyTest",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopeproperty:item=myitem} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeProperty(\"myitem\", \"myvalue\"))\n            {\n                logger.Debug(\"a\");\n            }\n\n            // Assert\n            Assert.Equal(\"myvalue a\", target.LastMessage);\n        }"
      },
      {
        "name": "ScopePropertyFormatTests",
        "body": "{\n            // Arrange\n            ScopeContext.Clear();\n            var logFactory = new LogFactory();\n            logFactory.Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${scopeproperty:item=myitem:format=@} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n            var logger = logFactory.GetCurrentClassLogger();\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n\n            // Act\n            using (logger.PushScopeProperty(\"myitem\", new { RequestId = 123 }))\n            {\n                logger.Debug(\"a\");\n            }\n\n            // Assert\n            Assert.Equal(\"{\\\"RequestId\\\":123} a\", target.LastMessage);\n        }"
      }
    ]
  },
  {
    "file": "SequenceIdLayoutRendererTest.cs",
    "methods": [
      {
        "name": "RenderSequenceIdLayoutRenderer",
        "body": "{\n            LogEventInfo logEventInfo = new LogEventInfo();\n            AssertLayoutRendererOutput(\"${sequenceid}\", logEventInfo, logEventInfo.SequenceID.ToString(CultureInfo.InvariantCulture));\n        }"
      }
    ]
  },
  {
    "file": "ShortDateTests.cs",
    "methods": [
      {
        "name": "UniversalTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateLocalTimeSource();\n\n                var layoutRenderer = new ShortDateLayoutRenderer();\n                layoutRenderer.UniversalTime = true;\n\n                var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(logEvent.TimeStamp.ToUniversalTime().ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "LocalTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();\n\n                var layoutRenderer = new ShortDateLayoutRenderer();\n                layoutRenderer.UniversalTime = false;\n\n                var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(logEvent.TimeStamp.ToLocalTime().ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "ShortDateTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();\n\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${shortdate}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n                var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                logFactory.GetLogger(\"d\").Debug(logEvent);\n                logFactory.AssertDebugLastMessage(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "OneDigitMonthTest",
        "body": "{\n            var layoutRenderer = new ShortDateLayoutRenderer();\n            layoutRenderer.UniversalTime = false;\n\n            var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            logEvent.TimeStamp = new DateTime(2015, 1, 1);\n            Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));\n        }"
      },
      {
        "name": "TwoDigitMonthTest",
        "body": "{\n            var layoutRenderer = new ShortDateLayoutRenderer();\n            layoutRenderer.UniversalTime = false;\n\n            var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            logEvent.TimeStamp = new DateTime(2015, 12, 1);\n            Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));\n        }"
      },
      {
        "name": "OneDigitDayTest",
        "body": "{\n            var layoutRenderer = new ShortDateLayoutRenderer();\n            layoutRenderer.UniversalTime = false;\n\n            var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            logEvent.TimeStamp = new DateTime(2015, 1, 1);\n            Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));\n        }"
      },
      {
        "name": "TwoDigitDayTest",
        "body": "{\n            var layoutRenderer = new ShortDateLayoutRenderer();\n            layoutRenderer.UniversalTime = false;\n\n            var logEvent = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            logEvent.TimeStamp = new DateTime(2015, 12, 12);\n            Assert.Equal(logEvent.TimeStamp.ToString(\"yyyy-MM-dd\"), layoutRenderer.Render(logEvent));\n        }"
      }
    ]
  },
  {
    "file": "SpecialFolderTests.cs",
    "methods": [
      {
        "name": "SpecialFolderTest",
        "body": "{\n            foreach (var specialDirString in Enum.GetNames(typeof(Environment.SpecialFolder)))\n            {\n                var folder = (Environment.SpecialFolder)Enum.Parse(typeof(Environment.SpecialFolder), specialDirString);\n\n                AssertLayoutRendererOutput($\"${{specialfolder:folder={specialDirString}}}\", Environment.GetFolderPath(folder));\n            }\n        }"
      },
      {
        "name": "SpecialFolderDirCombineTest",
        "body": "{\n            AssertLayoutRendererOutput($\"${{specialfolder:folder={sysDirString}:dir=aaa}}\", Path.Combine(sysDir, \"aaa\"));\n        }"
      },
      {
        "name": "SpecialFolderFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput($\"${{specialfolder:folder={sysDirString}:file=aaa.txt}}\", Path.Combine(sysDir, \"aaa.txt\"));\n        }"
      },
      {
        "name": "SpecialFolderDirFileCombineTest",
        "body": "{\n            AssertLayoutRendererOutput($\"${{specialfolder:folder={sysDirString}:dir=aaa:file=bbb.txt}}\", Path.Combine(sysDir, \"aaa\", \"bbb.txt\"));\n        }"
      },
      {
        "name": "SpecialFolderCommonApplicationDataTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${CommonApplicationDataDir}\", Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData));\n        }"
      },
      {
        "name": "SpecialFolderUserApplicationDataTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${UserApplicationDataDir}\", Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData));\n        }"
      },
      {
        "name": "SpecialFolderUserLocalApplicationDataTest",
        "body": "{\n            AssertLayoutRendererOutput(\"${UserLocalApplicationDataDir}\", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));\n        }"
      }
    ]
  },
  {
    "file": "StackTraceRendererTests.cs",
    "methods": [
      {
        "name": "RenderStackTrace",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessageContains(\" => StackTraceRendererTests.RenderStackTrace => StackTraceRendererTests.RenderMe\");\n        }"
      },
      {
        "name": "RenderStackTraceAndCallsite",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace} ${callsite:className=false}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n\n            logFactory.AssertDebugLastMessageContains(\" => StackTraceRendererTests.RenderStackTraceAndCallsite => StackTraceRendererTests.RenderMe\");\n        }"
      },
      {
        "name": "RenderStackTraceReversed",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:reverse=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.RenderMe => StackTraceRendererTests.RenderStackTraceReversed => \");\n        }"
      },
      {
        "name": "RenderStackTraceNoCaptureStackTrace",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:captureStackTrace=false}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessage(\"I am: \");\n        }"
      },
      {
        "name": "RenderStackTraceNoCaptureStackTraceWithStackTrace",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:captureStackTrace=false}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logEvent = new LogEventInfo(LogLevel.Info, null, \"I am:\");\n            logEvent.SetStackTrace(new System.Diagnostics.StackTrace(true), 0);\n            logFactory.GetCurrentClassLogger().Log(logEvent);\n            logFactory.AssertDebugLastMessageContains($\" => {nameof(StackTraceRendererTests)}.{nameof(RenderStackTraceNoCaptureStackTraceWithStackTrace)}\");\n        }"
      },
      {
        "name": "RenderStackTrace_topframes",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:topframes=2}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessage(\"I am: StackTraceRendererTests.RenderStackTrace_topframes => StackTraceRendererTests.RenderMe\");\n        }"
      },
      {
        "name": "RenderStackTrace_skipframes",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:skipframes=1}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessageContains(\" => StackTraceRendererTests.RenderStackTrace_skipframes\");\n        }"
      },
      {
        "name": "RenderStackTrace_raw",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=Raw}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n\n            logFactory.AssertDebugLastMessageContains(\"RenderStackTrace_raw at offset \");\n            logFactory.AssertDebugLastMessageContains(\"RenderMe at offset \");\n#if !MONO\n            logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.cs\");\n#endif\n\n            string debugLastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            int index0 = debugLastMessage.IndexOf(\"RenderStackTraceReversed_raw at offset \");\n            int index1 = debugLastMessage.IndexOf(\"RenderMe at offset \");\n            Assert.True(index0 < index1);\n        }"
      },
      {
        "name": "RenderStackTraceSeperator_raw",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=Raw:separator= \\=&gt; }' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n\n            logFactory.AssertDebugLastMessageContains(\" => RenderStackTraceSeperator_raw at offset \");\n            logFactory.AssertDebugLastMessageContains(\" => RenderMe at offset \");\n#if !MONO\n            logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.cs\");\n#endif\n\n            string debugLastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            int index0 = debugLastMessage.IndexOf(\" => RenderStackTraceSeperator_raw at offset \");\n            int index1 = debugLastMessage.IndexOf(\" => RenderMe at offset \");\n            Assert.True(index0 < index1);\n        }"
      },
      {
        "name": "RenderStackTraceReversed_raw",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=Raw:reverse=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n\n            logFactory.AssertDebugLastMessageContains(\"RenderMe at offset \");\n            logFactory.AssertDebugLastMessageContains(\"RenderStackTraceReversed_raw at offset \");\n#if !MONO\n            logFactory.AssertDebugLastMessageContains(\"StackTraceRendererTests.cs\");\n#endif\n\n            string debugLastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            int index0 = debugLastMessage.IndexOf(\"RenderMe at offset \");\n            int index1 = debugLastMessage.IndexOf(\"RenderStackTraceReversed_raw at offset \");\n            Assert.True(index0 < index1);\n        }"
      },
      {
        "name": "RenderStackTrace_DetailedFlat",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=DetailedFlat}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessageContains(\" => [Void RenderStackTrace_DetailedFlat()] => [Void RenderMe(NLog.LogFactory, System.String)]\");\n        }"
      },
      {
        "name": "RenderStackTraceReversed_DetailedFlat",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${message} ${stacktrace:format=DetailedFlat:reverse=true}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            RenderMe(logFactory, \"I am:\");\n            logFactory.AssertDebugLastMessageContains(\"[Void RenderMe(NLog.LogFactory, System.String)] => [Void RenderStackTraceReversed_DetailedFlat()] => \");\n        }"
      }
    ]
  },
  {
    "file": "TempDirRendererTests.cs",
    "methods": [
      {
        "name": "RenderTempDir",
        "body": "{\n            Layout layout = \"${tempdir}\";\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(Path.GetTempPath(), actual);\n        }"
      },
      {
        "name": "RenderTempDir_with_file_and_dir",
        "body": "{\n            Layout layout = \"${tempdir:dir=test:file=file1.txt}\";\n\n            layout.Initialize(null);\n            string actual = layout.Render(LogEventInfo.CreateNullEvent());\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(Path.Combine(Path.Combine(Path.GetTempPath(), \"test\" + Path.DirectorySeparatorChar), \"file1.txt\"), actual);\n        }"
      }
    ]
  },
  {
    "file": "ThreadNameTests.cs",
    "methods": [
      {
        "name": "ThreadNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${threadname} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            if (string.IsNullOrEmpty(System.Threading.Thread.CurrentThread.Name))\n                System.Threading.Thread.CurrentThread.Name = \"mythreadname\";\n\n            logFactory.GetLogger(\"A\").Debug(\"a\");\n            logFactory.AssertDebugLastMessage(System.Threading.Thread.CurrentThread.Name + \" a\");\n        }"
      }
    ]
  },
  {
    "file": "TicksLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderTicksLayoutRenderer",
        "body": "{\n            Layout layout = \"${ticks}\";\n\n            var logEventInfo = LogEventInfo.Create(LogLevel.Debug, \"logger1\", \"test message\");\n            var now = DateTime.Now;\n            logEventInfo.TimeStamp = now;\n            string actual = layout.Render(logEventInfo);\n            layout.Close();\n\n\n            Assert.NotNull(actual);\n            Assert.Equal(actual, now.Ticks.ToString(CultureInfo.InvariantCulture));\n        }"
      }
    ]
  },
  {
    "file": "TimeTests.cs",
    "methods": [
      {
        "name": "UniversalTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateLocalTimeSource();\n\n                var dt = new TimeLayoutRenderer();\n                dt.UniversalTime = true;\n\n                var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(ei.TimeStamp.ToUniversalTime().ToString(\"HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "LocalTimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();\n\n                var dt = new TimeLayoutRenderer();\n                dt.UniversalTime = false;\n\n                var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n                Assert.Equal(ei.TimeStamp.ToLocalTime().ToString(\"HH:mm:ss.ffff\", CultureInfo.InvariantCulture), dt.Render(ei));\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      },
      {
        "name": "LocalTimeGermanTest",
        "body": "{\n            var dt = new TimeLayoutRenderer() { Culture = new CultureInfo(\"de-DE\") };\n            dt.UniversalTime = false;\n\n            var ei = new LogEventInfo(LogLevel.Info, \"logger\", \"msg\");\n            Assert.Equal(ei.TimeStamp.ToString(\"HH:mm:ss,ffff\", CultureInfo.InvariantCulture), dt.Render(ei));\n        }"
      },
      {
        "name": "TimeTest",
        "body": "{\n            var orgTimeSource = NLog.Time.TimeSource.Current;\n\n            try\n            {\n                NLog.Time.TimeSource.Current = new NLog.Time.AccurateUtcTimeSource();\n\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${time}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n                logFactory.GetLogger(\"d\").Debug(\"zzz\");\n                string date = GetDebugLastMessage(\"debug\", logFactory);\n                Assert.Equal(13, date.Length);\n                Assert.Equal(':', date[2]);\n                Assert.Equal(':', date[5]);\n                Assert.Equal('.', date[8]);\n            }\n            finally\n            {\n                NLog.Time.TimeSource.Current = orgTimeSource;\n            }\n        }"
      }
    ]
  },
  {
    "file": "VariableLayoutRendererTests.cs",
    "methods": [
      {
        "name": "Var_from_xml",
        "body": "{\n            // Arrange\n            var logFactory = CreateConfigFromXml();\n            var logger = logFactory.GetLogger(\"A\");\n\n            // Act\n            logger.Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\"msg and admin=realgoodpassword\");\n            Assert.Equal(2, logFactory.Configuration.Variables.Count);\n            Assert.Equal(2, logFactory.Configuration.Variables.Keys.Count);\n            Assert.Equal(2, logFactory.Configuration.Variables.Values.Count);\n            Assert.True(logFactory.Configuration.Variables.ContainsKey(\"uSeR\"));\n            Assert.True(logFactory.Configuration.Variables.TryGetValue(\"passWORD\", out var _));\n        }"
      },
      {
        "name": "Var_from_xml_and_edit",
        "body": "{\n            // Arrange\n            var logFactory = CreateConfigFromXml();\n            var logger = logFactory.GetLogger(\"A\");\n\n            // Act\n            logFactory.Configuration.Variables[\"password\"] = \"123\";\n            logger.Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\"msg and admin=123\");\n        }"
      },
      {
        "name": "Var_from_xml_and_clear",
        "body": "{\n            // Arrange\n            var logFactory = CreateConfigFromXml();\n            var logger = logFactory.GetLogger(\"A\");\n\n            // Act\n            logFactory.Configuration.Variables.Clear();\n            logger.Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\"msg and =\");\n        }"
      },
      {
        "name": "Var_with_layout_renderers",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <variable name='user' value='logger=${logger}' />\n                <variable name='password' value='realgoodpassword' />\n\n                <targets>\n                    <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.Configuration.Variables[\"password\"] = \"123\";\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n\n            var lastMessage = GetDebugLastMessage(\"debug\", logFactory);\n            Assert.Equal(\"msg and logger=A=123\", lastMessage);\n        }"
      },
      {
        "name": "Var_Layout_Target_CallSite",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                .LoadConfigurationFromXml(@\"<nlog throwExceptions='true'>\n                    <variable name='myvar' value='${callsite}' />\n                    <targets>\n                        <target name='debug' type='Debug' layout='${var:myvar}' />\n                    </targets>\n                    <rules>\n                        <logger name='*' minLevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            // Act\n            logFactory.GetCurrentClassLogger().Info(\"Hello\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(GetType().ToString() + \".\" + nameof(Var_Layout_Target_CallSite));\n        }"
      },
      {
        "name": "Var_with_other_var",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <variable name='user' value='${var:password}=' />\n                <variable name='password' value='realgoodpassword' />\n\n                <targets>\n                    <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.Configuration.Variables[\"password\"] = \"123\";\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n\n            logFactory.AssertDebugLastMessage(\"msg and 123==123\");\n        }"
      },
      {
        "name": "Var_from_api",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <targets>\n                    <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            logFactory.Configuration.Variables[\"user\"] = \"admin\";\n            logFactory.Configuration.Variables[\"password\"] = \"123\";\n            var logger = logFactory.GetLogger(\"A\");\n\n            logger.Debug(\"msg\");\n            logFactory.AssertDebugLastMessage(\"msg and admin=123\");\n        }"
      },
      {
        "name": "Var_default",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <variable name='user' value='admin' />\n\n                <targets>\n                    <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password:default=unknown}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n\n            logFactory.AssertDebugLastMessage(\"msg and admin=unknown\");\n        }"
      },
      {
        "name": "Var_default_after_clear",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <variable name='user' value='admin' />\n                <variable name='password' value='realgoodpassword' />\n\n                <targets>\n                    <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password:default=unknown}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logFactory.Configuration.Variables.Remove(\"password\");\n            logger.Debug(\"msg\");\n\n            logFactory.AssertDebugLastMessage(\"msg and admin=unknown\");\n        }"
      },
      {
        "name": "Var_default_after_set_null",
        "body": "{\n            // Arrange\n            var logFactory = CreateConfigFromXml();\n            var logger = logFactory.GetLogger(\"A\");\n\n            // Act\n            logFactory.Configuration.Variables[\"password\"] = null;\n            logger.Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\"msg and admin=\");\n        }"
      },
      {
        "name": "Var_default_after_set_emptyString",
        "body": "{\n            // Arrange\n            var logFactory = CreateConfigFromXml();\n            var logger = logFactory.GetLogger(\"A\");\n\n            // Act\n            logFactory.Configuration.Variables[\"password\"] = \"\";\n            logger.Debug(\"msg\");\n\n            // Assert\n            logFactory.AssertDebugLastMessage(\"msg and admin=\");\n        }"
      },
      {
        "name": "Var_default_after_xml_emptyString",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <variable name='user' value='admin' />\n                <variable name='password' value='' />\n\n                <targets>\n                    <target name='debug' type='Debug' layout= '${message} and ${var:user}=${var:password}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n\n            logFactory.AssertDebugLastMessage(\"msg and admin=\");\n        }"
      },
      {
        "name": "null_should_be_ok",
        "body": "{\n            Layout l = \"${var:var1}\";\n            var config = new LoggingConfiguration();\n            config.Variables[\"var1\"] = null;\n            l.Initialize(config);\n            var result = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(\"\", result);\n        }"
      },
      {
        "name": "null_should_not_use_default",
        "body": "{\n            Layout l = \"${var:var1:default=x}\";\n            var config = new LoggingConfiguration();\n            config.Variables[\"var1\"] = null;\n            l.Initialize(config);\n            var result = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(\"\", result);\n        }"
      },
      {
        "name": "notset_should_use_default",
        "body": "{\n            Layout l = \"${var:var1:default=x}\";\n            var config = new LoggingConfiguration();\n            l.Initialize(config);\n            var result = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(\"x\", result);\n        }"
      },
      {
        "name": "test_with_mockLogManager",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(new DebugTarget\n                {\n                    Name = \"Debug\",\n                    Layout = \"${message}|${var:var1:default=x}\"\n                });\n                builder.Configuration.Variables[\"var1\"] = \"my-mocking-manager\";\n            }).LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n\n            logFactory.AssertDebugLastMessage(\"msg|my-mocking-manager\");\n        }"
      }
    ]
  },
  {
    "file": "CachedTests.cs",
    "methods": [
      {
        "name": "CachedLayoutRendererWrapper",
        "body": "{\n            SimpleLayout l = \"${guid}\";\n\n            string s1 = l.Render(LogEventInfo.CreateNullEvent());\n            string s2 = l.Render(LogEventInfo.CreateNullEvent());\n            string s3;\n\n            // normally GUIDs are never the same\n            Assert.NotEqual(s1, s2);\n\n            // but when you apply ${cached}, the guid will only be generated once\n            l = \"${cached:${guid}:cached=true}\";\n            s1 = l.Render(LogEventInfo.CreateNullEvent());\n            s2 = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(s1, s2);\n\n            // calling Close() on Layout Renderer will reset the cached value\n            l.Renderers[0].Close();\n            s3 = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.NotEqual(s2, s3);\n\n            // unless we use clearcache=none\n            l = \"${cached:${guid}:cached=true:clearcache=none}\";\n            s1 = l.Render(LogEventInfo.CreateNullEvent());\n            l.Renderers[0].Close();\n            s2 = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(s1, s2);\n\n            // another way to achieve the same thing is using cached=true\n            l = \"${guid:cached=true}\";\n            s1 = l.Render(LogEventInfo.CreateNullEvent());\n            s2 = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(s1, s2);\n\n            // another way to achieve the same thing is using cached=true\n            l = \"${guid:cached=false}\";\n            s1 = l.Render(LogEventInfo.CreateNullEvent());\n            s2 = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.NotEqual(s1, s2);\n        }"
      },
      {
        "name": "CacheKeyTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n            <nlog>\n                <targets><target name='debug' type='debug' layout='${cached:${guid}:cached=true:cachekey=${var:var1}}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='debug' appendto='debug'>\n\n                    </logger>\n                </rules>\n            </nlog>\");\n            LogManager.Configuration.Variables[\"var1\"] = \"a\";\n\n            var logger = LogManager.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n            var s1 = GetDebugLastMessage(\"debug\");\n            logger.Debug(\"msg\");\n            var s2 = GetDebugLastMessage(\"debug\");\n            Assert.NotEmpty(s1);\n            Assert.Equal(s1, s2);\n            //change var will reset cache\n            LogManager.Configuration.Variables[\"var1\"] = \"b\";\n            logger.Debug(\"msg\");\n            var s3 = GetDebugLastMessage(\"debug\");\n            Assert.NotEmpty(s3);\n            Assert.NotEqual(s1, s3);\n        }"
      },
      {
        "name": "CachedSecondsTimeoutTest",
        "body": "{\n            SimpleLayout l = \"${guid:cachedSeconds=60}\";\n            var s1 = l.Render(LogEventInfo.CreateNullEvent());\n            var s2 = l.Render(new LogEventInfo());\n            Assert.Equal(s1, s2);\n            var s3 = l.Render(new LogEventInfo() { TimeStamp = NLog.Time.TimeSource.Current.Time.AddMinutes(2) });\n            Assert.NotEqual(s2, s3);\n        }"
      }
    ]
  },
  {
    "file": "FileSystemNormalizeTests.cs",
    "methods": [
      {
        "name": "FSNormalizeTest1",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \"abc.log\");\n            SimpleLayout l = \"${filesystem-normalize:${scopeproperty:foo}}\";\n\n            Assert.Equal(\"abc.log\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            ScopeContext.PushProperty(\"foo\", \"\");\n            Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            ScopeContext.PushProperty(\"foo\", \"a/b/c\");\n            Assert.Equal(\"a_b_c\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            // all characters outside of alpha/digits/space/_/./- are replaced with _\n            ScopeContext.PushProperty(\"foo\", \":\\\\/$@#$%^\");\n            Assert.Equal(\"_________\", l.Render(LogEventInfo.CreateNullEvent()));\n        }"
      },
      {
        "name": "FSNormalizeTest2",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \"abc.log\");\n            SimpleLayout l = \"${scopeproperty:foo:fsnormalize=true}\";\n\n            Assert.Equal(\"abc.log\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            ScopeContext.PushProperty(\"foo\", \"\");\n            Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            ScopeContext.PushProperty(\"foo\", \"a/b/c\");\n            Assert.Equal(\"a_b_c\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            // all characters outside of alpha/digits/space/_/./- are replaced with _\n            ScopeContext.PushProperty(\"foo\", \":\\\\/$@#$%^\");\n            Assert.Equal(\"_________\", l.Render(LogEventInfo.CreateNullEvent()));\n        }"
      }
    ]
  },
  {
    "file": "JsonEncodeTests.cs",
    "methods": [
      {
        "name": "JsonEncodeTest1",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \" abc\\\"\\n\\b\\r\\f\\t/\\u1234\\u5432\\\\xyz \");\n            SimpleLayout l = \"${json-encode:${scopeproperty:foo}:escapeForwardSlash=true}\";\n\n            Assert.Equal(@\" abc\\\"\"\\n\\b\\r\\f\\t\\/\\u1234\\u5432\\\\xyz \", l.Render(LogEventInfo.CreateNullEvent()));\n        }"
      },
      {
        "name": "JsonHyperlinkEscapeForwardSlashTest",
        "body": "{\n            SimpleLayout l = \"${json-encode:${event-properties:prop1}:escapeForwardSlash=false}\";\n\n            var url = \"https://localhost:5001/api/values\";\n\n            var logEventInfo = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"myMessage\");\n            logEventInfo.Properties[\"prop1\"] = url;\n\n            // Act\n            var result = l.Render(logEventInfo);\n\n            // Assert\n            Assert.Equal(url, result);\n        }"
      }
    ]
  },
  {
    "file": "LeftLayoutRendererWrapperTests.cs",
    "methods": []
  },
  {
    "file": "LowerCaseLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderLowerCaseLayoutRenderer",
        "body": "{\n            Layout layout = \"${message:lowercase=true}\";\n\n            layout.Initialize(null);\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            logEventInfo.Message = \"Hello test\";\n            string actual = layout.Render(logEventInfo);\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(\"hello test\", actual);\n        }"
      },
      {
        "name": "RenderLowerCaseLayoutRenderer_false",
        "body": "{\n            Layout layout = \"${lowercase:Lowercase=false:inner=${message}}\";\n\n            layout.Initialize(null);\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            logEventInfo.Message = \"Hello test\";\n            string actual = layout.Render(logEventInfo);\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(\"Hello test\", actual);\n        }"
      }
    ]
  },
  {
    "file": "ObjectPathRendererWrapperTests.cs",
    "methods": []
  },
  {
    "file": "OnExceptionTests.cs",
    "methods": [
      {
        "name": "OnExceptionTest1",
        "body": "{\n            SimpleLayout l = @\"${message}|${onexception:EXCEPTION\\:${exception:format=message}:else=Success}|${logger}\";\n\n            // no exception - ${onexception} is ignored completely\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            Assert.Equal(\"message|Success|logger\", l.Render(le));\n\n            // have exception\n            var le2 = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            le2.Exception = new InvalidOperationException(\"ExceptionMessage\");\n            Assert.Equal(\"message|EXCEPTION:ExceptionMessage|logger\", l.Render(le2));\n        }"
      }
    ]
  },
  {
    "file": "OnHasPropertiesTests.cs",
    "methods": [
      {
        "name": "OnHasPropertiesValid",
        "body": "{\n            // Arrange\n            SimpleLayout l = @\"${message:raw=true}${onhasproperties:, Properties\\: ${all-event-properties}:Else=, No Properties}\";\n            var logevent = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            logevent.Properties[\"Foo\"] = \"Bar\";\n\n            // Act\n            var result = l.Render(logevent);\n\n            // Assert\n            Assert.Equal(\"message, Properties: Foo=Bar\", result);\n        }"
      },
      {
        "name": "OnHasPropertiesEmpty",
        "body": "{\n            // Arrange\n            SimpleLayout l = @\"${message:raw=true}${onhasproperties: Properties\\:${all-event-properties}}\";\n            var logevent = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n\n            // Act\n            var result = l.Render(logevent);\n\n            // Assert\n            Assert.Equal(\"message\", result);\n        }"
      },
      {
        "name": "OnHasPropertiesElse",
        "body": "{\n            // Arrange\n            SimpleLayout l = @\"${message:raw=true}${onhasproperties: Properties\\:${all-event-properties}:else=, No Properties}\";\n            var logevent = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n\n            // Act\n            var result = l.Render(logevent);\n\n            // Assert\n            Assert.Equal(\"message, No Properties\", result);\n        }"
      }
    ]
  },
  {
    "file": "PaddingTests.cs",
    "methods": [
      {
        "name": "PositivePaddingWithLeftAlign",
        "body": "{\n            SimpleLayout l;\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");\n\n            l = @\"${message:padding=16:alignmentOnTruncation=left}\";\n            Assert.Equal(\"  VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=15:alignmentOnTruncation=left}\";\n            Assert.Equal(\" VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=14:alignmentOnTruncation=left}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=13:alignmentOnTruncation=left}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=13:alignmentOnTruncation=left:fixedLength=true}\";\n            Assert.Equal(\"VeryBigMessag\", l.Render(le));\n\n            l = @\"${level:padding=6:alignmentOnTruncation=left}\";\n            Assert.Equal(\"  Info\", l.Render(le));\n\n            l = @\"${level:padding=5:alignmentOnTruncation=left}\";\n            Assert.Equal(\" Info\", l.Render(le));\n\n            l = @\"${level:padding=4:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=3:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=2:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=2:fixedLength=true:alignmentOnTruncation=left}\";\n            Assert.Equal(\"In\", l.Render(le));\n\n            l = @\"${level:padding=1:fixedLength=true:alignmentOnTruncation=left}\";\n            Assert.Equal(\"I\", l.Render(le));\n\n            l = @\"${logger:padding=5:alignmentOnTruncation=left}\";\n            Assert.Equal(\"     \", l.Render(le));\n        }"
      },
      {
        "name": "PositivePaddingWithRightAlign",
        "body": "{\n            SimpleLayout l;\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");\n\n            l = @\"${message:padding=16:alignmentOnTruncation=right}\";\n            Assert.Equal(\"  VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=15:alignmentOnTruncation=right}\";\n            Assert.Equal(\" VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=14:alignmentOnTruncation=right}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=13:alignmentOnTruncation=right}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=13:alignmentOnTruncation=right:fixedLength=true}\";\n            Assert.Equal(\"eryBigMessage\", l.Render(le));\n\n            l = @\"${level:padding=6:alignmentOnTruncation=right}\";\n            Assert.Equal(\"  Info\", l.Render(le));\n\n            l = @\"${level:padding=5:alignmentOnTruncation=right}\";\n            Assert.Equal(\" Info\", l.Render(le));\n\n            l = @\"${level:padding=4:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=3:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=2:fixedLength=true:alignmentOnTruncation=right}\";\n            Assert.Equal(\"fo\", l.Render(le));\n\n            l = @\"${level:padding=1:fixedLength=true:alignmentOnTruncation=right}\";\n            Assert.Equal(\"o\", l.Render(le));\n\n            l = @\"${logger:padding=5:alignmentOnTruncation=right}\";\n            Assert.Equal(\"     \", l.Render(le));\n        }"
      },
      {
        "name": "NegativePaddingWithLeftAlign",
        "body": "{\n            SimpleLayout l;\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");\n\n            l = @\"${message:padding=-16:alignmentOnTruncation=left}\";\n            Assert.Equal(\"VeryBigMessage  \", l.Render(le));\n\n            l = @\"${message:padding=-15:alignmentOnTruncation=left}\";\n            Assert.Equal(\"VeryBigMessage \", l.Render(le));\n\n            l = @\"${message:padding=-14:alignmentOnTruncation=left}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=-13:alignmentOnTruncation=left}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=-13:alignmentOnTruncation=left:fixedLength=true}\";\n            Assert.Equal(\"VeryBigMessag\", l.Render(le));\n\n            l = @\"${level:padding=-6:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info  \", l.Render(le));\n\n            l = @\"${level:padding=-5:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info \", l.Render(le));\n\n            l = @\"${level:padding=-4:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=-3:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=-2:alignmentOnTruncation=left}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=-2:fixedLength=true:alignmentOnTruncation=left}\";\n            Assert.Equal(\"In\", l.Render(le));\n\n            l = @\"${level:padding=-1:fixedLength=true:alignmentOnTruncation=left}\";\n            Assert.Equal(\"I\", l.Render(le));\n\n            l = @\"${logger:padding=-5:alignmentOnTruncation=left}\";\n            Assert.Equal(\"     \", l.Render(le));\n        }"
      },
      {
        "name": "NegativePaddingWithRightAlign",
        "body": "{\n            SimpleLayout l;\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");\n\n            l = @\"${message:padding=-16:alignmentOnTruncation=right}\";\n            Assert.Equal(\"VeryBigMessage  \", l.Render(le));\n\n            l = @\"${message:padding=-15:alignmentOnTruncation=right}\";\n            Assert.Equal(\"VeryBigMessage \", l.Render(le));\n\n            l = @\"${message:padding=-14:alignmentOnTruncation=right}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=-13:alignmentOnTruncation=right}\";\n            Assert.Equal(\"VeryBigMessage\", l.Render(le));\n\n            l = @\"${message:padding=-13:alignmentOnTruncation=right:fixedLength=true}\";\n            Assert.Equal(\"eryBigMessage\", l.Render(le));\n\n            l = @\"${level:padding=-6:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info  \", l.Render(le));\n\n            l = @\"${level:padding=-5:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info \", l.Render(le));\n\n            l = @\"${level:padding=-4:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=-3:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=-2:alignmentOnTruncation=right}\";\n            Assert.Equal(\"Info\", l.Render(le));\n\n            l = @\"${level:padding=-2:fixedLength=true:alignmentOnTruncation=right}\";\n            Assert.Equal(\"fo\", l.Render(le));\n\n            l = @\"${level:padding=-1:fixedLength=true:alignmentOnTruncation=right}\";\n            Assert.Equal(\"o\", l.Render(le));\n\n            l = @\"${logger:padding=-5:alignmentOnTruncation=right}\";\n            Assert.Equal(\"     \", l.Render(le));\n        }"
      },
      {
        "name": "DefaultAlignmentIsLeft",
        "body": "{\n            SimpleLayout defaultLayout, leftLayout, rightLayout;\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"\", \"VeryBigMessage\");\n\n            defaultLayout = @\"${message:padding=5:fixedLength=true}\";\n            leftLayout = @\"${message:padding=5:fixedLength=true:alignmentOnTruncation=left}\";\n            rightLayout = @\"${message:padding=5:fixedLength=true:alignmentOnTruncation=right}\";\n\n            Assert.Equal(leftLayout.Render(le), defaultLayout.Render(le));\n            Assert.NotEqual(rightLayout.Render(le), defaultLayout.Render(le));\n        }"
      }
    ]
  },
  {
    "file": "ReplaceNewLinesTests.cs",
    "methods": [
      {
        "name": "ReplaceNewLineWithDefaultTest",
        "body": "{\n            // Arrange\n            var foo = \"bar\" + Environment.NewLine + \"123\";\n            SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar 123\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineWithDefaultTestUnix",
        "body": "{\n            // Arrange\n            var foo = \"bar\\n123\";\n            SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar 123\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineWithDefaultTestWindows",
        "body": "{\n            // Arrange\n            var foo = \"bar\\r\\n123\";\n            SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar 123\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineWithDefaultTestMixed",
        "body": "{\n            // Arrange\n            var foo = \"bar\\r\\n123\\nabc\";\n            SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar 123 abc\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineWithSpecifiedSeparationStringTest",
        "body": "{\n            // Arrange\n            var foo = \"bar\" + System.Environment.NewLine + \"123\";\n            SimpleLayout l = \"${replace-newlines:replacement=|:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar|123\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineOneLineTest",
        "body": "{\n            // Arrange\n            var foo = \"bar123\";\n            SimpleLayout l = \"${replace-newlines:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar123\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineWithNoEmptySeparationStringTest",
        "body": "{\n            // Arrange\n            var foo = \"bar\" + System.Environment.NewLine + \"123\";\n            SimpleLayout l = \"${replace-newlines:replacement=:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar123\", result);\n        }"
      },
      {
        "name": "ReplaceNewLineWithNewLineSeparationStringTest",
        "body": "{\n            // Arrange\n            var foo = \"bar\\r\\n123\\n\";\n            SimpleLayout l = \"${replace-newlines:replacement=\\\\r\\\\n:${event-properties:foo}}\";\n            // Act\n            var result = l.Render(LogEventInfo.Create(LogLevel.Info, null, null, \"{foo}\", new[] { foo }));\n            // Assert\n            Assert.Equal(\"bar\\r\\n123\\r\\n\", result);\n        }"
      }
    ]
  },
  {
    "file": "ReplaceTests.cs",
    "methods": [
      {
        "name": "ReplaceTestWithoutRegEx",
        "body": "{\n            // Arrange\n            SimpleLayout layout = @\"${replace:inner=${message}:searchFor=foo:replaceWith=BAR}\";\n\n            // Act\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));\n\n            // Assert\n            Assert.Equal(\" BAR bar bar BAR bar FOO\", result);\n        }"
      },
      {
        "name": "ReplaceTestIgnoreCaseWithoutRegEx",
        "body": "{\n            // Arrange\n            SimpleLayout layout = @\"${replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true}\";\n\n            // Act\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \" foo bar bar foo bar FOO\"));\n\n            // Assert\n            Assert.Equal(\" BAR bar bar BAR bar BAR\", result);\n        }"
      },
      {
        "name": "ReplaceTestWholeWordsWithoutRegEx",
        "body": "{\n            // Arrange\n            SimpleLayout layout = @\"${replace:inner=${message}:searchFor=foo:replaceWith=BAR:ignorecase=true:WholeWords=true}\";\n\n            // Act\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"foo bar bar foobar barfoo bar FOO\"));\n\n            // Assert\n            Assert.Equal(\"BAR bar bar foobar barfoo bar BAR\", result);\n        }"
      }
    ]
  },
  {
    "file": "RightLayoutRendererWrapperTests.cs",
    "methods": []
  },
  {
    "file": "Rot13Tests.cs",
    "methods": [
      {
        "name": "Test1",
        "body": "{\n            Assert.Equal(\"NOPQRSTUVWXYZABCDEFGHIJKLM\",\n                    Rot13LayoutRendererWrapper.DecodeRot13(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n            Assert.Equal(\"nopqrstuvwxyzabcdefghijklm0123456789\",\n                    Rot13LayoutRendererWrapper.DecodeRot13(\"abcdefghijklmnopqrstuvwxyz0123456789\"));\n            Assert.Equal(\"How can you tell an extrovert from an introvert at NSA? Va gur ryringbef, gur rkgebiregf ybbx ng gur BGURE thl'f fubrf.\",\n            Rot13LayoutRendererWrapper.DecodeRot13(\n                            \"Ubj pna lbh gryy na rkgebireg sebz na vagebireg ng AFN? In the elevators, the extroverts look at the OTHER guy's shoes.\"));\n        }"
      },
      {
        "name": "Test2",
        "body": "{\n            Layout l = \"${rot13:HELLO}\";\n            LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");\n            Assert.Equal(\"URYYB\", l.Render(lei));\n        }"
      },
      {
        "name": "Test3",
        "body": "{\n            Layout l = \"${rot13:text=HELLO}\";\n            LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");\n            Assert.Equal(\"URYYB\", l.Render(lei));\n        }"
      },
      {
        "name": "Test4",
        "body": "{\n            Layout l = \"${rot13:${event-context:aaa}}\";\n            LogEventInfo lei = LogEventInfo.Create(LogLevel.Info, \"aaa\", \"bbb\");\n            lei.Properties[\"aaa\"] = \"HELLO\";\n            Assert.Equal(\"URYYB\", l.Render(lei));\n        }"
      },
      {
        "name": "Test5",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets>\n                        <target name='debug' type='Debug' layout='${rot13:${mdc:A}}' />\n                        <target name='debug2' type='Debug' layout='${rot13:${rot13:${scopeproperty:A}}}' />\n                     </targets>\n                    <rules>\n                        <logger name='*' levels='Trace' writeTo='debug,debug2' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"NLog.UnitTests.LayoutRenderers.Rot13Tests\");\n            using (logger.PushScopeProperty(\"A\", \"Foo.Bar!\"))\n            {\n                logger.Trace(\"aaa\");\n            }\n\n            logFactory.AssertDebugLastMessage(\"Debug\", \"Sbb.One!\");\n\n            // double rot-13 should be identity\n            logFactory.AssertDebugLastMessage(\"debug2\", \"Foo.Bar!\");\n        }"
      }
    ]
  },
  {
    "file": "SubstringLayoutRendererWrapperTests.cs",
    "methods": []
  },
  {
    "file": "TrimWhiteSpaceTests.cs",
    "methods": [
      {
        "name": "TrimWhiteSpaceTest1",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \"  bar  \");\n            SimpleLayout l = \"${trim-whitespace:${scopeproperty:foo}}\";\n\n            Assert.Equal(\"bar\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            ScopeContext.PushProperty(\"foo\", \"\");\n            Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));\n\n            ScopeContext.PushProperty(\"foo\", \"    \");\n            Assert.Equal(\"\", l.Render(LogEventInfo.CreateNullEvent()));\n        }"
      }
    ]
  },
  {
    "file": "UpperCaseLayoutRendererTests.cs",
    "methods": [
      {
        "name": "RenderUpperCaseLayoutRenderer",
        "body": "{\n            Layout layout = \"${message:uppercase=true}\";\n\n            layout.Initialize(null);\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            logEventInfo.Message = \"Hello test\";\n            string actual = layout.Render(logEventInfo);\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(\"HELLO TEST\", actual);\n        }"
      },
      {
        "name": "RenderUpperCaseLayoutRenderer_false",
        "body": "{\n            Layout layout = \"${uppercase:uppercase=false:inner=${message}}\";\n\n            layout.Initialize(null);\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            logEventInfo.Message = \"Hello test\";\n            string actual = layout.Render(logEventInfo);\n            layout.Close();\n\n            Assert.NotNull(actual);\n\n            Assert.Equal(\"Hello test\", actual);\n        }"
      }
    ]
  },
  {
    "file": "WhenEmptyTests.cs",
    "methods": [
      {
        "name": "CoalesceTest",
        "body": "{\n            SimpleLayout l = @\"${message:whenEmpty=<no message>}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            Assert.Equal(\"message\", l.Render(le));\n\n            // empty log message\n            var le2 = LogEventInfo.Create(LogLevel.Info, \"logger\", \"\");\n            Assert.Equal(\"<no message>\", l.Render(le2));\n        }"
      },
      {
        "name": "CoalesceWithANestedLayout",
        "body": "{\n            SimpleLayout l = @\"${message:whenEmpty=${logger} emitted empty message}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            Assert.Equal(\"message\", l.Render(le));\n\n            // empty log message\n            var le2 = LogEventInfo.Create(LogLevel.Info, \"mylogger\", \"\");\n            Assert.Equal(\"mylogger emitted empty message\", l.Render(le2));\n        }"
      },
      {
        "name": "WhenEmpty_MissingInner_ShouldNotThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                SimpleLayout l = @\"${whenEmpty:whenEmpty=${literal:text=c:\\logs\\}:inner=${environment:LOG_DIR_XXX}}api.log\";\n                var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n                LogManager.ThrowExceptions = true;\n                Assert.Equal(\"api.log\", l.Render(le));\n            }\n        }"
      }
    ]
  },
  {
    "file": "WhenTests.cs",
    "methods": [
      {
        "name": "PositiveWhenTest",
        "body": "{\n            SimpleLayout l = @\"${message:when=logger=='logger'}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            Assert.Equal(\"message\", l.Render(le));\n        }"
      },
      {
        "name": "NegativeWhenTest",
        "body": "{\n            SimpleLayout l = @\"${message:when=logger=='logger'}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger2\", \"message\");\n            Assert.Equal(\"\", l.Render(le));\n        }"
      },
      {
        "name": "ComplexWhenTest",
        "body": "{\n            // condition is pretty complex here and includes nested layout renderers\n            // we are testing here that layout parsers property invokes Condition parser to consume the right number of characters\n            SimpleLayout l = @\"${message:when='${pad:${logger}:padding=10:padCharacter=X}'=='XXXXlogger':padding=-10:padCharacter=Y}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            Assert.Equal(\"messageYYY\", l.Render(le));\n        }"
      },
      {
        "name": "ComplexWhenTest2",
        "body": "{\n            // condition is pretty complex here and includes nested layout renderers\n            // we are testing here that layout parsers property invokes Condition parser to consume the right number of characters\n            SimpleLayout l = @\"${message:padding=-10:padCharacter=Y:when='${pad:${logger}:padding=10:padCharacter=X}'=='XXXXlogger'}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n            Assert.Equal(\"messageYYY\", l.Render(le));\n        }"
      },
      {
        "name": "WhenElseCase",
        "body": "{\n            //else cannot be invoked ambiently. First param is inner\n            SimpleLayout l = @\"${when:good:when=logger=='logger':else=better}\";\n\n            {\n                var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n                Assert.Equal(\"good\", l.Render(le));\n            }\n            {\n                var le = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message\");\n                Assert.Equal(\"better\", l.Render(le));\n            }\n        }"
      },
      {
        "name": "WhenElseCase_empty_when",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                //else cannot be invoked ambiently. First param is inner\n                SimpleLayout l = @\"${when:good:else=better}\";\n\n                {\n                    var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n                    Assert.Equal(\"good\", l.Render(le));\n                }\n                {\n                    var le = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message\");\n                    Assert.Equal(\"good\", l.Render(le));\n                }\n            }\n        }"
      },
      {
        "name": "WhenElseCase_noIf",
        "body": "{\n            //else cannot be invoked ambiently. First param is inner\n            SimpleLayout l = @\"${when:when=logger=='logger':else=better}\";\n\n            {\n                var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"message\");\n                Assert.Equal(\"\", l.Render(le));\n            }\n            {\n                var le = LogEventInfo.Create(LogLevel.Info, \"logger1\", \"message\");\n                Assert.Equal(\"better\", l.Render(le));\n            }\n        }"
      },
      {
        "name": "WhenLogLevelConditionTestLayoutRenderer",
        "body": "{\n            //else cannot be invoked ambiently. First param is inner\n            SimpleLayout l = @\"${when:when=level<=LogLevel.Info:inner=Good:else=Bad}\";\n\n            {\n                var le = LogEventInfo.Create(LogLevel.Debug, \"logger\", \"message\");\n                Assert.Equal(\"Good\", l.Render(le));\n            }\n            {\n                var le = LogEventInfo.Create(LogLevel.Error, \"logger1\", \"message\");\n                Assert.Equal(\"Bad\", l.Render(le));\n            }\n        }"
      },
      {
        "name": "WhenLogLevelConditionTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog throwExceptions='true'>\n                <targets><target name='debug' type='Debug' layout='${level} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug'>\n                    <filters>\n                        <when condition=\"\"level>=LogLevel.Info\"\" action=\"\"Log\"\"></when>\n                        <when condition='true' action='Ignore' />\n                    </filters>\n                    </logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Fatal(\"Test\");\n            logFactory.AssertDebugLastMessage(\"Fatal Test\");\n            logger.Error(\"Test\");\n            logFactory.AssertDebugLastMessage(\"Error Test\");\n            logger.Warn(\"Test\");\n            logFactory.AssertDebugLastMessage(\"Warn Test\");\n            logger.Info(\"Test\");\n            logFactory.AssertDebugLastMessage(\"Info Test\");\n            logger.Debug(\"Test\");\n            logFactory.AssertDebugLastMessage(\"Info Test\");\n            logger.Trace(\"Test\");\n            logFactory.AssertDebugLastMessage(\"Info Test\");\n        }"
      },
      {
        "name": "WhenNumericAndPropertyConditionTest",
        "body": "{\n            //else cannot be invoked ambiently. First param is inner\n            SimpleLayout l = @\"${when:when=100 < '${event-properties:item=Elapsed}':inner=Slow:else=Fast}\";\n\n            //            WhenNumericAndPropertyConditionTest_inner(l, \"a\", false);\n            WhenNumericAndPropertyConditionTest_inner(l, 101, false);\n            WhenNumericAndPropertyConditionTest_inner(l, 11, true);\n            WhenNumericAndPropertyConditionTest_inner(l, 100, true);\n            WhenNumericAndPropertyConditionTest_inner(l, 1, true);\n            WhenNumericAndPropertyConditionTest_inner(l, 2, true);\n            WhenNumericAndPropertyConditionTest_inner(l, 20, true);\n            WhenNumericAndPropertyConditionTest_inner(l, 100000, false);\n        }"
      }
    ]
  },
  {
    "file": "WrapLineTests.cs",
    "methods": [
      {
        "name": "WrapLineWithInnerLayoutDefaultTest",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \"foobar\");\n\n            SimpleLayout le = \"${wrapline:${scopeproperty:foo}:WrapLine=3}\";\n\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", le.Render(LogEventInfo.CreateNullEvent()));\n        }"
      },
      {
        "name": "WrapLineWithInnerLayoutTest",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \"foobar\");\n\n            SimpleLayout le = \"${wrapline:Inner=${scopeproperty:foo}:WrapLine=3}\";\n\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", le.Render(LogEventInfo.CreateNullEvent()));\n        }"
      },
      {
        "name": "WrapLineAtPositionOnceTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=3}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");\n\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineAtPositionOnceTextLengthNotMultipleTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=3}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"fooba\");\n\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"ba\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineMultipleTimesTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=3}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobarbaz\");\n\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\" + System.Environment.NewLine + \"baz\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineMultipleTimesTextLengthNotMultipleTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=3}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobarba\");\n\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\" + System.Environment.NewLine + \"ba\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineAtPositionAtExactTextLengthTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=6}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");\n\n            Assert.Equal(\"foobar\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineAtPositionGreaterThanTextLengthTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=10}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");\n\n            Assert.Equal(\"foobar\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineAtPositionZeroTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=0}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");\n\n            Assert.Equal(\"foobar\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineAtNegativePositionTest",
        "body": "{\n            SimpleLayout l = \"${message:wrapline=0}\";\n\n            var le = LogEventInfo.Create(LogLevel.Info, \"logger\", \"foobar\");\n\n            Assert.Equal(\"foobar\", l.Render(le));\n        }"
      },
      {
        "name": "WrapLineFromConfig",
        "body": "{\n            var configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n<nlog throwExceptions='true'>\n    <targets>\n        <target name='d1' type='Debug' layout='${message:wrapline=3}' />\n    </targets>\n    <rules>\n      <logger name=\"\"*\"\" minlevel=\"\"Trace\"\" writeTo=\"\"d1\"\" />\n    </rules>\n</nlog>\");\n\n            var d1 = configuration.FindTargetByName(\"d1\") as DebugTarget;\n            Assert.NotNull(d1);\n            var layout = d1.Layout as SimpleLayout;\n            Assert.NotNull(layout);\n\n            var result = layout.Render(new LogEventInfo(LogLevel.Info, \"Test\", \"foobar\"));\n            Assert.Equal(\"foo\" + System.Environment.NewLine + \"bar\", result);\n        }"
      }
    ]
  },
  {
    "file": "XmlEncodeTests.cs",
    "methods": [
      {
        "name": "XmlEncodeTest1",
        "body": "{\n            ScopeContext.PushProperty(\"foo\", \" abc<>&'\\\"def \");\n            SimpleLayout l = \"${xml-encode:${scopeproperty:foo}}\";\n\n            Assert.Equal(\" abc&lt;&gt;&amp;&apos;&quot;def \", l.Render(LogEventInfo.CreateNullEvent()));\n        }"
      }
    ]
  },
  {
    "file": "CompoundLayoutTests.cs",
    "methods": [
      {
        "name": "CodeCompoundLayoutIsRenderedCorrectly",
        "body": "{\n            var compoundLayout = new CompoundLayout\n            {\n                Layouts =\n                {\n                    new SimpleLayout(\"Long date - ${longdate}\"),\n                    new SimpleLayout(\"|Before| \"),\n                    new JsonLayout\n                    {\n                        Attributes =\n                        {\n                            new JsonAttribute(\"short_date\", \"${shortdate}\"),\n                            new JsonAttribute(\"message\", \"${message}\"),\n                        }\n                    },\n                    new SimpleLayout(\" |After|\"),\n                    new SimpleLayout(\"Last - ${level}\")\n                }\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 20, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello, world\"\n            };\n\n            const string expected = \"Long date - 2010-01-20 12:34:56.0000|Before| { \\\"short_date\\\": \\\"2010-01-20\\\", \\\"message\\\": \\\"hello, world\\\" } |After|Last - Info\";\n            var actual = compoundLayout.Render(logEventInfo);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "XmlCompoundLayoutWithVariables",
        "body": "{\n            const string configXml = @\"\n<nlog>\n    <variable name='jsonLayoutv0.1'>\n        <layout type='JsonLayout'>\n          <attribute name='short_date' layout='${shortdate}' />\n          <attribute name='message' layout='${message}' />\n        </layout>\n    </variable>\n    <variable name='compoundLayoutv0.1'>\n      <layout type='CompoundLayout'>\n        <layout type='SimpleLayout' text='|Before| ' />\n        <layout type='${jsonLayoutv0.1}' />\n        <layout type='SimpleLayout' text=' |After|' />\n      </layout>\n    </variable>\n    <targets>\n    <target name='compoundFile1' type='File' fileName='log.txt'>\n      <layout type='CompoundLayout'>\n        <layout type='SimpleLayout' text='|Before| ' />\n        <layout type='${jsonLayoutv0.1}' />\n        <layout type='SimpleLayout' text=' |After|' />\n      </layout>\n    </target>\n    <target name='compoundFile2' type='file' fileName='other.txt'>\n      <layout type='${compoundLayoutv0.1}' />\n    </target>\n  </targets>\n  <rules>\n  </rules>\n</nlog>\n\";\n\n            var config = XmlLoggingConfiguration.CreateFromXmlString(configXml);\n            Assert.NotNull(config);\n            var target = config.FindTargetByName<FileTarget>(\"compoundFile1\");\n            Assert.NotNull(target);\n            var compoundLayout = target.Layout as CompoundLayout;\n            Assert.NotNull(compoundLayout);\n            var layouts = compoundLayout.Layouts;\n            Assert.Equal(3, layouts.Count);\n            Assert.Equal(typeof(SimpleLayout), layouts[0].GetType());\n            Assert.Equal(typeof(JsonLayout), layouts[1].GetType());\n            Assert.Equal(typeof(SimpleLayout), layouts[2].GetType());\n            var innerJsonLayout = (JsonLayout)layouts[1];\n            Assert.Equal(typeof(JsonLayout), innerJsonLayout.GetType());\n            Assert.Equal(2, innerJsonLayout.Attributes.Count);\n            Assert.Equal(\"${shortdate}\", innerJsonLayout.Attributes[0].Layout.ToString());\n            Assert.Equal(\"${message}\", innerJsonLayout.Attributes[1].Layout.ToString());\n\n            target = config.FindTargetByName<FileTarget>(\"compoundFile2\");\n            Assert.NotNull(target);\n            compoundLayout = target.Layout as CompoundLayout;\n            Assert.NotNull(compoundLayout);\n            layouts = compoundLayout.Layouts;\n            Assert.Equal(3, layouts.Count);\n            Assert.Equal(typeof(SimpleLayout), layouts[0].GetType());\n            Assert.Equal(typeof(JsonLayout), layouts[1].GetType());\n            Assert.Equal(typeof(SimpleLayout), layouts[2].GetType());\n            innerJsonLayout = (JsonLayout)layouts[1];\n            Assert.Equal(typeof(JsonLayout), innerJsonLayout.GetType());\n            Assert.Equal(2, innerJsonLayout.Attributes.Count);\n            Assert.Equal(\"${shortdate}\", innerJsonLayout.Attributes[0].Layout.ToString());\n            Assert.Equal(\"${message}\", innerJsonLayout.Attributes[1].Layout.ToString());\n        }"
      },
      {
        "name": "XmlCompoundLayoutIsRenderedCorrectly",
        "body": "{\n            const string configXml = @\"\n<nlog>\n  <targets>\n    <target name='compoundFile' type='File' fileName='log.txt'>\n      <layout type='CompoundLayout'>\n        <layout type='SimpleLayout' text='Long date - ${longdate}' />\n        <layout type='SimpleLayout' text='|Before| ' />\n        <layout type='JsonLayout'>\n          <attribute name='short_date' layout='${shortdate}' />\n          <attribute name='message' layout='${message}' />\n        </layout>\n        <layout type='SimpleLayout' text=' |After|' />\n        <layout type='SimpleLayout' text='Last - ${level}' />\n      </layout>\n    </target>\n  </targets>\n  <rules>\n  </rules>\n</nlog>\n\";\n\n            var config = XmlLoggingConfiguration.CreateFromXmlString(configXml);\n\n            Assert.NotNull(config);\n            var target = config.FindTargetByName<FileTarget>(\"compoundFile\");\n            Assert.NotNull(target);\n            var compoundLayout = target.Layout as CompoundLayout;\n            Assert.NotNull(compoundLayout);\n            var layouts = compoundLayout.Layouts;\n            Assert.NotNull(layouts);\n            Assert.Equal(5, layouts.Count);\n            Assert.Equal(typeof(SimpleLayout), layouts[0].GetType());\n            Assert.Equal(typeof(SimpleLayout), layouts[1].GetType());\n            var innerJsonLayout = (JsonLayout)layouts[2];\n            Assert.Equal(typeof(JsonLayout), innerJsonLayout.GetType());\n            Assert.Equal(2, innerJsonLayout.Attributes.Count);\n            Assert.Equal(\"${shortdate}\", innerJsonLayout.Attributes[0].Layout.ToString());\n            Assert.Equal(\"${message}\", innerJsonLayout.Attributes[1].Layout.ToString());\n            Assert.Equal(typeof(SimpleLayout), layouts[3].GetType());\n            Assert.Equal(typeof(SimpleLayout), layouts[4].GetType());\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 20, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello, world\"\n            };\n\n            const string expected = \"Long date - 2010-01-20 12:34:56.0000|Before| { \\\"short_date\\\": \\\"2010-01-20\\\", \\\"message\\\": \\\"hello, world\\\" } |After|Last - Info\";\n            var actual = compoundLayout.Render(logEventInfo);\n            Assert.Equal(expected, actual);\n        }"
      }
    ]
  },
  {
    "file": "CsvLayoutTests.cs",
    "methods": [
      {
        "name": "EndToEndTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                  <target name='m' type='Memory'>\n                    <layout type='CSVLayout'>\n                      <column name='level' layout='${level}' />\n                      <column name='message' layout='${message}' />\n                      <column name='counter' layout='${counter}' />\n                      <delimiter>Comma</delimiter>\n                    </layout>\n                  </target>\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='m' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n            logger.Info(\"msg2\");\n            logger.Warn(\"Message with, a comma\");\n\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.MemoryTarget>(\"m\");\n            Assert.NotNull(target);\n            Assert.Equal(4, target.Logs.Count);\n            Assert.Equal(\"level,message,counter\", target.Logs[0]);\n            Assert.Equal(\"Debug,msg,1\", target.Logs[1]);\n            Assert.Equal(\"Info,msg2,2\", target.Logs[2]);\n            Assert.Equal(\"Warn,\\\"Message with, a comma\\\",3\", target.Logs[3]);\n        }"
      },
      {
        "name": "CustomHeaderTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                  <target name='m' type='Memory'>\n                    <layout type='CSVLayout'>\n                      <header>headertest</header>\n                      <column name='level' layout='${level}' quoting='Nothing' />\n                      <column name='message' layout='${message}' />\n                      <column name='counter' layout='${counter}' />\n                      <delimiter>Comma</delimiter>\n                    </layout>\n                  </target>\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='m' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n            logger.Info(\"msg2\");\n            logger.Warn(\"Message with, a comma\");\n\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.MemoryTarget>(\"m\");\n            Assert.NotNull(target);\n            Assert.Equal(4, target.Logs.Count);\n            Assert.Equal(\"headertest\", target.Logs[0]);\n            Assert.Equal(\"Debug,msg,1\", target.Logs[1]);\n            Assert.Equal(\"Info,msg2,2\", target.Logs[2]);\n            Assert.Equal(\"Warn,\\\"Message with, a comma\\\",3\", target.Logs[3]);\n        }"
      },
      {
        "name": "NoHeadersTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                  <target name='m' type='Memory'>\n                    <layout type='CSVLayout' withHeader='false'>\n                      <delimiter>Comma</delimiter>\n                      <column name='level' layout='${level}' />\n                      <column name='message' layout='${message}' />\n                      <column name='counter' layout='${counter}' />\n                    </layout>\n                  </target>\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='m' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"msg\");\n            logger.Info(\"msg2\");\n            logger.Warn(\"Message with, a comma\");\n\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.MemoryTarget>(\"m\");\n            Assert.NotNull(target);\n            Assert.Equal(3, target.Logs.Count);\n            Assert.Equal(\"Debug,msg,1\", target.Logs[0]);\n            Assert.Equal(\"Info,msg2,2\", target.Logs[1]);\n            Assert.Equal(\"Warn,\\\"Message with, a comma\\\",3\", target.Logs[2]);\n        }"
      },
      {
        "name": "CsvLayoutRenderingNoQuoting",
        "body": "{\n            var delimiters = new Dictionary<CsvColumnDelimiterMode, string>\n            {\n                { CsvColumnDelimiterMode.Auto, CultureInfo.CurrentCulture.TextInfo.ListSeparator },\n                { CsvColumnDelimiterMode.Comma, \",\" },\n                { CsvColumnDelimiterMode.Semicolon, \";\" },\n                { CsvColumnDelimiterMode.Space, \" \" },\n                { CsvColumnDelimiterMode.Tab, \"\\t\" },\n                { CsvColumnDelimiterMode.Pipe, \"|\" },\n                { CsvColumnDelimiterMode.Custom, \"zzz\" },\n            };\n\n            foreach (var delim in delimiters)\n            {\n                var csvLayout = new CsvLayout()\n                {\n                    Quoting = CsvQuotingMode.Nothing,\n                    Columns =\n                        {\n                            new CsvColumn(\"date\", \"${longdate}\"),\n                            new CsvColumn(\"level\", \"${level}\"),\n                            new CsvColumn(\"message;text\", \"${message}\"),\n                        },\n                    Delimiter = delim.Key,\n                    CustomColumnDelimiter = \"zzz\",\n                };\n\n                var ev = new LogEventInfo();\n                ev.TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56);\n                ev.Level = LogLevel.Info;\n                ev.Message = string.Concat(csvLayout.QuoteChar, \"hello, world\", csvLayout.QuoteChar);\n\n                string sep = delim.Value;\n                Assert.Equal(\"2010-01-01 12:34:56.0000\" + sep + \"Info\" + sep + \"\\\"hello, world\\\"\", csvLayout.Render(ev));\n                Assert.Equal(\"date\" + sep + \"level\" + sep + \"message;text\", csvLayout.Header.Render(ev));\n            }\n        }"
      },
      {
        "name": "CsvLayoutRenderingFullQuoting",
        "body": "{\n            var delimiters = new Dictionary<CsvColumnDelimiterMode, string>\n            {\n                { CsvColumnDelimiterMode.Auto, CultureInfo.CurrentCulture.TextInfo.ListSeparator },\n                { CsvColumnDelimiterMode.Comma, \",\" },\n                { CsvColumnDelimiterMode.Semicolon, \";\" },\n                { CsvColumnDelimiterMode.Space, \" \" },\n                { CsvColumnDelimiterMode.Tab, \"\\t\" },\n                { CsvColumnDelimiterMode.Pipe, \"|\" },\n                { CsvColumnDelimiterMode.Custom, \"zzz\" },\n            };\n\n            foreach (var delim in delimiters)\n            {\n                var csvLayout = new CsvLayout()\n                {\n                    Quoting = CsvQuotingMode.All,\n                    Columns =\n                        {\n                            new CsvColumn(\"date\", \"${longdate}\"),\n                            new CsvColumn(\"level\", \"${level}\"),\n                            new CsvColumn(\"message;text\", \"${message}\"),\n                        },\n                    QuoteChar = \"'\",\n                    Delimiter = delim.Key,\n                    CustomColumnDelimiter = \"zzz\",\n                };\n\n                var ev = new LogEventInfo();\n                ev.TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56);\n                ev.Level = LogLevel.Info;\n                ev.Message = string.Concat(csvLayout.QuoteChar, \"hello, world\", csvLayout.QuoteChar);\n\n                string sep = delim.Value;\n                Assert.Equal(\"'2010-01-01 12:34:56.0000'\" + sep + \"'Info'\" + sep + \"'''hello, world'''\", csvLayout.Render(ev));\n                Assert.Equal(\"'date'\" + sep + \"'level'\" + sep + \"'message;text'\", csvLayout.Header.Render(ev));\n            }\n        }"
      },
      {
        "name": "CsvLayoutRenderingAutoQuoting",
        "body": "{\n            var csvLayout = new CsvLayout()\n            {\n                Quoting = CsvQuotingMode.Auto,\n                Columns =\n                    {\n                        new CsvColumn(\"date\", \"${longdate}\"),\n                        new CsvColumn(\"level\", \"${level}\"),\n                        new CsvColumn(\"message;text\", \"${message}\"),\n                    },\n                QuoteChar = \"'\",\n                Delimiter = CsvColumnDelimiterMode.Semicolon,\n            };\n\n            // no quoting\n            Assert.Equal(\n                \"2010-01-01 12:34:56.0000;Info;hello, world\",\n                csvLayout.Render(new LogEventInfo\n                {\n                    TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                    Level = LogLevel.Info,\n                    Message = \"hello, world\"\n                }));\n\n            // multi-line string - requires quoting\n            Assert.Equal(\n                \"2010-01-01 12:34:56.0000;Info;'hello\\rworld'\",\n                csvLayout.Render(new LogEventInfo\n                {\n                    TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                    Level = LogLevel.Info,\n                    Message = \"hello\\rworld\"\n                }));\n\n            // multi-line string - requires quoting\n            Assert.Equal(\n                \"2010-01-01 12:34:56.0000;Info;'hello\\nworld'\",\n                csvLayout.Render(new LogEventInfo\n                {\n                    TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                    Level = LogLevel.Info,\n                    Message = \"hello\\nworld\"\n                }));\n\n            // quote character used in string, will be quoted and doubled\n            Assert.Equal(\n                \"2010-01-01 12:34:56.0000;Info;'hello''world'\",\n                csvLayout.Render(new LogEventInfo\n                {\n                    TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                    Level = LogLevel.Info,\n                    Message = \"hello'world\"\n                }));\n\n            Assert.Equal(\"date;level;'message;text'\", csvLayout.Header.Render(LogEventInfo.CreateNullEvent()));\n        }"
      },
      {
        "name": "CsvLayoutCachingTest",
        "body": "{\n            var csvLayout = new CsvLayout()\n            {\n                Quoting = CsvQuotingMode.Auto,\n                Columns =\n                    {\n                        new CsvColumn(\"date\", \"${longdate}\"),\n                        new CsvColumn(\"level\", \"${level}\"),\n                        new CsvColumn(\"message\", \"${message}\"),\n                        new CsvColumn(\"threadid\", \"${threadid}\"),\n                    },\n                QuoteChar = \"'\",\n                Delimiter = CsvColumnDelimiterMode.Semicolon,\n            };\n\n            var e1 = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello, world\"\n            };\n\n            var e2 = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 57),\n                Level = LogLevel.Info,\n                Message = \"hello, world\"\n            };\n\n            var r11 = csvLayout.Render(e1);\n            var r12 = csvLayout.Render(e1);\n            var r21 = csvLayout.Render(e2);\n            var r22 = csvLayout.Render(e2);\n\n            var h11 = csvLayout.Header.Render(e1);\n            var h12 = csvLayout.Header.Render(e1);\n            var h21 = csvLayout.Header.Render(e2);\n            var h22 = csvLayout.Header.Render(e2);\n\n            Assert.Same(r11, r12);\n            Assert.Same(r21, r22);\n\n            Assert.NotSame(r11, r21);\n            Assert.NotSame(r12, r22);\n\n            Assert.Equal(h11, h21);\n            Assert.Same(h11, h12);\n            Assert.Same(h21, h22);\n        }"
      }
    ]
  },
  {
    "file": "JsonArrayLayoutTests.cs",
    "methods": [
      {
        "name": "JsonArrayLayoutRendering",
        "body": "{\n            var jsonLayout = new JsonArrayLayout()\n            {\n                Items =\n                    {\n                        new SimpleLayout(\"${longdate}\"),\n                        new SimpleLayout(\"${level}\"),\n                        new SimpleLayout(\"${message}\"),\n                    }\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello\\n world\",\n            };\n\n            Assert.Equal(\"[ \\\"2010-01-01T12:34:56Z\\\", \\\"Info\\\", \\\"hello\\\\n world\\\" ]\", jsonLayout.Render(logEventInfo));\n        }"
      },
      {
        "name": "JsonArrayLayoutRenderingFromXml",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets>\n                        <target type='Debug' name='Debug'>\n                            <layout type='JsonArrayLayout'>\n                                <item type='SimpleLayout' text='${longdate}' />\n                                <item type='SimpleLayout' text='${level}' />\n                                <item type='SimpleLayout' text='${message}' />\n                            </layout>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger writeTo='Debug' />\n                    </rules>\n                </nlog>\n            \").LogFactory;\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello\\n world\",\n            };\n            logFactory.GetCurrentClassLogger().Log(logEventInfo);\n\n            logFactory.AssertDebugLastMessage(\"[ \\\"2010-01-01T12:34:56Z\\\", \\\"Info\\\", \\\"hello\\\\n world\\\" ]\");\n        }"
      },
      {
        "name": "JsonArrayLayoutRenderingNoSpaces",
        "body": "{\n            var jsonLayout = new JsonArrayLayout()\n            {\n                Items =\n                    {\n                        new SimpleLayout(\"${longdate}\"),\n                        new SimpleLayout(\"${level}\"),\n                        new SimpleLayout(\"${message}\"),\n                    },\n                SuppressSpaces = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello\\n world\",\n            };\n\n            Assert.Equal(\"[\\\"2010-01-01T12:34:56Z\\\",\\\"Info\\\",\\\"hello\\\\n world\\\"]\", jsonLayout.Render(logEventInfo));\n        }"
      },
      {
        "name": "JsonArrayLayoutRenderingNotEmpty",
        "body": "{\n            var jsonLayout = new JsonArrayLayout()\n            {\n                Items =\n                    {\n                        new JsonLayout() { IncludeEventProperties = true, RenderEmptyObject = false },\n                    }\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello\\n world\",\n            };\n\n            Assert.Equal(\"[ ]\", jsonLayout.Render(logEventInfo));\n        }"
      },
      {
        "name": "JsonArrayLayoutRenderingEmpty",
        "body": "{\n            var jsonLayout = new JsonArrayLayout()\n            {\n                Items =\n                    {\n                        new JsonLayout() { IncludeEventProperties = true, RenderEmptyObject = false },\n                    },\n                RenderEmptyObject = false,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello\\n world\",\n            };\n\n            Assert.Equal(\"\", jsonLayout.Render(logEventInfo));\n        }"
      },
      {
        "name": "JsonArrayLayoutObjectRendering",
        "body": "{\n            var jsonLayout = new JsonArrayLayout()\n            {\n                Items =\n                    {\n                        new JsonLayout() { Attributes = { new JsonAttribute(\"date\", \"${longdate}\") } },\n                        new JsonLayout() { Attributes = { new JsonAttribute(\"level\", \"${level}\") } },\n                        new JsonLayout() { Attributes = { new JsonAttribute(\"message\", \"${message}\") } },\n                    }\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello\\n world\",\n            };\n\n            Assert.Equal(\"[ { \\\"date\\\": \\\"2010-01-01 12:34:56.0000\\\" }, { \\\"level\\\": \\\"Info\\\" }, { \\\"message\\\": \\\"hello\\\\n world\\\" } ]\", jsonLayout.Render(logEventInfo));\n        }"
      }
    ]
  },
  {
    "file": "SimpleLayoutOutputTests.cs",
    "methods": [
      {
        "name": "VeryLongRendererOutput",
        "body": "{\n            int stringLength = 100000;\n\n            SimpleLayout l = new string('x', stringLength) + \"${message}\";\n            string output = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(new string('x', stringLength), output);\n            string output2 = l.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(new string('x', stringLength), output);\n            Assert.NotSame(output, output2);\n        }"
      },
      {
        "name": "LayoutRendererThrows",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                ConfigurationItemFactory configurationItemFactory = new ConfigurationItemFactory();\n                configurationItemFactory.LayoutRendererFactory.RegisterType<ThrowsExceptionRenderer>(\"throwsException\");\n\n                SimpleLayout l = new SimpleLayout(\"xx${throwsException}yy\", configurationItemFactory);\n                string output = l.Render(LogEventInfo.CreateNullEvent());\n                Assert.Equal(\"xxyy\", output);\n            }\n        }"
      },
      {
        "name": "SimpleLayoutCachingTest",
        "body": "{\n            var l = new SimpleLayout(\"xx${threadid}yy\");\n            var ev = LogEventInfo.CreateNullEvent();\n            string output1 = l.Render(ev);\n            string output2 = l.Render(ev);\n            Assert.Same(output1, output2);\n        }"
      },
      {
        "name": "SimpleLayoutToStringTest",
        "body": "{\n            var l = new SimpleLayout(\"xx${level}yy\");\n            Assert.Equal(\"xx${level}yy\", l.ToString());\n\n            var l2 = new SimpleLayout(ArrayHelper.Empty<LayoutRenderer>(), \"someFakeText\", ConfigurationItemFactory.Default);\n            Assert.Equal(\"someFakeText\", l2.ToString());\n\n            var l3 = new SimpleLayout(\"\");\n            Assert.Equal(\"\", l3.ToString());\n        }"
      },
      {
        "name": "LayoutRendererThrows2",
        "body": "{\n            string internalLogOutput = RunAndCaptureInternalLog(\n                () =>\n                    {\n                        using (new NoThrowNLogExceptions())\n                        {\n                            ConfigurationItemFactory configurationItemFactory = new ConfigurationItemFactory();\n                            configurationItemFactory.LayoutRendererFactory.RegisterType<ThrowsExceptionRenderer>(\"throwsException\");\n\n                            SimpleLayout l = new SimpleLayout(\"xx${throwsException:msg1}yy${throwsException:msg2}zz\", configurationItemFactory);\n                            string output = l.Render(LogEventInfo.CreateNullEvent());\n                            Assert.Equal(\"xxyyzz\", output);\n                        }\n                    },\n                    LogLevel.Warn);\n\n            Assert.Contains(\"msg1\", internalLogOutput);\n            Assert.Contains(\"msg2\", internalLogOutput);\n        }"
      },
      {
        "name": "LayoutInitTest1",
        "body": "{\n            var lr = new MockLayout();\n            Assert.Equal(0, lr.InitCount);\n            Assert.Equal(0, lr.CloseCount);\n\n            // make sure render will call Init\n            lr.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(1, lr.InitCount);\n            Assert.Equal(0, lr.CloseCount);\n\n            lr.Close();\n            Assert.Equal(1, lr.InitCount);\n            Assert.Equal(1, lr.CloseCount);\n\n            // second call to Close() will be ignored\n            lr.Close();\n            Assert.Equal(1, lr.InitCount);\n            Assert.Equal(1, lr.CloseCount);\n        }"
      },
      {
        "name": "LayoutInitTest2",
        "body": "{\n            var lr = new MockLayout();\n            Assert.Equal(0, lr.InitCount);\n            Assert.Equal(0, lr.CloseCount);\n\n            // calls to Close() will be ignored because\n            lr.Close();\n            Assert.Equal(0, lr.InitCount);\n            Assert.Equal(0, lr.CloseCount);\n\n            lr.Initialize(null);\n            Assert.Equal(1, lr.InitCount);\n\n            // make sure render will not call another Init\n            lr.Render(LogEventInfo.CreateNullEvent());\n            Assert.Equal(1, lr.InitCount);\n            Assert.Equal(0, lr.CloseCount);\n\n            lr.Close();\n            Assert.Equal(1, lr.InitCount);\n            Assert.Equal(1, lr.CloseCount);\n        }"
      },
      {
        "name": "TryGetRawValue_SingleLayoutRender_ShouldGiveRawValue",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${sequenceid}\";\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n\n            // Act\n            var success = l.TryGetRawValue(logEventInfo, out var value);\n\n            // Assert\n            Assert.True(success, \"success\");\n            Assert.IsType<int>(value);\n            Assert.True((int)value >= 0, \"(int)value >= 0\");\n        }"
      },
      {
        "name": "TryGetRawValue_MultipleLayoutRender_ShouldGiveNullRawValue",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${sequenceid} \";\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n\n            // Act\n            var success = l.TryGetRawValue(logEventInfo, out var value);\n\n            // Assert\n            Assert.False(success);\n            Assert.Null(value);\n        }"
      },
      {
        "name": "TryGetRawValue_MutableLayoutRender_ShouldGiveNullRawValue",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${event-properties:builder}\";\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            logEventInfo.Properties[\"builder\"] = new StringBuilder(\"mybuilder\");\n            l.Precalculate(logEventInfo);\n\n            // Act\n            var success = l.TryGetRawValue(logEventInfo, out var value);\n\n            // Assert\n            Assert.False(success);\n            Assert.Null(value);\n        }"
      },
      {
        "name": "TryGetRawValue_ImmutableLayoutRender_ShouldGiveRawValue",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${event-properties:correlationid}\";\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            var correlationId = Guid.NewGuid();\n            logEventInfo.Properties[\"correlationid\"] = correlationId;\n            l.Precalculate(logEventInfo);\n\n            // Act\n            var success = l.TryGetRawValue(logEventInfo, out var value);\n\n            // Assert\n            Assert.True(success, \"success\");\n            Assert.IsType<Guid>(value);\n            Assert.Equal(correlationId, value);\n        }"
      },
      {
        "name": "TryGetRawValue_WhenEmpty_ShouldNotFailWithNullException",
        "body": "{\n            // Arrange\n            SimpleLayout l = \"${event-properties:eventId:whenEmpty=0}\";\n            var logEventInfo = LogEventInfo.CreateNullEvent();\n            l.Precalculate(logEventInfo);\n\n            // Act\n            var success = l.TryGetRawValue(logEventInfo, out var value);\n\n            // Assert\n            Assert.False(success, \"Missing EventId\");\n        }"
      }
    ]
  },
  {
    "file": "ThreadAgnosticTests.cs",
    "methods": [
      {
        "name": "ThreadAgnosticTest",
        "body": "{\n            Layout l = new SimpleLayout(\"${message}\");\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "NonThreadAgnosticTest",
        "body": "{\n            Layout l = new SimpleLayout(\"${threadname}\");\n            l.Initialize(null);\n            Assert.False(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "AgnosticPlusNonAgnostic",
        "body": "{\n            Layout l = new SimpleLayout(\"${message}${threadname}\");\n            l.Initialize(null);\n            Assert.False(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "AgnosticPlusAgnostic",
        "body": "{\n            Layout l = new SimpleLayout(\"${message}${level}${logger}\");\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "WrapperOverAgnostic",
        "body": "{\n            Layout l = new SimpleLayout(\"${rot13:${message}}\");\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "DoubleWrapperOverAgnostic",
        "body": "{\n            Layout l = new SimpleLayout(\"${lowercase:${rot13:${message}}}\");\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "TripleWrapperOverAgnostic",
        "body": "{\n            Layout l = new SimpleLayout(\"${uppercase:${lowercase:${rot13:${message}}}}\");\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "TripleWrapperOverNonAgnostic",
        "body": "{\n            Layout l = new SimpleLayout(\"${uppercase:${lowercase:${rot13:${message}${threadname}}}}\");\n            l.Initialize(null);\n            Assert.False(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "ComplexAgnosticWithCondition",
        "body": "{\n            Layout l = @\"${message:padding=-10:padCharacter=Y:when='${pad:${logger}:padding=10:padCharacter=X}'=='XXXXlogger'}\";\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "ComplexNonAgnosticWithCondition",
        "body": "{\n            Layout l = @\"${message:padding=-10:padCharacter=Y:when='${pad:${threadname}:padding=10:padCharacter=X}'=='XXXXlogger'}\";\n            l.Initialize(null);\n            Assert.False(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "CsvThreadAgnostic",
        "body": "{\n            CsvLayout l = new CsvLayout()\n            {\n                Columns =\n                {\n                    new CsvColumn(\"name1\", \"${message}\"),\n                    new CsvColumn(\"name2\", \"${level}\"),\n                    new CsvColumn(\"name3\", \"${longdate}\"),\n                },\n            };\n\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "CsvNonAgnostic",
        "body": "{\n            CsvLayout l = new CsvLayout()\n            {\n                Columns =\n                {\n                    new CsvColumn(\"name1\", \"${message}\"),\n                    new CsvColumn(\"name2\", \"${threadname}\"),\n                    new CsvColumn(\"name3\", \"${longdate}\"),\n                },\n            };\n\n            l.Initialize(null);\n            Assert.False(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "CustomNotAgnosticTests",
        "body": "{\n            var cif = new ConfigurationItemFactory();\n            cif.LayoutRendererFactory.RegisterType<CustomRendererNonAgnostic>(\"customNotAgnostic\");\n            Layout l = new SimpleLayout(\"${customNotAgnostic}\", cif);\n\n            l.Initialize(null);\n            Assert.False(l.ThreadAgnostic);\n        }"
      },
      {
        "name": "CustomAgnosticTests",
        "body": "{\n            var cif = new ConfigurationItemFactory();\n            cif.LayoutRendererFactory.RegisterType<CustomRendererAgnostic>(\"customAgnostic\");\n\n            Layout l = new SimpleLayout(\"${customAgnostic}\", cif);\n\n            l.Initialize(null);\n            Assert.True(l.ThreadAgnostic);\n        }"
      }
    ]
  },
  {
    "file": "XmlLayoutTests.cs",
    "methods": [
      {
        "name": "XmlLayoutRendering",
        "body": "{\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                    {\n                        new XmlElement(\"date\", \"${longdate}\"),\n                        new XmlElement(\"level\", \"${level}\"),\n                        new XmlElement(\"message\", \"${message}\"),\n                    },\n                IndentXml = true,\n                IncludeEventProperties = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                TimeStamp = new DateTime(2010, 01, 01, 12, 34, 56),\n                Level = LogLevel.Info,\n                Message = \"hello, world\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = \"nlogPropertyValue\";\n\n            Assert.Equal(string.Format(System.Globalization.CultureInfo.InvariantCulture, @\"<logevent>{0}{1}<date>2010-01-01 12:34:56.0000</date>{0}{1}<level>Info</level>{0}{1}<message>hello, world</message>{0}{1}<property key=\"\"nlogPropertyKey\"\">nlogPropertyValue</property>{0}</logevent>\", Environment.NewLine, \"  \"), xmlLayout.Render(logEventInfo));\n        }"
      },
      {
        "name": "XmlLayoutLog4j",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <target name='debug' type='debug'>\n                            <layout type='xmllayout' elementName='log4j:event' propertiesElementName='log4j:data' propertiesElementKeyAttribute='name' propertiesElementValueAttribute='value' includeAllProperties='true' includeMdc='true' includeMdlc='true' excludeProperties='BADPROPERTYKEY' >\n                                <attribute name='logger' layout='${logger}' includeEmptyValue='true' />\n                                <attribute name='level' layout='${uppercase:${level}}' includeEmptyValue='true' />\n                                <element name='log4j:message' value='${message}' />\n                                <element name='log4j:throwable' value='${exception:format=tostring}' />\n                                <element name='log4j:locationInfo'>\n                                    <attribute name='class' layout='${callsite:methodName=false}' includeEmptyValue='true' />\n                                </element>\n                            </layout>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' minlevel='debug' appendto='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            ScopeContext.Clear();\n\n            ScopeContext.PushProperty(\"foo1\", \"bar1\");\n            ScopeContext.PushProperty(\"foo2\", \"bar2\");\n            ScopeContext.PushProperty(\"foo3\", \"bar3\");\n\n            var logger = logFactory.GetLogger(\"hello\");\n\n            var logEventInfo = LogEventInfo.Create(LogLevel.Debug, \"A\", null, null, \"some message\");\n            logEventInfo.Properties[\"nlogPropertyKey\"] = \"<nlog\\r\\nPropertyValue>\";\n            logEventInfo.Properties[\"badPropertyKey\"] = \"NOT ME\";\n            logger.Log(logEventInfo);\n\n            var target = logFactory.Configuration.FindTargetByName<NLog.Targets.DebugTarget>(\"debug\");\n            Assert.Equal(@\"<log4j:event logger=\"\"A\"\" level=\"\"DEBUG\"\"><log4j:message>some message</log4j:message><log4j:locationInfo class=\"\"NLog.UnitTests.Layouts.XmlLayoutTests\"\"/><log4j:data name=\"\"foo1\"\" value=\"\"bar1\"\"/><log4j:data name=\"\"foo2\"\" value=\"\"bar2\"\"/><log4j:data name=\"\"foo3\"\" value=\"\"bar3\"\"/><log4j:data name=\"\"nlogPropertyKey\"\" value=\"\"&lt;nlog&#13;&#10;PropertyValue&gt;\"\"/></log4j:event>\", target.LastMessage);\n        }"
      },
      {
        "name": "XmlLayout_EncodeValue_RenderXmlMessage",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                {\n                    new XmlElement(\"message\", \"${message}\"),\n                },\n            };\n\n            var logEventInfo = new LogEventInfo { Message = @\"<hello planet=\"\"earth\"\"/>\" };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>&lt;hello planet=&quot;earth&quot;/&gt;</message></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_SkipEncodeValue_RenderXmlMessage",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                {\n                    new XmlElement(\"message\", \"${message}\") { Encode = false }\n                },\n            };\n\n            var logEventInfo = new LogEventInfo { Message = @\"<hello planet=\"\"earth\"\"/>\" };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message><hello planet=\"\"earth\"\"/></message></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_IncludeEmptyValue_RenderEmptyValue",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                {\n                    new XmlElement(\"message\", \"${message}\") { IncludeEmptyValue = true },\n                },\n                IncludeEventProperties = true,\n                IncludeEmptyValue = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = null;\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message></message><property key=\"\"nlogPropertyKey\"\">null</property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_NoIndent_RendersOneLine",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                {\n                    new XmlElement(\"level\", \"${level}\"),\n                    new XmlElement(\"message\", \"${message}\"),\n                },\n                IndentXml = false,\n                IncludeEventProperties = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"message 1\",\n                Level = LogLevel.Debug\n            };\n\n            logEventInfo.Properties[\"prop1\"] = \"a\";\n            logEventInfo.Properties[\"prop2\"] = \"b\";\n            logEventInfo.Properties[\"prop3\"] = \"c\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected =\n                @\"<logevent><level>Debug</level><message>message 1</message><property key=\"\"prop1\"\">a</property><property key=\"\"prop2\"\">b</property><property key=\"\"prop3\"\">c</property></logevent>\";\n\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_ExcludeProperties_RenderNotProperty",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                {\n                    new XmlElement(\"message\", \"${message}\"),\n                },\n                IncludeEventProperties = true,\n                ExcludeProperties = new HashSet<string> { \"prop2\" }\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"message 1\"\n            };\n            logEventInfo.Properties[\"prop1\"] = \"a\";\n            logEventInfo.Properties[\"prop2\"] = \"b\";\n            logEventInfo.Properties[\"prop3\"] = \"c\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>message 1</message><property key=\"\"prop1\"\">a</property><property key=\"\"prop3\"\">c</property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_OnlyLogEventProperties_RenderRootCorrect",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                IncludeEventProperties = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"message 1\"\n            };\n            logEventInfo.Properties[\"prop1\"] = \"a\";\n            logEventInfo.Properties[\"prop2\"] = \"b\";\n            logEventInfo.Properties[\"prop3\"] = \"c\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><property key=\"\"prop1\"\">a</property><property key=\"\"prop2\"\">b</property><property key=\"\"prop3\"\">c</property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_InvalidXmlPropertyName_RenderNameCorrect",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                IncludeEventProperties = true,\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"message 1\"\n            };\n            logEventInfo.Properties[\"1prop\"] = \"a\";\n            logEventInfo.Properties[\"_2prop\"] = \"b\";\n            logEventInfo.Properties[\" 3prop\"] = \"c\";\n            logEventInfo.Properties[\"_4 prop\"] = \"d\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><_1prop>a</_1prop><_2prop>b</_2prop><_3prop>c</_3prop><_4_prop>d</_4_prop></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesAttributeNames_RenderPropertyName",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                IncludeEventProperties = true,\n                PropertiesElementName = \"p\",\n                PropertiesElementKeyAttribute = \"k\",\n                PropertiesElementValueAttribute = \"v\",\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"message 1\"\n            };\n            logEventInfo.Properties[\"prop1\"] = \"a\";\n            logEventInfo.Properties[\"prop2\"] = \"b\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><p k=\"\"prop1\"\" v=\"\"a\"\"/><p k=\"\"prop2\"\" v=\"\"b\"\"/></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyName",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                IncludeEventProperties = true,\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                PropertiesElementValueAttribute = \"v\",\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"message 1\"\n            };\n            logEventInfo.Properties[\"prop1\"] = \"a\";\n            logEventInfo.Properties[\"prop2\"] = \"b\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><prop1 v=\"\"a\"\"/><prop2 v=\"\"b\"\"/></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_DoubleNestedElements_RendersAllElements",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements =\n                {\n                    new XmlElement(\"message\", \"${message}\")\n                    {\n                        Elements =\n                        {\n                            new XmlElement(\"level\", \"${level}\")\n                        },\n                        IncludeEventProperties = true,\n                    }\n\n                },\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Level = LogLevel.Debug,\n                Message = \"message 1\"\n            };\n            logEventInfo.Properties[\"prop1\"] = \"a\";\n            logEventInfo.Properties[\"prop2\"] = \"b\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            string expected = @\"<logevent><message>message 1<level>Debug</level><property key=\"\"prop1\"\">a</property><property key=\"\"prop2\"\">b</property></message></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyDictionary",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                IncludeEventProperties = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new Dictionary<string, object> { { \"Hello\", \"World\" } };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><property key=\"\"Hello\"\">World</property></property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyDictionary",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                IncludeEventProperties = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new Dictionary<string, object> { { \"Hello\", \"World\" } };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><Hello>World</Hello></nlogPropertyKey></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyList",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                IncludeEventProperties = true,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new[] { \"Hello\", \"World\" };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><item>Hello</item><item>World</item></property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyList",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                IncludeEventProperties = true,\n                PropertiesCollectionItemName = \"node\",\n                PropertiesElementValueAttribute = \"value\",\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new[] { \"Hello\", \"World\" };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><node value=\"\"Hello\"\"/><node value=\"\"World\"\"/></nlogPropertyKey></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyObject",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                IncludeEventProperties = true,\n            };\n\n            var guid = Guid.NewGuid();\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new { Id = guid, Name = \"Hello World\", Elements = new[] { \"Earth\", \"Wind\", \"Fire\" } };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><property key=\"\"Id\"\">\" + guid.ToString() + @\"</property><property key=\"\"Name\"\">Hello World</property><property key=\"\"Elements\"\"><item>Earth</item><item>Wind</item><item>Fire</item></property></property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderPropertyObject",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                IncludeEventProperties = true,\n            };\n\n            var guid = Guid.NewGuid();\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new { Id = guid, Name = \"Hello World\", Elements = new[] { \"Earth\", \"Wind\", \"Fire\" } };\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><Id>\" + guid.ToString() + @\"</Id><Name>Hello World</Name><Elements><item>Earth</item><item>Wind</item><item>Fire</item></Elements></nlogPropertyKey></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameDefault_Properties_RenderPropertyExpando",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                IncludeEventProperties = true,\n            };\n\n            dynamic object1 = new System.Dynamic.ExpandoObject();\n            object1.Id = 123;\n            object1.Name = \"test name\";\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = object1;\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster message</message><property key=\"\"nlogPropertyKey\"\"><property key=\"\"Id\"\">123</property><property key=\"\"Name\"\">test name</property></property></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderSafeXml",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                IncludeEventProperties = true,\n                MaxRecursionLimit = 10,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster < message\"\n            };\n            logEventInfo.Properties[\"<xmltag>\"] = \"<xmltag>\";\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster &lt; message</message><_xmltag_>&lt;xmltag&gt;</_xmltag_></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderInfiniteLoop",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                IncludeEventProperties = true,\n                MaxRecursionLimit = 10,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            logEventInfo.Properties[\"nlogPropertyKey\"] = new TestList();\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            var cnt = System.Text.RegularExpressions.Regex.Matches(result, \"<item>alpha</item><item>bravo</item>\").Count;\n            Assert.Equal(10, cnt);\n        }"
      },
      {
        "name": "XmlLayout_PropertiesElementNameFormat_RenderTrickyDictionary",
        "body": "{\n            // Arrange\n            var xmlLayout = new XmlLayout()\n            {\n                Elements = { new XmlElement(\"message\", \"${message}\") },\n                PropertiesElementName = \"{0}\",\n                PropertiesElementKeyAttribute = \"\",\n                IncludeEventProperties = true,\n                MaxRecursionLimit = 10,\n            };\n\n            var logEventInfo = new LogEventInfo\n            {\n                Message = \"Monster message\"\n            };\n            IDictionary<object, object> testDictionary = new Internal.TrickyTestDictionary();\n            testDictionary.Add(\"key1\", 13);\n            testDictionary.Add(\"key 2\", 1.3m);\n            logEventInfo.Properties[\"nlogPropertyKey\"] = testDictionary;\n\n            // Act\n            var result = xmlLayout.Render(logEventInfo);\n\n            // Assert\n            const string expected = @\"<logevent><message>Monster message</message><nlogPropertyKey><key1>13</key1><key_2>1.3</key_2></nlogPropertyKey></logevent>\";\n            Assert.Equal(expected, result);\n        }"
      }
    ]
  },
  {
    "file": "LogFactoryTestExtensions.cs",
    "methods": []
  },
  {
    "file": "LogFactoryTests.cs",
    "methods": [
      {
        "name": "Flush_DoNotThrowExceptionsAndTimeout_DoesNotThrow",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml($@\"\n            <nlog throwExceptions='false'>\n                <targets>\n                    <target type='BufferingWrapper' name='test'>\n                        <target type='MethodCall' name='test_wrapped' methodName='{nameof(TestClass.GenerateTimeout)}' className='{typeof(TestClass).AssemblyQualifiedName}' />\n                    </target>\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeto='test'></logger>\n                </rules>\n            </nlog>\").LogFactory;\n\n            Logger logger = logFactory.GetCurrentClassLogger();\n            logger.Info(\"Prepare Timeout\");\n\n            Exception timeoutException = null;\n            ManualResetEvent manualResetEvent = new ManualResetEvent(false);\n\n            // Act\n            logger.Factory.Flush(TimeSpan.FromMilliseconds(1));\n            logger.Factory.Flush(ex => { timeoutException = ex; manualResetEvent.Set(); }, TimeSpan.FromMilliseconds(1));\n\n            // Assert\n            Assert.True(manualResetEvent.WaitOne(5000));\n            Assert.NotNull(timeoutException);\n        }"
      },
      {
        "name": "InvalidXMLConfiguration_DoesNotThrowErrorWhen_ThrowExceptionFlagIsNotSet",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog internalLogIncludeTimestamp='IamNotBooleanValue'>\n                <targets><target type='Debug' name='test' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeto='test'></logger>\n                </rules>\n            </nlog>\").LogFactory;\n                Assert.NotNull(logFactory.Configuration);\n            }\n        }"
      },
      {
        "name": "InvalidXMLConfiguration_ThrowErrorWhen_ThrowExceptionFlagIsSet",
        "body": "{\n            Boolean ExceptionThrown = false;\n            try\n            {\n                new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog internalLogIncludeTimestamp='IamNotBooleanValue'>\n                <targets><target type='Debug' name='test' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeto='test'></logger>\n                </rules>\n            </nlog>\");\n            }\n            catch (Exception)\n            {\n                ExceptionThrown = true;\n            }\n\n            Assert.True(ExceptionThrown);\n        }"
      },
      {
        "name": "Configuration_InaccessibleNLog_doesNotThrowException",
        "body": "{\n            string tempDirectory = null;\n\n            try\n            {\n                // Arrange\n                var logFactory = CreateEmptyNLogFile(out tempDirectory, out var configFile);\n                using (OpenStream(configFile))\n                {\n                    // Act\n                    var loggingConfig = logFactory.Configuration;\n\n                    // Assert\n                    Assert.Null(loggingConfig);\n                }\n\n                // Assert\n                Assert.NotNull(logFactory.Configuration);\n            }\n            finally\n            {\n                if (tempDirectory != null && Directory.Exists(tempDirectory))\n                    Directory.Delete(tempDirectory, true);\n            }\n        }"
      },
      {
        "name": "LoadConfiguration_InaccessibleNLog_throwException",
        "body": "{\n            string tempDirectory = null;\n\n            try\n            {\n                // Arrange\n                var logFactory = CreateEmptyNLogFile(out tempDirectory, out var configFile);\n                using (OpenStream(configFile))\n                {\n                    // Act\n                    var ex = Record.Exception(() => logFactory.LoadConfiguration(configFile));\n\n                    // Assert\n                    Assert.IsType<FileNotFoundException>(ex);\n                }\n\n                // Assert\n                Assert.NotNull(logFactory.LoadConfiguration(configFile).Configuration);\n            }\n            finally\n            {\n                if (tempDirectory != null && Directory.Exists(tempDirectory))\n                    Directory.Delete(tempDirectory, true);\n            }\n        }"
      },
      {
        "name": "SecondaryLogFactoryDoesNotTakePrimaryLogFactoryLock",
        "body": "{\n            File.WriteAllText(\"NLog.config\", \"<nlog />\");\n            try\n            {\n                bool threadTerminated;\n\n                var primaryLogFactory = LogManager.LogFactory;\n                var primaryLogFactoryLock = primaryLogFactory._syncRoot;\n                // Simulate a potential deadlock.\n                // If the creation of the new LogFactory takes the lock of the global LogFactory, the thread will deadlock.\n                lock (primaryLogFactoryLock)\n                {\n                    var thread = new Thread(() =>\n                    {\n                        (new LogFactory()).GetCurrentClassLogger();\n                    });\n                    thread.Start();\n                    threadTerminated = thread.Join(TimeSpan.FromSeconds(1));\n                }\n\n                Assert.True(threadTerminated);\n            }\n            finally\n            {\n                try\n                {\n                    File.Delete(\"NLog.config\");\n                }\n                catch { }\n            }\n        }"
      },
      {
        "name": "NewAttrOnNLogLevelShouldNotThrowError",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog imAnewAttribute='noError'>\n                    <targets><target type='file' name='f1' filename='test.log' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeto='f1'></logger>\n                    </rules>\n                </nlog>\").LogFactory;\n                Assert.NotNull(logFactory.Configuration);\n            }\n        }"
      },
      {
        "name": "SuspendAndResumeLogging_InOrder",
        "body": "{\n            LogFactory factory = new LogFactory();\n\n            // In order Suspend => Resume [Case 1]\n            Assert.True(factory.IsLoggingEnabled());\n            factory.SuspendLogging();\n            Assert.False(factory.IsLoggingEnabled());\n            factory.ResumeLogging();\n            Assert.True(factory.IsLoggingEnabled());\n\n            // In order Suspend => Resume [Case 2]\n            using (var factory2 = new LogFactory())\n            {\n                Assert.True(factory.IsLoggingEnabled());\n                factory.SuspendLogging();\n                Assert.False(factory.IsLoggingEnabled());\n                factory.ResumeLogging();\n                Assert.True(factory.IsLoggingEnabled());\n            }\n        }"
      },
      {
        "name": "SuspendAndResumeLogging_OutOfOrder",
        "body": "{\n            LogFactory factory = new LogFactory();\n\n            // Out of order Resume => Suspend => (Suspend => Resume)\n            factory.ResumeLogging();\n            Assert.True(factory.IsLoggingEnabled());\n            factory.SuspendLogging();\n            Assert.True(factory.IsLoggingEnabled());\n            factory.SuspendLogging();\n            Assert.False(factory.IsLoggingEnabled());\n            factory.ResumeLogging();\n            Assert.True(factory.IsLoggingEnabled());\n        }"
      },
      {
        "name": "LogFactory_GetLoggerWithNull_ShouldThrow",
        "body": "{\n            LogFactory factory = new LogFactory();\n            Assert.Throws<ArgumentNullException>(() => factory.GetLogger(null));\n        }"
      },
      {
        "name": "PurgeObsoleteLoggersTest",
        "body": "{\n            var factory = new LogFactory();\n            var logger = GetWeakReferenceToTemporaryLogger(factory);\n            Assert.NotNull(logger);\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n            factory.ReconfigExistingLoggers(true);\n            var loggerKeysCount = factory.ResetLoggerCache();\n            Assert.Equal(0, loggerKeysCount);\n\n            logger = GetWeakReferenceToTemporaryLogger(factory);\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n            factory.ReconfigExistingLoggers();\n            factory.ReconfigExistingLoggers(false);\n            loggerKeysCount = factory.ResetLoggerCache();\n            Assert.Equal(1, loggerKeysCount);\n        }"
      }
    ]
  },
  {
    "file": "LogLevelTests.cs",
    "methods": [
      {
        "name": "LogLevelTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"Debug a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"Info a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"Warn a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"Error a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"Fatal a\");\n        }"
      },
      {
        "name": "LogLevelUppercaseTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:uppercase=true} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            ILogger logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"DEBUG a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"INFO a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"WARN a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"ERROR a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"FATAL a\");\n        }"
      },
      {
        "name": "LogLevelSingleCharacterTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=FirstCharacter} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"T a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"D a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"I a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"W a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"E a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"F a\");\n        }"
      },
      {
        "name": "LogLevelOrdinalTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=Ordinal} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"0 a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"1 a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"2 a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"3 a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"4 a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"5 a\");\n        }"
      },
      {
        "name": "LogLevelFullNameTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=FullName} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"Trace a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"Debug a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"Information a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"Warning a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"Error a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"Fatal a\");\n        }"
      },
      {
        "name": "LogLevelTriLetterTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets><target name='debug' type='Debug' layout='${level:format=TriLetter} ${message}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Trace' writeTo='debug' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Trace(\"a\");\n            logFactory.AssertDebugLastMessage(\"Trc a\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"Dbg a\");\n            logger.Info(\"a\");\n            logFactory.AssertDebugLastMessage(\"Inf a\");\n            logger.Warn(\"a\");\n            logFactory.AssertDebugLastMessage(\"Wrn a\");\n            logger.Error(\"a\");\n            logFactory.AssertDebugLastMessage(\"Err a\");\n            logger.Fatal(\"a\");\n            logFactory.AssertDebugLastMessage(\"Ftl a\");\n        }"
      },
      {
        "name": "LogLevelGetTypeCodeTest",
        "body": "{\n            // Arrange\n            var logLevel = LogLevel.Info;\n\n            // Act\n            var result = Convert.GetTypeCode(logLevel);\n\n            // Assert\n            Assert.Equal(TypeCode.Object, result);\n        }"
      }
    ]
  },
  {
    "file": "LogManagerTests.cs",
    "methods": [
      {
        "name": "GetLoggerTest",
        "body": "{\n            var loggerA = LogManager.GetLogger(\"A\");\n            var loggerA2 = LogManager.GetLogger(\"A\");\n            var loggerB = LogManager.GetLogger(\"B\");\n            Assert.Same(loggerA, loggerA2);\n            Assert.NotSame(loggerA, loggerB);\n            Assert.Equal(\"A\", loggerA.Name);\n            Assert.Equal(\"B\", loggerB.Name);\n        }"
      },
      {
        "name": "GarbageCollectionTest",
        "body": "{\n            string uniqueLoggerName = Guid.NewGuid().ToString();\n            var loggerA1 = LogManager.GetLogger(uniqueLoggerName);\n            GC.Collect();\n            var loggerA2 = LogManager.GetLogger(uniqueLoggerName);\n            Assert.Same(loggerA1, loggerA2);\n        }"
      },
      {
        "name": "GarbageCollection2Test",
        "body": "{\n            WeakReference wr = GetWeakReferenceToTemporaryLogger();\n\n            // nobody's holding a reference to this Logger anymore, so GC.Collect(2) should free it\n            GC.Collect(2, GCCollectionMode.Forced, true);\n            Assert.False(wr.IsAlive);\n        }"
      },
      {
        "name": "NullLoggerTest",
        "body": "{\n            var logger = LogManager.CreateNullLogger();\n            Assert.Equal(String.Empty, logger.Name);\n        }"
      },
      {
        "name": "GlobalThresholdTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog globalThreshold='Info'>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            Assert.Equal(LogLevel.Info, logFactory.GlobalThreshold);\n\n            // nothing gets logged because of globalThreshold\n            logFactory.GetLogger(\"A\").Debug(\"xxx\");\n            logFactory.AssertDebugLastMessage(\"debug\", \"\");\n\n            // lower the threshold\n            logFactory.GlobalThreshold = LogLevel.Trace;\n\n            logFactory.GetLogger(\"A\").Debug(\"yyy\");\n            logFactory.AssertDebugLastMessage(\"debug\", \"yyy\");\n\n            // raise the threshold\n            logFactory.GlobalThreshold = LogLevel.Info;\n\n            // this should be yyy, meaning that the target is in place\n            // only rules have been modified.\n\n            logFactory.GetLogger(\"A\").Debug(\"zzz\");\n            logFactory.AssertDebugLastMessage(\"debug\", \"yyy\");\n        }"
      },
      {
        "name": "DisableLoggingTest_UsingStatement",
        "body": "{\n            const string LoggerConfig = @\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='DisableLoggingTest_UsingStatement_A' levels='Trace' writeTo='debug' />\n                        <logger name='DisableLoggingTest_UsingStatement_B' levels='Error' writeTo='debug' />\n                    </rules>\n                </nlog>\";\n\n            // Disable/Enable logging should affect ALL the loggers.\n            var loggerA = LogManager.GetLogger(\"DisableLoggingTest_UsingStatement_A\");\n            var loggerB = LogManager.GetLogger(\"DisableLoggingTest_UsingStatement_B\");\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(LoggerConfig);\n\n            // The starting state for logging is enable.\n            Assert.True(LogManager.IsLoggingEnabled());\n\n            loggerA.Trace(\"TTT\");\n            AssertDebugLastMessage(\"debug\", \"TTT\");\n\n            loggerB.Error(\"EEE\");\n            AssertDebugLastMessage(\"debug\", \"EEE\");\n\n            loggerA.Trace(\"---\");\n            AssertDebugLastMessage(\"debug\", \"---\");\n\n            using (LogManager.SuspendLogging())\n            {\n                Assert.False(LogManager.IsLoggingEnabled());\n\n                // The last of LastMessage outside using statement should be returned.\n\n                loggerA.Trace(\"TTT\");\n                AssertDebugLastMessage(\"debug\", \"---\");\n\n                loggerB.Error(\"EEE\");\n                AssertDebugLastMessage(\"debug\", \"---\");\n            }\n\n            Assert.True(LogManager.IsLoggingEnabled());\n\n            loggerA.Trace(\"TTT\");\n            AssertDebugLastMessage(\"debug\", \"TTT\");\n\n            loggerB.Error(\"EEE\");\n            AssertDebugLastMessage(\"debug\", \"EEE\");\n\n            LogManager.Shutdown();\n            LogManager.Configuration = null;\n        }"
      },
      {
        "name": "DisableLoggingTest_WithoutUsingStatement",
        "body": "{\n            const string LoggerConfig = @\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${message}' /></targets>\n                    <rules>\n                        <logger name='DisableLoggingTest_WithoutUsingStatement_A' levels='Trace' writeTo='debug' />\n                        <logger name='DisableLoggingTest_WithoutUsingStatement_B' levels='Error' writeTo='debug' />\n                    </rules>\n                </nlog>\";\n\n            // Disable/Enable logging should affect ALL the loggers.\n            var loggerA = LogManager.GetLogger(\"DisableLoggingTest_WithoutUsingStatement_A\");\n            var loggerB = LogManager.GetLogger(\"DisableLoggingTest_WithoutUsingStatement_B\");\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(LoggerConfig);\n\n            // The starting state for logging is enable.\n            Assert.True(LogManager.IsLoggingEnabled());\n\n            loggerA.Trace(\"TTT\");\n            AssertDebugLastMessage(\"debug\", \"TTT\");\n\n            loggerB.Error(\"EEE\");\n            AssertDebugLastMessage(\"debug\", \"EEE\");\n\n            loggerA.Trace(\"---\");\n            AssertDebugLastMessage(\"debug\", \"---\");\n\n            LogManager.SuspendLogging();\n            Assert.False(LogManager.IsLoggingEnabled());\n\n            // The last value of LastMessage before DisableLogging() should be returned.\n\n            loggerA.Trace(\"TTT\");\n            AssertDebugLastMessage(\"debug\", \"---\");\n\n            loggerB.Error(\"EEE\");\n            AssertDebugLastMessage(\"debug\", \"---\");\n\n            LogManager.ResumeLogging();\n\n            Assert.True(LogManager.IsLoggingEnabled());\n\n            loggerA.Trace(\"TTT\");\n            AssertDebugLastMessage(\"debug\", \"TTT\");\n\n            loggerB.Error(\"EEE\");\n            AssertDebugLastMessage(\"debug\", \"EEE\");\n\n            LogManager.Shutdown();\n            LogManager.Configuration = null;\n        }"
      },
      {
        "name": "GivenCurrentClass_WhenGetCurrentClassLogger_ThenLoggerShouldBeCurrentClass",
        "body": "{\n            var logger = LogManager.GetCurrentClassLogger();\n\n            Assert.Equal(GetType().FullName, logger.Name);\n        }"
      },
      {
        "name": "GetCurrentClassLogger_static_class",
        "body": "{\n            ImAStaticClass.DummyToInvokeInitializers();\n            Assert.Equal(typeof(ImAStaticClass).FullName, ImAStaticClass.Logger.Name);\n        }"
      },
      {
        "name": "GetCurrentClassLogger_abstract_class",
        "body": "{\n            var instance = new InheritedFromAbstractClass();\n            Assert.Equal(instance.BaseName, instance.Logger.Name);\n            Assert.Equal(instance.BaseName, instance.LoggerType.Name);\n            Assert.Equal(instance.InheritedName, instance.LoggerInherited.Name);\n            Assert.Equal(instance.InheritedName, instance.LoggerTypeInherited.Name);\n        }"
      },
      {
        "name": "GetCurrentClassLogger_abstract_class_with_parameter",
        "body": "{\n            var instance = new InheritedFromAbstractClass(\"Hello\", null);\n            Assert.Equal(instance.BaseName, instance.Logger.Name);\n            Assert.Equal(instance.BaseName, instance.LoggerType.Name);\n            Assert.Equal(instance.InheritedName, instance.LoggerInherited.Name);\n            Assert.Equal(instance.InheritedName, instance.LoggerTypeInherited.Name);\n        }"
      },
      {
        "name": "GetLogger_wrong_loggertype_should_continue",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var instance = LogManager.GetLogger(\"a\", typeof(ImNotALogger));\n                Assert.NotNull(instance);\n            }\n        }"
      },
      {
        "name": "GetLogger_wrong_loggertype_should_continue_even_if_class_is_static",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var instance = LogManager.GetLogger(\"a\", typeof(ImAStaticClass));\n                Assert.NotNull(instance);\n            }\n        }"
      },
      {
        "name": "GivenLazyClass_WhenGetCurrentClassLogger_ThenLoggerNameShouldBeCurrentClass",
        "body": "{\n            var logger = new Lazy<Logger>(LogManager.GetCurrentClassLogger);\n\n            Assert.Equal(GetType().FullName, logger.Value.Name);\n        }"
      },
      {
        "name": "ThreadSafe_Shutdown",
        "body": "{\n            LogManager.Configuration = new LoggingConfiguration();\n            LogManager.ThrowExceptions = true;\n            LogManager.Configuration.AddTarget(\"memory\", new NLog.Targets.Wrappers.BufferingTargetWrapper(new MemoryTarget() { MaxLogsCount = 500 }, 5, 1));\n            LogManager.Configuration.LoggingRules.Add(new LoggingRule(\"*\", LogLevel.Debug, LogManager.Configuration.FindTargetByName(\"memory\")));\n            LogManager.Configuration.AddTarget(\"memory2\", new NLog.Targets.Wrappers.BufferingTargetWrapper(new MemoryTarget() { MaxLogsCount = 500 }, 5, 1));\n            LogManager.Configuration.LoggingRules.Add(new LoggingRule(\"*\", LogLevel.Debug, LogManager.Configuration.FindTargetByName(\"memory2\")));\n            var stopFlag = false;\n            var exceptionThrown = false;\n            Task.Run(() => { try { var logger = LogManager.GetLogger(\"Hello\"); while (!stopFlag) { logger.Debug(\"Hello World\"); System.Threading.Thread.Sleep(1); } } catch { exceptionThrown = true; } });\n            Task.Run(() => { try { var logger = LogManager.GetLogger(\"Hello\"); while (!stopFlag) { logger.Debug(\"Hello World\"); System.Threading.Thread.Sleep(1); } } catch { exceptionThrown = true; } });\n            System.Threading.Thread.Sleep(20);\n            LogManager.Shutdown();  // Shutdown active LoggingConfiguration\n            System.Threading.Thread.Sleep(20);\n            stopFlag = true;\n            System.Threading.Thread.Sleep(20);\n            Assert.False(exceptionThrown);\n        }"
      },
      {
        "name": "ThreadSafe_getCurrentClassLogger_test",
        "body": "{\n            MemoryTarget mTarget = new MemoryTarget() { Name = \"memory\", MaxLogsCount = 1000 };\n            MemoryTarget mTarget2 = new MemoryTarget() { Name = \"memory2\", MaxLogsCount = 1000 };\n\n            var task1 = Task.Run(() =>\n            {\n                //need for init\n                LogManager.Configuration = new LoggingConfiguration();\n\n                LogManager.Configuration.AddTarget(mTarget.Name, mTarget);\n                LogManager.Configuration.AddRuleForAllLevels(mTarget.Name);\n                System.Threading.Thread.Sleep(1);\n                LogManager.ReconfigExistingLoggers();\n                System.Threading.Thread.Sleep(1);\n                mTarget.Layout = @\"${date:format=HH\\:mm\\:ss}|${level:uppercase=true}|${message} ${exception:format=tostring}\";\n            });\n\n            var task2 = task1.ContinueWith((t) =>\n            {\n                LogManager.Configuration.AddTarget(mTarget2.Name, mTarget2);\n                LogManager.Configuration.AddRuleForAllLevels(mTarget2.Name);\n                System.Threading.Thread.Sleep(1);\n                LogManager.ReconfigExistingLoggers();\n                System.Threading.Thread.Sleep(1);\n                mTarget2.Layout = @\"${date:format=HH\\:mm\\:ss}|${level:uppercase=true}|${message} ${exception:format=tostring}\";\n            });\n\n            System.Threading.Thread.Sleep(1);\n\n            Parallel.For(0, 8, new ParallelOptions() { MaxDegreeOfParallelism = 8 }, (e) =>\n            {\n                bool task1Complete = false, task2Complete = false;\n                for (int i = 0; i < 100; ++i)\n                {\n                    if (i > 25 && !task1Complete)\n                    {\n                        task1.Wait(5000);\n                        task1Complete = true;\n                    }\n                    if (i > 75 && !task2Complete)\n                    {\n                        task2.Wait(5000);\n                        task2Complete = true;\n                    }\n\n                    // Multiple threads initializing new loggers while configuration is changing\n                    var loggerA = LogManager.GetLogger(e + \"A\" + i);\n                    loggerA.Info(\"Hi there {0}\", e);\n                    var loggerB = LogManager.GetLogger(e + \"B\" + i);\n                    loggerB.Info(\"Hi there {0}\", e);\n                    var loggerC = LogManager.GetLogger(e + \"C\" + i);\n                    loggerC.Info(\"Hi there {0}\", e);\n                    var loggerD = LogManager.GetLogger(e + \"D\" + i);\n                    loggerD.Info(\"Hi there {0}\", e);\n                };\n            });\n\n            Assert.NotEqual(0, mTarget.Logs.Count + mTarget2.Logs.Count);\n        }"
      },
      {
        "name": "RemovedTargetShouldNotLog",
        "body": "{\n            var config = new LoggingConfiguration();\n            var targetA = new MemoryTarget(\"TargetA\") { Layout = \"A | ${message}\", MaxLogsCount = 1 };\n            var targetB = new MemoryTarget(\"TargetB\") { Layout = \"B | ${message}\", MaxLogsCount = 1 };\n            config.AddRule(LogLevel.Debug, LogLevel.Fatal, targetA);\n            config.AddRule(LogLevel.Debug, LogLevel.Fatal, targetB);\n\n            LogManager.Configuration = config;\n\n            Assert.Equal(new[] { \"TargetA\", \"TargetB\" }, LogManager.Configuration.ConfiguredNamedTargets.Select(target => target.Name));\n\n            Assert.NotNull(LogManager.Configuration.FindTargetByName(\"TargetA\"));\n            Assert.NotNull(LogManager.Configuration.FindTargetByName(\"TargetB\"));\n\n            var logger = LogManager.GetCurrentClassLogger();\n            logger.Info(\"Hello World\");\n\n            Assert.Equal(\"A | Hello World\", targetA.Logs.LastOrDefault());\n            Assert.Equal(\"B | Hello World\", targetB.Logs.LastOrDefault());\n\n            // Remove the first target from the configuration\n            LogManager.Configuration.RemoveTarget(\"TargetA\");\n\n            Assert.Equal(new[] { \"TargetB\" }, LogManager.Configuration.ConfiguredNamedTargets.Select(target => target.Name));\n\n            Assert.Null(LogManager.Configuration.FindTargetByName(\"TargetA\"));\n            Assert.NotNull(LogManager.Configuration.FindTargetByName(\"TargetB\"));\n\n            logger.Info(\"Goodbye World\");\n\n            Assert.Equal(\"A | Hello World\", targetA.Logs.LastOrDefault());  // Flushed and closed\n            Assert.Equal(\"B | Goodbye World\", targetB.Logs.LastOrDefault());\n        }"
      }
    ]
  },
  {
    "file": "LogMessageFormatterTests.cs",
    "methods": [
      {
        "name": "ExtensionsLoggingFormatTest",
        "body": "{\n            LogEventInfo logEventInfo = new LogEventInfo(LogLevel.Info, \"MyLogger\", \"Login request from {Username} for {Application}\", new[]\n            {\n                new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal),\n                new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal)\n            });\n            logEventInfo.Parameters = new object[] { \"Login request from John for BestApplicationEver\" };\n            logEventInfo.MessageFormatter = (logEvent) =>\n            {\n                if (logEvent.Parameters != null && logEvent.Parameters.Length > 0)\n                {\n                    return logEvent.Parameters[logEvent.Parameters.Length - 1] as string ?? logEvent.Message;\n                }\n                return logEvent.Message;\n            };\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <target name='debug' type='Debug'  >\n                                <layout type='JsonLayout' IncludeAllProperties='true'>\n                                    <attribute name='LogMessage' layout='${message:raw=true}' />\n                                </layout>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Info' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Log(logEventInfo);\n            logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"Login request from {Username} for {Application}\\\", \\\"Username\\\": \\\"John\\\", \\\"Application\\\": \\\"BestApplicationEver\\\" }\");\n\n            Assert.Equal(\"Login request from John for BestApplicationEver\", logEventInfo.FormattedMessage);\n\n            AssertContainsInDictionary(logEventInfo.Properties, \"Username\", \"John\");\n            AssertContainsInDictionary(logEventInfo.Properties, \"Application\", \"BestApplicationEver\");\n            Assert.Contains(new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n            Assert.Contains(new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n        }"
      },
      {
        "name": "ExtensionsLoggingPreFormatTest",
        "body": "{\n            LogEventInfo logEventInfo1 = new LogEventInfo(LogLevel.Info, \"MyLogger\", \"Login request from John for BestApplicationEver\", \"Login request from {Username} for {Application}\", new[]\n            {\n                new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal),\n                new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal)\n            });\n\n            LogEventInfo logEventInfo2 = new LogEventInfo(LogLevel.Info, \"MyLogger\", \"Login request from John for BestApplicationEver\", \"Login request from {Username} for {Application}\", new[]\n{\n                new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal),\n                new MessageTemplateParameter(\"Application\", new StringBuilder(\"BestApplicationEver\", 32), null, CaptureType.Normal)\n            });\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <target name='buffer' type='BufferingWrapper'>\n                            <target name='debug' type='Debug'  >\n                                    <layout type='JsonLayout' IncludeAllProperties='true' maxRecursionLimit='0'>\n                                        <attribute name='LogMessage' layout='${message:raw=true}' />\n                                    </layout>\n                            </target>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Info' writeTo='buffer' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var debugTarget = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\");\n            var logger = logFactory.GetLogger(\"A\");\n\n            logger.Log(logEventInfo2);\n            logFactory.Flush();\n            var result2 = debugTarget.Layout.Render(logEventInfo2);\n            Assert.Same(result2, debugTarget.LastMessage);\n\n            logger.Log(logEventInfo1);\n            logFactory.Flush();\n            var result1 = debugTarget.Layout.Render(logEventInfo1);\n            Assert.NotSame(result1, debugTarget.LastMessage);\n\n            logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"Login request from {Username} for {Application}\\\", \\\"Username\\\": \\\"John\\\", \\\"Application\\\": \\\"BestApplicationEver\\\" }\");\n\n            Assert.Equal(\"Login request from John for BestApplicationEver\", logEventInfo1.FormattedMessage);\n\n            AssertContainsInDictionary(logEventInfo1.Properties, \"Username\", \"John\");\n            AssertContainsInDictionary(logEventInfo1.Properties, \"Application\", \"BestApplicationEver\");\n            Assert.Contains(new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Normal), logEventInfo1.MessageTemplateParameters);\n            Assert.Contains(new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", null, CaptureType.Normal), logEventInfo1.MessageTemplateParameters);\n        }"
      },
      {
        "name": "NormalStringFormatTest",
        "body": "{\n            LogEventInfo logEventInfo = new LogEventInfo(LogLevel.Info, \"MyLogger\", null, \"{0:X} - Login request from {1} for {2} with userid {0}\", new object[]\n            {\n                42,\n                \"John\",\n                \"BestApplicationEver\"\n            });\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <target name='debug' type='Debug'  >\n                                <layout type='JsonLayout' IncludeAllProperties='true'>\n                                    <attribute name='LogMessage' layout='${message:raw=true}' />\n                                </layout>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Info' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Log(logEventInfo);\n            logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"{0:X} - Login request from {1} for {2} with userid {0}\\\" }\");\n\n            Assert.Equal(\"2A - Login request from John for BestApplicationEver with userid 42\", logEventInfo.FormattedMessage);\n\n            Assert.Contains(new MessageTemplateParameter(\"0\", 42, \"X\", CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n            Assert.Contains(new MessageTemplateParameter(\"1\", \"John\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n            Assert.Contains(new MessageTemplateParameter(\"2\", \"BestApplicationEver\", null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n            Assert.Contains(new MessageTemplateParameter(\"0\", 42, null, CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n        }"
      },
      {
        "name": "MessageTemplateFormatTest",
        "body": "{\n            LogEventInfo logEventInfo = new LogEventInfo(LogLevel.Info, \"MyLogger\", null, \"Login request from {@Username} for {Application:l}\", new object[]\n            {\n                \"John\",\n                \"BestApplicationEver\"\n            });\n\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <target name='debug' type='Debug'  >\n                                <layout type='JsonLayout' IncludeAllProperties='true'>\n                                    <attribute name='LogMessage' layout='${message:raw=true}' />\n                                </layout>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Info' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Log(logEventInfo);\n            logFactory.AssertDebugLastMessage(\"{ \\\"LogMessage\\\": \\\"Login request from {@Username} for {Application:l}\\\", \\\"Username\\\": \\\"John\\\", \\\"Application\\\": \\\"BestApplicationEver\\\" }\");\n\n            Assert.Equal(\"Login request from \\\"John\\\" for BestApplicationEver\", logEventInfo.FormattedMessage);\n\n            AssertContainsInDictionary(logEventInfo.Properties, \"Username\", \"John\");\n            AssertContainsInDictionary(logEventInfo.Properties, \"Application\", \"BestApplicationEver\");\n            Assert.Contains(new MessageTemplateParameter(\"Username\", \"John\", null, CaptureType.Serialize), logEventInfo.MessageTemplateParameters);\n            Assert.Contains(new MessageTemplateParameter(\"Application\", \"BestApplicationEver\", \"l\", CaptureType.Normal), logEventInfo.MessageTemplateParameters);\n        }"
      }
    ]
  },
  {
    "file": "MessageTemplateParameterTests.cs",
    "methods": []
  },
  {
    "file": "MessageTemplateParametersTests.cs",
    "methods": []
  },
  {
    "file": "ParserTests.cs",
    "methods": []
  },
  {
    "file": "RendererTests.cs",
    "methods": []
  },
  {
    "file": "ValueFormatterTest.cs",
    "methods": [
      {
        "name": "TestSerialisationOfStringToJsonIsSuccessful",
        "body": "{\n            var str = \"Test\";\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(str, string.Empty, CaptureType.Serialize, null, builder);\n            Assert.True(result);\n            Assert.Equal(\"\\\"Test\\\"\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfClassObjectToJsonIsSuccessful",
        "body": "{\n            var @class = new Test2();\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Serialize, null, builder);\n            Assert.True(result);\n            Assert.Equal(\"{\\\"Str\\\":\\\"Test\\\", \\\"Integer\\\":1}\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfRecursiveClassObjectToJsonIsSuccessful",
        "body": "{\n            var @class = new RecursiveTest(0);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Serialize, null, builder);\n            Assert.True(result);\n            var actual = builder.ToString();\n\n            var deepestInteger = @\"\"\"Integer\"\":10\";\n            Assert.Contains(deepestInteger, actual);\n\n            var deepestNext = @\"\"\"Next\"\":\"\"NLog.UnitTests.MessageTemplates.ValueFormatterTest+RecursiveTest\"\"\";\n            Assert.Contains(deepestNext, actual);\n        }"
      },
      {
        "name": "TestStringifyOfStringIsSuccessful",
        "body": "{\n            var @class = \"str\";\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Stringify, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"\\\"str\\\"\", builder.ToString());\n        }"
      },
      {
        "name": "TestStringifyOfIFormatableObjectIsSuccessful",
        "body": "{\n            var @class = new Test();\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Stringify, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"\\\"Test\\\"\", builder.ToString());\n        }"
      },
      {
        "name": "TestStringifyOfNonIFormatableObjectIsSuccessful",
        "body": "{\n            var @class = new Test1();\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Stringify, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            var expectedValue = $\"\\\"{typeof(Test1).FullName}\\\"\";\n            Assert.Equal(expectedValue, builder.ToString());\n        }"
      },
      {
        "name": "TestSerializationOfListObjectIsSuccessful",
        "body": "{\n            var list = new List<int>() { 1, 2, 3, 4, 5, 6 };\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"1, 2, 3, 4, 5, 6\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerializationOfDictionaryObjectIsSuccessful",
        "body": "{\n            var list = new Dictionary<int, object>() { { 1, new Test() }, { 2, new Test1() } };\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal($\"1=Test, 2={typeof(Test1).FullName}\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerializationOfCollectionOfListObjectWithDepth2IsNotSuccessful",
        "body": "{\n            var list = new List<List<List<List<int>>>>() { new List<List<List<int>>>() { new List<List<int>>() { new List<int>() { 1, 2 }, new List<int>() { 3, 4 } }, new List<List<int>>() { new List<int>() { 4, 5 }, new List<int>() { 6, 7 } } } };\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.NotEqual(\"1,2,3,4,5,6,7\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerializationWillbeSkippedForElementsThatHaveRepeatedElements",
        "body": "{\n            var list = new List<List<List<List<int>>>>() { new List<List<List<int>>>() { new List<List<int>>() { new List<int>() { 1, 2 }, new List<int>() { 1, 2 } }, new List<List<int>>() { new List<int>() { 1, 2 }, new List<int>() { 1, 2 } } } };\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.NotEqual(\"1,2\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerializationWillBeSuccessfulForNullObjects",
        "body": "{\n            object list = null;\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(list, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"NULL\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerializationOfStringIsSuccessful",
        "body": "{\n            var @class = \"str\";\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"\\\"str\\\"\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfIConvertibleObjectIsSuccessful",
        "body": "{\n            var @class = new Test(TypeCode.Object);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"Test\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfIConvertibleStringObjectIsSuccessful",
        "body": "{\n            var @class = new Test(TypeCode.String);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            var expectedValue = $\"\\\"{typeof(Test).FullName}\\\"\";\n            Assert.Equal(expectedValue, builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfIConvertibleBooleanObjectIsSuccessful",
        "body": "{\n            var @class = new Test(TypeCode.Boolean);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"true\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfIConvertibleCharObjectIsSuccessful",
        "body": "{\n            var @class = new Test(TypeCode.Char);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"\\\"t\\\"\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfIConvertibleEnumObjectIsSuccessful",
        "body": "{\n            var @class = new Test(TypeCode.Byte);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class.Data, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"Foo\", builder.ToString());\n        }"
      },
      {
        "name": "TestSerialisationOfIConvertibleDateTimeObjectIsSuccessful",
        "body": "{\n            var @class = new Test(TypeCode.DateTime);\n            StringBuilder builder = new StringBuilder();\n            var result = CreateValueFormatter().FormatValue(@class, string.Empty, CaptureType.Normal, new CultureInfo(\"fr-FR\"), builder);\n            Assert.True(result);\n            Assert.Equal(\"Test\", builder.ToString());\n        }"
      }
    ]
  },
  {
    "file": "TrickyTestDictionary.cs",
    "methods": []
  },
  {
    "file": "NLogTestBase.cs",
    "methods": []
  },
  {
    "file": "NLogTraceListenerTests.cs",
    "methods": [
      {
        "name": "TraceWriteTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            Trace.Listeners.Clear();\n            Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\" });\n\n            Trace.Write(\"Hello\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Debug Hello  \");\n\n            Trace.Write(\"Hello\", \"Cat1\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Debug Cat1: Hello  \");\n\n            Trace.Write(3.1415);\n            AssertDebugLastMessage(\"debug\", $\"Logger1 Debug {3.1415}  \");\n\n            Trace.Write(3.1415, \"Cat2\");\n            AssertDebugLastMessage(\"debug\", $\"Logger1 Debug Cat2: {3.1415}  \");\n        }"
      },
      {
        "name": "TraceWriteLineTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            Trace.Listeners.Clear();\n            Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\" });\n\n            Trace.WriteLine(\"Hello\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Debug Hello  \");\n\n            Trace.WriteLine(\"Hello\", \"Cat1\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Debug Cat1: Hello  \");\n\n            Trace.WriteLine(3.1415);\n            AssertDebugLastMessage(\"debug\", $\"Logger1 Debug {3.1415}  \");\n\n            Trace.WriteLine(3.1415, \"Cat2\");\n            AssertDebugLastMessage(\"debug\", $\"Logger1 Debug Cat2: {3.1415}  \");\n        }"
      },
      {
        "name": "TraceWriteNonDefaultLevelTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            Trace.Listeners.Clear();\n            Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });\n\n            Trace.Write(\"Hello\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Trace Hello  \");\n        }"
      },
      {
        "name": "TraceConfiguration",
        "body": "{\n            var listener = new NLogTraceListener();\n            listener.Attributes.Add(\"defaultLogLevel\", \"Warn\");\n            listener.Attributes.Add(\"forceLogLevel\", \"Error\");\n            listener.Attributes.Add(\"autoLoggerName\", \"1\");\n            listener.Attributes.Add(\"DISABLEFLUSH\", \"true\");\n\n            Assert.Equal(LogLevel.Warn, listener.DefaultLogLevel);\n            Assert.Equal(LogLevel.Error, listener.ForceLogLevel);\n            Assert.True(listener.AutoLoggerName);\n            Assert.True(listener.DisableFlush);\n        }"
      },
      {
        "name": "TraceFailTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            Trace.Listeners.Clear();\n            Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\" });\n\n            Trace.Fail(\"Message\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Error Message  Error\");\n\n            Trace.Fail(\"Message\", \"Detailed Message\");\n            AssertDebugLastMessage(\"debug\", \"Logger1 Error Message Detailed Message  Error\");\n        }"
      },
      {
        "name": "AutoLoggerNameTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            Trace.Listeners.Clear();\n            Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", AutoLoggerName = true });\n\n            Trace.Write(\"Hello\");\n            AssertDebugLastMessage(\"debug\", GetType().FullName + \" Debug Hello  \");\n        }"
      },
      {
        "name": "TraceDataTests",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            TraceSource ts = CreateTraceSource();\n            ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });\n\n            ts.TraceData(TraceEventType.Critical, 123, 42);\n            AssertDebugLastMessage(\"debug\", \"MySource1 Fatal 42 123 Critical\");\n\n            ts.TraceData(TraceEventType.Critical, 145, 42, 3.14, \"foo\");\n            AssertDebugLastMessage(\"debug\", $\"MySource1 Fatal 42, {3.14.ToString(CultureInfo.CurrentCulture)}, foo 145 Critical\");\n        }"
      },
      {
        "name": "LogInformationTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            TraceSource ts = CreateTraceSource();\n            ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });\n\n            ts.TraceInformation(\"Quick brown fox\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Info Quick brown fox  Information\");\n\n            ts.TraceInformation(\"Mary had {0} lamb\", \"a little\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Info Mary had a little lamb  Information\");\n        }"
      },
      {
        "name": "TraceEventTests",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            TraceSource ts = CreateTraceSource();\n            ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace });\n\n            ts.TraceEvent(TraceEventType.Information, 123, \"Quick brown {0} jumps over the lazy {1}.\", \"fox\", \"dog\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Info Quick brown fox jumps over the lazy dog. 123 Information\");\n\n            ts.TraceEvent(TraceEventType.Information, 123);\n            AssertDebugLastMessage(\"debug\", \"MySource1 Info  123 Information\");\n\n            ts.TraceEvent(TraceEventType.Verbose, 145, \"Bar\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Trace Bar 145 \");\n\n            ts.TraceEvent(TraceEventType.Error, 145, \"Foo\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Error Foo 145 Error\");\n\n            ts.TraceEvent(TraceEventType.Suspend, 145, \"Bar\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Debug Bar 145 Suspend\");\n\n            ts.TraceEvent(TraceEventType.Resume, 145, \"Foo\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Debug Foo 145 Resume\");\n\n            ts.TraceEvent(TraceEventType.Warning, 145, \"Bar\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Warn Bar 145 Warning\");\n\n            ts.TraceEvent(TraceEventType.Critical, 145, \"Foo\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Fatal Foo 145 Critical\");\n        }"
      },
      {
        "name": "ForceLogLevelTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            TraceSource ts = CreateTraceSource();\n            ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace, ForceLogLevel = LogLevel.Warn });\n\n            // force all logs to be Warn, DefaultLogLevel has no effect on TraceSource\n            ts.TraceInformation(\"Quick brown fox\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Warn Quick brown fox  Information\");\n\n            ts.TraceInformation(\"Mary had {0} lamb\", \"a little\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Warn Mary had a little lamb  Information\");\n        }"
      },
      {
        "name": "FilterTraceTest",
        "body": "{\n            LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n            TraceSource ts = CreateTraceSource();\n            ts.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", DefaultLogLevel = LogLevel.Trace, ForceLogLevel = LogLevel.Warn, Filter = new EventTypeFilter(SourceLevels.Error) });\n\n            // force all logs to be Warn, DefaultLogLevel has no effect on TraceSource\n            ts.TraceEvent(TraceEventType.Error, 0, \"Quick brown fox\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Warn Quick brown fox  Error\");\n\n            ts.TraceInformation(\"Mary had {0} lamb\", \"a little\");\n            AssertDebugLastMessage(\"debug\", \"MySource1 Warn Quick brown fox  Error\");\n        }"
      },
      {
        "name": "GlobalAllFilterTraceTest",
        "body": "{\n            try\n            {\n                Trace.Listeners.Clear();\n                Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", Filter = new EventTypeFilter(SourceLevels.Verbose) });\n\n                LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n                Trace.WriteLine(\"Quick brown fox\");\n                AssertDebugLastMessage(\"debug\", \"Logger1 Debug Quick brown fox  \");\n                Trace.WriteLine(new ArgumentException(\"Mary had a little lamb\"));\n                AssertDebugLastMessage(\"debug\", \"Logger1 Debug System.ArgumentException: Mary had a little lamb  \");\n                Trace.Write(\"Quick brown fox\");\n                AssertDebugLastMessage(\"debug\", \"Logger1 Debug Quick brown fox  \");\n                Trace.Write(new ArgumentException(\"Mary had a little lamb\"));\n                AssertDebugLastMessage(\"debug\", \"Logger1 Debug System.ArgumentException: Mary had a little lamb  \");\n                Trace.Flush();\n            }\n            finally\n            {\n                Trace.Listeners.Clear();\n            }\n        }"
      },
      {
        "name": "GlobalInfoFilterTraceTest",
        "body": "{\n            try\n            {\n                Trace.Listeners.Clear();\n                Trace.Listeners.Add(new NLogTraceListener { Name = \"Logger1\", Filter = new EventTypeFilter(SourceLevels.Information) });\n\n                LogManager.Configuration = XmlLoggingConfiguration.CreateFromXmlString(@\"\n                <nlog>\n                    <targets><target name='debug' type='Debug' layout='${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Trace' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n\n                Trace.TraceInformation(\"Mary had a little lamb\");\n                AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb  Information\");\n                Trace.WriteLine(\"Quick brown fox\");\n                AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb  Information\");\n                Trace.WriteLine(new ArgumentException(\"Mary had a little lamb\"));\n                AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb  Information\");\n                Trace.Write(\"Quick brown fox\");\n                AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb  Information\");\n                Trace.Write(new ArgumentException(\"Mary had a little lamb\"));\n                AssertDebugLastMessageContains(\"debug\", \"Mary had a little lamb  Information\");\n                Trace.Flush();\n            }\n            finally\n            {\n                Trace.Listeners.Clear();\n            }\n        }"
      },
      {
        "name": "TraceTargetWriteLineTest",
        "body": "{\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteToTrace(layout: \"${logger} ${level} ${message} ${event-properties:EventID} ${event-properties:EventType}\", rawWrite: true);\n            }).GetLogger(\"MySource1\");\n\n            var sw = new System.IO.StringWriter();\n\n            try\n            {\n                Trace.Listeners.Clear();\n                Trace.Listeners.Add(new TextWriterTraceListener(sw));\n                foreach (var logLevel in LogLevel.AllLevels)\n                {\n                    if (logLevel == LogLevel.Off)\n                        continue;\n                    logger.Log(logLevel, \"Quick brown fox\");\n                    Trace.Flush();\n                    Assert.Equal($\"MySource1 {logLevel} Quick brown fox  \" + Environment.NewLine, sw.GetStringBuilder().ToString());\n                    sw.GetStringBuilder().Length = 0;\n                }\n\n                Trace.Flush();\n            }\n            finally\n            {\n                Trace.Listeners.Clear();\n            }\n        }"
      }
    ]
  },
  {
    "file": "RegressionTests.cs",
    "methods": [
      {
        "name": "Bug4655UnableToReconfigureExistingLoggers",
        "body": "{\n            var debugTarget1 = new DebugTarget();\n            var debugTarget2 = new DebugTarget();\n\n            var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(debugTarget1);\n            }).LogFactory;\n\n            var logger = logFactory.GetLogger(Guid.NewGuid().ToString(\"N\"));\n\n            logger.Info(\"foo\");\n\n            Assert.Equal(1, debugTarget1.Counter);\n            Assert.Equal(0, debugTarget2.Counter);\n\n            logFactory.Configuration.AddTarget(\"DesktopConsole\", debugTarget2);\n            logFactory.Configuration.LoggingRules.Add(new LoggingRule(\"*\", LogLevel.Debug, debugTarget2));\n            logFactory.ReconfigExistingLoggers();\n\n            logger.Info(\"foo\");\n\n            Assert.Equal(2, debugTarget1.Counter);\n            Assert.Equal(1, debugTarget2.Counter);\n        }"
      },
      {
        "name": "Bug5965StackOverflow",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n<nlog xmlns='http://www.nlog-project.org/schemas/NLog.xsd'\n      xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n\n  <targets>\n    <target name='file'  xsi:type='AsyncWrapper' queueLimit='5000' overflowAction='Discard'  >\n      <target xsi:type='Debug'>\n        <layout xsi:type='CSVLayout'>\n          <column name='counter' layout='${counter}' />\n          <column name='time' layout='${longdate}' />\n          <column name='message' layout='${message}' />\n        </layout>\n      </target>\n    </target>\n  </targets>\n\n  <rules>\n    <logger name='*' minlevel='Trace' writeTo='file' />\n  </rules>\n\n</nlog>\").LogFactory;\n\n            var log = logFactory.GetLogger(\"x\");\n            log.Fatal(\"Test\");\n            Assert.NotNull(logFactory.Configuration);\n            logFactory.Configuration = null;\n        }"
      }
    ]
  },
  {
    "file": "AsyncTaskTargetTest.cs",
    "methods": [
      {
        "name": "AsyncTaskTarget_TestLogging",
        "body": "{\n            var asyncTarget = new AsyncTaskTestTarget { Layout = \"${threadid}|${level}|${message}|${mdlc:item=Test}\" };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            int managedThreadId = 0;\n            Task task;\n            using (ScopeContext.PushProperty(\"Test\", 42))\n            {\n                task = Task.Run(() =>\n                {\n                    managedThreadId = CurrentManagedThreadId;\n                    logger.Trace(\"TTT\");\n                    logger.Debug(\"DDD\");\n                    logger.Info(\"III\");\n                    logger.Warn(\"WWW\");\n                    logger.Error(\"EEE\");\n                    logger.Fatal(\"FFF\");\n                });\n            }\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            task.Wait();\n            logger.Factory.Flush();\n            Assert.Equal(6, asyncTarget.Logs.Count);\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                Assert.StartsWith(managedThreadId.ToString() + \"|\", logEventMessage);\n                Assert.EndsWith(\"|42\", logEventMessage);\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_SkipAsyncTargetWrapper",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                .SetupExtensions(ext => ext.RegisterTarget<AsyncTaskTestTarget>(\"AsyncTaskTest\"))\n                .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                <targets async='true'>\n                    <target name='asyncDebug' type='AsyncTaskTest' />\n                    <target name='debug' type='Debug' />\n                </targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            Assert.NotNull(logFactory.Configuration.FindTargetByName<AsyncTaskTestTarget>(\"asyncDebug\"));\n            Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.AsyncTargetWrapper>(\"debug\"));\n        }"
      },
      {
        "name": "AsyncTaskTarget_SkipDefaultAsyncWrapper",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                .SetupExtensions(ext => ext.RegisterTarget<AsyncTaskTestTarget>(\"AsyncTaskTest\"))\n                .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                <targets>\n                    <default-wrapper type='AsyncWrapper' />\n                    <target name='asyncDebug' type='AsyncTaskTest' />\n                    <target name='debug' type='Debug' />\n                </targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            Assert.NotNull(logFactory.Configuration.FindTargetByName<AsyncTaskTestTarget>(\"asyncDebug\"));\n            Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.AsyncTargetWrapper>(\"debug\"));\n        }"
      },
      {
        "name": "AsyncTaskTarget_AllowDefaultBufferWrapper",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                .SetupExtensions(ext => ext.RegisterTarget<AsyncTaskTestTarget>(\"AsyncTaskTest\"))\n                .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                <targets>\n                    <default-wrapper type='BufferingWrapper' />\n                    <target name='asyncDebug' type='AsyncTaskTest' />\n                    <target name='debug' type='Debug' />\n                </targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.BufferingTargetWrapper>(\"asyncDebug\"));\n            Assert.NotNull(logFactory.Configuration.FindTargetByName<NLog.Targets.Wrappers.BufferingTargetWrapper>(\"debug\"));\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestAsyncException",
        "body": "{\n            var asyncTarget = new AsyncTaskTestTarget\n            {\n                Layout = \"${level}\",\n                RetryDelayMilliseconds = 50\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            foreach (var logLevel in LogLevel.AllLoggingLevels)\n                logger.Log(logLevel, logLevel == LogLevel.Debug ? \"ASYNCEXCEPTION\" : logLevel.Name.ToUpperInvariant());\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            logger.Factory.Flush();\n            Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);\n\n            int ordinal = 0;\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                var logLevel = LogLevel.FromString(logEventMessage);\n                Assert.NotEqual(LogLevel.Debug, logLevel);\n                Assert.Equal(ordinal++, logLevel.Ordinal);\n                if (ordinal == LogLevel.Debug.Ordinal)\n                    ++ordinal;\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestTimeout",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                var asyncTarget = new AsyncTaskTestTarget\n                {\n                    Layout = \"${level}\",\n                    TaskTimeoutSeconds = 1\n                };\n\n                var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n                {\n                    builder.ForLogger().WriteTo(asyncTarget);\n                }).GetCurrentClassLogger();\n\n                logger.Trace(\"TTT\");\n                logger.Debug(\"TIMEOUT\");\n                logger.Info(\"III\");\n                logger.Warn(\"WWW\");\n                logger.Error(\"EEE\");\n                logger.Fatal(\"FFF\");\n                Assert.True(asyncTarget.WaitForWriteEvent());\n                Assert.NotEmpty(asyncTarget.Logs);\n                logger.Factory.Flush();\n                Assert.Equal(5, asyncTarget.Logs.Count);\n                while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n                {\n                    Assert.DoesNotContain(\"Debug|\", logEventMessage);\n                }\n\n                logger.Factory.Configuration = null;\n            });\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestRetryAsyncException",
        "body": "{\n            var asyncTarget = new AsyncTaskTestTarget\n            {\n                Layout = \"${level}\",\n                RetryDelayMilliseconds = 10,\n                RetryCount = 3\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            foreach (var logLevel in LogLevel.AllLoggingLevels)\n                logger.Log(logLevel, logLevel == LogLevel.Debug ? \"ASYNCEXCEPTION\" : logLevel.Name.ToUpperInvariant());\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            logger.Factory.Flush();\n            Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);\n            Assert.Equal(LogLevel.MaxLevel.Ordinal + 4, asyncTarget.WriteTasks);\n\n            int ordinal = 0;\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                var logLevel = LogLevel.FromString(logEventMessage);\n                Assert.NotEqual(LogLevel.Debug, logLevel);\n                Assert.Equal(ordinal++, logLevel.Ordinal);\n                if (ordinal == LogLevel.Debug.Ordinal)\n                    ++ordinal;\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestRetryException",
        "body": "{\n            var asyncTarget = new AsyncTaskTestTarget\n            {\n                Layout = \"${level}\",\n                RetryDelayMilliseconds = 10,\n                RetryCount = 3\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            foreach (var logLevel in LogLevel.AllLoggingLevels)\n                logger.Log(logLevel, logLevel == LogLevel.Debug ? \"EXCEPTION\" : logLevel.Name.ToUpperInvariant());\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            logger.Factory.Flush();\n            Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);\n            Assert.Equal(LogLevel.MaxLevel.Ordinal + 4, asyncTarget.WriteTasks);\n\n            int ordinal = 0;\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                var logLevel = LogLevel.FromString(logEventMessage);\n                Assert.NotEqual(LogLevel.Debug, logLevel);\n                Assert.Equal(ordinal++, logLevel.Ordinal);\n                if (ordinal == LogLevel.Debug.Ordinal)\n                    ++ordinal;\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestFallbackException",
        "body": "{\n            var asyncTarget = new AsyncTaskTestTarget\n            {\n                Layout = \"${level}\",\n                RetryDelayMilliseconds = 10,\n                RetryCount = 1\n            };\n\n            var fallbacKTarget = new MemoryTarget() { Layout = \"${level}\" };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget).WithFallback(fallbacKTarget);\n            }).GetCurrentClassLogger();\n\n            foreach (var logLevel in LogLevel.AllLoggingLevels)\n                logger.Log(logLevel, logLevel == LogLevel.Debug ? \"EXCEPTION\" : logLevel.Name.ToUpperInvariant());\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            logger.Factory.Flush();\n            Assert.Equal(LogLevel.MaxLevel.Ordinal, asyncTarget.Logs.Count);\n            Assert.Equal(LogLevel.MaxLevel.Ordinal + 2, asyncTarget.WriteTasks);\n\n            Assert.Single(fallbacKTarget.Logs);\n            Assert.Equal(LogLevel.Debug.ToString(), fallbacKTarget.Logs[0]);\n\n            int ordinal = 0;\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                var logLevel = LogLevel.FromString(logEventMessage);\n                Assert.NotEqual(LogLevel.Debug, logLevel);\n                Assert.Equal(ordinal++, logLevel.Ordinal);\n                if (ordinal == LogLevel.Debug.Ordinal)\n                    ++ordinal;\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestBatchWriting",
        "body": "{\n            var asyncTarget = new AsyncTaskBatchTestTarget\n            {\n                Layout = \"${level}\",\n                BatchSize = 3,\n                TaskDelayMilliseconds = 10\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            foreach (var logLevel in LogLevel.AllLoggingLevels)\n                logger.Log(logLevel, logLevel.Name.ToUpperInvariant());\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            logger.Factory.Flush();\n            Assert.Equal(LogLevel.MaxLevel.Ordinal + 1, asyncTarget.Logs.Count);\n            Assert.Equal(LogLevel.MaxLevel.Ordinal / 2, asyncTarget.WriteTasks);\n\n            int ordinal = 0;\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                var logLevel = LogLevel.FromString(logEventMessage);\n                Assert.Equal(ordinal++, logLevel.Ordinal);\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestBatchRetryTimings",
        "body": "{\n            var asyncTarget = new AsyncTaskBatchExceptionTestTarget\n            {\n                Layout = \"${level}\",\n                BatchSize = 10,\n                TaskDelayMilliseconds = 10,\n                RetryCount = 5,\n                RetryDelayMilliseconds = 3\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            logger.Log(LogLevel.Info, \"test\");\n\n            logger.Factory.Flush();\n\n            // The zero at the end of the array is used when there will be no more retries.\n            Assert.Equal(new[] { 3, 6, 12, 24, 48, 0 }, asyncTarget.retryDelayLog);\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestFakeBatchWriting",
        "body": "{\n            var asyncTarget = new AsyncTaskTestTarget\n            {\n                Layout = \"${level}\",\n                BatchSize = 3,\n                TaskDelayMilliseconds = 10\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            foreach (var logLevel in LogLevel.AllLoggingLevels)\n                logger.Log(logLevel, logLevel.Name.ToUpperInvariant());\n\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n            logger.Factory.Flush();\n            Assert.Equal(LogLevel.MaxLevel.Ordinal + 1, asyncTarget.Logs.Count);\n            Assert.Equal(LogLevel.MaxLevel.Ordinal + 1, asyncTarget.WriteTasks);\n\n            int ordinal = 0;\n            while (asyncTarget.Logs.TryDequeue(out var logEventMessage))\n            {\n                var logLevel = LogLevel.FromString(logEventMessage);\n                Assert.Equal(ordinal++, logLevel.Ordinal);\n            }\n\n            logger.Factory.Configuration = null;\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestSlowBatchWriting",
        "body": "{\n            var asyncTarget = new AsyncTaskBatchTestTarget\n            {\n                Layout = \"${level}\",\n                TaskDelayMilliseconds = 200\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            DateTime utcNow = DateTime.UtcNow;\n\n            logger.Log(LogLevel.Info, LogLevel.Info.ToString().ToUpperInvariant());\n            logger.Log(LogLevel.Fatal, \"SLEEP\");\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.Single(asyncTarget.Logs);\n            logger.Log(LogLevel.Error, LogLevel.Error.ToString().ToUpperInvariant());\n\n            asyncTarget.Dispose();  // Trigger fast shutdown\n            logger.Factory.Configuration = null;\n\n            TimeSpan shutdownTime = DateTime.UtcNow - utcNow;\n            Assert.True(shutdownTime < TimeSpan.FromSeconds(4), $\"Shutdown took {shutdownTime.TotalMilliseconds} msec\");\n        }"
      },
      {
        "name": "AsyncTaskTarget_TestThrottleOnTaskDelay",
        "body": "{\n            var asyncTarget = new AsyncTaskBatchTestTarget\n            {\n                Layout = \"${level}\",\n                TaskDelayMilliseconds = 50,\n                BatchSize = 10,\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncTarget);\n            }).GetCurrentClassLogger();\n\n            for (int i = 0; i < 5; ++i)\n            {\n                for (int j = 0; j < 10; ++j)\n                {\n                    logger.Log(LogLevel.Info, i.ToString());\n                    Thread.Sleep(20);\n                }\n                Assert.True(asyncTarget.WaitForWriteEvent());\n            }\n\n            Assert.True(asyncTarget.Logs.Count > 25, $\"{asyncTarget.Logs.Count} LogEvents are too few after {asyncTarget.WriteTasks} writes\");\n            Assert.True(asyncTarget.WriteTasks < 20, $\"{asyncTarget.WriteTasks} writes are too many.\");\n        }"
      },
      {
        "name": "AsynTaskTarget_AutoFlushWrapper",
        "body": "{\n            var asyncTarget = new AsyncTaskBatchTestTarget\n            {\n                Layout = \"${level}\",\n                TaskDelayMilliseconds = 5000,\n                BatchSize = 10,\n            };\n            var autoFlush = new NLog.Targets.Wrappers.AutoFlushTargetWrapper(\"autoflush\", asyncTarget);\n            autoFlush.Condition = \"level > LogLevel.Warn\";\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(autoFlush);\n            }).GetCurrentClassLogger();\n\n            logger.Info(\"Hello World\");\n            Assert.Empty(asyncTarget.Logs);\n            logger.Error(\"Goodbye World\");\n            Assert.True(asyncTarget.WaitForWriteEvent());\n            Assert.NotEmpty(asyncTarget.Logs);\n        }"
      },
      {
        "name": "AsyncTaskTarget_FlushWhenBlocked",
        "body": "{\n            // Arrange\n            var logFactory = new LogFactory();\n            var logConfig = new LoggingConfiguration(logFactory);\n            var asyncTarget = new AsyncTaskBatchTestTarget\n            {\n                Layout = \"${level}\",\n                TaskDelayMilliseconds = 10000,\n                BatchSize = 10,\n                QueueLimit = 10,\n                OverflowAction = NLog.Targets.Wrappers.AsyncTargetWrapperOverflowAction.Block,\n            };\n            logConfig.AddRuleForAllLevels(asyncTarget);\n            logFactory.Configuration = logConfig;\n            var logger = logFactory.GetLogger(nameof(AsyncTaskTarget_FlushWhenBlocked));\n\n            // Act\n            for (int i = 0; i < 10; ++i)\n                logger.Info(\"Testing {0}\", i);\n            logFactory.Flush(TimeSpan.FromSeconds(5));\n\n            // Assert\n            Assert.Equal(1, asyncTarget.WriteTasks);\n        }"
      },
      {
        "name": "AsyncTaskTarget_MissingDependency_EnqueueLogEvents",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                // Arrange\n                var logFactory = new LogFactory();\n                logFactory.ThrowConfigExceptions = true;\n                var logConfig = new LoggingConfiguration(logFactory);\n                var asyncTarget = new AsyncTaskTestTarget() { Name = \"asynctarget\", RequiredDependency = typeof(IMisingDependencyClass) };\n                logConfig.AddRuleForAllLevels(asyncTarget);\n                logFactory.Configuration = logConfig;\n                var logger = logFactory.GetLogger(nameof(AsyncTaskTarget_MissingDependency_EnqueueLogEvents));\n\n                // Act\n                logger.Info(\"Hello World\");\n                Assert.False(asyncTarget.WaitForWriteEvent(50));\n                logFactory.ServiceRepository.RegisterService(typeof(IMisingDependencyClass), new MisingDependencyClass());\n\n                // Assert\n                Assert.True(asyncTarget.WaitForWriteEvent());\n            }\n        }"
      }
    ]
  },
  {
    "file": "ColoredConsoleTargetTests.cs",
    "methods": []
  },
  {
    "file": "ConcurrentFileTargetTests.cs",
    "methods": []
  },
  {
    "file": "ConsoleTargetTests.cs",
    "methods": [
      {
        "name": "ConsoleOutWriteLineTest",
        "body": "{\n            ConsoleOutTest(false);\n        }"
      },
      {
        "name": "ConsoleOutWriteBufferTest",
        "body": "{\n            ConsoleOutTest(true);\n        }"
      },
      {
        "name": "ConsoleErrorTest",
        "body": "{\n            var target = new ConsoleTarget()\n            {\n                Header = \"-- header --\",\n                Layout = \"${logger} ${message}\",\n                Footer = \"-- footer --\",\n                StdErr = true,\n            };\n\n            var consoleErrorWriter = new StringWriter();\n            TextWriter oldConsoleErrorWriter = Console.Error;\n            Console.SetError(consoleErrorWriter);\n\n            try\n            {\n                var exceptions = new List<Exception>();\n                target.Initialize(null);\n                target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message1\").WithContinuation(exceptions.Add));\n                target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message2\").WithContinuation(exceptions.Add));\n                target.WriteAsyncLogEvents(\n                    new LogEventInfo(LogLevel.Info, \"Logger1\", \"message3\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger2\", \"message4\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger2\", \"message5\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger1\", \"message6\").WithContinuation(exceptions.Add));\n                Assert.Equal(6, exceptions.Count);\n                target.Flush((ex) => { });\n                target.Close();\n            }\n            finally\n            {\n                Console.SetError(oldConsoleErrorWriter);\n            }\n\n            string expectedResult = string.Format(\"-- header --{0}Logger1 message1{0}Logger1 message2{0}Logger1 message3{0}Logger2 message4{0}Logger2 message5{0}Logger1 message6{0}-- footer --{0}\", Environment.NewLine);\n            Assert.Equal(expectedResult, consoleErrorWriter.ToString());\n        }"
      },
      {
        "name": "SetupBuilder_WriteToConsole",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfiguration(c =>\n            {\n                c.ForLogger().FilterMinLevel(LogLevel.Error).WriteToConsole(\"${message}\", stderr: true);\n            }).LogFactory;\n\n            var consoleErrorWriter = new StringWriter();\n            TextWriter oldConsoleErrorWriter = Console.Error;\n            Console.SetError(consoleErrorWriter);\n\n            try\n            {\n                logFactory.GetCurrentClassLogger().Error(\"Abort\");\n                logFactory.GetCurrentClassLogger().Info(\"Continue\");\n            }\n            finally\n            {\n                Console.SetError(oldConsoleErrorWriter);\n            }\n\n            Assert.Equal($\"Abort{System.Environment.NewLine}\", consoleErrorWriter.ToString());\n        }"
      },
      {
        "name": "ConsoleEncodingTest",
        "body": "{\n            var consoleOutputEncoding = Console.OutputEncoding;\n\n            var target = new ConsoleTarget()\n            {\n                Header = \"-- header --\",\n                Layout = \"${logger} ${message}\",\n                Footer = \"-- footer --\",\n                Encoding = System.Text.Encoding.UTF8\n            };\n\n            Assert.Equal(System.Text.Encoding.UTF8, target.Encoding);\n\n            var consoleOutWriter = new StringWriter();\n            TextWriter oldConsoleOutWriter = Console.Out;\n            Console.SetOut(consoleOutWriter);\n\n            try\n            {\n                var exceptions = new List<Exception>();\n                target.Initialize(null);\n                // Not really testing whether Console.OutputEncoding works, but just that it is configured without breaking ConsoleTarget\n                Assert.Equal(System.Text.Encoding.UTF8, Console.OutputEncoding);\n                Assert.Equal(System.Text.Encoding.UTF8, target.Encoding);\n                target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message1\").WithContinuation(exceptions.Add));\n                target.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"message2\").WithContinuation(exceptions.Add));\n                Assert.Equal(2, exceptions.Count);\n                target.Encoding = consoleOutputEncoding;\n                Assert.Equal(consoleOutputEncoding, Console.OutputEncoding);\n                target.Close();\n            }\n            finally\n            {\n                Console.OutputEncoding = consoleOutputEncoding;\n                Console.SetOut(oldConsoleOutWriter);\n            }\n\n            string expectedResult = string.Format(\"-- header --{0}Logger1 message1{0}Logger1 message2{0}-- footer --{0}\", Environment.NewLine);\n            Assert.Equal(expectedResult, consoleOutWriter.ToString());\n        }"
      },
      {
        "name": "ConsoleRaceCondtionIgnoreTest",
        "body": "{\n            var configXml = @\"\n            <nlog throwExceptions='true'>\n                <targets>\n                  <target name='console' type='console' layout='${message}' />\n                  <target name='consoleError' type='console' layout='${message}'  error='true' />\n                </targets>\n                <rules>\n                  <logger name='*' minlevel='Trace' writeTo='console,consoleError' />\n                </rules>\n            </nlog>\";\n\n            var success = ConsoleRaceCondtionIgnoreInnerTest(configXml);\n            Assert.True(success);\n        }"
      }
    ]
  },
  {
    "file": "DebugSystemTargetTests.cs",
    "methods": [
      {
        "name": "DebugWriteLineTest",
        "body": "{\n            var sw = new System.IO.StringWriter();\n\n            try\n            {\n                // Arrange\n#if NETFRAMEWORK\n                Debug.Listeners.Clear();\n                Debug.Listeners.Add(new TextWriterTraceListener(sw));\n#endif\n                var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n                {\n                    builder.ForLogger().WriteToDebug();\n                }).LogFactory;\n\n                // Act\n                logFactory.GetCurrentClassLogger().Info(\"Hello World\");\n\n                // Assert\n                Assert.Single(logFactory.Configuration.AllTargets);\n#if NETFRAMEWORK\n                Assert.Contains(\"Hello World\", sw.ToString());\n#endif\n            }\n            finally\n            {\n#if NETFRAMEWORK\n                Debug.Listeners.Clear();\n#endif\n            }\n        }"
      },
      {
        "name": "DebugWriteLineHeaderFooterTest",
        "body": "{\n            var sw = new System.IO.StringWriter();\n\n            try\n            {\n                // Arrange\n#if NETFRAMEWORK\n                Debug.Listeners.Clear();\n                Debug.Listeners.Add(new TextWriterTraceListener(sw));\n#endif\n                var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n                <nlog>\n                    <targets>\n                        <target type='debugsystem' name='Debug' layout='${message}'>\n                            <header>Startup</header>\n                            <footer>Shutdown</footer>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' writeTo='Debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n                // Act\n                logFactory.GetCurrentClassLogger().Info(\"Hello World\");\n\n                // Assert\n                Assert.Single(logFactory.Configuration.AllTargets);\n#if NETFRAMEWORK\n                Assert.Contains(\"Startup\", sw.ToString());\n                Assert.Contains(\"Hello World\", sw.ToString());\n                Assert.DoesNotContain(\"Shutdown\", sw.ToString());\n\n                logFactory.Shutdown();\n                Assert.Contains(\"Shutdown\", sw.ToString());\n#endif\n            }\n            finally\n            {\n#if NETFRAMEWORK\n                Debug.Listeners.Clear();\n#endif\n            }\n        }"
      }
    ]
  },
  {
    "file": "DefaultJsonSerializerClassTests.cs",
    "methods": [
      {
        "name": "SimpleValue_RegistersSerializeAsToString_ConvertsValue",
        "body": "{\n            var logFactory = new LogFactory();\n            logFactory.Setup().SetupSerialization(s => s.RegisterObjectTransformation<System.IO.MemoryStream>(o => o.Capacity));\n\n            var testObject = new System.IO.MemoryStream(42);\n\n            var sb = new StringBuilder();\n            var options = new JsonSerializeOptions();\n            var jsonSerializer = new DefaultJsonSerializer(logFactory.ServiceRepository);\n            jsonSerializer.SerializeObject(testObject, sb, options);\n\n            Assert.Equal($\"{testObject.Capacity}\", sb.ToString());\n        }"
      },
      {
        "name": "IExcludedInterfaceSerializer_RegistersSerializeAsToString_InvokesToString",
        "body": "{\n            var testObject = BuildSampleObject();\n\n            var sb = new StringBuilder();\n            var options = new JsonSerializeOptions();\n\n            var logFactory = new LogFactory();\n            logFactory.Setup().SetupSerialization(s => s.RegisterObjectTransformation<IExcludedInterface>(o => o.ToString()));\n\n            var jsonSerializer = new DefaultJsonSerializer(logFactory.ServiceRepository);\n            jsonSerializer.SerializeObject(testObject, sb, options);\n            const string expectedValue =\n                @\"{\"\"S\"\":\"\"sample\"\", \"\"Excluded\"\":\"\"Skipped\"\", \"\"Included\"\":{\"\"IncludedString\"\":\"\"serialized\"\"}}\";\n            Assert.Equal(expectedValue, sb.ToString());\n        }"
      },
      {
        "name": "ExcludedClassSerializer_RegistersSerializeAsToString_InvokesToString",
        "body": "{\n            var testObject = BuildSampleObject();\n\n            var sb = new StringBuilder();\n            var options = new JsonSerializeOptions();\n\n            var logFactory = new LogFactory();\n            logFactory.Setup().SetupSerialization(s => s.RegisterObjectTransformation(typeof(ExcludedClass), o => o.ToString()));\n\n            var jsonSerializer = new DefaultJsonSerializer(logFactory.ServiceRepository);\n            jsonSerializer.SerializeObject(testObject, sb, options);\n            const string expectedValue =\n                @\"{\"\"S\"\":\"\"sample\"\", \"\"Excluded\"\":\"\"Skipped\"\", \"\"Included\"\":{\"\"IncludedString\"\":\"\"serialized\"\"}}\";\n            Assert.Equal(expectedValue, sb.ToString());\n        }"
      }
    ]
  },
  {
    "file": "DefaultJsonSerializerLegacyTests.cs",
    "methods": [
      {
        "name": "SerializeEnumInt_Test",
        "body": "{\n            var val = ExceptionRenderingFormat.Method;\n            var actual = SerializeObjectWithOptions(val, new JsonSerializeOptions() { EnumAsInteger = true });\n            Assert.Equal(\"4\", actual);\n        }"
      }
    ]
  },
  {
    "file": "DefaultJsonSerializerTests.cs",
    "methods": []
  },
  {
    "file": "DefaultJsonSerializerTestsBase.cs",
    "methods": [
      {
        "name": "SingleLineString_Test",
        "body": "{\n            var text = \"This is, sort of, surprising the 1. time you see that test-result.\";\n            var expected = \"\\\"This is, sort of, surprising the 1. time you see that test-result.\\\"\";\n\n            var actual = SerializeObject(text);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "MultiLineString_Test",
        "body": "{\n            var text = \"First line followed by Windows line break\\r\\nNow this is second with UNIX\\nand third at last\";\n            var expected = \"\\\"First line followed by Windows line break\\\\r\\\\nNow this is second with UNIX\\\\nand third at last\\\"\";\n\n            var actual = SerializeObject(text);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "StringWithTabBackSpaceFormfeed_Test",
        "body": "{\n            var text = \"A tab\\tis followed by a feed\\fand finally cancel last character\\b\";\n            var expected = \"\\\"A tab\\\\tis followed by a feed\\\\fand finally cancel last character\\\\b\\\"\";\n\n            var actual = SerializeObject(text);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "StringWithSlashAndQuotes_Test",
        "body": "{\n            var text = \"This sentence/text is \\\"normal\\\", we think.\";\n            var expected = \"\\\"This sentence/text is \\\\\\\"normal\\\\\\\", we think.\\\"\";\n\n            var actual = SerializeObject(text);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "SerializeUnicode_test",
        "body": "{\n            var actual = SerializeObject(\"©\");\n            Assert.Equal(\"\\\"©\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeUnicodeInAnomObject_test",
        "body": "{\n            var item = new\n            {\n                text = \"©\"\n            };\n\n            var actual = SerializeObject(item);\n            Assert.Equal(\"{\\\"text\\\":\\\"©\\\"}\", actual);\n        }"
      },
      {
        "name": "ReferenceLoopInDictionary_Test",
        "body": "{\n            var d = new Dictionary<string, object>();\n            d.Add(\"First\", 17);\n            d.Add(\"Loop\", d);\n            var target = new Dictionary<string, object>\n            {\n                {\"Name\", \"TestObject\" },\n                {\"Assets\" , d }\n            };\n\n            var expected = \"{\\\"Name\\\":\\\"TestObject\\\",\\\"Assets\\\":{\\\"First\\\":17}}\";\n            var actual = SerializeObject(target);\n\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "ReferenceLoopInList_Test",
        "body": "{\n            var d = new List<object>();\n            d.Add(17);\n            d.Add(d);\n            d.Add(3.14);\n            var target = new List<object>\n            {\n                {\"TestObject\" },\n                {d }\n            };\n\n            var expected = \"[\\\"TestObject\\\",[17,3.14]]\";\n            var actual = SerializeObject(target);\n\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "InfiniteLoop_Test",
        "body": "{\n            var d = new TestList();\n            var actual = SerializeObject(d);\n\n            var cnt = Regex.Matches(actual, \"\\\\[\\\"alpha\\\",\\\"bravo\\\"\\\\]\").Count;\n            Assert.Equal(10, cnt);\n        }"
      },
      {
        "name": "StringWithMixedControlCharacters_Test",
        "body": "{\n            var text = \"First\\\\Second\\tand\" + (char)3 + \"for\" + (char)0x1f + \"with\" + (char)0x10 + \"but\" + (char)0x0d + \"and no\" + (char)0x20;\n            var expected = \"\\\"First\\\\\\\\Second\\\\tand\\\\u0003for\\\\u001fwith\\\\u0010but\\\\rand no \\\"\";\n\n            var actual = SerializeObject(text);\n            Assert.Equal(expected, actual);\n        }"
      },
      {
        "name": "SerializeBool_Test",
        "body": "{\n            var actual = SerializeObject(true);\n            Assert.Equal(\"true\", actual);\n            actual = SerializeObject(false);\n            Assert.Equal(\"false\", actual);\n        }"
      },
      {
        "name": "SerializeNumberDecimal_Test",
        "body": "{\n            var actual = SerializeObject(-1M);\n            Assert.Equal(\"-1.0\", actual);\n\n            actual = SerializeObject(0M);\n            Assert.Equal(\"0.0\", actual);\n\n            actual = SerializeObject(1M);\n            Assert.Equal(\"1.0\", actual);\n\n            actual = SerializeObject(2M);\n            Assert.Equal(\"2.0\", actual);\n\n            actual = SerializeObject(3M);\n            Assert.Equal(\"3.0\", actual);\n\n            actual = SerializeObject(4M);\n            Assert.Equal(\"4.0\", actual);\n\n            actual = SerializeObject(5M);\n            Assert.Equal(\"5.0\", actual);\n\n            actual = SerializeObject(6M);\n            Assert.Equal(\"6.0\", actual);\n\n            actual = SerializeObject(7M);\n            Assert.Equal(\"7.0\", actual);\n\n            actual = SerializeObject(8M);\n            Assert.Equal(\"8.0\", actual);\n\n            actual = SerializeObject(9M);\n            Assert.Equal(\"9.0\", actual);\n\n            actual = SerializeObject(3.14159265M);\n            Assert.Equal(\"3.14159265\", actual);\n        }"
      },
      {
        "name": "SerializeDateTime_Test",
        "body": "{\n            DateTime utcNow = DateTime.UtcNow;\n            utcNow = utcNow.AddTicks(-utcNow.Ticks % TimeSpan.TicksPerSecond);\n            var actual = SerializeObject(utcNow);\n            Assert.Equal(\"\\\"\" + utcNow.ToString(\"yyyy-MM-ddTHH:mm:ssZ\", CultureInfo.InvariantCulture) + \"\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeDateTime_Test2",
        "body": "{\n            var culture = System.Threading.Thread.CurrentThread.CurrentCulture;\n\n            try\n            {\n                System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-GB\");    // uses \".\" instead of \":\" for time\n\n                var val = new DateTime(2016, 12, 31);\n                var actual = SerializeObject(val);\n                Assert.Equal(\"\\\"\" + \"2016-12-31T00:00:00Z\" + \"\\\"\", actual);\n            }\n            finally\n            {\n                // Restore\n                System.Threading.Thread.CurrentThread.CurrentCulture = culture;\n            }\n        }"
      },
      {
        "name": "SerializeDateTimeOffset_Test",
        "body": "{\n            var culture = System.Threading.Thread.CurrentThread.CurrentCulture;\n\n            try\n            {\n                System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-GB\");    // uses \".\" instead of \":\" for time\n\n                var val = new DateTimeOffset(new DateTime(2016, 12, 31, 2, 30, 59), new TimeSpan(4, 30, 0));\n                var actual = SerializeObject(val);\n                Assert.Equal(\"\\\"\" + \"2016-12-31 02:30:59 +04:30\" + \"\\\"\", actual);\n            }\n            finally\n            {\n                // Restore\n                System.Threading.Thread.CurrentThread.CurrentCulture = culture;\n            }\n        }"
      },
      {
        "name": "SerializeTime_Test",
        "body": "{\n            var actual = SerializeObject(new TimeSpan(1, 2, 3, 4));\n            Assert.Equal(\"\\\"1.02:03:04\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeTime2_Test",
        "body": "{\n            var actual = SerializeObject(new TimeSpan(0, 2, 3, 4));\n            Assert.Equal(\"\\\"02:03:04\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeTime3_Test",
        "body": "{\n            var culture = System.Threading.Thread.CurrentThread.CurrentCulture;\n\n            try\n            {\n                System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo(\"en-GB\");    // uses \".\" instead of \":\" for time\n\n                var actual = SerializeObject(new TimeSpan(0, 0, 2, 3, 4));\n                Assert.Equal(\"\\\"00:02:03.0040000\\\"\", actual);\n            }\n            finally\n            {\n                // Restore\n                System.Threading.Thread.CurrentThread.CurrentCulture = culture;\n            }\n        }"
      },
      {
        "name": "SerializeEmptyDict_Test",
        "body": "{\n            var actual = SerializeObject(new Dictionary<string, int>());\n            Assert.Equal(\"{}\", actual);\n        }"
      },
      {
        "name": "SerializeDict_Test",
        "body": "{\n            var dictionary = new Dictionary<string, object>();\n            dictionary.Add(\"key1\", 13);\n            dictionary.Add(\"key 2\", 1.3m);\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"key1\\\":13,\\\"key 2\\\":1.3}\", actual);\n        }"
      },
      {
        "name": "SerializeCustomNullDict_Test",
        "body": "{\n            var dictionary = new Dictionary<string, object>();\n            dictionary.Add(\"key1\", 13);\n            dictionary.Add(\"key 2\", new CustomNullProperty());\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"key1\\\":13,\\\"key 2\\\":null}\", actual);\n        }"
      },
      {
        "name": "SerializeTrickyDict_Test",
        "body": "{\n            IDictionary<object, object> dictionary = new Internal.TrickyTestDictionary();\n            dictionary.Add(\"key1\", 13);\n            dictionary.Add(\"key 2\", 1.3m);\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"key1\\\":13,\\\"key 2\\\":1.3}\", actual);\n        }"
      },
      {
        "name": "SerializeExpandoDict_Test",
        "body": "{\n            IDictionary<string, IFormattable> dictionary = new Internal.ExpandoTestDictionary();\n            dictionary.Add(\"key 2\", 1.3m);\n            dictionary.Add(\"level\", LogLevel.Info);\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"key 2\\\":1.3, \\\"level\\\":\\\"Info\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializEmptyExpandoDict_Test",
        "body": "{\n            IDictionary<string, IFormattable> dictionary = new Internal.ExpandoTestDictionary();\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{}\", actual);\n        }"
      },
      {
        "name": "SerializeReadOnlyExpandoDict_Test",
        "body": "{\n            var dictionary = new Dictionary<string, object>();\n            dictionary.Add(\"key 2\", 1.3m);\n            dictionary.Add(\"level\", LogLevel.Info);\n\n            var readonlyDictionary = new Internal.ReadOnlyExpandoTestDictionary(dictionary);\n            var actual = SerializeObject(readonlyDictionary);\n            Assert.Equal(\"{\\\"key 2\\\":1.3, \\\"level\\\":\\\"Info\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeIntegerKeyDict_Test",
        "body": "{\n            var dictionary = new Dictionary<int, string>();\n            dictionary.Add(1, \"One\");\n            dictionary.Add(2, \"Two\");\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"1\\\":\\\"One\\\",\\\"2\\\":\\\"Two\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeEnumKeyDict_Test",
        "body": "{\n            var dictionary = new Dictionary<ExceptionRenderingFormat, int>();\n            dictionary.Add(ExceptionRenderingFormat.Method, 4);\n            dictionary.Add(ExceptionRenderingFormat.StackTrace, 5);\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"Method\\\":4,\\\"StackTrace\\\":5}\", actual);\n        }"
      },
      {
        "name": "SerializeObjectKeyDict_Test",
        "body": "{\n            var dictionary = new Dictionary<object, string>();\n            dictionary.Add(new { Name = \"Hello\" }, \"World\");\n            dictionary.Add(new { Name = \"Goodbye\" }, \"Money\");\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"{ Name = Hello }\\\":\\\"World\\\",\\\"{ Name = Goodbye }\\\":\\\"Money\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeBadStringKeyDict_Test",
        "body": "{\n            var dictionary = new Dictionary<string, string>();\n            dictionary.Add(\"\\t\", \"Tab\");\n            dictionary.Add(\"\\n\", \"Newline\");\n            var actual = SerializeObject(dictionary);\n            Assert.Equal(\"{\\\"\\\\t\\\":\\\"Tab\\\",\\\"\\\\n\\\":\\\"Newline\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeNull_Test",
        "body": "{\n            var actual = SerializeObject(null);\n            Assert.Equal(\"null\", actual);\n        }"
      },
      {
        "name": "SerializeGuid_Test",
        "body": "{\n            Guid newGuid = Guid.NewGuid();\n            var actual = SerializeObject(newGuid);\n            Assert.Equal(\"\\\"\" + newGuid.ToString() + \"\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeEnum_Test",
        "body": "{\n            var val = ExceptionRenderingFormat.Method;\n            var actual = SerializeObject(val);\n            Assert.Equal(\"\\\"Method\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeFlagEnum_Test",
        "body": "{\n            var val = UrlHelper.EscapeEncodingOptions.LegacyRfc2396 | UrlHelper.EscapeEncodingOptions.LowerCaseHex;\n            var actual = SerializeObject(val);\n            Assert.Equal(\"\\\"LegacyRfc2396, LowerCaseHex\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeObject_Test",
        "body": "{\n            var object1 = new TestObject(\"object1\");\n            var object2 = new TestObject(\"object2\");\n\n            object1.Linked = object2;\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"{\\\"Name\\\":\\\"object1\\\", \\\"Linked\\\":{\\\"Name\\\":\\\"object2\\\"}}\", actual);\n        }"
      },
      {
        "name": "SerializeRecusiveObject_Test",
        "body": "{\n            var object1 = new TestObject(\"object1\");\n\n            object1.Linked = object1;\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"{\\\"Name\\\":\\\"object1\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeListObject_Test",
        "body": "{\n            var object1 = new TestObject(\"object1\");\n            var object2 = new TestObject(\"object2\");\n            object1.Linked = object2;\n\n            var list = new[] { object1, object2 };\n\n            var actual = SerializeObject(list);\n            Assert.Equal(\"[{\\\"Name\\\":\\\"object1\\\", \\\"Linked\\\":{\\\"Name\\\":\\\"object2\\\"}},{\\\"Name\\\":\\\"object2\\\"}]\", actual);\n        }"
      },
      {
        "name": "SerializeNoPropsObject_Test",
        "body": "{\n            var object1 = new NoPropsObject();\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"\\\"something\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeObjectWithExceptionAndPrivateSetter_Test",
        "body": "{\n            var object1 = new ObjectWithExceptionAndPrivateSetter(\"test name\");\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"{\\\"Name\\\":\\\"test name\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeValueTuple_Test",
        "body": "{\n            // Could perform reflection on fields, but one have to lookup TupleElementNamesAttribute to get names\n            // ValueTuples are for internal usage, better to use AnonymousObject for key/value-pairs\n            var object1 = (Name: \"test name\", Id: 1);\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"\\\"(test name, 1)\\\"\", actual);\n        }"
      },
      {
        "name": "SerializeAnonymousObject_Test",
        "body": "{\n            var object1 = new { Id = 123, Name = \"test name\" };\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"{\\\"Id\\\":123, \\\"Name\\\":\\\"test name\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeExpandoObject_Test",
        "body": "{\n            dynamic object1 = new ExpandoObject();\n            object1.Id = 123;\n            object1.Name = \"test name\";\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"{\\\"Id\\\":123, \\\"Name\\\":\\\"test name\\\"}\", actual);\n        }"
      },
      {
        "name": "SerializeDynamicObject_Test",
        "body": "{\n            var object1 = new MyDynamicClass();\n            var actual = SerializeObject(object1);\n            Assert.Equal(\"{\\\"Id\\\":123, \\\"Name\\\":\\\"test name\\\"}\", actual);\n        }"
      },
      {
        "name": "SingleItemOptimizedHashSetTest",
        "body": "{\n            var hashSet = default(NLog.Internal.SingleItemOptimizedHashSet<object>);\n            Assert.Empty(hashSet);\n            Assert.DoesNotContain(new object(), hashSet);\n            foreach (var obj in hashSet)\n                throw new Exception(\"Wrong\");\n            hashSet.Clear();\n            Assert.Empty(hashSet);\n            hashSet.Add(new object());\n            Assert.Single(hashSet);\n            hashSet.Add(new object());\n            Assert.Equal(2, hashSet.Count);\n            foreach (var obj in hashSet)\n                Assert.Contains(obj, hashSet);\n            object[] objArray = new object[2];\n            hashSet.CopyTo(objArray, 0);\n            foreach (var obj in objArray)\n            {\n                Assert.NotNull(obj);\n                hashSet.Remove(obj);\n            }\n            Assert.Empty(hashSet);\n            hashSet.Clear();\n            Assert.Empty(hashSet);\n        }"
      }
    ]
  },
  {
    "file": "LineEndingModeTests.cs",
    "methods": [
      {
        "name": "LineEndingModeEqualityTest",
        "body": "{\n            LineEndingMode modeDefault = LineEndingMode.Default;\n            LineEndingMode modeNone = LineEndingMode.None;\n            LineEndingMode modeLF = LineEndingMode.LF;\n            LineEndingMode modeCRLF = LineEndingMode.CRLF;\n            LineEndingMode modeNull = LineEndingMode.Null;\n\n            Assert.True(LineEndingMode.Default == modeDefault);\n            Assert.True(LineEndingMode.None == modeNone);\n            Assert.True(LineEndingMode.LF == modeLF);\n            Assert.True(LineEndingMode.Null == modeNull);\n            Assert.False(LineEndingMode.Default == modeNone);\n            Assert.False(LineEndingMode.None == modeLF);\n            Assert.False(LineEndingMode.None == modeCRLF);\n            Assert.False(LineEndingMode.None == modeNull);\n            Assert.False(LineEndingMode.None == (object)new { });\n            Assert.False(LineEndingMode.None is null);\n\n            Assert.True(LineEndingMode.Default.Equals(modeDefault));\n            Assert.True(LineEndingMode.None.Equals(modeNone));\n            Assert.True(LineEndingMode.LF.Equals(modeLF));\n            Assert.True(LineEndingMode.Null.Equals(modeNull));\n            Assert.False(LineEndingMode.Default.Equals(modeNone));\n            Assert.False(LineEndingMode.None.Equals(modeLF));\n            Assert.False(LineEndingMode.None.Equals(modeCRLF));\n            Assert.False(LineEndingMode.None.Equals(modeNull));\n            Assert.False(LineEndingMode.None.Equals(new { }));\n            Assert.False(LineEndingMode.None.Equals(null));\n\n            // Handle running tests on different operating systems\n            if (modeCRLF.NewLineCharacters == Environment.NewLine)\n            {\n                Assert.False(LineEndingMode.LF == modeDefault);\n                Assert.True(LineEndingMode.CRLF == modeDefault);\n            }\n            else\n            {\n                Assert.True(LineEndingMode.LF == modeDefault);\n                Assert.False(LineEndingMode.CRLF == modeDefault);\n            }\n        }"
      },
      {
        "name": "LineEndingModeInequalityTest",
        "body": "{\n            LineEndingMode modeDefault = LineEndingMode.Default;\n            LineEndingMode modeNone = LineEndingMode.None;\n            LineEndingMode modeLF = LineEndingMode.LF;\n            LineEndingMode modeCRLF = LineEndingMode.CRLF;\n            LineEndingMode modeNull = LineEndingMode.Null;\n\n            Assert.True(LineEndingMode.Default != modeNone);\n            Assert.True(LineEndingMode.None != modeLF);\n            Assert.True(LineEndingMode.None != modeCRLF);\n            Assert.True(LineEndingMode.None != modeNull);\n            Assert.False(LineEndingMode.Default != modeDefault);\n            Assert.False(LineEndingMode.None != modeNone);\n            Assert.False(LineEndingMode.LF != modeLF);\n            Assert.False(LineEndingMode.CRLF != modeCRLF);\n            Assert.False(LineEndingMode.Null != modeNull);\n\n            Assert.True(null != LineEndingMode.LF);\n            Assert.True(null != modeLF);\n            Assert.True(LineEndingMode.LF != null);\n            Assert.True(modeLF != null);\n            Assert.True(null != LineEndingMode.CRLF);\n            Assert.True(null != modeCRLF);\n            Assert.True(LineEndingMode.CRLF != null);\n            Assert.True(modeCRLF != null);\n            Assert.True(null != LineEndingMode.Null);\n            Assert.True(null != modeNull);\n            Assert.True(LineEndingMode.Null != null);\n            Assert.True(modeNull != null);\n\n            // Handle running tests on different operating systems\n            if (modeCRLF.NewLineCharacters == Environment.NewLine)\n            {\n                Assert.True(LineEndingMode.LF != modeDefault);\n            }\n            else\n            {\n                Assert.True(LineEndingMode.CRLF != modeDefault);\n            }\n        }"
      },
      {
        "name": "LineEndingModeNullComparison",
        "body": "{\n            LineEndingMode mode1 = LineEndingMode.LF;\n            Assert.False(mode1 is null);\n            Assert.True(mode1 != null);\n            Assert.False(null == mode1);\n            Assert.True(null != mode1);\n\n            LineEndingMode mode2 = null;\n            Assert.True(mode2 is null);\n            Assert.False(mode2 != null);\n            Assert.True(null == mode2);\n            Assert.False(null != mode2);\n        }"
      },
      {
        "name": "LineEndingModeToStringTest",
        "body": "{\n            Assert.Equal(\"None\", LineEndingMode.None.ToString());\n            Assert.Equal(\"Default\", LineEndingMode.Default.ToString());\n            Assert.Equal(\"CRLF\", LineEndingMode.CRLF.ToString());\n            Assert.Equal(\"CR\", LineEndingMode.CR.ToString());\n            Assert.Equal(\"LF\", LineEndingMode.LF.ToString());\n            Assert.Equal(\"Null\", LineEndingMode.Null.ToString());\n        }"
      }
    ]
  },
  {
    "file": "MemoryTargetTests.cs",
    "methods": [
      {
        "name": "MemoryTarget_LogLevelTest",
        "body": "{\n            var memoryTarget = new MemoryTarget\n            {\n                Layout = \"${level} ${message}\"\n            };\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(memoryTarget);\n            }).GetCurrentClassLogger();\n\n            Assert.Empty(memoryTarget.Logs);\n            logger.Trace(\"TTT\");\n            logger.Debug(\"DDD\");\n            logger.Info(\"III\");\n            logger.Warn(\"WWW\");\n            logger.Error(\"EEE\");\n            logger.Fatal(\"FFF\");\n\n            logger.Factory.Configuration = null;\n\n            Assert.Equal(6, memoryTarget.Logs.Count);\n            Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Debug DDD\", memoryTarget.Logs[1]);\n            Assert.Equal(\"Info III\", memoryTarget.Logs[2]);\n            Assert.Equal(\"Warn WWW\", memoryTarget.Logs[3]);\n            Assert.Equal(\"Error EEE\", memoryTarget.Logs[4]);\n            Assert.Equal(\"Fatal FFF\", memoryTarget.Logs[5]);\n        }"
      },
      {
        "name": "MemoryTarget_ReconfigureTest_SameTarget_ExpectLogsEmptied",
        "body": "{\n            var memoryTarget = new MemoryTarget\n            {\n                Layout = \"${level} ${message}\"\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(memoryTarget);\n            }).GetCurrentClassLogger();\n\n            logger.Debug(\"DDD\");\n            logger.Info(\"III\");\n            logger.Warn(\"WWW\");\n\n            Assert.Equal(3, memoryTarget.Logs.Count);\n            Assert.Equal(\"Debug DDD\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Info III\", memoryTarget.Logs[1]);\n            Assert.Equal(\"Warn WWW\", memoryTarget.Logs[2]);\n\n            logger.Factory.Configuration = null;\n\n            // Reconfigure the logger to use a new MemoryTarget.\n            memoryTarget = new MemoryTarget\n            {\n                Layout = \"${level} ${message}\"\n            };\n\n            logger.Factory.Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(memoryTarget);\n            }).GetCurrentClassLogger();\n\n            logger.Trace(\"TTT\");\n            logger.Error(\"EEE\");\n            logger.Fatal(\"FFF\");\n\n            Assert.Equal(3, memoryTarget.Logs.Count);\n            Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Error EEE\", memoryTarget.Logs[1]);\n            Assert.Equal(\"Fatal FFF\", memoryTarget.Logs[2]);\n        }"
      },
      {
        "name": "MemoryTarget_ClearLogsTest",
        "body": "{\n            var memoryTarget = new MemoryTarget\n            {\n                Layout = \"${level} ${message}\"\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(memoryTarget);\n            }).GetCurrentClassLogger();\n\n            logger.Warn(\"WWW\");\n            logger.Error(\"EEE\");\n            logger.Fatal(\"FFF\");\n\n            memoryTarget.Logs.Clear();\n            logger.Trace(\"TTT\");\n            logger.Debug(\"DDD\");\n            logger.Info(\"III\");\n\n            logger.Factory.Configuration = null;\n\n            Assert.Equal(3, memoryTarget.Logs.Count);\n            Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Debug DDD\", memoryTarget.Logs[1]);\n            Assert.Equal(\"Info III\", memoryTarget.Logs[2]);\n\n            Assert.True(memoryTarget.Logs.All(l => !string.IsNullOrEmpty(l)));\n            Assert.True(memoryTarget.Logs.Contains(memoryTarget.Logs[0]));\n            Assert.False(memoryTarget.Logs.Contains(string.Empty));\n            Assert.True(memoryTarget.Logs.Remove(memoryTarget.Logs[0]));\n            Assert.False(memoryTarget.Logs.Remove(string.Empty));\n            Assert.Equal(2, memoryTarget.Logs.Count);\n            Assert.Equal(0, memoryTarget.Logs.IndexOf(memoryTarget.Logs[0]));\n            Assert.Equal(1, memoryTarget.Logs.IndexOf(memoryTarget.Logs[1]));\n            Assert.Equal(-1, memoryTarget.Logs.IndexOf(string.Empty));\n            memoryTarget.Logs.RemoveAt(1);\n            Assert.Single(memoryTarget.Logs);\n            memoryTarget.Logs[0] = \"Hello World\";\n            Assert.Contains(\"Hello World\", memoryTarget.Logs);\n            memoryTarget.Logs.Insert(1, \"Goodbye World\");\n            Assert.Equal(\"Hello World\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Goodbye World\", memoryTarget.Logs[1]);\n            Assert.Equal(2, memoryTarget.Logs.Count);\n        }"
      },
      {
        "name": "MemoryTarget_NullMessageTest",
        "body": "{\n            var memoryTarget = new MemoryTarget\n            {\n                Layout = \"${level} ${message}\"\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(memoryTarget);\n            }).GetCurrentClassLogger();\n\n            string nullMessage = null;\n\n            logger.Trace(\"TTT\");\n            logger.Debug((String)null);\n            logger.Info(\"III\");\n            logger.Warn(nullMessage);\n            logger.Error(\"EEE\");\n\n            logger.Factory.Configuration = null;\n\n            Assert.Equal(5, memoryTarget.Logs.Count);\n            Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Debug \", memoryTarget.Logs[1]);\n            Assert.Equal(\"Info III\", memoryTarget.Logs[2]);\n            Assert.Equal(\"Warn \", memoryTarget.Logs[3]);\n            Assert.Equal(\"Error EEE\", memoryTarget.Logs[4]);\n        }"
      },
      {
        "name": "MemoryTarget_EmptyMessageTest",
        "body": "{\n            var memoryTarget = new MemoryTarget\n            {\n                Layout = \"${level} ${message}\"\n            };\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(memoryTarget);\n            }).GetCurrentClassLogger();\n\n            logger.Trace(\"TTT\");\n            logger.Debug(String.Empty);\n            logger.Info(\"III\");\n            logger.Warn(\"\");\n            logger.Error(\"EEE\");\n\n            logger.Factory.Configuration = null;\n\n            Assert.Equal(5, memoryTarget.Logs.Count);\n            Assert.Equal(\"Trace TTT\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Debug \", memoryTarget.Logs[1]);\n            Assert.Equal(\"Info III\", memoryTarget.Logs[2]);\n            Assert.Equal(\"Warn \", memoryTarget.Logs[3]);\n            Assert.Equal(\"Error EEE\", memoryTarget.Logs[4]);\n        }"
      }
    ]
  },
  {
    "file": "MethodCallTests.cs",
    "methods": [
      {
        "name": "TestMethodCall1",
        "body": "{\n            TestMethodCall(new MethodCallRecord(\"StaticAndPublic\", \"test1\", 2), \"StaticAndPublic\", CorrectClassName);\n        }"
      },
      {
        "name": "TestMethodCall2",
        "body": "{\n            //Type AssemblyQualifiedName\n            //to find, use typeof(MethodCallTests).AssemblyQualifiedName\n            TestMethodCall(new MethodCallRecord(\"StaticAndPublic\", \"test1\", 2), \"StaticAndPublic\", \"NLog.UnitTests.Targets.MethodCallTests, NLog.UnitTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b793d3de60bec2b9\");\n        }"
      },
      {
        "name": "PrivateMethodDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"NonStaticAndPublic\", CorrectClassName);\n            }\n        }"
      },
      {
        "name": "WrongClassDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"StaticAndPublic\", \"NLog.UnitTests222.Targets.CallTest, NLog.UnitTests\");\n            }\n        }"
      },
      {
        "name": "WrongMethodDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"WrongStaticAndPublic\", CorrectClassName);\n            }\n        }"
      },
      {
        "name": "EmptyClassDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"\", \"\");\n            }\n        }"
      },
      {
        "name": "WrongParametersDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"StaticAndPublicWrongParameters\", CorrectClassName);\n            }\n        }"
      },
      {
        "name": "TooLessParametersDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"StaticAndPublicTooLessParameters\", CorrectClassName);\n            }\n        }"
      },
      {
        "name": "TooManyParametersDontThrow",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                TestMethodCall(null, \"StaticAndPublicTooManyParameters\", CorrectClassName);\n            }\n        }"
      },
      {
        "name": "OptionalParameters",
        "body": "{\n            TestMethodCall(new MethodCallRecord(\"StaticAndPublicOptional\", \"test1\", 2, \"fixedValue\"), \"StaticAndPublicOptional\", CorrectClassName);\n        }"
      },
      {
        "name": "FluentDelegateConfiguration",
        "body": "{\n            string expectedMessage = \"Hello World\";\n            string actualMessage = string.Empty;\n\n            var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                var target = new MethodCallTarget(\"Hello\", (logEvent, parameters) => { actualMessage = logEvent.Message; });\n                builder.ForLogger().WriteTo(target);\n            }).LogFactory;\n\n            logFactory.GetCurrentClassLogger().Debug(expectedMessage);\n            logFactory.GetCurrentClassLogger().Debug(expectedMessage);  // Bonus call to verify compiled expression tree works\n\n            Assert.Equal(expectedMessage, actualMessage);\n        }"
      }
    ]
  },
  {
    "file": "TargetWithContextTest.cs",
    "methods": [
      {
        "name": "TargetWithContextAsyncTest",
        "body": "{\n            CustomTargetWithContext target = new CustomTargetWithContext();\n            target.ContextProperties.Add(new TargetPropertyWithContext(\"threadid\", \"${threadid}\"));\n            target.IncludeScopeProperties = true;\n            target.IncludeGdc = true;\n            target.IncludeScopeNested = true;\n            target.IncludeCallSite = true;\n\n            AsyncTargetWrapper wrapper = new AsyncTargetWrapper();\n            wrapper.WrappedTarget = target;\n            wrapper.TimeToSleepBetweenBatches = 0;\n\n            var logger = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(wrapper);\n            }).GetLogger(\"Example\");\n\n            GlobalDiagnosticsContext.Clear();\n            ScopeContext.Clear();\n            GlobalDiagnosticsContext.Set(\"TestKey\", \"Hello Global World\");\n            GlobalDiagnosticsContext.Set(\"GlobalKey\", \"Hello Global World\");\n            ScopeContext.PushProperty(\"TestKey\", \"Hello Async World\");\n            ScopeContext.PushProperty(\"AsyncKey\", \"Hello Async World\");\n            logger.Debug(\"log message\");\n            Assert.True(WaitForLastMessage(target));\n\n            Assert.NotEqual(0, target.LastMessage.Length);\n            Assert.NotNull(target.LastCombinedProperties);\n            Assert.NotEmpty(target.LastCombinedProperties);\n            Assert.Equal(5, target.LastCombinedProperties.Count);\n            Assert.Contains(new KeyValuePair<string, object>(\"GlobalKey\", \"Hello Global World\"), target.LastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"AsyncKey\", \"Hello Async World\"), target.LastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"TestKey\", \"Hello Async World\"), target.LastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"TestKey_1\", \"Hello Global World\"), target.LastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"threadid\", CurrentManagedThreadId.ToString()), target.LastCombinedProperties);\n        }"
      },
      {
        "name": "TargetWithContextMdcSerializeTest",
        "body": "{\n            MappedDiagnosticsContext.Clear();\n            MappedDiagnosticsContext.Set(\"TestKey\", new { a = \"b\" });\n\n            CustomTargetWithContext target = new CustomTargetWithContext() { IncludeMdc = true, SkipAssert = true };\n\n            WriteAndAssertSingleKey(target);\n        }"
      },
      {
        "name": "TargetWithContextMdlcSerializeTest",
        "body": "{\n            MappedDiagnosticsLogicalContext.Clear();\n            MappedDiagnosticsLogicalContext.Set(\"TestKey\", new { a = \"b\" });\n\n            CustomTargetWithContext target = new CustomTargetWithContext() { IncludeMdlc = true, SkipAssert = true };\n\n            WriteAndAssertSingleKey(target);\n        }"
      },
      {
        "name": "TargetWithContextNdcSerializeTest",
        "body": "{\n            NestedDiagnosticsContext.Clear();\n            NestedDiagnosticsContext.Push(new { a = \"b\" });\n\n            CustomTargetWithContext target = new CustomTargetWithContext() { IncludeNdc = true, SkipAssert = true };\n\n            WriteAndAssertSingleKey(target);\n        }"
      },
      {
        "name": "TargetWithContextNdlcSerializeTest",
        "body": "{\n            NestedDiagnosticsLogicalContext.Clear();\n            NestedDiagnosticsLogicalContext.Push(new { a = \"b\" });\n\n            CustomTargetWithContext target = new CustomTargetWithContext() { IncludeNdlc = true, SkipAssert = true };\n\n            WriteAndAssertSingleKey(target);\n        }"
      },
      {
        "name": "TargetWithContextConfigTest",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                                             .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))\n                                             .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <target name='debug' type='contexttarget' includeCallSite='true'>\n                            <contextproperty name='threadid' layout='${threadid}' hello='world' />\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Error' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            ScopeContext.Clear();\n            logger.Error(\"log message\");\n            var target = logFactory.Configuration.FindTargetByName(\"debug\") as CustomTargetWithContext;\n            Assert.NotEqual(0, target.LastMessage.Length);\n            var lastCombinedProperties = target.LastCombinedProperties;\n            Assert.NotEmpty(lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"threadid\", CurrentManagedThreadId.ToString()), lastCombinedProperties);\n        }"
      },
      {
        "name": "TargetWithContextAsyncPropertyTest",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                                             .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))\n                                             .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />\n                        <target name='debug' type='contexttarget' includeCallSite='true' includeEventProperties='true' excludeProperties='password' />\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Error' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();\n\n            LogEventInfo logEvent = LogEventInfo.Create(LogLevel.Error, logger.Name, \"Hello\");\n            logEvent.Properties[\"name\"] = \"Kenny\";\n            logEvent.Properties[\"password\"] = \"123Password\";\n            logger.Error(logEvent);\n            logFactory.Flush();\n            Assert.NotEqual(0, target.LastMessage.Length);\n            var lastCombinedProperties = target.LastCombinedProperties;\n            Assert.Single(lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"name\", \"Kenny\"), lastCombinedProperties);\n\n            logger.Error(\"Hello {name}\", \"Cartman\");\n            logEvent.Properties[\"Password\"] = \"123Password\";\n            logFactory.Flush();\n            lastCombinedProperties = target.LastCombinedProperties;\n            Assert.Single(lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"name\", \"Cartman\"), lastCombinedProperties);\n        }"
      },
      {
        "name": "TargetWithContextAsyncBufferScopePropertyTest",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                                 .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))\n                                 .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />\n                        <target name='debug_buffer' type='BufferingWrapper'>\n                           <target name='debug' type='contexttarget' includeCallSite='true' includeScopeProperties='true' excludeProperties='password' />\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Error' writeTo='debug_buffer' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();\n\n            using (logger.PushScopeProperty(\"name\", \"Kenny\"))\n            using (logger.PushScopeProperty(\"password\", \"123Password\"))\n            {\n                logger.Error(\"Hello\");\n            }\n            logFactory.Flush();\n            Assert.NotEqual(0, target.LastMessage.Length);\n            var lastCombinedProperties = target.LastCombinedProperties;\n            Assert.Single(lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"name\", \"Kenny\"), lastCombinedProperties);\n        }"
      },
      {
        "name": "TargetWithContextJsonTest",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                                             .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))\n                                             .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />\n                        <target name='debug' type='contexttarget' includeCallSite='true'>\n                            <layout type='JsonLayout' includeScopeProperties='true'>\n                                <attribute name='level' layout='${level:upperCase=true}'/>\n                                <attribute name='message' layout='${message}' />\n                                <attribute name='exception' layout='${exception}' />\n                                <attribute name='threadid' layout='${threadid}' />\n                            </layout>\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Error' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n\n            ScopeContext.Clear();\n            ScopeContext.PushProperty(\"TestKey\", \"Hello Thread World\");\n            logger.Error(\"log message\");\n            var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();\n            System.Threading.Thread.Sleep(1);\n            for (int i = 0; i < 1000; ++i)\n            {\n                if (target.LastMessage != null)\n                    break;\n\n                System.Threading.Thread.Sleep(1);\n            }\n\n            Assert.NotEqual(0, target.LastMessage.Length);\n            Assert.Contains(CurrentManagedThreadId.ToString(), target.LastMessage);\n            var lastCombinedProperties = target.LastCombinedProperties;\n            Assert.Empty(lastCombinedProperties);\n        }"
      },
      {
        "name": "TargetWithContextPropertyTypeTest",
        "body": "{\n            var logFactory = new LogFactory().Setup()\n                                             .SetupExtensions(ext => ext.RegisterTarget<CustomTargetWithContext>(\"contexttarget\"))\n                                             .LoadConfigurationFromXml(@\"\n                <nlog throwExceptions='true'>\n                    <targets>\n                        <default-wrapper type='AsyncWrapper' timeToSleepBetweenBatches='0' overflowAction='Block' />\n                        <target name='debug' type='contexttarget' includeCallSite='true'>\n                            <contextproperty name='threadid' layout='${threadid}' propertyType='System.Int32' />\n                            <contextproperty name='processid' layout='${processid}' propertyType='System.Int32' />\n                            <contextproperty name='timestamp' layout='${date}' propertyType='System.DateTime' />\n                            <contextproperty name='int-non-existing' layout='${event-properties:non-existing}' propertyType='System.Int32' includeEmptyValue='true' />\n                            <contextproperty name='int-non-existing-empty' layout='${event-properties:non-existing}' propertyType='System.Int32' includeEmptyValue='false' />\n                            <contextproperty name='string-non-existing' layout='${event-properties:non-existing}' propertyType='System.String' includeEmptyValue='true' />\n                            <contextproperty name='object-non-existing' layout='${event-properties:non-existing}' propertyType='System.Object' includeEmptyValue='true' />\n                            <contextproperty name='object-non-existing-empty' layout='${event-properties:non-existing}' propertyType='System.Object' includeEmptyValue='false' />\n                       </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' levels='Error' writeTo='debug' />\n                    </rules>\n                </nlog>\").LogFactory;\n\n            var logger = logFactory.GetLogger(\"A\");\n            ScopeContext.Clear();\n\n            var logEvent = new LogEventInfo() { Message = \"log message\" };\n            logger.Error(logEvent);\n            logFactory.Flush();\n            var target = logFactory.Configuration.AllTargets.OfType<CustomTargetWithContext>().FirstOrDefault();\n            Assert.NotEqual(0, target.LastMessage.Length);\n            var lastCombinedProperties = target.LastCombinedProperties;\n            Assert.NotEmpty(lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"threadid\", CurrentManagedThreadId), lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"processid\", CurrentProcessId), lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"int-non-existing\", 0), lastCombinedProperties);\n            Assert.DoesNotContain(\"int-non-existing-empty\", lastCombinedProperties.Keys);\n            Assert.Contains(new KeyValuePair<string, object>(\"string-non-existing\", \"\"), lastCombinedProperties);\n            Assert.Contains(new KeyValuePair<string, object>(\"object-non-existing\", null), lastCombinedProperties);\n            Assert.DoesNotContain(\"object-non-existing-empty\", lastCombinedProperties.Keys);\n        }"
      }
    ]
  },
  {
    "file": "AsyncRequestQueueTests.cs",
    "methods": [
      {
        "name": "AsyncRequestQueueWithDiscardBehaviorTest",
        "body": "{\n            var ev1 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev2 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev3 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev4 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n\n            var queue = new AsyncRequestQueue(3, AsyncTargetWrapperOverflowAction.Discard);\n            Assert.Equal(3, queue.RequestLimit);\n            Assert.Equal(AsyncTargetWrapperOverflowAction.Discard, queue.OnOverflow);\n            Assert.Equal(0, queue.RequestCount);\n            queue.Enqueue(ev1);\n            Assert.Equal(1, queue.RequestCount);\n            queue.Enqueue(ev2);\n            Assert.Equal(2, queue.RequestCount);\n            queue.Enqueue(ev3);\n            Assert.Equal(3, queue.RequestCount);\n            queue.Enqueue(ev4);\n            Assert.Equal(3, queue.RequestCount);\n\n            AsyncLogEventInfo[] logEventInfos = queue.DequeueBatch(10);\n            Assert.Equal(0, queue.RequestCount);\n\n            // ev1 is lost\n            Assert.Same(logEventInfos[0].LogEvent, ev2.LogEvent);\n            Assert.Same(logEventInfos[1].LogEvent, ev3.LogEvent);\n            Assert.Same(logEventInfos[2].LogEvent, ev4.LogEvent);\n            Assert.Same(logEventInfos[0].Continuation, ev2.Continuation);\n            Assert.Same(logEventInfos[1].Continuation, ev3.Continuation);\n            Assert.Same(logEventInfos[2].Continuation, ev4.Continuation);\n        }"
      },
      {
        "name": "AsyncRequestQueueWithGrowBehaviorTest",
        "body": "{\n            var ev1 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev2 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev3 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev4 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n\n            var queue = new AsyncRequestQueue(3, AsyncTargetWrapperOverflowAction.Grow);\n            Assert.Equal(3, queue.RequestLimit);\n            Assert.Equal(AsyncTargetWrapperOverflowAction.Grow, queue.OnOverflow);\n            Assert.Equal(0, queue.RequestCount);\n            queue.Enqueue(ev1);\n            Assert.Equal(1, queue.RequestCount);\n            queue.Enqueue(ev2);\n            Assert.Equal(2, queue.RequestCount);\n            queue.Enqueue(ev3);\n            Assert.Equal(3, queue.RequestCount);\n            queue.Enqueue(ev4);\n            Assert.Equal(4, queue.RequestCount);\n\n            AsyncLogEventInfo[] logEventInfos = queue.DequeueBatch(10);\n            int result = logEventInfos.Length;\n\n            Assert.Equal(4, result);\n            Assert.Equal(0, queue.RequestCount);\n\n            // ev1 is lost\n            Assert.Same(logEventInfos[0].LogEvent, ev1.LogEvent);\n            Assert.Same(logEventInfos[1].LogEvent, ev2.LogEvent);\n            Assert.Same(logEventInfos[2].LogEvent, ev3.LogEvent);\n            Assert.Same(logEventInfos[3].LogEvent, ev4.LogEvent);\n            Assert.Same(logEventInfos[0].Continuation, ev1.Continuation);\n            Assert.Same(logEventInfos[1].Continuation, ev2.Continuation);\n            Assert.Same(logEventInfos[2].Continuation, ev3.Continuation);\n            Assert.Same(logEventInfos[3].Continuation, ev4.Continuation);\n        }"
      },
      {
        "name": "AsyncRequestQueueWithBlockBehavior",
        "body": "{\n            var queue = new AsyncRequestQueue(10, AsyncTargetWrapperOverflowAction.Block);\n\n            ManualResetEvent producerFinished = new ManualResetEvent(false);\n\n            int pushingEvent = 0;\n\n            ThreadPool.QueueUserWorkItem(\n                s =>\n                {\n                    // producer thread\n                    for (int i = 0; i < 1000; ++i)\n                    {\n                        AsyncLogEventInfo logEvent = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n                        logEvent.LogEvent.Message = \"msg\" + i;\n\n                        // Console.WriteLine(\"Pushing event {0}\", i);\n                        pushingEvent = i;\n                        queue.Enqueue(logEvent);\n                    }\n\n                    producerFinished.Set();\n                });\n\n            // consumer thread\n            AsyncLogEventInfo[] logEventInfos;\n            int total = 0;\n\n            while (total < 500)\n            {\n                int left = 500 - total;\n\n                logEventInfos = queue.DequeueBatch(left);\n                int got = logEventInfos.Length;\n                Assert.True(got <= queue.RequestLimit);\n                total += got;\n            }\n\n            Thread.Sleep(500);\n\n            // producer is blocked on trying to push event #510\n            Assert.Equal(510, pushingEvent);\n            queue.DequeueBatch(1);\n            total++;\n            Thread.Sleep(500);\n\n            // producer is now blocked on trying to push event #511\n\n            Assert.Equal(511, pushingEvent);\n            while (total < 1000)\n            {\n                int left = 1000 - total;\n\n                logEventInfos = queue.DequeueBatch(left);\n                int got = logEventInfos.Length;\n                Assert.True(got <= queue.RequestLimit);\n                total += got;\n            }\n\n            // producer should now finish\n            producerFinished.WaitOne();\n        }"
      },
      {
        "name": "AsyncRequestQueueClearTest",
        "body": "{\n            var ev1 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev2 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev3 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n            var ev4 = LogEventInfo.CreateNullEvent().WithContinuation(ex => { });\n\n            var queue = new AsyncRequestQueue(3, AsyncTargetWrapperOverflowAction.Grow);\n            Assert.Equal(3, queue.RequestLimit);\n            Assert.Equal(AsyncTargetWrapperOverflowAction.Grow, queue.OnOverflow);\n            Assert.Equal(0, queue.RequestCount);\n            queue.Enqueue(ev1);\n            Assert.Equal(1, queue.RequestCount);\n            queue.Enqueue(ev2);\n            Assert.Equal(2, queue.RequestCount);\n            queue.Enqueue(ev3);\n            Assert.Equal(3, queue.RequestCount);\n            queue.Enqueue(ev4);\n            Assert.Equal(4, queue.RequestCount);\n            queue.Clear();\n            Assert.Equal(0, queue.RequestCount);\n\n            AsyncLogEventInfo[] logEventInfos;\n\n            logEventInfos = queue.DequeueBatch(10);\n            int result = logEventInfos.Length;\n            Assert.Equal(0, result);\n            Assert.Equal(0, queue.RequestCount);\n        }"
      },
      {
        "name": "RaiseEventLogEventQueueGrow_OnLogItems",
        "body": "{\n            const int RequestsLimit = 2;\n            const int EventsCount = 5;\n            const int ExpectedCountOfGrovingTimes = 2;\n            const int ExpectedFinalSize = 8;\n            int grovingItemsCount = 0;\n\n            AsyncRequestQueue requestQueue = new AsyncRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Grow);\n\n            requestQueue.LogEventQueueGrow += (o, e) => { grovingItemsCount++; };\n\n            for (int i = 0; i < EventsCount; i++)\n            {\n                requestQueue.Enqueue(new AsyncLogEventInfo());\n            }\n\n            Assert.Equal(ExpectedCountOfGrovingTimes, grovingItemsCount);\n            Assert.Equal(ExpectedFinalSize, requestQueue.RequestLimit);\n        }"
      },
      {
        "name": "RaiseEventLogEventDropped_OnLogItems",
        "body": "{\n            const int RequestsLimit = 2;\n            const int EventsCount = 5;\n            int discardedItemsCount = 0;\n\n            int ExpectedDiscardedItemsCount = EventsCount - RequestsLimit;\n            AsyncRequestQueue requestQueue = new AsyncRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Discard);\n\n            requestQueue.LogEventDropped += (o, e) => { discardedItemsCount++; };\n\n            for (int i = 0; i < EventsCount; i++)\n            {\n                requestQueue.Enqueue(new AsyncLogEventInfo());\n            }\n\n            Assert.Equal(ExpectedDiscardedItemsCount, discardedItemsCount);\n        }"
      }
    ]
  },
  {
    "file": "AsyncTargetWrapperTests.cs",
    "methods": [
      {
        "name": "AsyncTargetWrapperInitTest",
        "body": "{\n            var myTarget = new MyTarget();\n            var targetWrapper = new AsyncTargetWrapper(myTarget, 300, AsyncTargetWrapperOverflowAction.Grow);\n            Assert.Equal(AsyncTargetWrapperOverflowAction.Grow, targetWrapper.OverflowAction);\n            Assert.Equal(300, targetWrapper.QueueLimit);\n            Assert.Equal(1, targetWrapper.TimeToSleepBetweenBatches);\n            Assert.Equal(200, targetWrapper.BatchSize);\n        }"
      },
      {
        "name": "AsyncTargetWrapperInitTest2",
        "body": "{\n            var myTarget = new MyTarget();\n            var targetWrapper = new AsyncTargetWrapper()\n            {\n                WrappedTarget = myTarget,\n            };\n\n            Assert.Equal(AsyncTargetWrapperOverflowAction.Discard, targetWrapper.OverflowAction);\n            Assert.Equal(10000, targetWrapper.QueueLimit);\n            Assert.Equal(1, targetWrapper.TimeToSleepBetweenBatches);\n            Assert.Equal(200, targetWrapper.BatchSize);\n        }"
      },
      {
        "name": "AsyncTargetWrapperSyncTest_WithLock_WhenTimeToSleepBetweenBatchesIsEqualToZero",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                AsyncTargetWrapperSyncTest_WhenTimeToSleepBetweenBatchesIsEqualToZero(true);\n            });\n        }"
      },
      {
        "name": "AsyncTargetWrapperSyncTest_NoLock_WhenTimeToSleepBetweenBatchesIsEqualToZero",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                AsyncTargetWrapperSyncTest_WhenTimeToSleepBetweenBatchesIsEqualToZero(false);                \n            });\n        }"
      },
      {
        "name": "AsyncTargetWrapperSyncTest1",
        "body": "{\n            var myTarget = new MyTarget();\n            var targetWrapper = new AsyncTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                Name = \"AsyncTargetWrapperSyncTest1_Wrapper\",\n            };\n            targetWrapper.Initialize(null);\n            myTarget.Initialize(null);\n\n            try\n            {\n                var logEvent = new LogEventInfo();\n                Exception lastException = null;\n                ManualResetEvent continuationHit = new ManualResetEvent(false);\n                Thread continuationThread = null;\n                AsyncContinuation continuation =\n                    ex =>\n                        {\n                            lastException = ex;\n                            continuationThread = Thread.CurrentThread;\n                            continuationHit.Set();\n                        };\n\n                targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n                // continuation was not hit\n                Assert.True(continuationHit.WaitOne(5000));\n                Assert.NotSame(continuationThread, Thread.CurrentThread);\n                Assert.Null(lastException);\n                Assert.Equal(1, myTarget.WriteCount);\n\n                continuationHit.Reset();\n                targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n                Assert.True(continuationHit.WaitOne(5000));\n                Assert.NotSame(continuationThread, Thread.CurrentThread);\n                Assert.Null(lastException);\n                Assert.Equal(2, myTarget.WriteCount);\n            }\n            finally\n            {\n                myTarget.Close();\n                targetWrapper.Close();\n            }\n        }"
      },
      {
        "name": "AsyncTargetWrapperAsyncTest1",
        "body": "{\n            var myTarget = new MyAsyncTarget();\n            var targetWrapper = new AsyncTargetWrapper(myTarget) { Name = \"AsyncTargetWrapperAsyncTest1_Wrapper\" };\n            targetWrapper.Initialize(null);\n            myTarget.Initialize(null);\n            try\n            {\n                var logEvent = new LogEventInfo();\n                Exception lastException = null;\n                var continuationHit = new ManualResetEvent(false);\n                AsyncContinuation continuation =\n                    ex =>\n                    {\n                        lastException = ex;\n                        continuationHit.Set();\n                    };\n\n                targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n                Assert.True(continuationHit.WaitOne(5000));\n                Assert.Null(lastException);\n                Assert.Equal(1, myTarget.WriteCount);\n\n                continuationHit.Reset();\n                targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n                Assert.True(continuationHit.WaitOne(5000));\n                Assert.Null(lastException);\n                Assert.Equal(2, myTarget.WriteCount);\n            }\n            finally\n            {\n                myTarget.Close();\n                targetWrapper.Close();\n            }\n        }"
      },
      {
        "name": "AsyncTargetWrapperAsyncWithExceptionTest1",
        "body": "{\n            var myTarget = new MyAsyncTarget\n            {\n                ThrowExceptions = true,\n\n            };\n\n            var targetWrapper = new AsyncTargetWrapper(myTarget) { Name = \"AsyncTargetWrapperAsyncWithExceptionTest1_Wrapper\" };\n            targetWrapper.Initialize(null);\n            myTarget.Initialize(null);\n            try\n            {\n                var logEvent = new LogEventInfo();\n                Exception lastException = null;\n                var continuationHit = new ManualResetEvent(false);\n                AsyncContinuation continuation =\n                    ex =>\n                    {\n                        lastException = ex;\n                        continuationHit.Set();\n                    };\n\n                targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n                Assert.True(continuationHit.WaitOne(5000));\n                Assert.NotNull(lastException);\n                Assert.IsType<InvalidOperationException>(lastException);\n\n                // no flush on exception\n                Assert.Equal(0, myTarget.FlushCount);\n                Assert.Equal(1, myTarget.WriteCount);\n\n                continuationHit.Reset();\n                lastException = null;\n                targetWrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n                Assert.True(continuationHit.WaitOne(5000));\n                Assert.NotNull(lastException);\n                Assert.IsType<InvalidOperationException>(lastException);\n                Assert.Equal(0, myTarget.FlushCount);\n                Assert.Equal(2, myTarget.WriteCount);\n            }\n            finally\n            {\n                myTarget.Close();\n                targetWrapper.Close();\n            }\n        }"
      },
      {
        "name": "AsyncTargetWrapperFlushTest",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                var myTarget = new MyAsyncTarget\n                {\n                    ThrowExceptions = true\n                };\n\n                var targetWrapper = new AsyncTargetWrapper(myTarget)\n                {\n                    Name = \"AsyncTargetWrapperFlushTest_Wrapper\",\n                    OverflowAction = AsyncTargetWrapperOverflowAction.Grow\n                };\n\n                targetWrapper.Initialize(null);\n                myTarget.Initialize(null);\n\n                try\n                {\n                    List<Exception> exceptions = new List<Exception>();\n\n                    int eventCount = 5000;\n\n                    for (int i = 0; i < eventCount; ++i)\n                    {\n                        targetWrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(\n                            ex =>\n                            {\n                                lock (exceptions)\n                                {\n                                    exceptions.Add(ex);\n                                }\n                            }));\n                    }\n\n                    Exception lastException = null;\n                    ManualResetEvent mre = new ManualResetEvent(false);\n\n                    string internalLog = RunAndCaptureInternalLog(\n                        () =>\n                        {\n                            targetWrapper.Flush(\n                                cont =>\n                                {\n                                    try\n                                    {\n                                        // by this time all continuations should be completed\n                                        Assert.Equal(eventCount, exceptions.Count);\n\n                                        // with just 1 flush of the target\n                                        Assert.Equal(1, myTarget.FlushCount);\n\n                                        // and all writes should be accounted for\n                                        Assert.Equal(eventCount, myTarget.WriteCount);\n                                    }\n                                    catch (Exception ex)\n                                    {\n                                        lastException = ex;\n                                    }\n                                    finally\n                                    {\n                                        mre.Set();\n                                    }\n                                });\n                            Assert.True(mre.WaitOne(5000), InternalLogger.LogWriter?.ToString() ?? string.Empty);\n                        },\n                        LogLevel.Trace);\n\n                    Assert.True(lastException is null, lastException?.ToString() + \"\\r\\n\" + internalLog);\n                }\n                finally\n                {\n                    myTarget.Close();\n                    targetWrapper.Close();\n                }\n            });\n        }"
      },
      {
        "name": "AsyncTargetWrapperCloseTest",
        "body": "{\n            var myTarget = new MyAsyncTarget\n            {\n                ThrowExceptions = true\n            };\n\n            var targetWrapper = new AsyncTargetWrapper(myTarget)\n            {\n                OverflowAction = AsyncTargetWrapperOverflowAction.Grow,\n                TimeToSleepBetweenBatches = 1000,\n                Name = \"AsyncTargetWrapperCloseTest_Wrapper\",\n            };\n\n            targetWrapper.Initialize(null);\n            myTarget.Initialize(null);\n\n            var writeOnClose = new ManualResetEvent(false);\n\n            targetWrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => { writeOnClose.Set(); }));\n\n            // quickly close the target before the timer elapses\n            targetWrapper.Close();\n\n            Assert.True(writeOnClose.WaitOne(5000));\n        }"
      },
      {
        "name": "AsyncTargetWrapperExceptionTest",
        "body": "{\n            var targetWrapper = new AsyncTargetWrapper\n            {\n                OverflowAction = AsyncTargetWrapperOverflowAction.Grow,\n                TimeToSleepBetweenBatches = 500,\n                WrappedTarget = new DebugTarget(),\n                Name = \"AsyncTargetWrapperExceptionTest_Wrapper\"\n            };\n\n            using (new NoThrowNLogExceptions())\n            {\n                targetWrapper.Initialize(null);\n\n                // null out wrapped target - will cause exception on the timer thread\n                targetWrapper.WrappedTarget = null;\n\n                string internalLog = RunAndCaptureInternalLog(\n                    () =>\n                    {\n                        targetWrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => { }));\n                        targetWrapper.Close();\n                    },\n                    LogLevel.Trace);\n\n                Assert.True(internalLog.Contains(\"WrappedTarget is NULL\"), internalLog);\n            }\n        }"
      },
      {
        "name": "FlushingMultipleTimesSimultaneous",
        "body": "{\n            var asyncTarget = new AsyncTargetWrapper\n            {\n                TimeToSleepBetweenBatches = 1000,\n                WrappedTarget = new DebugTarget(),\n                Name = \"FlushingMultipleTimesSimultaneous_Wrapper\"\n            };\n            asyncTarget.Initialize(null);\n\n            try\n            {\n                asyncTarget.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => { }));\n\n                var firstContinuationCalled = false;\n                var secondContinuationCalled = false;\n                var firstContinuationResetEvent = new ManualResetEvent(false);\n                var secondContinuationResetEvent = new ManualResetEvent(false);\n                asyncTarget.Flush(ex =>\n                {\n                    firstContinuationCalled = true;\n                    firstContinuationResetEvent.Set();\n                });\n                asyncTarget.Flush(ex =>\n                {\n                    secondContinuationCalled = true;\n                    secondContinuationResetEvent.Set();\n                });\n\n                Assert.True(firstContinuationResetEvent.WaitOne(5000), nameof(firstContinuationResetEvent));\n                Assert.True(secondContinuationResetEvent.WaitOne(5000), nameof(secondContinuationResetEvent));\n                Assert.True(firstContinuationCalled);\n                Assert.True(secondContinuationCalled);\n            }\n            finally\n            {\n                asyncTarget.Close();\n            }\n        }"
      },
      {
        "name": "LogEventDropped_OnRequestqueueOverflow",
        "body": "{\n            int queueLimit = 2;\n            int loggedEventCount = 5;\n            int eventsCounter = 0;\n            var myTarget = new MyTarget();\n\n            var targetWrapper = new AsyncTargetWrapper()\n            {\n                WrappedTarget = myTarget,\n                QueueLimit = queueLimit,\n                TimeToSleepBetweenBatches = 500,    // Make it slow\n                OverflowAction = AsyncTargetWrapperOverflowAction.Discard,\n            };\n\n            var logFactory = new LogFactory();\n            var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);\n            loggingConfig.AddRuleForAllLevels(targetWrapper);\n            logFactory.Configuration = loggingConfig;\n            var logger = logFactory.GetLogger(\"Test\");\n\n            try\n            {\n                targetWrapper.LogEventDropped += (o, e) => { eventsCounter++; };\n\n                for (int i = 0; i < loggedEventCount; i++)\n                {\n                    logger.Info(\"Hello\");\n                }\n\n                Assert.Equal(loggedEventCount - queueLimit, eventsCounter);\n            }\n            finally\n            {\n                logFactory.Configuration = null;\n            }\n        }"
      },
      {
        "name": "LogEventNotDropped_IfOverflowActionBlock",
        "body": "{\n            int queueLimit = 2;\n            int loggedEventCount = 5;\n            int eventsCounter = 0;\n            var myTarget = new MyTarget();\n\n            var targetWrapper = new AsyncTargetWrapper()\n            {\n                WrappedTarget = myTarget,\n                QueueLimit = queueLimit,\n                OverflowAction = AsyncTargetWrapperOverflowAction.Block\n            };\n\n            var logFactory = new LogFactory();\n            var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);\n            loggingConfig.AddRuleForAllLevels(targetWrapper);\n            logFactory.Configuration = loggingConfig;\n            var logger = logFactory.GetLogger(\"Test\");\n\n            try\n            {\n                targetWrapper.LogEventDropped += (o, e) => { eventsCounter++; };\n\n                for (int i = 0; i < loggedEventCount; i++)\n                {\n                    logger.Info(\"Hello\");\n                }\n\n                Assert.Equal(0, eventsCounter);\n            }\n            finally\n            {\n                logFactory.Configuration = null;\n            }\n        }"
      },
      {
        "name": "LogEventNotDropped_IfOverflowActionGrow",
        "body": "{\n            int queueLimit = 2;\n            int loggedEventCount = 5;\n            int eventsCounter = 0;\n            var myTarget = new MyTarget();\n\n            var targetWrapper = new AsyncTargetWrapper()\n            {\n                WrappedTarget = myTarget,\n                QueueLimit = queueLimit,\n                OverflowAction = AsyncTargetWrapperOverflowAction.Grow\n            };\n\n            var logFactory = new LogFactory();\n            var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);\n            loggingConfig.AddRuleForAllLevels(targetWrapper);\n            logFactory.Configuration = loggingConfig;\n            var logger = logFactory.GetLogger(\"Test\");\n\n            try\n            {\n                targetWrapper.LogEventDropped += (o, e) => { eventsCounter++; };\n\n                for (int i = 0; i < loggedEventCount; i++)\n                {\n                    logger.Info(\"Hello\");\n                }\n\n                Assert.Equal(0, eventsCounter);\n            }\n            finally\n            {\n                logFactory.Configuration = null;\n            }\n        }"
      },
      {
        "name": "EventQueueGrow_OnQueueGrow",
        "body": "{\n            int queueLimit = 2;\n            int loggedEventCount = 10;\n\n            int expectedGrowingNumber = 3;\n\n            int eventsCounter = 0;\n            var myTarget = new MyTarget();\n\n            var targetWrapper = new AsyncTargetWrapper()\n            {\n                WrappedTarget = myTarget,\n                QueueLimit = queueLimit,\n                TimeToSleepBetweenBatches = 500,    // Make it slow\n                OverflowAction = AsyncTargetWrapperOverflowAction.Grow,\n            };\n\n            var logFactory = new LogFactory();\n            var loggingConfig = new NLog.Config.LoggingConfiguration(logFactory);\n            loggingConfig.AddRuleForAllLevels(targetWrapper);\n            logFactory.Configuration = loggingConfig;\n            var logger = logFactory.GetLogger(\"Test\");\n\n            try\n            {\n                targetWrapper.EventQueueGrow += (o, e) => { eventsCounter++; };\n\n                for (int i = 0; i < loggedEventCount; i++)\n                {\n                    logger.Info(\"Hello\");\n                }\n\n                Assert.Equal(expectedGrowingNumber, eventsCounter);\n            }\n            finally\n            {\n                logFactory.Configuration = null;\n            }\n        }"
      },
      {
        "name": "EnqueuQueueBlock_WithLock_OnClose_ReleasesWriters",
        "body": "{\n            EnqueuQueueBlock_OnClose_ReleasesWriters(true);\n        }"
      },
      {
        "name": "EnqueuQueueBlock_NoLock_OnClose_ReleasesWriters",
        "body": "{\n            EnqueuQueueBlock_OnClose_ReleasesWriters(false);\n        }"
      },
      {
        "name": "AsyncTargetWrapper_MissingDependency_EnqueueLogEvents",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                // Arrange\n                var logFactory = new LogFactory();\n                logFactory.ThrowConfigExceptions = true;\n                var logConfig = new LoggingConfiguration(logFactory);\n                var asyncTarget = new MyTarget() { Name = \"asynctarget\", RequiredDependency = typeof(IMisingDependencyClass) };\n                logConfig.AddRuleForAllLevels(new AsyncTargetWrapper(\"wrapper\", asyncTarget));\n                logFactory.Configuration = logConfig;\n                var logger = logFactory.GetLogger(nameof(AsyncTargetWrapper_MissingDependency_EnqueueLogEvents));\n\n                // Act\n                logger.Info(\"Hello World\");\n                Assert.False(asyncTarget.WaitForWriteEvent(50));\n                logFactory.ServiceRepository.RegisterService(typeof(IMisingDependencyClass), new MisingDependencyClass());\n\n                // Assert\n                Assert.True(asyncTarget.WaitForWriteEvent());\n            }\n        }"
      }
    ]
  },
  {
    "file": "AutoFlushTargetWrapperTests.cs",
    "methods": [
      {
        "name": "AutoFlushTargetWrapperSyncTest1",
        "body": "{\n            var myTarget = new MyTarget();\n            var wrapper = new AutoFlushTargetWrapper\n            {\n                WrappedTarget = myTarget,\n            };\n\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            bool continuationHit = false;\n            AsyncContinuation continuation =\n                ex =>\n                    {\n                        lastException = ex;\n                        continuationHit = true;\n                    };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            Assert.True(continuationHit);\n            Assert.Null(lastException);\n            Assert.Equal(1, myTarget.FlushCount);\n            Assert.Equal(1, myTarget.WriteCount);\n\n            continuationHit = false;\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            Assert.True(continuationHit);\n            Assert.Null(lastException);\n            Assert.Equal(2, myTarget.WriteCount);\n            Assert.Equal(2, myTarget.FlushCount);\n        }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncTest1",
        "body": "{\n            var myTarget = new MyAsyncTarget();\n            var wrapper = new AutoFlushTargetWrapper(myTarget);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit.Set();\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            Assert.True(continuationHit.WaitOne(5000));\n            Assert.Null(lastException);\n            Assert.Equal(1, myTarget.FlushCount);\n            Assert.Equal(1, myTarget.WriteCount);\n\n            continuationHit.Reset();\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            Assert.True(continuationHit.WaitOne(5000));\n            Assert.Null(lastException);\n            Assert.Equal(2, myTarget.WriteCount);\n            Assert.Equal(2, myTarget.FlushCount);\n        }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncTest2",
        "body": "{\n            var myTarget = new MyAsyncTarget();\n            var wrapper = new AutoFlushTargetWrapper(myTarget);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n\n            // Schedule 100 writes, where each write on completion schedules followup-flush (in random order)\n            const int expectedWriteCount = 100;\n            const int expectedFlushCount = expectedWriteCount + 3;\n            for (int i = 0; i < expectedWriteCount; ++i)\n            {\n                wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(ex => lastException = ex));\n            }\n\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    continuationHit.Set();\n                };\n\n            // Schedule 1st flush (can complete before follow-flushes)\n            wrapper.Flush(ex => { });\n            Assert.Null(lastException);\n            // Schedule 2nd flush (can complete before follow-flushes)\n            wrapper.Flush(continuation);\n            Assert.Null(lastException);\n            Assert.True(continuationHit.WaitOne(5000));\n            Assert.Null(lastException);\n            // Schedule 3rd flush (can complete before follow-flushes)\n            wrapper.Flush(ex => { });\n            Assert.Null(lastException);\n\n            for (int i = 0; i < 500; ++i)\n            {\n                if (myTarget.WriteCount == expectedWriteCount && myTarget.FlushCount == expectedFlushCount)\n                    break;\n                Thread.Sleep(10);\n            }\n\n            Assert.Equal(expectedWriteCount, myTarget.WriteCount);\n            Assert.Equal(expectedFlushCount, myTarget.FlushCount);\n        }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncTest3",
        "body": "{\n            var myTarget = new MyAsyncTarget();\n            var wrapper = new AutoFlushTargetWrapper(myTarget) { AsyncFlush = false };\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n\n            for (int i = 0; i < 100; ++i)\n            {\n                wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(ex => lastException = ex));\n            }\n\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    continuationHit.Set();\n                };\n\n            wrapper.Flush(ex => { });\n            Assert.Null(lastException);\n            wrapper.Flush(continuation);\n            Assert.Null(lastException);\n            Assert.True(continuationHit.WaitOne(5000));\n            Assert.Null(lastException);\n            wrapper.Flush(ex => { });   // Executed right away\n            Assert.Null(lastException);\n            Assert.Equal(100, myTarget.WriteCount);\n            Assert.Equal(103, myTarget.FlushCount);\n        }"
      },
      {
        "name": "AutoFlushTargetWrapperAsyncWithExceptionTest1",
        "body": "{\n            var myTarget = new MyAsyncTarget\n            {\n                ThrowExceptions = true,\n            };\n\n            var wrapper = new AutoFlushTargetWrapper(myTarget);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit.Set();\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            Assert.True(continuationHit.WaitOne(5000));\n            Assert.NotNull(lastException);\n            Assert.IsType<InvalidOperationException>(lastException);\n\n            // no flush on exception\n            Assert.Equal(0, myTarget.FlushCount);\n            Assert.Equal(1, myTarget.WriteCount);\n\n            continuationHit.Reset();\n            lastException = null;\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            Assert.True(continuationHit.WaitOne(5000));\n            Assert.NotNull(lastException);\n            Assert.IsType<InvalidOperationException>(lastException);\n            Assert.Equal(0, myTarget.FlushCount);\n            Assert.Equal(2, myTarget.WriteCount);\n        }"
      },
      {
        "name": "AutoFlushConditionConfigurationTest",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"<nlog>\n                    <targets>\n                        <target type='AutoFlushWrapper' condition='level >= LogLevel.Debug' name='FlushOnError'>\n                    <target name='d2' type='Debug' />\n                        </target>\n                    </targets>\n                    <rules>\n                        <logger name='*' level='Warn' writeTo='FlushOnError'>\n                        </logger>\n                    </rules>\n                  </nlog>\").LogFactory;\n            var target = logFactory.Configuration.FindTargetByName(\"FlushOnError\") as AutoFlushTargetWrapper;\n            Assert.NotNull(target);\n            Assert.NotNull(target.Condition);\n            Assert.Equal(\"(level >= Debug)\", target.Condition.ToString());\n            Assert.Equal(\"d2\", target.WrappedTarget.Name);\n        }"
      },
      {
        "name": "AutoFlushOnConditionTest",
        "body": "{\n            var testTarget = new MyTarget();\n            var autoFlushWrapper = new AutoFlushTargetWrapper(testTarget);\n            autoFlushWrapper.Condition = \"level > LogLevel.Info\";\n            testTarget.Initialize(null);\n            autoFlushWrapper.Initialize(null);\n            AsyncContinuation continuation = ex => { };\n            autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Info, \"*\", \"test\").WithContinuation(continuation));\n            autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n            autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Warn, \"*\", \"test\").WithContinuation(continuation));\n            autoFlushWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Error, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(4, testTarget.WriteCount);\n            Assert.Equal(2, testTarget.FlushCount);\n        }"
      },
      {
        "name": "MultipleConditionalAutoFlushWrappersTest",
        "body": "{\n            var testTarget = new MyTarget();\n            var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(testTarget);\n            autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";\n            var autoFlushOnMessageWrapper = new AutoFlushTargetWrapper(autoFlushOnLevelWrapper);\n            autoFlushOnMessageWrapper.Condition = \"contains('${message}','FlushThis')\";\n            testTarget.Initialize(null);\n            autoFlushOnLevelWrapper.Initialize(null);\n            autoFlushOnMessageWrapper.Initialize(null);\n\n            AsyncContinuation continuation = ex => { };\n            autoFlushOnMessageWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(1, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n            autoFlushOnMessageWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Fatal, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n            autoFlushOnMessageWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"Please FlushThis\").WithContinuation(continuation));\n            Assert.Equal(3, testTarget.WriteCount);\n            Assert.Equal(2, testTarget.FlushCount);\n        }"
      },
      {
        "name": "BufferingAutoFlushWrapperTest",
        "body": "{\n            var testTarget = new MyTarget();\n            var bufferingTargetWrapper = new BufferingTargetWrapper(testTarget, 100);\n            var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(bufferingTargetWrapper);\n            autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";\n            testTarget.Initialize(null);\n            bufferingTargetWrapper.Initialize(null);\n            autoFlushOnLevelWrapper.Initialize(null);\n\n            AsyncContinuation continuation = ex => { };\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(0, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Fatal, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"Please do not FlushThis\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.Flush(continuation);\n            Assert.Equal(3, testTarget.WriteCount);\n            Assert.Equal(2, testTarget.FlushCount);\n        }"
      },
      {
        "name": "IgnoreExplicitAutoFlushWrapperTest",
        "body": "{\n            var testTarget = new MyTarget();\n            var bufferingTargetWrapper = new BufferingTargetWrapper(testTarget, 100);\n            var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(bufferingTargetWrapper);\n            autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";\n            autoFlushOnLevelWrapper.FlushOnConditionOnly = true;\n            testTarget.Initialize(null);\n            bufferingTargetWrapper.Initialize(null);\n            autoFlushOnLevelWrapper.Initialize(null);\n\n            AsyncContinuation continuation = ex => { };\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(0, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Fatal, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"Ignore on Explict Flush\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.Flush(continuation);\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n        }"
      },
      {
        "name": "ExplicitFlushWaitsForAutoFlushWrapperCompletionTest",
        "body": "{\n            var testTarget = new MyTarget();\n            var bufferingTargetWrapper = new BufferingTargetWrapper(testTarget, 100);\n            var autoFlushOnLevelWrapper = new AutoFlushTargetWrapper(bufferingTargetWrapper);\n            autoFlushOnLevelWrapper.Condition = \"level > LogLevel.Info\";\n            autoFlushOnLevelWrapper.FlushOnConditionOnly = true;\n            testTarget.Initialize(null);\n            bufferingTargetWrapper.Initialize(null);\n            autoFlushOnLevelWrapper.Initialize(null);\n\n            AsyncContinuation continuation = ex => { };\n\n            var flushCompleted = false;\n\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Trace, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(0, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.Flush((ex) => flushCompleted = true);\n            Assert.True(flushCompleted);\n            Assert.Equal(0, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n\n            flushCompleted = false;\n            var manualResetEvent = new ManualResetEvent(false);\n            testTarget.FlushEvent = (arg) =>\n            {\n                Task.Run(() => manualResetEvent.WaitOne(10000)).ContinueWith(t => arg(null));\n            };\n\n            autoFlushOnLevelWrapper.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Error, \"*\", \"test\").WithContinuation(continuation));\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(0, testTarget.FlushCount);\n            autoFlushOnLevelWrapper.Flush((ex) => flushCompleted = true);\n            Assert.False(flushCompleted);\n            Assert.Equal(0, testTarget.FlushCount);\n            manualResetEvent.Set();\n            for (int i = 0; i < 500; ++i)\n            {\n                if (flushCompleted && testTarget.FlushCount > 0)\n                    break;\n                Thread.Sleep(10);\n            }\n            Assert.Equal(2, testTarget.WriteCount);\n            Assert.Equal(1, testTarget.FlushCount);\n        }"
      }
    ]
  },
  {
    "file": "BufferingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "BufferingTargetWrapperSyncTest1",
        "body": "{\n            var myTarget = new MyTarget();\n            var targetWrapper = new BufferingTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                BufferSize = 10,\n            };\n\n            InitializeTargets(myTarget, targetWrapper);\n\n            const int totalEvents = 100;\n\n            var continuationHit = new bool[totalEvents];\n            var lastException = new Exception[totalEvents];\n            var continuationThread = new Thread[totalEvents];\n            var hitCount = 0;\n\n            CreateContinuationFunc createAsyncContinuation =\n                eventNumber =>\n                    ex =>\n                    {\n                        lastException[eventNumber] = ex;\n                        continuationThread[eventNumber] = Thread.CurrentThread;\n                        continuationHit[eventNumber] = true;\n                        Interlocked.Increment(ref hitCount);\n                    };\n\n            // write 9 events - they will all be buffered and no final continuation will be reached\n            var eventCounter = 0;\n            for (var i = 0; i < 9; ++i)\n            {\n                targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            }\n\n            Assert.Equal(0, hitCount);\n            Assert.Equal(0, myTarget.WriteCount);\n\n            // write one more event - everything will be flushed\n            targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            Assert.Equal(10, hitCount);\n            Assert.Equal(1, myTarget.BufferedWriteCount);\n            Assert.Equal(10, myTarget.BufferedTotalEvents);\n            Assert.Equal(10, myTarget.WriteCount);\n            for (var i = 0; i < hitCount; ++i)\n            {\n                Assert.Same(Thread.CurrentThread, continuationThread[i]);\n                Assert.Null(lastException[i]);\n            }\n\n            // write 9 more events - they will all be buffered and no final continuation will be reached\n            for (var i = 0; i < 9; ++i)\n            {\n                targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            }\n\n            // no change\n            Assert.Equal(10, hitCount);\n            Assert.Equal(1, myTarget.BufferedWriteCount);\n            Assert.Equal(10, myTarget.BufferedTotalEvents);\n            Assert.Equal(10, myTarget.WriteCount);\n\n            Exception flushException = null;\n            var flushHit = new ManualResetEvent(false);\n\n            targetWrapper.Flush(\n                ex =>\n                {\n                    flushException = ex;\n                    flushHit.Set();\n                });\n\n            Assert.True(flushHit.WaitOne(5000), \"Wait Flush Timeout\");\n            Assert.Null(flushException);\n\n            // make sure remaining events were written\n            Assert.Equal(19, hitCount);\n            Assert.Equal(2, myTarget.BufferedWriteCount);\n            Assert.Equal(19, myTarget.BufferedTotalEvents);\n            Assert.Equal(19, myTarget.WriteCount);\n            Assert.Equal(1, myTarget.FlushCount);\n\n            // flushes happen on the same thread\n            for (var i = 10; i < hitCount; ++i)\n            {\n                Assert.NotNull(continuationThread[i]);\n                Assert.Same(Thread.CurrentThread, continuationThread[i]);\n                Assert.Null(lastException[i]);\n            }\n\n            // flush again - should just invoke Flush() on the wrapped target\n            flushHit.Reset();\n            targetWrapper.Flush(\n                ex =>\n                {\n                    flushException = ex;\n                    flushHit.Set();\n                });\n\n            Assert.True(flushHit.WaitOne(5000), \"Wait Again Flush Timeout\");\n            Assert.Equal(19, hitCount);\n            Assert.Equal(2, myTarget.BufferedWriteCount);\n            Assert.Equal(19, myTarget.BufferedTotalEvents);\n            Assert.Equal(19, myTarget.WriteCount);\n            Assert.Equal(2, myTarget.FlushCount);\n\n            targetWrapper.Close();\n            myTarget.Close();\n        }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithTimedFlushTest",
        "body": "{\n            var myTarget = new MyTarget();\n            var targetWrapper = new BufferingTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                BufferSize = 10,\n                FlushTimeout = 50,\n            };\n            var writeHit = new ManualResetEvent(false);\n\n            InitializeTargets(myTarget, targetWrapper);\n\n            const int totalEvents = 100;\n\n            var continuationHit = new bool[totalEvents];\n            var lastException = new Exception[totalEvents];\n            var continuationThread = new Thread[totalEvents];\n            var hitCount = 0;\n\n            CreateContinuationFunc createAsyncContinuation =\n                eventNumber =>\n                    ex =>\n                    {\n                        lastException[eventNumber] = ex;\n                        continuationThread[eventNumber] = Thread.CurrentThread;\n                        continuationHit[eventNumber] = true;\n                        Interlocked.Increment(ref hitCount);\n                        writeHit.Set();\n                    };\n\n            // write 9 events - they will all be buffered and no final continuation will be reached\n            var eventCounter = 0;\n            for (var i = 0; i < 9; ++i)\n            {\n                targetWrapper.WriteAsyncLogEvent(\n                    new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            }\n\n            Assert.Equal(0, hitCount);\n            Assert.Equal(0, myTarget.WriteCount);\n\n            // sleep and wait for the trigger timer to flush all events\n            Assert.True(writeHit.WaitOne(5000), \"Wait Write Timeout\");\n            WaitAndAssertExpectedValue(ref hitCount, 9);\n\n            Assert.Equal(1, myTarget.BufferedWriteCount);\n            Assert.Equal(9, myTarget.BufferedTotalEvents);\n            Assert.Equal(9, myTarget.WriteCount);\n            for (var i = 0; i < hitCount; ++i)\n            {\n                Assert.NotSame(Thread.CurrentThread, continuationThread[i]);\n                Assert.Null(lastException[i]);\n            }\n\n            // write 11 more events, 10 will be hit immediately because the buffer will fill up\n            // 1 will be pending\n            for (var i = 0; i < 11; ++i)\n            {\n                targetWrapper.WriteAsyncLogEvent(\n                    new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            }\n\n            Assert.Equal(19, hitCount);\n            Assert.Equal(2, myTarget.BufferedWriteCount);\n            Assert.Equal(19, myTarget.BufferedTotalEvents);\n            Assert.Equal(19, myTarget.WriteCount);\n\n            // sleep and wait for the remaining one to be flushed\n            WaitAndAssertExpectedValue(ref hitCount, 20);\n            Assert.Equal(3, myTarget.BufferedWriteCount);\n            Assert.Equal(20, myTarget.BufferedTotalEvents);\n            Assert.Equal(20, myTarget.WriteCount);\n        }"
      },
      {
        "name": "BufferingTargetWrapperAsyncTest1",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                var myTarget = new MyAsyncTarget();\n                var targetWrapper = new BufferingTargetWrapper\n                {\n                    WrappedTarget = myTarget,\n                    BufferSize = 10,\n                };\n                var writeHit = new ManualResetEvent(false);\n\n                InitializeTargets(myTarget, targetWrapper);\n\n                const int totalEvents = 100;\n\n                var continuationHit = new bool[totalEvents];\n                var lastException = new Exception[totalEvents];\n                var continuationThread = new Thread[totalEvents];\n                var hitCount = 0;\n\n                CreateContinuationFunc createAsyncContinuation =\n                    eventNumber =>\n                        ex =>\n                        {\n                            lastException[eventNumber] = ex;\n                            continuationThread[eventNumber] = Thread.CurrentThread;\n                            continuationHit[eventNumber] = true;\n                            Interlocked.Increment(ref hitCount);\n                            writeHit.Set();\n                        };\n\n                // write 9 events - they will all be buffered and no final continuation will be reached\n                var eventCounter = 0;\n                for (var i = 0; i < 9; ++i)\n                {\n                    targetWrapper.WriteAsyncLogEvent(\n                        new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n                }\n\n                Assert.Equal(0, hitCount);\n\n                // write one more event - everything will be flushed\n                targetWrapper.WriteAsyncLogEvent(\n                    new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n\n                Assert.True(writeHit.WaitOne(5000), \"Wait Write Timeout\");\n                WaitAndAssertExpectedValue(ref hitCount, 10);\n                Assert.Equal(1, myTarget.BufferedWriteCount);\n                Assert.Equal(10, myTarget.BufferedTotalEvents);\n                for (var i = 0; i < hitCount; ++i)\n                {\n                    Assert.NotSame(Thread.CurrentThread, continuationThread[i]);\n                    Assert.Null(lastException[i]);\n                }\n\n                // write 9 more events - they will all be buffered and no final continuation will be reached\n                for (var i = 0; i < 9; ++i)\n                {\n                    targetWrapper.WriteAsyncLogEvent(\n                        new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n                }\n\n                // no change\n                Assert.Equal(10, hitCount);\n                Assert.Equal(1, myTarget.BufferedWriteCount);\n                Assert.Equal(10, myTarget.BufferedTotalEvents);\n\n                Exception flushException = null;\n                var flushHit = new ManualResetEvent(false);\n\n                targetWrapper.Flush(\n                    ex =>\n                    {\n                        flushException = ex;\n                        flushHit.Set();\n                    });\n\n                Assert.True(flushHit.WaitOne(5000), \"Wait Flush Timeout\");\n                Assert.Null(flushException);\n\n                // make sure remaining events were written\n                Assert.Equal(19, hitCount);\n                Assert.Equal(2, myTarget.BufferedWriteCount);\n                Assert.Equal(19, myTarget.BufferedTotalEvents);\n\n                // flushes happen on another thread\n                for (var i = 10; i < hitCount; ++i)\n                {\n                    Assert.NotNull(continuationThread[i]);\n                    Assert.NotSame(Thread.CurrentThread, continuationThread[i]);\n                    Assert.Null(lastException[i]);\n                }\n\n                // flush again - should not do anything\n                flushHit.Reset();\n                targetWrapper.Flush(\n                    ex =>\n                    {\n                        flushException = ex;\n                        flushHit.Set();\n                    });\n\n                Assert.True(flushHit.WaitOne(5000), \"Wait Again Flush Timeout\");\n                Assert.Equal(19, hitCount);\n                Assert.Equal(2, myTarget.BufferedWriteCount);\n                Assert.Equal(19, myTarget.BufferedTotalEvents);\n\n                targetWrapper.Close();\n                myTarget.Close();\n            });\n        }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithTimedFlushNonSlidingTest",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n\n                var myTarget = new MyTarget();\n                var targetWrapper = new BufferingTargetWrapper\n                {\n                    WrappedTarget = myTarget,\n                    BufferSize = 10,\n                    FlushTimeout = 400,\n                    SlidingTimeout = false,\n                };\n\n                InitializeTargets(myTarget, targetWrapper);\n\n                const int totalEvents = 100;\n\n                var continuationHit = new bool[totalEvents];\n                var lastException = new Exception[totalEvents];\n                var continuationThread = new Thread[totalEvents];\n                var hitCount = 0;\n\n                var resetEvent = new ManualResetEvent(false);\n                CreateContinuationFunc createAsyncContinuation =\n                    eventNumber =>\n                        ex =>\n                        {\n                            lastException[eventNumber] = ex;\n                            continuationThread[eventNumber] = Thread.CurrentThread;\n                            continuationHit[eventNumber] = true;\n                            Interlocked.Increment(ref hitCount);\n                            if (eventNumber > 0)\n                            {\n                                resetEvent.Set();\n                            }\n                        };\n\n                var eventCounter = 0;\n                targetWrapper.WriteAsyncLogEvent(\n                    new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n\n                Assert.Equal(0, hitCount);\n                Assert.Equal(0, myTarget.WriteCount);\n\n                targetWrapper.WriteAsyncLogEvent(\n                    new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n                Assert.True(resetEvent.WaitOne(5000), \"Wait Write Timeout\");\n\n                Assert.Equal(2, hitCount);\n                Assert.Equal(2, myTarget.WriteCount);\n\n            });\n        }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithTimedFlushSlidingTest",
        "body": "{\n            var myTarget = new MyTarget();\n            var targetWrapper = new BufferingTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                BufferSize = 10,\n                FlushTimeout = 400,\n            };\n            var writeEvent = new ManualResetEvent(false);\n\n            InitializeTargets(myTarget, targetWrapper);\n\n            const int totalEvents = 100;\n\n            var continuationHit = new bool[totalEvents];\n            var lastException = new Exception[totalEvents];\n            var continuationThread = new Thread[totalEvents];\n            var hitCount = 0;\n\n            CreateContinuationFunc createAsyncContinuation =\n                eventNumber =>\n                    ex =>\n                    {\n                        lastException[eventNumber] = ex;\n                        continuationThread[eventNumber] = Thread.CurrentThread;\n                        continuationHit[eventNumber] = true;\n                        Interlocked.Increment(ref hitCount);\n                        writeEvent.Set();\n                    };\n\n            var eventCounter = 0;\n            targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            Thread.Sleep(100);\n\n            Assert.Equal(0, hitCount);\n            Assert.Equal(0, myTarget.WriteCount);\n\n            targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(eventCounter++)));\n            Thread.Sleep(100);\n\n            Assert.Equal(0, hitCount);\n            Assert.Equal(0, myTarget.WriteCount);\n\n            Assert.True(writeEvent.WaitOne(5000), \"Wait Write Timeout\");\n            WaitAndAssertExpectedValue(ref hitCount, 2);\n            Assert.Equal(2, myTarget.WriteCount);\n        }"
      },
      {
        "name": "WhenWrappedTargetThrowsExceptionThisIsHandled",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var myTarget = new MyTarget { ThrowException = true };\n                var bufferingTargetWrapper = new BufferingTargetWrapper\n                {\n                    WrappedTarget = myTarget,\n                    FlushTimeout = -1\n                };\n\n                InitializeTargets(myTarget, bufferingTargetWrapper);\n                bufferingTargetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(_ => { }));\n\n                var flushHit = new ManualResetEvent(false);\n                bufferingTargetWrapper.Flush(ex => flushHit.Set());\n                Assert.True(flushHit.WaitOne(5000), \"Wait Flush Timeout\");\n                Assert.Equal(1, myTarget.FlushCount);\n            }\n        }"
      },
      {
        "name": "BufferingTargetWrapperSyncWithOverflowDiscardTest",
        "body": "{\n            const int totalEvents = 15;\n            const int bufferSize = 10;\n\n            var myTarget = new MyTarget();\n            var targetWrapper = new BufferingTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                BufferSize = bufferSize,\n                OverflowAction = BufferingTargetWrapperOverflowAction.Discard\n            };\n\n            InitializeTargets(myTarget, targetWrapper);\n\n            var continuationHit = new bool[totalEvents];\n            var hitCount = 0;\n            CreateContinuationFunc createAsyncContinuation =\n                eventNumber =>\n                    ex =>\n                    {\n                        continuationHit[eventNumber] = true;\n                        Interlocked.Increment(ref hitCount);\n                    };\n\n            Assert.Equal(0, myTarget.WriteCount);\n\n            for (int i = 0; i < totalEvents; i++)\n            {\n                targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(i)));\n            }\n\n            // No events should be written to the wrapped target unless flushing manually.\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(0, myTarget.BufferedWriteCount);\n            Assert.Equal(0, myTarget.BufferedTotalEvents);\n\n            targetWrapper.Flush(e => { });\n            Assert.Equal(bufferSize, hitCount);\n            Assert.Equal(bufferSize, myTarget.WriteCount);\n            Assert.Equal(1, myTarget.BufferedWriteCount);\n            Assert.Equal(bufferSize, myTarget.BufferedTotalEvents);\n\n            // Validate that we dropped the oldest events.\n            Assert.False(continuationHit[totalEvents - bufferSize - 1]);\n            Assert.True(continuationHit[totalEvents - bufferSize]);\n\n            // Make sure the events do not stay in the buffer.\n            targetWrapper.Flush(e => { });\n            Assert.Equal(bufferSize, hitCount);\n            Assert.Equal(bufferSize, myTarget.WriteCount);\n            Assert.Equal(1, myTarget.BufferedWriteCount);\n            Assert.Equal(bufferSize, myTarget.BufferedTotalEvents);\n\n            // Make sure that events are discarded when closing target (config-reload + shutdown)\n            targetWrapper.WriteAsyncLogEvent(new LogEventInfo().WithContinuation(createAsyncContinuation(totalEvents)));\n            targetWrapper.Close();\n            Assert.Equal(bufferSize, hitCount);\n            Assert.Equal(bufferSize, myTarget.WriteCount);\n            Assert.Equal(1, myTarget.BufferedWriteCount);\n            Assert.Equal(bufferSize, myTarget.BufferedTotalEvents);\n        }"
      }
    ]
  },
  {
    "file": "ConcurrentRequestQueueTests.cs",
    "methods": [
      {
        "name": "RaiseEventLogEventQueueGrow_OnLogItems",
        "body": "{\n            const int RequestsLimit = 2;\n            const int EventsCount = 5;\n            const int ExpectedCountOfGrovingTimes = 2;\n            const int ExpectedFinalSize = 8;\n            int grovingItemsCount = 0;\n\n            ConcurrentRequestQueue requestQueue = new ConcurrentRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Grow);\n\n            requestQueue.LogEventQueueGrow += (o, e) => { grovingItemsCount++; };\n\n            for (int i = 0; i < EventsCount; i++)\n            {\n                requestQueue.Enqueue(new AsyncLogEventInfo());\n            }\n\n            Assert.Equal(ExpectedCountOfGrovingTimes, grovingItemsCount);\n            Assert.Equal(ExpectedFinalSize, requestQueue.RequestLimit);\n        }"
      },
      {
        "name": "RaiseEventLogEventDropped_OnLogItems",
        "body": "{\n            const int RequestsLimit = 2;\n            const int EventsCount = 5;\n            int discardedItemsCount = 0;\n\n            int ExpectedDiscardedItemsCount = EventsCount - RequestsLimit;\n            ConcurrentRequestQueue requestQueue = new ConcurrentRequestQueue(RequestsLimit, AsyncTargetWrapperOverflowAction.Discard);\n\n            requestQueue.LogEventDropped += (o, e) => { discardedItemsCount++; };\n\n            for (int i = 0; i < EventsCount; i++)\n            {\n                requestQueue.Enqueue(new AsyncLogEventInfo());\n            }\n\n            Assert.Equal(ExpectedDiscardedItemsCount, discardedItemsCount);\n        }"
      }
    ]
  },
  {
    "file": "FallbackGroupTargetTests.cs",
    "methods": [
      {
        "name": "FirstTargetWorks_Write_AllEventsAreWrittenToFirstTarget",
        "body": "{\n            var myTarget1 = new MyTarget();\n            var myTarget2 = new MyTarget();\n            var myTarget3 = new MyTarget();\n\n            var wrapper = CreateAndInitializeFallbackGroupTarget(false, myTarget1, myTarget2, myTarget3);\n\n            WriteAndAssertNoExceptions(wrapper);\n\n            Assert.Equal(10, myTarget1.WriteCount);\n            Assert.Equal(0, myTarget2.WriteCount);\n            Assert.Equal(0, myTarget3.WriteCount);\n\n            AssertNoFlushException(wrapper);\n        }"
      },
      {
        "name": "FirstTargetFails_Write_SecondTargetWritesAllEvents",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var myTarget1 = new MyTarget { FailCounter = 1 };\n                var myTarget2 = new MyTarget();\n                var myTarget3 = new MyTarget();\n\n                var wrapper = CreateAndInitializeFallbackGroupTarget(false, myTarget1, myTarget2, myTarget3);\n\n                WriteAndAssertNoExceptions(wrapper);\n\n                Assert.Equal(1, myTarget1.WriteCount);\n                Assert.Equal(10, myTarget2.WriteCount);\n                Assert.Equal(0, myTarget3.WriteCount);\n\n                AssertNoFlushException(wrapper);\n            }\n        }"
      },
      {
        "name": "FirstTwoTargetsFails_Write_ThirdTargetWritesAllEvents",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var myTarget1 = new MyTarget { FailCounter = 1 };\n                var myTarget2 = new MyTarget { FailCounter = 1 };\n                var myTarget3 = new MyTarget();\n\n                var wrapper = CreateAndInitializeFallbackGroupTarget(false, myTarget1, myTarget2, myTarget3);\n\n                WriteAndAssertNoExceptions(wrapper);\n\n                Assert.Equal(1, myTarget1.WriteCount);\n                Assert.Equal(1, myTarget2.WriteCount);\n                Assert.Equal(10, myTarget3.WriteCount);\n\n                AssertNoFlushException(wrapper);\n            }\n        }"
      },
      {
        "name": "ReturnToFirstOnSuccessAndSecondTargetSucceeds_Write_ReturnToFirstTargetOnSuccess",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var myTarget1 = new MyTarget { FailCounter = 1 };\n                var myTarget2 = new MyTarget();\n                var myTarget3 = new MyTarget();\n\n                var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1, myTarget2, myTarget3);\n\n                WriteAndAssertNoExceptions(wrapper);\n\n                Assert.Equal(10, myTarget1.WriteCount);\n                Assert.Equal(1, myTarget2.WriteCount);\n                Assert.Equal(0, myTarget3.WriteCount);\n\n                AssertNoFlushException(wrapper);\n            }\n        }"
      },
      {
        "name": "FallbackGroupTargetSyncTest5",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                // fail once\n                var myTarget1 = new MyTarget { FailCounter = 3 };\n                var myTarget2 = new MyTarget { FailCounter = 3 };\n                var myTarget3 = new MyTarget { FailCounter = 3 };\n\n                var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1, myTarget2, myTarget3);\n\n                var exceptions = new List<Exception>();\n\n                // no exceptions\n                for (var i = 0; i < 10; ++i)\n                {\n                    wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n                }\n\n                Assert.Equal(10, exceptions.Count);\n                for (var i = 0; i < 10; ++i)\n                {\n                    if (i < 3)\n                    {\n                        Assert.NotNull(exceptions[i]);\n                    }\n                    else\n                    {\n                        Assert.Null(exceptions[i]);\n                    }\n                }\n\n                Assert.Equal(10, myTarget1.WriteCount);\n                Assert.Equal(3, myTarget2.WriteCount);\n                Assert.Equal(3, myTarget3.WriteCount);\n\n                AssertNoFlushException(wrapper);\n            }\n        }"
      },
      {
        "name": "FallbackGroupTargetSyncTest6",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                // fail once\n                var myTarget1 = new MyTarget { FailCounter = 10 };\n                var myTarget2 = new MyTarget { FailCounter = 3 };\n                var myTarget3 = new MyTarget { FailCounter = 3 };\n\n                var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1, myTarget2, myTarget3);\n\n                var exceptions = new List<Exception>();\n\n                // no exceptions\n                for (var i = 0; i < 10; ++i)\n                {\n                    wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n                }\n\n                Assert.Equal(10, exceptions.Count);\n                for (var i = 0; i < 10; ++i)\n                {\n                    if (i < 3)\n                    {\n                        // for the first 3 rounds, no target is available\n                        Assert.NotNull(exceptions[i]);\n                        Assert.IsType<ApplicationException>(exceptions[i]);\n                        Assert.Equal(\"Some failure.\", exceptions[i].Message);\n                    }\n                    else\n                    {\n                        Assert.Null(exceptions[i]);\n                    }\n                }\n\n                Assert.Equal(10, myTarget1.WriteCount);\n                Assert.Equal(10, myTarget2.WriteCount);\n                Assert.Equal(3, myTarget3.WriteCount);\n\n                AssertNoFlushException(wrapper);\n\n                Assert.Equal(1, myTarget1.FlushCount);\n                Assert.Equal(1, myTarget2.FlushCount);\n                Assert.Equal(1, myTarget3.FlushCount);\n            }\n        }"
      },
      {
        "name": "FallbackGroupWithBufferingTargets_ReturnToFirstOnSuccess",
        "body": "{\n            FallbackGroupWithBufferingTargets(true);\n        }"
      },
      {
        "name": "FallbackGroupWithBufferingTargets_DoNotReturnToFirstOnSuccess",
        "body": "{\n            FallbackGroupWithBufferingTargets(false);\n        }"
      },
      {
        "name": "FallbackGroupTargetAsyncTest",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var myTarget1 = new MyTarget { FailCounter = int.MaxValue }; // Always failing.\n                var myTarget1Async = new AsyncTargetWrapper(myTarget1) { TimeToSleepBetweenBatches = 0 }; // Always failing.\n                var myTarget2 = new MyTarget() { Layout = \"${ndlc}\" };\n\n                var wrapper = CreateAndInitializeFallbackGroupTarget(true, myTarget1Async, myTarget2);\n\n                var exceptions = new List<Exception>();\n\n                // no exceptions\n                for (var i = 0; i < 10; ++i)\n                {\n                    using (ScopeContext.PushNestedState(\"Hello World\"))\n                    {\n                        wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n                    }\n                }\n\n                ManualResetEvent resetEvent = new ManualResetEvent(false);\n                myTarget1Async.Flush((ex) => { Assert.Null(ex); resetEvent.Set(); });\n                resetEvent.WaitOne(1000);\n\n                Assert.Equal(10, exceptions.Count);\n                for (var i = 0; i < 10; ++i)\n                {\n                    Assert.Null(exceptions[i]);\n                }\n\n                Assert.Equal(10, myTarget2.WriteCount);\n\n                AssertNoFlushException(wrapper);\n            }\n        }"
      }
    ]
  },
  {
    "file": "FilteringTargetWrapperTests.cs",
    "methods": [
      {
        "name": "FilteringTargetWrapperSyncTest1",
        "body": "{\n            var myMockCondition = new MyMockCondition(true);\n            var myTarget = new MyTarget();\n            var wrapper = new FilteringTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                Condition = myMockCondition,\n            };\n\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            bool continuationHit = false;\n            AsyncContinuation continuation =\n                ex =>\n                    {\n                        lastException = ex;\n                        continuationHit = true;\n                    };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            Assert.True(continuationHit);\n            Assert.Null(lastException);\n            Assert.Equal(1, myTarget.WriteCount);\n\n            continuationHit = false;\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            Assert.True(continuationHit);\n            Assert.Null(lastException);\n            Assert.Equal(2, myTarget.WriteCount);\n            Assert.Equal(2, myMockCondition.CallCount);\n        }"
      },
      {
        "name": "FilteringTargetWrapperAsyncTest1",
        "body": "{\n            var myMockCondition = new MyMockCondition(true);\n            var myTarget = new MyAsyncTarget();\n            var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit.Set();\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            continuationHit.WaitOne();\n            Assert.Null(lastException);\n            Assert.Equal(1, myTarget.WriteCount);\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            continuationHit.Reset();\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            continuationHit.WaitOne();\n            Assert.Null(lastException);\n            Assert.Equal(2, myTarget.WriteCount);\n            Assert.Equal(2, myMockCondition.CallCount);\n        }"
      },
      {
        "name": "FilteringTargetWrapperAsyncWithExceptionTest1",
        "body": "{\n            var myMockCondition = new MyMockCondition(true);\n            var myTarget = new MyAsyncTarget\n            {\n                ThrowExceptions = true,\n            };\n\n            var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit.Set();\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            continuationHit.WaitOne();\n            Assert.NotNull(lastException);\n            Assert.IsType<InvalidOperationException>(lastException);\n\n            Assert.Equal(1, myTarget.WriteCount);\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            continuationHit.Reset();\n            lastException = null;\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            continuationHit.WaitOne();\n            Assert.NotNull(lastException);\n            Assert.IsType<InvalidOperationException>(lastException);\n            Assert.Equal(2, myTarget.WriteCount);\n            Assert.Equal(2, myMockCondition.CallCount);\n        }"
      },
      {
        "name": "FilteringTargetWrapperSyncTest2",
        "body": "{\n            var myMockCondition = new MyMockCondition(false);\n            var myTarget = new MyTarget();\n            var wrapper = new FilteringTargetWrapper\n            {\n                WrappedTarget = myTarget,\n                Condition = myMockCondition,\n            };\n\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            bool continuationHit = false;\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit = true;\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            Assert.True(continuationHit);\n            Assert.Null(lastException);\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            continuationHit = false;\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            Assert.True(continuationHit);\n            Assert.Null(lastException);\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(2, myMockCondition.CallCount);\n        }"
      },
      {
        "name": "FilteringTargetWrapperAsyncTest2",
        "body": "{\n            var myMockCondition = new MyMockCondition(false);\n            var myTarget = new MyAsyncTarget();\n            var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit.Set();\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            continuationHit.WaitOne();\n            Assert.Null(lastException);\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            continuationHit.Reset();\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            continuationHit.WaitOne();\n            Assert.Null(lastException);\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(2, myMockCondition.CallCount);\n        }"
      },
      {
        "name": "FilteringTargetWrapperAsyncWithExceptionTest2",
        "body": "{\n            var myMockCondition = new MyMockCondition(false);\n            var myTarget = new MyAsyncTarget\n            {\n                ThrowExceptions = true,\n            };\n            var wrapper = new FilteringTargetWrapper(myTarget, myMockCondition);\n            myTarget.Initialize(null);\n            wrapper.Initialize(null);\n            var logEvent = new LogEventInfo();\n            Exception lastException = null;\n            var continuationHit = new ManualResetEvent(false);\n            AsyncContinuation continuation =\n                ex =>\n                {\n                    lastException = ex;\n                    continuationHit.Set();\n                };\n\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n\n            continuationHit.WaitOne();\n            Assert.Null(lastException);\n\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(1, myMockCondition.CallCount);\n\n            continuationHit.Reset();\n            lastException = null;\n            wrapper.WriteAsyncLogEvent(logEvent.WithContinuation(continuation));\n            continuationHit.WaitOne();\n            Assert.Null(lastException);\n            Assert.Equal(0, myTarget.WriteCount);\n            Assert.Equal(2, myMockCondition.CallCount);\n        }"
      },
      {
        "name": "FilteringTargetWrapperWhenRepeatedFilter",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <variable name='test' value='${message}' />\n                <targets>\n                  <target name='debug' type='BufferingWrapper'>\n                      <target name='filter' type='FilteringWrapper'>\n                        <filter type='whenRepeated' layout='${var:test:whenempty=${guid}}' timeoutSeconds='30' action='Ignore' />\n                        <target name='memory' type='Memory' />\n                      </target>\n                  </target>\n                </targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug'/>\n                </rules>\n            </nlog>\").LogFactory;\n\n            var myTarget = logFactory.Configuration.FindTargetByName<MemoryTarget>(\"memory\");\n            var logger = logFactory.GetLogger(nameof(FilteringTargetWrapperWhenRepeatedFilter));\n            logger.Info(\"Hello World\");\n            logger.Info(\"Hello World\");     // Will be ignored\n            logger.Info(\"Goodbye World\");\n            logger.Warn(\"Goodbye World\");\n            logFactory.Flush();\n            Assert.Equal(3, myTarget.Logs.Count);\n            logger.Info(\"Hello World\");     // Will be ignored\n            logger.Error(\"Goodbye World\");\n            logger.Fatal(\"Goodbye World\");\n            logFactory.Flush();\n            Assert.Equal(5, myTarget.Logs.Count);\n        }"
      },
      {
        "name": "FilteringTargetWrapperWithConditionAttribute_correctBehavior",
        "body": "{\n            // Arrange\n            var logFactory = CreateConfigWithCondition();\n            var myTarget = logFactory.Configuration.FindTargetByName<MemoryTarget>(\"memory\");\n\n            // Act\n            var logger = logFactory.GetLogger(nameof(FilteringTargetWrapperWhenRepeatedFilter));\n            logger.Info(\"Hello World\");\n            logger.Info(\"2\");     // Will be ignored\n            logger.Info(\"3\");     // Will be ignored\n            logFactory.Flush();\n\n            // Assert\n            Assert.Single(myTarget.Logs);\n        }"
      },
      {
        "name": "FilteringTargetWrapperWithConditionAttribute_validCondition",
        "body": "{\n            // Arrange\n            var expectedCondition = \"(length(message) > 2)\";\n\n            // Act\n            var logFactory = CreateConfigWithCondition();\n\n            // Assert\n            var myTarget = logFactory.Configuration.FindTargetByName<FilteringTargetWrapper>(\"target1\");\n\n            Assert.Equal(expectedCondition, myTarget.Condition?.ToString());\n            var conditionBasedFilter = Assert.IsType<ConditionBasedFilter>(myTarget.Filter);\n            Assert.Equal(expectedCondition, conditionBasedFilter.Condition?.ToString());\n        }"
      }
    ]
  },
  {
    "file": "GroupByTargetWrapperTests.cs",
    "methods": [
      {
        "name": "SimpleGroupByTest",
        "body": "{\n            // Arrange\n            var memoryTarget = new MemoryTarget(\"memory\") { Layout = \"${level}\" };\n            var groupByTarget = new GroupByTargetWrapper(\"groupby\", memoryTarget, \"${logger}\");\n            var bufferTarget = new BufferingTargetWrapper(\"buffer\", groupByTarget);\n\n            var logFactory = new LogFactory();\n            var logConfig = new NLog.Config.LoggingConfiguration(logFactory);\n            logConfig.AddRule(LogLevel.Info, LogLevel.Fatal, bufferTarget);\n            logFactory.Configuration = logConfig;\n\n            var logger1 = logFactory.GetLogger(\"Logger1\");\n            var logger2 = logFactory.GetLogger(\"Logger2\");\n            var logger3 = logFactory.GetLogger(\"Logger3\");\n\n            // Act\n            logger1.Trace(\"Ignore Me\");\n            logger2.Warn(\"Special Warning\");\n            logger1.Debug(\"Hello world\");\n            logger1.Fatal(\"Catastropic Goodbye\");\n            logger2.Error(\"General Error\");\n            logFactory.Flush();\n            groupByTarget.WriteAsyncLogEvent(LogEventInfo.Create(LogLevel.Info, logger1.Name, \"Special Hello\").WithContinuation((ex) => { }));\n\n            // Assert\n            Assert.Equal(4, memoryTarget.Logs.Count);\n            Assert.Equal(\"Warn\", memoryTarget.Logs[0]);\n            Assert.Equal(\"Error\", memoryTarget.Logs[1]);\n            Assert.Equal(\"Fatal\", memoryTarget.Logs[2]);\n            Assert.Equal(\"Info\", memoryTarget.Logs[3]);\n        }"
      }
    ]
  },
  {
    "file": "LimitingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "WriteMoreMessagesThanLimitOnlyWritesLimitMessages",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <wrapper-target name='limiting' type='LimitingWrapper' messagelimit='5'>\n                        <target name='debug' type='Debug' layout='${message}' />\n                    </wrapper-target>\n                </targets>\n                <rules>\n                    <logger name='*' level='Debug' writeTo='limiting' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            const int messagelimit = 5;\n            var logger = logFactory.GetLogger(\"A\");\n            for (int i = 1; i <= 10; i++)\n            {\n                logger.Debug(\"message {0}\", i);\n                //Should have only written 5 messages, since limit is 5.\n                if (i <= messagelimit)\n                    logFactory.AssertDebugLastMessage($\"message {i}\");\n            }\n            logFactory.AssertDebugLastMessage(\"debug\", $\"message {messagelimit}\");\n        }"
      },
      {
        "name": "WriteMessagesAfterLimitExpiredWritesMessages",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <wrapper-target name='limiting' type='LimitingWrapper' messagelimit='5' interval='0:0:0:0.100'>\n                        <target name='debug' type='Debug' layout='${message}' />\n                    </wrapper-target>\n                </targets>\n                <rules>\n                    <logger name='*' level='Debug' writeTo='limiting' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            const int messagelimit = 5;\n            var logger = logFactory.GetLogger(\"A\");\n            for (int i = 1; i <= 10; i++)\n            {\n                logger.Debug(\"message {0}\", i);\n                if (i <= messagelimit)\n                    logFactory.AssertDebugLastMessage($\"message {i}\");\n            }\n\n            //Wait for the interval to expire.\n            Thread.Sleep(100);\n\n            for (int i = 1; i <= 10; i++)\n            {\n                logger.Debug(\"message {0}\", i + 10);\n                if (i <= messagelimit)\n                    logFactory.AssertDebugLastMessage($\"message {i + 10}\");\n            }\n\n            //Should have written 10 messages.\n            //5 from the first interval and 5 from the second.\n            logFactory.AssertDebugLastMessage(\"debug\", \"message 15\");\n        }"
      },
      {
        "name": "WriteMessagesLessThanMessageLimitWritesToWrappedTarget",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromMilliseconds(100));\n            InitializeTargets(wrappedTarget, wrapper);\n\n            // Write limit number of messages should just write them to the wrappedTarget.\n            WriteNumberAsyncLogEventsStartingAt(0, 5, wrapper);\n\n            Assert.Equal(5, wrappedTarget.WriteCount);\n\n            //Let the interval expire to start a new one.\n            Thread.Sleep(100);\n\n            // Write limit number of messages should just write them to the wrappedTarget.\n            var lastException = WriteNumberAsyncLogEventsStartingAt(5, 5, wrapper);\n\n            // We should have 10 messages (5 from first interval, 5 from second interval).\n            Assert.Equal(10, wrappedTarget.WriteCount);\n            Assert.Null(lastException);\n        }"
      },
      {
        "name": "WriteMoreMessagesThanMessageLimitDiscardsExcessMessages",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromHours(1));\n            InitializeTargets(wrappedTarget, wrapper);\n\n            // Write limit number of messages should just write them to the wrappedTarget.\n            var lastException = WriteNumberAsyncLogEventsStartingAt(0, 5, wrapper);\n\n            Assert.Equal(5, wrappedTarget.WriteCount);\n\n            //Additional messages will be discarded, but InternalLogger will write to trace.\n            string internalLog = RunAndCaptureInternalLog(() =>\n            {\n                wrapper.WriteAsyncLogEvent(\n                    new LogEventInfo(LogLevel.Debug, \"test\", $\"Hello {5}\").WithContinuation(ex => lastException = ex));\n            }, LogLevel.Trace);\n\n            Assert.Equal(5, wrappedTarget.WriteCount);\n            Assert.Contains(\"MessageLimit\", internalLog);\n            Assert.Null(lastException);\n        }"
      },
      {
        "name": "WriteMessageAfterIntervalHasExpiredStartsNewInterval",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromMilliseconds(100));\n            InitializeTargets(wrappedTarget, wrapper);\n            Exception lastException = null;\n            wrapper.WriteAsyncLogEvent(\n                new LogEventInfo(LogLevel.Debug, \"test\", \"first interval\").WithContinuation(ex => lastException = ex));\n\n            //Let the interval expire.\n            Thread.Sleep(100);\n\n            //Writing a logEvent should start a new Interval. This should be written to InternalLogger.Debug.\n            string internalLog = RunAndCaptureInternalLog(() =>\n            {\n                // We can write 5 messages again since a new interval started.\n                lastException = WriteNumberAsyncLogEventsStartingAt(0, 5, wrapper);\n\n            }, LogLevel.Trace);\n\n            //We should have written 6 messages (1 in first interval and 5 in second interval).\n            Assert.Equal(6, wrappedTarget.WriteCount);\n            Assert.Contains(\"New interval\", internalLog);\n            Assert.Null(lastException);\n        }"
      },
      {
        "name": "TestWritingMessagesOverMultipleIntervals",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget, 5, TimeSpan.FromMilliseconds(100));\n            InitializeTargets(wrappedTarget, wrapper);\n            Exception lastException = null;\n\n            lastException = WriteNumberAsyncLogEventsStartingAt(0, 10, wrapper);\n\n            //Let the interval expire.\n            Thread.Sleep(100);\n\n            Assert.Equal(5, wrappedTarget.WriteCount);\n            Assert.Equal(\"Hello 4\", wrappedTarget.LastWrittenMessage);\n            Assert.Null(lastException);\n\n            lastException = WriteNumberAsyncLogEventsStartingAt(10, 10, wrapper);\n\n            //We should have 10 messages (5 from first, 5 from second interval).\n            Assert.Equal(10, wrappedTarget.WriteCount);\n            Assert.Equal(\"Hello 14\", wrappedTarget.LastWrittenMessage);\n            Assert.Null(lastException);\n\n            //Let the interval expire.\n            Thread.Sleep(230);\n\n            lastException = WriteNumberAsyncLogEventsStartingAt(20, 10, wrapper);\n\n            //We should have 15 messages (5 from first, 5 from second, 5 from third interval).\n            Assert.Equal(15, wrappedTarget.WriteCount);\n            Assert.Equal(\"Hello 24\", wrappedTarget.LastWrittenMessage);\n            Assert.Null(lastException);\n\n            //Let the interval expire.\n            Thread.Sleep(20);\n            lastException = WriteNumberAsyncLogEventsStartingAt(30, 10, wrapper);\n\n            //No more messages should be been written, since we are still in the third interval.\n            Assert.Equal(15, wrappedTarget.WriteCount);\n            Assert.Equal(\"Hello 24\", wrappedTarget.LastWrittenMessage);\n            Assert.Null(lastException);\n        }"
      },
      {
        "name": "ConstructorWithNoParametersInitialisesDefaultsCorrectly",
        "body": "{\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper();\n\n            Assert.Equal(1000, wrapper.MessageLimit);\n            Assert.Equal(TimeSpan.FromHours(1), wrapper.Interval);\n        }"
      },
      {
        "name": "ConstructorWithTargetInitialisesDefaultsCorrectly",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget);\n\n            Assert.Equal(1000, wrapper.MessageLimit);\n            Assert.Equal(TimeSpan.FromHours(1), wrapper.Interval);\n        }"
      },
      {
        "name": "ConstructorWithNameInitialisesDefaultsCorrectly",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(\"Wrapper\", wrappedTarget);\n\n            Assert.Equal(1000, wrapper.MessageLimit);\n            Assert.Equal(TimeSpan.FromHours(1), wrapper.Interval);\n        }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfMessageLimitIsSetToZero",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { MessageLimit = 0 };\n            wrappedTarget.Initialize(null);\n            LogManager.ThrowConfigExceptions = true;\n\n            Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));\n            LogManager.ThrowConfigExceptions = false;\n        }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfMessageLimitIsSmallerZero",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { MessageLimit = -1 };\n            wrappedTarget.Initialize(null);\n            LogManager.ThrowConfigExceptions = true;\n\n            Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));\n            LogManager.ThrowConfigExceptions = false;\n        }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfIntervalIsSmallerZero",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { Interval = TimeSpan.MinValue };\n            wrappedTarget.Initialize(null);\n            LogManager.ThrowConfigExceptions = true;\n\n            Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));\n            LogManager.ThrowConfigExceptions = false;\n        }"
      },
      {
        "name": "InitializeThrowsNLogConfigurationExceptionIfIntervalIsZero",
        "body": "{\n            MyTarget wrappedTarget = new MyTarget();\n            LimitingTargetWrapper wrapper = new LimitingTargetWrapper(wrappedTarget) { Interval = TimeSpan.Zero };\n            wrappedTarget.Initialize(null);\n            LogManager.ThrowConfigExceptions = true;\n\n            Assert.Throws<NLogConfigurationException>(() => wrapper.Initialize(null));\n            LogManager.ThrowConfigExceptions = false;\n        }"
      },
      {
        "name": "CreatingFromConfigSetsMessageLimitCorrectly",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <wrapper-target name='limiting' type='LimitingWrapper' messagelimit='50'>\n                        <target name='debug' type='Debug' layout='${message}' />\n                    </wrapper-target>\n                </targets>\n                <rules>\n                    <logger name='*' level='Debug' writeTo='limiting' />\n                </rules>\n            </nlog>\").LogFactory;\n\n            LimitingTargetWrapper limitingWrapper = logFactory.Configuration.FindTargetByName<LimitingTargetWrapper>(\"limiting\");\n            DebugTarget debugTarget = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\");\n            Assert.NotNull(limitingWrapper);\n            Assert.NotNull(debugTarget);\n            Assert.Equal(50, limitingWrapper.MessageLimit);\n            Assert.Equal(TimeSpan.FromHours(1), limitingWrapper.Interval);\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n        }"
      },
      {
        "name": "CreatingFromConfigSetsIntervalCorrectly",
        "body": "{\n            var logFactory = new LogFactory().Setup().LoadConfigurationFromXml(@\"\n            <nlog>\n                <targets>\n                    <wrapper-target name='limiting' type='LimitingWrapper' interval='1:2:5:00'>\n                        <target name='debug' type='Debug' layout='${message}' />\n                    </wrapper-target>\n                </targets>\n                <rules>\n                    <logger name='*' level='Debug' writeTo='limiting' />\n                </rules>\n            </nlog>\").LogFactory;\n\n\n            LimitingTargetWrapper limitingWrapper = logFactory.Configuration.FindTargetByName<LimitingTargetWrapper>(\"limiting\");\n            DebugTarget debugTarget = logFactory.Configuration.FindTargetByName<DebugTarget>(\"debug\");\n            Assert.NotNull(limitingWrapper);\n            Assert.NotNull(debugTarget);\n            Assert.Equal(1000, limitingWrapper.MessageLimit);\n            Assert.Equal(TimeSpan.FromDays(1) + TimeSpan.FromHours(2) + TimeSpan.FromMinutes(5), limitingWrapper.Interval);\n\n            var logger = logFactory.GetLogger(\"A\");\n            logger.Debug(\"a\");\n            logFactory.AssertDebugLastMessage(\"a\");\n        }"
      }
    ]
  },
  {
    "file": "PostFilteringTargetWrapperTests.cs",
    "methods": [
      {
        "name": "PostFilteringTargetWrapperUsingDefaultFilterTest",
        "body": "{\n            var target = new MyTarget();\n            var wrapper = new PostFilteringTargetWrapper()\n            {\n                WrappedTarget = target,\n                Rules =\n                {\n                    // if we had any warnings, log debug too\n                    new FilteringRule(\"level >= LogLevel.Warn\", \"level >= LogLevel.Debug\"),\n\n                    // when there is an error, emit everything\n                    new FilteringRule\n                    {\n                        Exists = \"level >= LogLevel.Error\",\n                        Filter = \"true\",\n                    },\n                },\n\n                // by default log info and above\n                DefaultFilter = \"level >= LogLevel.Info\",\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            wrapper.WriteAsyncLogEvents(events);\n\n            // make sure all Info events went through\n            Assert.Equal(3, target.Events.Count);\n            Assert.Same(events[1].LogEvent, target.Events[0]);\n            Assert.Same(events[2].LogEvent, target.Events[1]);\n            Assert.Same(events[5].LogEvent, target.Events[2]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n        }"
      },
      {
        "name": "PostFilteringTargetWrapperUsingDefaultNonFilterTest",
        "body": "{\n            var target = new MyTarget();\n            var wrapper = new PostFilteringTargetWrapper()\n            {\n                WrappedTarget = target,\n                Rules =\n                {\n                    // if we had any warnings, log debug too\n                    new FilteringRule(\"level >= LogLevel.Warn\", \"level >= LogLevel.Debug\"),\n\n                    // when there is an error, emit everything\n                    new FilteringRule(\"level >= LogLevel.Error\", \"true\"),\n                },\n\n                // by default log info and above\n                DefaultFilter = \"level >= LogLevel.Info\",\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Warn, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            string result = RunAndCaptureInternalLog(() => wrapper.WriteAsyncLogEvents(events), LogLevel.Trace);\n            Assert.Contains(\"Running on 7 events\", result);\n            Assert.Contains(\"Rule matched: (level >= Warn)\", result);\n            Assert.Contains(\"Filter to apply: (level >= Debug)\", result);\n            Assert.Contains(\"After filtering: 6 events.\", result);\n            Assert.Contains(\"Sending to MyTarget\", result);\n\n            // make sure all Debug,Info,Warn events went through\n            Assert.Equal(6, target.Events.Count);\n            Assert.Same(events[0].LogEvent, target.Events[0]);\n            Assert.Same(events[1].LogEvent, target.Events[1]);\n            Assert.Same(events[2].LogEvent, target.Events[2]);\n            Assert.Same(events[3].LogEvent, target.Events[3]);\n            Assert.Same(events[5].LogEvent, target.Events[4]);\n            Assert.Same(events[6].LogEvent, target.Events[5]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n        }"
      },
      {
        "name": "PostFilteringTargetWrapperUsingDefaultNonFilterTest2",
        "body": "{\n            // in this case both rules would match, but first one is picked\n            var target = new MyTarget();\n            var wrapper = new PostFilteringTargetWrapper()\n            {\n                WrappedTarget = target,\n                Rules =\n                {\n                    // when there is an error, emit everything\n                    new FilteringRule(\"level >= LogLevel.Error\", \"true\"),\n\n                    // if we had any warnings, log debug too\n                    new FilteringRule(\"level >= LogLevel.Warn\", \"level >= LogLevel.Debug\"),\n                },\n\n                // by default log info and above\n                DefaultFilter = \"level >= LogLevel.Info\",\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Error, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            var result = RunAndCaptureInternalLog(() => wrapper.WriteAsyncLogEvents(events), LogLevel.Trace);\n            Assert.Contains(\"Running on 7 events\", result);\n            Assert.Contains(\"Rule matched: (level >= Error)\", result);\n            Assert.Contains(\"Filter to apply: True\", result);\n            Assert.Contains(\"After filtering: 7 events.\", result);\n            Assert.Contains(\"Sending to MyTarget\", result);\n\n            // make sure all events went through\n            Assert.Equal(7, target.Events.Count);\n            Assert.Same(events[0].LogEvent, target.Events[0]);\n            Assert.Same(events[1].LogEvent, target.Events[1]);\n            Assert.Same(events[2].LogEvent, target.Events[2]);\n            Assert.Same(events[3].LogEvent, target.Events[3]);\n            Assert.Same(events[4].LogEvent, target.Events[4]);\n            Assert.Same(events[5].LogEvent, target.Events[5]);\n            Assert.Same(events[6].LogEvent, target.Events[6]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n        }"
      },
      {
        "name": "PostFilteringTargetWrapperOnlyDefaultFilter",
        "body": "{\n            var target = new MyTarget();\n            var wrapper = new PostFilteringTargetWrapper()\n            {\n                WrappedTarget = target,\n                DefaultFilter = \"level >= LogLevel.Info\",   // by default log info and above\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n            wrapper.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add));\n            Assert.Single(target.Events);\n            wrapper.WriteAsyncLogEvent(new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add));\n            Assert.Single(target.Events);\n        }"
      },
      {
        "name": "PostFilteringTargetWrapperNoFiltersDefined",
        "body": "{\n            var target = new MyTarget();\n            var wrapper = new PostFilteringTargetWrapper()\n            {\n                WrappedTarget = target,\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Trace, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger3\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Error, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            wrapper.WriteAsyncLogEvents(events);\n\n            // make sure all events went through\n            Assert.Equal(7, target.Events.Count);\n            Assert.Same(events[0].LogEvent, target.Events[0]);\n            Assert.Same(events[1].LogEvent, target.Events[1]);\n            Assert.Same(events[2].LogEvent, target.Events[2]);\n            Assert.Same(events[3].LogEvent, target.Events[3]);\n            Assert.Same(events[4].LogEvent, target.Events[4]);\n            Assert.Same(events[5].LogEvent, target.Events[5]);\n            Assert.Same(events[6].LogEvent, target.Events[6]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n        }"
      }
    ]
  },
  {
    "file": "RandomizeGroupTargetTests.cs",
    "methods": [
      {
        "name": "RandomizeGroupSyncTest1",
        "body": "{\n            var myTarget1 = new MyTarget();\n            var myTarget2 = new MyTarget();\n            var myTarget3 = new MyTarget();\n\n            var wrapper = new RandomizeGroupTarget()\n            {\n                Targets = { myTarget1, myTarget2, myTarget3 },\n            };\n\n            myTarget1.Initialize(null);\n            myTarget2.Initialize(null);\n            myTarget3.Initialize(null);\n            wrapper.Initialize(null);\n\n            List<Exception> exceptions = new List<Exception>();\n\n            // no exceptions\n            for (int i = 0; i < 10; ++i)\n            {\n                wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n            }\n\n            Assert.Equal(10, exceptions.Count);\n            foreach (var e in exceptions)\n            {\n                Assert.Null(e);\n            }\n\n            Assert.Equal(10, myTarget1.WriteCount + myTarget2.WriteCount + myTarget3.WriteCount);\n\n            Exception flushException = null;\n            var flushHit = new ManualResetEvent(false);\n            wrapper.Flush(ex => { flushException = ex; flushHit.Set(); });\n\n            flushHit.WaitOne();\n            Assert.True(flushException is null, flushException?.ToString());\n            Assert.Equal(1, myTarget1.FlushCount);\n            Assert.Equal(1, myTarget2.FlushCount);\n            Assert.Equal(1, myTarget3.FlushCount);\n        }"
      },
      {
        "name": "RandomizeGroupSyncTest2",
        "body": "{\n            var wrapper = new RandomizeGroupTarget()\n            {\n                // no targets\n            };\n\n            wrapper.Initialize(null);\n\n            List<Exception> exceptions = new List<Exception>();\n\n            // no exceptions\n            for (int i = 0; i < 10; ++i)\n            {\n                wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n            }\n\n            Assert.Equal(10, exceptions.Count);\n            foreach (var e in exceptions)\n            {\n                Assert.Null(e);\n            }\n\n            Exception flushException = new Exception(\"Flush not hit synchronously.\");\n            wrapper.Flush(ex => flushException = ex);\n            Assert.True(flushException is null, flushException?.ToString());\n        }"
      }
    ]
  },
  {
    "file": "RepeatingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "RepeatingTargetWrapperTest1",
        "body": "{\n            var target = new MyTarget();\n            var wrapper = new RepeatingTargetWrapper()\n            {\n                WrappedTarget = target,\n                RepeatCount = 3,\n            };\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            wrapper.WriteAsyncLogEvents(events);\n\n            // make sure all events went through and were replicated 3 times\n            Assert.Equal(9, target.Events.Count);\n            Assert.Same(events[0].LogEvent, target.Events[0]);\n            Assert.Same(events[0].LogEvent, target.Events[1]);\n            Assert.Same(events[0].LogEvent, target.Events[2]);\n            Assert.Same(events[1].LogEvent, target.Events[3]);\n            Assert.Same(events[1].LogEvent, target.Events[4]);\n            Assert.Same(events[1].LogEvent, target.Events[5]);\n            Assert.Same(events[2].LogEvent, target.Events[6]);\n            Assert.Same(events[2].LogEvent, target.Events[7]);\n            Assert.Same(events[2].LogEvent, target.Events[8]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n        }"
      },
      {
        "name": "RepeatingTargetWrapperTest2",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                var target = new MyTarget();\n                target.ThrowExceptions = true;\n                var wrapper = new RepeatingTargetWrapper()\n                {\n                    WrappedTarget = target,\n                    RepeatCount = 3,\n                };\n                wrapper.Initialize(null);\n                target.Initialize(null);\n\n                var exceptions = new List<Exception>();\n\n                var events = new[]\n                {\n                    new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n                };\n\n                wrapper.WriteAsyncLogEvents(events);\n\n                // make sure all events went through but were registered only once\n                // since repeating target wrapper will not repeat in case of exception.\n                Assert.Equal(3, target.Events.Count);\n                Assert.Same(events[0].LogEvent, target.Events[0]);\n                Assert.Same(events[1].LogEvent, target.Events[1]);\n                Assert.Same(events[2].LogEvent, target.Events[2]);\n\n                Assert.Equal(events.Length, exceptions.Count);\n                foreach (var exception in exceptions)\n                {\n                    Assert.NotNull(exception);\n                    Assert.Equal(\"Some exception has occurred.\", exception.Message);\n                }\n            }\n        }"
      }
    ]
  },
  {
    "file": "RetryingTargetWrapperTests.cs",
    "methods": [
      {
        "name": "RetryingTargetWrapperTest1",
        "body": "{\n            var target = new MyTarget();\n            var wrapper = new RetryingTargetWrapper()\n            {\n                WrappedTarget = target,\n                RetryCount = 10,\n                RetryDelayMilliseconds = 1,\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            wrapper.WriteAsyncLogEvents(events);\n\n            // make sure all events went through\n            Assert.Equal(3, target.Events.Count);\n            Assert.Same(events[0].LogEvent, target.Events[0]);\n            Assert.Same(events[1].LogEvent, target.Events[1]);\n            Assert.Same(events[2].LogEvent, target.Events[2]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n\n            // make sure there were no exception\n            foreach (var ex in exceptions)\n            {\n                Assert.Null(ex);\n            }\n        }"
      },
      {
        "name": "RetryingTargetWrapperTest2",
        "body": "{\n            var target = new MyTarget()\n            {\n                ThrowExceptions = 6,\n            };\n\n            var wrapper = new RetryingTargetWrapper()\n            {\n                WrappedTarget = target,\n                RetryCount = 4,\n                RetryDelayMilliseconds = 1,\n            };\n\n            wrapper.Initialize(null);\n            target.Initialize(null);\n\n            var exceptions = new List<Exception>();\n\n            var events = new[]\n            {\n                new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n            };\n\n            var result = RunAndCaptureInternalLog(() => wrapper.WriteAsyncLogEvents(events), LogLevel.Trace);\n            Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 1/4\", result);\n            Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 2/4\", result);\n            Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 3/4\", result);\n            Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 4/4\", result);\n            Assert.Contains(\"Too many retries. Aborting.\", result);\n            Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 1/4\", result);\n            Assert.Contains(\"Error while writing to 'MyTarget([unnamed])'. Try 2/4\", result);\n\n            // first event does not get to wrapped target because of too many attempts.\n            // second event gets there in 3rd retry\n            // and third event gets there immediately\n            Assert.Equal(2, target.Events.Count);\n            Assert.Same(events[1].LogEvent, target.Events[0]);\n            Assert.Same(events[2].LogEvent, target.Events[1]);\n\n            Assert.Equal(events.Length, exceptions.Count);\n\n            Assert.NotNull(exceptions[0]);\n            Assert.Equal(\"Some exception has occurred.\", exceptions[0].Message);\n            Assert.Null(exceptions[1]);\n            Assert.Null(exceptions[2]);\n        }"
      },
      {
        "name": "RetryingTargetWrapperBlockingCloseTest",
        "body": "{\n            RetryingIntegrationTest(3, () =>\n            {\n                var target = new MyTarget()\n                {\n                    ThrowExceptions = 5,\n                };\n                var wrapper = new RetryingTargetWrapper()\n                {\n                    WrappedTarget = target,\n                    RetryCount = 10,\n                    RetryDelayMilliseconds = 5000,\n                };\n                var asyncWrapper = new AsyncTargetWrapper(wrapper) { TimeToSleepBetweenBatches = 1 };\n\n                asyncWrapper.Initialize(null);\n                wrapper.Initialize(null);\n                target.Initialize(null);\n\n                var exceptions = new List<Exception>();\n\n                var events = new[]\n                {\n                    new LogEventInfo(LogLevel.Debug, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger1\", \"Hello\").WithContinuation(exceptions.Add),\n                    new LogEventInfo(LogLevel.Info, \"Logger2\", \"Hello\").WithContinuation(exceptions.Add),\n                };\n\n                // Attempt to write LogEvents that will take forever to retry\n                asyncWrapper.WriteAsyncLogEvents(events);\n                // Wait a little for the AsyncWrapper to start writing\n                System.Threading.Thread.Sleep(50);\n                // Close down the AsyncWrapper while busy writing\n                asyncWrapper.Close();\n                // Close down the RetryingWrapper while busy retrying\n                wrapper.Close();\n                // Close down the actual target while busy writing\n                target.Close();\n                // Wait a little for the RetryingWrapper to detect that it has been closed down\n                System.Threading.Thread.Sleep(200);\n                // The premature abort, causes the exception to be logged\n                Assert.NotNull(exceptions[0]);\n            });\n        }"
      },
      {
        "name": "RetryingTargetWrapperBatchingTest",
        "body": "{\n            var target = new MyTarget()\n            {\n                ThrowExceptions = 3,\n            };\n            var retryWrapper = new RetryingTargetWrapper()\n            {\n                WrappedTarget = target,\n                RetryCount = 2,\n                RetryDelayMilliseconds = 10,\n                EnableBatchWrite = true,\n            };\n            var asyncWrapper = new AsyncTargetWrapper(retryWrapper) { TimeToSleepBetweenBatches = 5000 };\n\n            var logFactory = new LogFactory().Setup().LoadConfiguration(builder =>\n            {\n                builder.ForLogger().WriteTo(asyncWrapper);\n            }).LogFactory;\n\n            // Verify that RetryingTargetWrapper is not sleeping for every LogEvent in single batch\n            var stopWatch = new System.Diagnostics.Stopwatch();\n            stopWatch.Start();\n\n            var logger = logFactory.GetCurrentClassLogger();\n            for (int i = 1; i <= 500; ++i)\n                logger.Info(\"Test {0}\", i);\n            logFactory.Flush();\n            Assert.Equal(1, target.WriteBatchCount);\n\n            for (int i = 0; i < 5000; ++i)\n            {\n                if (target.Events.Count >= 495)\n                    break;\n                System.Threading.Thread.Sleep(1);\n            }\n\n            Assert.Equal(1, target.WriteBatchCount);\n            Assert.InRange(target.Events.Count, 495, 500);\n            Assert.InRange(stopWatch.ElapsedMilliseconds, 0, 3000);\n        }"
      }
    ]
  },
  {
    "file": "RoundRobinGroupTargetTests.cs",
    "methods": [
      {
        "name": "RoundRobinGroupTargetSyncTest1",
        "body": "{\n            var myTarget1 = new MyTarget();\n            var myTarget2 = new MyTarget();\n            var myTarget3 = new MyTarget();\n\n            var wrapper = new RoundRobinGroupTarget()\n            {\n                Targets = { myTarget1, myTarget2, myTarget3 },\n            };\n\n            myTarget1.Initialize(null);\n            myTarget2.Initialize(null);\n            myTarget3.Initialize(null);\n            wrapper.Initialize(null);\n\n            List<Exception> exceptions = new List<Exception>();\n\n            // no exceptions\n            for (int i = 0; i < 10; ++i)\n            {\n                wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n            }\n\n            Assert.Equal(10, exceptions.Count);\n            foreach (var e in exceptions)\n            {\n                Assert.Null(e);\n            }\n\n            Assert.Equal(4, myTarget1.WriteCount);\n            Assert.Equal(3, myTarget2.WriteCount);\n            Assert.Equal(3, myTarget3.WriteCount);\n\n            Exception flushException = null;\n            var flushHit = new ManualResetEvent(false);\n            wrapper.Flush(ex => { flushException = ex; flushHit.Set(); });\n\n            flushHit.WaitOne();\n            Assert.True(flushException is null, flushException?.ToString());\n            Assert.Equal(1, myTarget1.FlushCount);\n            Assert.Equal(1, myTarget2.FlushCount);\n            Assert.Equal(1, myTarget3.FlushCount);\n        }"
      },
      {
        "name": "RoundRobinGroupTargetSyncTest2",
        "body": "{\n            var wrapper = new RoundRobinGroupTarget()\n            {\n                // empty target list\n            };\n\n            wrapper.Initialize(null);\n\n            List<Exception> exceptions = new List<Exception>();\n\n            // no exceptions\n            for (int i = 0; i < 10; ++i)\n            {\n                wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(exceptions.Add));\n            }\n\n            Assert.Equal(10, exceptions.Count);\n            foreach (var e in exceptions)\n            {\n                Assert.Null(e);\n            }\n\n            Exception flushException = null;\n            var flushHit = new ManualResetEvent(false);\n            wrapper.Flush(ex => { flushException = ex; flushHit.Set(); });\n\n            flushHit.WaitOne();\n            Assert.True(flushException is null, flushException?.ToString());\n        }"
      }
    ]
  },
  {
    "file": "SplitGroupTargetTests.cs",
    "methods": [
      {
        "name": "NoTargets_SplitGroupTarget_IsWorking",
        "body": "{\n            SplitGroupTarget_Exercise(ArrayHelper.Empty<MyTarget>());\n        }"
      },
      {
        "name": "SingleTarget_SplitGroupTarget_IsWorking",
        "body": "{\n            SplitGroupTarget_Exercise(new[] { new MyTarget() });\n        }"
      },
      {
        "name": "MultipleTargets_SplitGroupTarget_IsWorking",
        "body": "{\n            SplitGroupTarget_Exercise(new[] { new MyTarget(), new MyTarget(), new MyTarget() });\n        }"
      },
      {
        "name": "FirstTargetFails_SplitGroupTarget_WritesToAll",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                int logEventFailCount = 2;\n                var failingTarget = new MyTarget() { FailCounter = logEventFailCount };\n                SplitGroupTarget_Exercise(new[] { failingTarget, new MyTarget(), new MyTarget() }, logEventFailCount);\n            }\n        }"
      },
      {
        "name": "AsyncOutOfOrder_SplitGroupTarget_IsWorking",
        "body": "{\n            var targets = Enumerable.Range(0, 3).Select(i => new AsyncTargetWrapper(i.ToString(), new MyTarget()) { TimeToSleepBetweenBatches = i * 10 }).ToArray();\n            targets.ToList().ForEach(t => t.WrappedTarget.Initialize(null));\n            Func<Target, MyTarget> lookupTarget = t => (MyTarget)((AsyncTargetWrapper)t).WrappedTarget;\n            SplitGroupTarget_Exercise(targets, 0, lookupTarget);\n        }"
      },
      {
        "name": "SplitGroupToStringTest",
        "body": "{\n            var myTarget1 = new MyTarget();\n            var myTarget2 = new FileTarget(\"file1\");\n            var myTarget3 = new ConsoleTarget(\"Console2\");\n\n            var wrapper = new SplitGroupTarget()\n            {\n                Targets = { myTarget1, myTarget2, myTarget3 },\n            };\n\n            Assert.Equal(\"SplitGroup[MyTarget([unnamed]), FileTarget(Name=file1), ConsoleTarget(Name=Console2)]\", wrapper.ToString());\n        }"
      }
    ]
  },
  {
    "file": "WrapperTargetBaseTests.cs",
    "methods": [
      {
        "name": "WrapperTargetNestedToStringTest",
        "body": "{\n            var wrapper = new MyWrapper\n            {\n                WrappedTarget = new DebugTarget() { Name = \"foo\" },\n            };\n\n            var wrapper2 = new MyWrapper()\n            {\n                WrappedTarget = wrapper,\n            };\n\n            Assert.Equal(\"MyWrapper_MyWrapper_DebugTarget(Name=foo)\", wrapper2.ToString());\n        }"
      },
      {
        "name": "WrapperTargetToStringTest",
        "body": "{\n            var wrapper = new MyWrapper\n            {\n                Name = \"foo\",\n                WrappedTarget = new DebugTarget() { Name = \"foo_wrapped\" },\n            };\n\n            Assert.Equal(\"MyWrapper_DebugTarget(Name=foo)\", wrapper.ToString());\n        }"
      },
      {
        "name": "WrapperTargetFlushTest",
        "body": "{\n            var wrapped = new MyWrappedTarget();\n\n            var wrapper = new MyWrapper\n            {\n                WrappedTarget = wrapped,\n            };\n\n            wrapper.Initialize(null);\n            wrapped.Initialize(null);\n\n            wrapper.Flush(ex => { });\n            Assert.Equal(1, wrapped.FlushCount);\n        }"
      },
      {
        "name": "WrapperTargetDefaultWriteTest",
        "body": "{\n            using (new NoThrowNLogExceptions())\n            {\n                Exception lastException = null;\n                var wrapper = new MyWrapper();\n                wrapper.WrappedTarget = new MyWrappedTarget();\n                wrapper.Initialize(null);\n                wrapper.WriteAsyncLogEvent(LogEventInfo.CreateNullEvent().WithContinuation(ex => lastException = ex));\n                Assert.NotNull(lastException);\n                Assert.IsType<NotSupportedException>(lastException);\n            }\n        }"
      }
    ]
  },
  {
    "file": "TimeSourceTests.cs",
    "methods": [
      {
        "name": "AccurateLocalTest",
        "body": "{\n            TestTimeSource(new AccurateLocalTimeSource(), DateTime.Now, DateTimeKind.Local);\n        }"
      },
      {
        "name": "AccurateUtcTest",
        "body": "{\n            TestTimeSource(new AccurateUtcTimeSource(), DateTime.UtcNow, DateTimeKind.Utc);\n        }"
      },
      {
        "name": "FastLocalTest",
        "body": "{\n            TestTimeSource(new FastLocalTimeSource(), DateTime.Now, DateTimeKind.Local);\n        }"
      },
      {
        "name": "FastUtcTest",
        "body": "{\n            TestTimeSource(new FastUtcTimeSource(), DateTime.UtcNow, DateTimeKind.Utc);\n        }"
      },
      {
        "name": "CustomTimeSourceTest",
        "body": "{\n            TestTimeSource(new CustomTimeSource(), DateTime.UtcNow.AddHours(1), DateTimeKind.Unspecified);\n        }"
      }
    ]
  },
  {
    "file": "RegistryTests.cs",
    "methods": [
      {
        "name": "RegistryNamedValueTest",
        "body": "{\n            AssertLayoutRendererResult(\"FooValue\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=Foo}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryNamedValueTest_hive32",
        "body": "{\n            AssertLayoutRendererResult(\"reg32\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=view32:view=Registry32}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryNamedValueTest_hive64",
        "body": "{\n            AssertLayoutRendererResult(\"reg64\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=view64:view=Registry64}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryNamedValueTest_forward_slash",
        "body": "{\n            AssertLayoutRendererResult(\"FooValue\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU/Software/NLogTest:value=Foo}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryUnnamedValueTest",
        "body": "{\n            AssertLayoutRendererResult(\"UnnamedValue\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryUnnamedValueTest_forward_slash",
        "body": "{\n            AssertLayoutRendererResult(\"UnnamedValue\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU/Software/NLogTest}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryKeyNotFoundTest",
        "body": "{\n            AssertLayoutRendererResult(\"xyz\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NoSuchKey:defaultValue=xyz}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryKeyNotFoundTest_forward_slash",
        "body": "{\n            AssertLayoutRendererResult(\"xyz\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU/Software/NoSuchKey:defaultValue=xyz}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryValueNotFoundTest",
        "body": "{\n            AssertLayoutRendererResult(\"xyz\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKCU\\\\Software\\\\NLogTest:value=NoSuchValue:defaultValue=xyz}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryDefaultValueTest",
        "body": "{\n            AssertLayoutRendererResult(\"logdefaultvalue\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=logdefaultvalue}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryDefaultValueTest_with_colon",
        "body": "{\n            AssertLayoutRendererResult(\"C:temp\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C\\:temp}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryDefaultValueTest_with_slash",
        "body": "{\n            AssertLayoutRendererResult(\"C/temp\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C/temp}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryDefaultValueTest_with_foward_slash",
        "body": "{\n            AssertLayoutRendererResult(\"C\\\\temp\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C\\\\temp}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryDefaultValueTest_with_foward_slash2",
        "body": "{\n            AssertLayoutRendererResult(\"C\\\\temp\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT:defaultValue=C\\temp:requireEscapingSlashesInDefaultValue=false}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "Registry_nosubky",
        "body": "{\n            AssertLayoutRendererResult(\"\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:key=HKEY_CURRENT_CONFIG}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryDefaultValueNull",
        "body": "{\n            AssertLayoutRendererResult(\"\",\n            @\"<nlog>\n                <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=HKLM/NOT_EXISTENT}' /></targets>\n                <rules>\n                    <logger name='*' minlevel='Debug' writeTo='debug' />\n                </rules>\n            </nlog>\");\n        }"
      },
      {
        "name": "RegistryTestWrongKey_no_ex",
        "body": "{\n            try\n            {\n                LogManager.ThrowExceptions = false;\n                AssertLayoutRendererResult(\"\",\n                @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=garabageHKLM/NOT_EXISTENT:defaultValue=empty}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n            }\n            finally\n            {\n                LogManager.ThrowExceptions = true;\n            }\n        }"
      },
      {
        "name": "RegistryTestWrongKey_ex",
        "body": "{\n            try\n            {\n                LogManager.ThrowExceptions = false;\n                AssertLayoutRendererResult(\"\",\n                @\"<nlog>\n                    <targets><target name='debug' type='Debug' layout='${registry:value=NOT_EXISTENT:key=garabageHKLM/NOT_EXISTENT:defaultValue=empty}' /></targets>\n                    <rules>\n                        <logger name='*' minlevel='Debug' writeTo='debug' />\n                    </rules>\n                </nlog>\");\n            }\n            finally\n            {\n                LogManager.ThrowExceptions = true;\n            }\n        }"
      }
    ]
  },
  {
    "file": "SourceCodeTests.cs",
    "methods": []
  }
]